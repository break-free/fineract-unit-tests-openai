{"prompt":"check Upfront Accrual Accounting Flow\n\n###\n\n","completion":"    @Test\n    public void checkUpfrontAccrualAccountingFlow() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithUpfrontAccrualAccountingEnabled(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(requestSpec, responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(requestSpec, responseSpec, clientID.toString(),\n                collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, collaterals);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(EXPECTED_DISBURSAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(EXPECTED_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        \/\/ CHECK ACCOUNT ENTRIES\n        LOG.info(\"Entries ......\");\n        final float PRINCIPAL_VALUE_FOR_EACH_PERIOD = 2000.0f;\n        final float TOTAL_INTEREST = 1000.0f;\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(TOTAL_INTEREST, JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.DEBIT), };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, EXPECTED_DISBURSAL_DATE, assetAccountInitialEntry);\n        LOG.info(\"CHECKING INCOME: ******************************************\");\n        final JournalEntry incomeJournalEntry = new JournalEntry(TOTAL_INTEREST, JournalEntry.TransactionType.CREDIT);\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, EXPECTED_DISBURSAL_DATE, incomeJournalEntry);\n\n        \/\/ MAKE 1\n        LOG.info(\"Repayment 1 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[1], REPAYMENT_AMOUNT[1], loanID);\n        final float FIRST_INTEREST = 200.0f;\n        final float FIRST_PRINCIPAL = 2000.0f;\n        float expected_value = LP_PRINCIPAL - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(1, expected_value, loanID);\n        final JournalEntry[] assetAccountFirstEntry = { new JournalEntry(REPAYMENT_AMOUNT[1], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(FIRST_INTEREST + FIRST_PRINCIPAL, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[1], assetAccountFirstEntry);\n        LOG.info(\"Repayment 1 Done......\");\n\n        \/\/ REPAYMENT 2\n        LOG.info(\"Repayment 2 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[2], REPAYMENT_AMOUNT[2], loanID);\n        final float SECOND_AND_THIRD_INTEREST = 400.0f;\n        final float SECOND_PRINCIPAL = REPAYMENT_AMOUNT[2] - SECOND_AND_THIRD_INTEREST;\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(2, expected_value, loanID);\n        final JournalEntry[] assetAccountSecondEntry = { new JournalEntry(REPAYMENT_AMOUNT[2], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(SECOND_AND_THIRD_INTEREST + SECOND_PRINCIPAL, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[2], assetAccountSecondEntry);\n        LOG.info(\"Repayment 2 Done ......\");\n\n        \/\/ WAIVE INTEREST\n        LOG.info(\"Waive Interest  ......\");\n        this.loanTransactionHelper.waiveInterest(REPAYMENT_DATE[4], AMOUNT_TO_BE_WAIVE.toString(), loanID);\n\n        final JournalEntry waivedEntry = new JournalEntry(AMOUNT_TO_BE_WAIVE, JournalEntry.TransactionType.CREDIT);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[4], waivedEntry);\n\n        final JournalEntry expenseJournalEntry = new JournalEntry(AMOUNT_TO_BE_WAIVE, JournalEntry.TransactionType.DEBIT);\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, REPAYMENT_DATE[4], expenseJournalEntry);\n        LOG.info(\"Waive Interest Done......\");\n\n        \/\/ REPAYMENT 3\n        LOG.info(\"Repayment 3 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[3], REPAYMENT_AMOUNT[3], loanID);\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        final JournalEntry[] assetAccountThirdEntry = { new JournalEntry(REPAYMENT_AMOUNT[3], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[3], JournalEntry.TransactionType.CREDIT) };\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(3, expected_value, loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[3], assetAccountThirdEntry);\n        LOG.info(\"Repayment 3 Done ......\");\n\n        \/\/ REPAYMENT 4\n        LOG.info(\"Repayment 4 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[4], REPAYMENT_AMOUNT[4], loanID);\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(4, expected_value, loanID);\n        final JournalEntry[] assetAccountFourthEntry = { new JournalEntry(REPAYMENT_AMOUNT[4], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[4], JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[4], assetAccountFourthEntry);\n        LOG.info(\"Repayment 4 Done  ......\");\n\n        \/\/ Repayment 5\n        LOG.info(\"Repayment 5 ......\");\n        final JournalEntry[] assetAccountFifthEntry = { new JournalEntry(REPAYMENT_AMOUNT[5], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[5], JournalEntry.TransactionType.CREDIT) };\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[5], REPAYMENT_AMOUNT[5], loanID);\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(5, expected_value, loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[5], assetAccountFifthEntry);\n        LOG.info(\"Repayment 5 Done  ......\");\n    } END"}
{"prompt":"check Accounting With Savings Flow\n\n###\n\n","completion":"    @Test\n    public void checkAccountingWithSavingsFlow() {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer savingsProductID = createSavingsProduct(MINIMUM_OPENING_BALANCE, assetAccount, incomeAccount, expenseAccount,\n                liabilityAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n        final Integer savingsID = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, savingsID);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsID);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsID);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        \/\/ Checking initial Account entries.\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(SP_BALANCE, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountInitialEntry = { new JournalEntry(SP_BALANCE, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, TRANSACTION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, TRANSACTION_DATE, liablilityAccountInitialEntry);\n\n        \/\/ First Transaction-Deposit\n        this.savingsAccountHelper.depositToSavingsAccount(savingsID, DEPOSIT_AMOUNT, SavingsAccountHelper.TRANSACTION_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        Float balance = SP_BALANCE + SP_DEPOSIT_AMOUNT;\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsID);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance after Deposit\");\n\n        LOG.info(\"----------------------Verifying Journal Entry after the Transaction Deposit----------------------------\");\n        final JournalEntry[] assetAccountFirstTransactionEntry = {\n                new JournalEntry(SP_DEPOSIT_AMOUNT, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liabililityAccountFirstTransactionEntry = {\n                new JournalEntry(SP_DEPOSIT_AMOUNT, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, TRANSACTION_DATE, assetAccountFirstTransactionEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, TRANSACTION_DATE,\n                liabililityAccountFirstTransactionEntry);\n\n        \/\/ Second Transaction-Withdrawal\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsID, WITHDRAWAL_AMOUNT, SavingsAccountHelper.TRANSACTION_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        balance -= SP_WITHDRAWAL_AMOUNT;\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsID);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance after Withdrawal\");\n\n        LOG.info(\"-------------------Verifying Journal Entry after the Transaction Withdrawal----------------------\");\n        final JournalEntry[] assetAccountSecondTransactionEntry = {\n                new JournalEntry(SP_WITHDRAWAL_AMOUNT, JournalEntry.TransactionType.CREDIT) };\n        final JournalEntry[] liabililityAccountSecondTransactionEntry = {\n                new JournalEntry(SP_WITHDRAWAL_AMOUNT, JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, TRANSACTION_DATE, assetAccountSecondTransactionEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, TRANSACTION_DATE,\n                liabililityAccountSecondTransactionEntry);\n\n        \/\/ Third Transaction-Add Charges for Withdrawal Fee\n        final Integer withdrawalChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getSavingsWithdrawalFeeJSON());\n        Assertions.assertNotNull(withdrawalChargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsID, withdrawalChargeId, false);\n        ArrayList<HashMap> chargesPendingState = this.savingsAccountHelper.getSavingsCharges(savingsID);\n        Assertions.assertEquals(1, chargesPendingState.size());\n        HashMap savingsChargeForPay = chargesPendingState.get(0);\n        HashMap paidCharge = this.savingsAccountHelper.getSavingsCharge(savingsID, (Integer) savingsChargeForPay.get(\"id\"));\n        Float chargeAmount = (Float) paidCharge.get(\"amount\");\n\n        \/\/ Withdrawal after adding Charge of type Withdrawal Fee\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsID, WITHDRAWAL_AMOUNT_ADJUSTED, SavingsAccountHelper.TRANSACTION_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsID);\n        balance = balance - SP_WITHDRAWAL_AMOUNT_ADJUSTED - chargeAmount;\n\n        final JournalEntry[] liabililityAccountThirdTransactionEntry = { new JournalEntry(chargeAmount, JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(SP_WITHDRAWAL_AMOUNT_ADJUSTED, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] assetAccountThirdTransactionEntry = {\n                new JournalEntry(SP_WITHDRAWAL_AMOUNT_ADJUSTED, JournalEntry.TransactionType.CREDIT) };\n        final JournalEntry[] incomeAccountThirdTransactionEntry = { new JournalEntry(chargeAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, TRANSACTION_DATE, assetAccountThirdTransactionEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, TRANSACTION_DATE,\n                liabililityAccountThirdTransactionEntry);\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, TRANSACTION_DATE, incomeAccountThirdTransactionEntry);\n\n        \/\/ Verifying Balance after applying Charge for Withdrawal Fee\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance\");\n    } END"}
{"prompt":"test Fixed Deposit Accounting Flow\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountingFlow() {\n        this.accountHelper = new AccountHelper(requestSpec, responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(requestSpec, responseSpec);\n\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(3);\n        final String VALID_FROM = dateFormat.format(todaysDate);\n        todaysDate = todaysDate.plusYears(10);\n        final String VALID_TO = dateFormat.format(todaysDate);\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate);\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate);\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n\n        todaysDate = todaysDate.plusMonths(1).withDayOfMonth(1);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate);\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientId);\n        \/\/ Assertions.assertNotNull(clientId);\n\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, assetAccount, incomeAccount, expenseAccount,\n                liabilityAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(), VALID_FROM,\n                VALID_TO, SUBMITTED_ON_DATE, FixedDepositTest.WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(requestSpec,\n                responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n\n        Float depositAmount = (Float) accountSummary.get(\"totalDeposits\");\n\n        \/\/ Checking initial Journal entries after Activation.\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, ACTIVATION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, ACTIVATION_DATE, liablilityAccountInitialEntry);\n\n        Integer transactionIdForPostInterest = this.fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n\n        \/\/ Checking initial Journal entries after Interest Posting.\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n    } END"}
{"prompt":"test Recurring Deposit Accounting Flow\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountingFlow() {\n        this.accountHelper = new AccountHelper(requestSpec, responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(requestSpec, responseSpec);\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(3);\n        final String VALID_FROM = dateFormat.format(todaysDate);\n        todaysDate = todaysDate.plusYears(10);\n        final String VALID_TO = dateFormat.format(todaysDate);\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate);\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate);\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n        final String EXPECTED_FIRST_DEPOSIT_ON_DATE = dateFormat.format(todaysDate);\n\n        todaysDate = todaysDate.plusMonths(1).withDayOfMonth(1);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate);\n\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientId);\n\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, assetAccount, liabilityAccount,\n                incomeAccount, expenseAccount);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, RecurringDepositTest.WHOLE_TERM, EXPECTED_FIRST_DEPOSIT_ON_DATE);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(requestSpec,\n                responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(requestSpec, responseSpec,\n                recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                depositAmount, EXPECTED_FIRST_DEPOSIT_ON_DATE);\n        Assertions.assertNotNull(depositTransactionId);\n\n        \/\/ Checking initial Journal entries after Activation.\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, EXPECTED_FIRST_DEPOSIT_ON_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, EXPECTED_FIRST_DEPOSIT_ON_DATE,\n                liablilityAccountInitialEntry);\n\n        Integer interestPostingTransactionId = this.recurringDepositAccountHelper\n                .postInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(interestPostingTransactionId);\n\n        HashMap accountSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n\n        \/\/ Checking initial Journal entries after Interest Posting.\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n    } END"}
{"prompt":"check Periodic Accrual Accounting Flow\n\n###\n\n","completion":"    @Test\n    public void checkPeriodicAccrualAccountingFlow() throws InterruptedException, ParseException {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingEnabled(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(requestSpec, responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(requestSpec, responseSpec, clientID.toString(),\n                collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, collaterals);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(EXPECTED_DISBURSAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(EXPECTED_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        \/\/ CHECK ACCOUNT ENTRIES\n        LOG.info(\"Entries ......\");\n        final float PRINCIPAL_VALUE_FOR_EACH_PERIOD = 2000.0f;\n        final float TOTAL_INTEREST = 1000.0f;\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.DEBIT), };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, EXPECTED_DISBURSAL_DATE, assetAccountInitialEntry);\n\n        final String jobName = \"Add Accrual Transactions\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(jobName);\n\n        \/\/ MAKE 1\n        LOG.info(\"Repayment 1 ......\");\n        final float FIRST_INTEREST = 200.0f;\n        final float FIRST_PRINCIPAL = 2000.0f;\n        final float FEE_PORTION = 0.0f;\n        final float PENALTY_PORTION = 0.0f;\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(getDateAsLocalDate(REPAYMENT_DATE[1]), FIRST_INTEREST, FEE_PORTION,\n                PENALTY_PORTION, loanID);\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[1], REPAYMENT_AMOUNT[1], loanID);\n        float expected_value = LP_PRINCIPAL - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(1, expected_value, loanID);\n        final JournalEntry[] assetAccountFirstEntry = { new JournalEntry(REPAYMENT_AMOUNT[1], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(FIRST_INTEREST + FIRST_PRINCIPAL, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[1], assetAccountFirstEntry);\n        LOG.info(\"Repayment 1 Done......\");\n\n        \/\/ REPAYMENT 2\n        LOG.info(\"Repayment 2 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[2], REPAYMENT_AMOUNT[2], loanID);\n        final float SECOND_AND_THIRD_INTEREST = 400.0f;\n        final float SECOND_PRINCIPAL = REPAYMENT_AMOUNT[2] - SECOND_AND_THIRD_INTEREST;\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(getDateAsLocalDate(REPAYMENT_DATE[2]), FIRST_INTEREST, FEE_PORTION,\n                PENALTY_PORTION, loanID);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(getDateAsLocalDate(REPAYMENT_DATE[3]), FIRST_INTEREST, FEE_PORTION,\n                PENALTY_PORTION, loanID);\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(2, expected_value, loanID);\n        final JournalEntry[] assetAccountSecondEntry = { new JournalEntry(REPAYMENT_AMOUNT[2], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(SECOND_AND_THIRD_INTEREST + SECOND_PRINCIPAL, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[2], assetAccountSecondEntry);\n        LOG.info(\"Repayment 2 Done ......\");\n\n        \/\/ WAIVE INTEREST\n        LOG.info(\"Waive Interest  ......\");\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(getDateAsLocalDate(REPAYMENT_DATE[4]), FIRST_INTEREST, FEE_PORTION,\n                PENALTY_PORTION, loanID);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(getDateAsLocalDate(REPAYMENT_DATE[5]), FIRST_INTEREST, FEE_PORTION,\n                PENALTY_PORTION, loanID);\n        this.loanTransactionHelper.waiveInterest(REPAYMENT_DATE[4], AMOUNT_TO_BE_WAIVE.toString(), loanID);\n\n        final JournalEntry waivedEntry = new JournalEntry(AMOUNT_TO_BE_WAIVE, JournalEntry.TransactionType.CREDIT);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[4], waivedEntry);\n\n        final JournalEntry expenseJournalEntry = new JournalEntry(AMOUNT_TO_BE_WAIVE, JournalEntry.TransactionType.DEBIT);\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, REPAYMENT_DATE[4], expenseJournalEntry);\n        LOG.info(\"Waive Interest Done......\");\n\n        \/\/ REPAYMENT 3\n        LOG.info(\"Repayment 3 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[3], REPAYMENT_AMOUNT[3], loanID);\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        final JournalEntry[] assetAccountThirdEntry = { new JournalEntry(REPAYMENT_AMOUNT[3], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[3], JournalEntry.TransactionType.CREDIT) };\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(3, expected_value, loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[3], assetAccountThirdEntry);\n        LOG.info(\"Repayment 3 Done ......\");\n\n        \/\/ REPAYMENT 4\n        LOG.info(\"Repayment 4 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[4], REPAYMENT_AMOUNT[4], loanID);\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(4, expected_value, loanID);\n        final JournalEntry[] assetAccountFourthEntry = { new JournalEntry(REPAYMENT_AMOUNT[4], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[4], JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[4], assetAccountFourthEntry);\n        LOG.info(\"Repayment 4 Done  ......\");\n\n        \/\/ Repayment 5\n        LOG.info(\"Repayment 5 ......\");\n        final JournalEntry[] assetAccountFifthEntry = { new JournalEntry(REPAYMENT_AMOUNT[5], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[5], JournalEntry.TransactionType.CREDIT) };\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[5], REPAYMENT_AMOUNT[5], loanID);\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(5, expected_value, loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[5], assetAccountFifthEntry);\n        LOG.info(\"Repayment 5 Done  ......\");\n    } END"}
{"prompt":"check Periodic Accrual Accounting Flow OVER PAYMENT\n\n###\n\n","completion":"    @Test\n    public void checkPeriodicAccrualAccountingFlow_OVER_PAYMENT() throws InterruptedException, ParseException {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingEnabled(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(requestSpec, responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(requestSpec, responseSpec, clientID.toString(),\n                collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, collaterals);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(EXPECTED_DISBURSAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(EXPECTED_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        \/\/ CHECK ACCOUNT ENTRIES\n        LOG.info(\"Entries ......\");\n        final float PRINCIPAL_VALUE_FOR_EACH_PERIOD = 2000.0f;\n        final float TOTAL_INTEREST = 1000.0f;\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.DEBIT), };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, EXPECTED_DISBURSAL_DATE, assetAccountInitialEntry);\n\n        final String jobName = \"Add Accrual Transactions\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(jobName);\n\n        \/\/ MAKE 1\n        LOG.info(\"Repayment 1 ......\");\n        final float FIRST_INTEREST = 200.0f;\n        final float FIRST_PRINCIPAL = 2000.0f;\n        final float FEE_PORTION = 0.0f;\n        final float PENALTY_PORTION = 0.0f;\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(getDateAsLocalDate(REPAYMENT_DATE[1]), FIRST_INTEREST, FEE_PORTION,\n                PENALTY_PORTION, loanID);\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[1], 15000f, loanID);\n        float expected_value = LP_PRINCIPAL - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(1, expected_value, loanID);\n        final JournalEntry[] assetAccountEntry = { new JournalEntry(15000f, JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(11000f, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[1], assetAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, REPAYMENT_DATE[1],\n                new JournalEntry(4000f, JournalEntry.TransactionType.CREDIT));\n        LOG.info(\"Repayment  Done......\");\n\n    } END"}
{"prompt":"check Periodic Accrual Accounting Till Current Date Flow\n\n###\n\n","completion":"    @Test\n    public void checkPeriodicAccrualAccountingTillCurrentDateFlow() throws InterruptedException, ParseException {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingEnabled(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(requestSpec, responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(requestSpec, responseSpec, clientID.toString(),\n                collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, collaterals);\n\n        final float FEE_PORTION = 50.0f;\n        final float PENALTY_PORTION = 100.0f;\n        Integer flat = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(FEE_PORTION), false));\n        Integer flatSpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(PENALTY_PORTION), true));\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(EXPECTED_DISBURSAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n\n        final LocalDate localDate = LocalDate.now(this.systemTimeZone.toZoneId());\n        final ZonedDateTime currentDate = ZonedDateTime.of(localDate, LocalTime.MIDNIGHT, this.systemTimeZone.toZoneId());\n        ZonedDateTime zonedDate = currentDate.minusDays(4);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(zonedDate);\n\n        zonedDate = currentDate.minusDays(2);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(\n                String.valueOf(flatSpecifiedDueDate), dateFormat.format(zonedDate), String.valueOf(PENALTY_PORTION)));\n        zonedDate = zonedDate.plusDays(1);\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flat), dateFormat.format(zonedDate), String.valueOf(FEE_PORTION)));\n\n        \/\/ CHECK ACCOUNT ENTRIES\n        LOG.info(\"Entries ......\");\n        final float PRINCIPAL_VALUE_FOR_EACH_PERIOD = 2000.0f;\n        final float TOTAL_INTEREST = 1000.0f;\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.DEBIT), };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, LOAN_DISBURSEMENT_DATE, assetAccountInitialEntry);\n\n        final String jobName = \"Add Periodic Accrual Transactions\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(jobName);\n\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        \/\/ MAKE 1\n        List fromDateList = (List) loanSchedule.get(1).get(\"fromDate\");\n        LocalDate fromDateLocal = LocalDate.now(Utils.getZoneIdOfTenant());\n        fromDateLocal = fromDateLocal.withYear((int) fromDateList.get(0));\n        fromDateLocal = fromDateLocal.withMonth((int) fromDateList.get(1));\n        fromDateLocal = fromDateLocal.withDayOfMonth((int) fromDateList.get(2));\n\n        List dueDateList = (List) loanSchedule.get(1).get(\"dueDate\");\n        LocalDate dueDateLocal = LocalDate.now(Utils.getZoneIdOfTenant());\n        dueDateLocal = dueDateLocal.withYear((int) dueDateList.get(0));\n        dueDateLocal = dueDateLocal.withMonth((int) dueDateList.get(1));\n        dueDateLocal = dueDateLocal.withDayOfMonth((int) dueDateList.get(2));\n\n        int totalDaysInPeriod = Math.toIntExact(ChronoUnit.DAYS.between(fromDateLocal, dueDateLocal));\n\n        float totalInterest = (float) loanSchedule.get(1).get(\"interestOriginalDue\");\n        DecimalFormat numberFormat = new DecimalFormat(\"#.00\", new DecimalFormatSymbols(Locale.US));\n        float interest4Days = totalInterest \/ totalDaysInPeriod * 4;\n        interest4Days = Float.parseFloat(numberFormat.format(interest4Days));\n\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(currentDate.toLocalDate(), interest4Days, FEE_PORTION,\n                PENALTY_PORTION, loanID);\n\n    } END"}
{"prompt":"check Periodic Accrual Accounting APIFlow\n\n###\n\n","completion":"    @Test\n    public void checkPeriodicAccrualAccountingAPIFlow() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"0\");\n\n        final float FEE_PORTION = 50.0f;\n        final float PENALTY_PORTION = 100.0f;\n        final float NEXT_FEE_PORTION = 55.0f;\n        final float NEXT_PENALTY_PORTION = 105.0f;\n\n        Integer flat = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(FEE_PORTION), false));\n        Integer flatSpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(PENALTY_PORTION), true));\n\n        Integer flatNext = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(NEXT_FEE_PORTION), false));\n        Integer flatSpecifiedDueDateNext = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(NEXT_PENALTY_PORTION), true));\n\n        HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(EXPECTED_DISBURSAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LocalDate targetDate = LocalDate.of(2011, 3, 4);\n        final String loanDisbursementDate = dateFormatter.format(targetDate);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(2, loanSchedule.size());\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesDue\"));\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesOutstanding\"));\n        assertEquals(0, loanSchedule.get(1).get(\"penaltyChargesDue\"));\n        assertEquals(0, loanSchedule.get(1).get(\"penaltyChargesOutstanding\"));\n        assertEquals(10000.0f, loanSchedule.get(1).get(\"totalDueForPeriod\"));\n        assertEquals(10000.0f, loanSchedule.get(1).get(\"totalOutstandingForPeriod\"));\n        targetDate = LocalDate.of(2011, 4, 5);\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatSpecifiedDueDate), penaltyCharge1AddedDate,\n                        String.valueOf(PENALTY_PORTION)));\n\n        this.loanTransactionHelper.noAccrualTransactionForRepayment(loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(3, loanSchedule.size());\n        assertEquals(0, loanSchedule.get(2).get(\"feeChargesDue\"));\n        assertEquals(0, loanSchedule.get(2).get(\"feeChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesDue\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"totalDueForPeriod\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"totalOutstandingForPeriod\"));\n        assertEquals(LocalDate.of(2011, 4, 5), LocalDate.of((int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(0),\n                (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(1), (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(2)));\n\n        String runOnDateStr = penaltyCharge1AddedDate;\n        LocalDate runOnDate = targetDate;\n        this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(runOnDateStr);\n\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(runOnDate, 0.0f, 0.0f, PENALTY_PORTION, loanID);\n\n        targetDate = LocalDate.of(2011, 4, 6);\n        final String feeCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer fee1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flat), feeCharge1AddedDate, String.valueOf(FEE_PORTION)));\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(3, loanSchedule.size());\n        assertEquals(FEE_PORTION, loanSchedule.get(2).get(\"feeChargesDue\"));\n        assertEquals(FEE_PORTION, loanSchedule.get(2).get(\"feeChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesDue\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION + FEE_PORTION, loanSchedule.get(2).get(\"totalDueForPeriod\"));\n        assertEquals(PENALTY_PORTION + FEE_PORTION, loanSchedule.get(2).get(\"totalOutstandingForPeriod\"));\n        assertEquals(LocalDate.of(2011, 4, 6), LocalDate.of((int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(0),\n                (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(1), (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(2)));\n\n        targetDate = LocalDate.of(2011, 4, 7);\n        final String penaltyCharge2AddedDate = dateFormatter.format(targetDate);\n        Integer penalty2LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatSpecifiedDueDateNext),\n                        penaltyCharge2AddedDate, String.valueOf(NEXT_PENALTY_PORTION)));\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(3, loanSchedule.size());\n        assertEquals(FEE_PORTION, loanSchedule.get(2).get(\"feeChargesDue\"));\n        assertEquals(FEE_PORTION, loanSchedule.get(2).get(\"feeChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION + NEXT_PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesDue\"));\n        assertEquals(PENALTY_PORTION + NEXT_PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION + FEE_PORTION + NEXT_PENALTY_PORTION, loanSchedule.get(2).get(\"totalDueForPeriod\"));\n        assertEquals(PENALTY_PORTION + FEE_PORTION + NEXT_PENALTY_PORTION, loanSchedule.get(2).get(\"totalOutstandingForPeriod\"));\n        assertEquals(LocalDate.of(2011, 4, 7), LocalDate.of((int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(0),\n                (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(1), (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(2)));\n\n        targetDate = LocalDate.of(2011, 4, 8);\n        final String feeCharge2AddedDate = dateFormatter.format(targetDate);\n        Integer fee2LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatNext), feeCharge2AddedDate, String.valueOf(NEXT_FEE_PORTION)));\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(3, loanSchedule.size());\n        assertEquals(FEE_PORTION + NEXT_FEE_PORTION, loanSchedule.get(2).get(\"feeChargesDue\"));\n        assertEquals(FEE_PORTION + NEXT_FEE_PORTION, loanSchedule.get(2).get(\"feeChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION + NEXT_PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesDue\"));\n        assertEquals(PENALTY_PORTION + NEXT_PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION + FEE_PORTION + NEXT_PENALTY_PORTION + NEXT_FEE_PORTION, loanSchedule.get(2).get(\"totalDueForPeriod\"));\n        assertEquals(PENALTY_PORTION + FEE_PORTION + NEXT_PENALTY_PORTION + NEXT_FEE_PORTION,\n                loanSchedule.get(2).get(\"totalOutstandingForPeriod\"));\n        assertEquals(LocalDate.of(2011, 4, 8), LocalDate.of((int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(0),\n                (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(1), (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(2)));\n\n        runOnDateStr = penaltyCharge2AddedDate;\n        runOnDate = LocalDate.of(2011, 4, 7);\n        this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(runOnDateStr);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(runOnDate, 0.0f, FEE_PORTION, NEXT_PENALTY_PORTION, loanID);\n    } END"}
{"prompt":"check Cash Based Accounting Flow\n\n###\n\n","completion":"    @Test\n    public void checkCashBasedAccountingFlow() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithCashBasedAccountingEnabled(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(requestSpec, responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(requestSpec, responseSpec, clientID.toString(),\n                collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, collaterals);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(EXPECTED_DISBURSAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(EXPECTED_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        \/\/ CHECK ACCOUNT ENTRIES\n        LOG.info(\"Entries ......\");\n        final float PRINCIPAL_VALUE_FOR_EACH_PERIOD = 2000.0f;\n        final float TOTAL_INTEREST = 1000.0f;\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, EXPECTED_DISBURSAL_DATE, assetAccountInitialEntry);\n\n        \/\/ MAKE 1\n        LOG.info(\"Repayment 1 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[1], REPAYMENT_AMOUNT[1], loanID);\n        final float FIRST_INTEREST = 200.0f;\n        final float FIRST_PRINCIPAL = 2000.0f;\n        float expected_value = LP_PRINCIPAL - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(1, expected_value, loanID);\n        final JournalEntry[] assetAccountFirstEntry = { new JournalEntry(REPAYMENT_AMOUNT[1], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(FIRST_PRINCIPAL, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[1], assetAccountFirstEntry);\n        LOG.info(\"CHECKING INCOME: ******************************************\");\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, REPAYMENT_DATE[1],\n                new JournalEntry(FIRST_INTEREST, JournalEntry.TransactionType.CREDIT));\n        LOG.info(\"Repayment 1 Done......\");\n\n        \/\/ REPAYMENT 2\n        LOG.info(\"Repayment 2 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[2], REPAYMENT_AMOUNT[2], loanID);\n        final float SECOND_AND_THIRD_INTEREST = 400.0f;\n        final float SECOND_PRINCIPAL = REPAYMENT_AMOUNT[2] - SECOND_AND_THIRD_INTEREST;\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(2, expected_value, loanID);\n        final JournalEntry[] assetAccountSecondEntry = { new JournalEntry(REPAYMENT_AMOUNT[2], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(SECOND_PRINCIPAL, JournalEntry.TransactionType.CREDIT), };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[2], assetAccountSecondEntry);\n        LOG.info(\"CHECKING INCOME: ******************************************\");\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, REPAYMENT_DATE[2],\n                new JournalEntry(SECOND_AND_THIRD_INTEREST, JournalEntry.TransactionType.CREDIT));\n        LOG.info(\"Repayment 2 Done ......\");\n\n        \/\/ WAIVE INTEREST\n        LOG.info(\"Waive Interest  ......\");\n        Integer transactionId = this.loanTransactionHelper.waiveInterestAndReturnTransactionId(REPAYMENT_DATE[4],\n                AMOUNT_TO_BE_WAIVE.toString(), loanID);\n        \/\/ waive of fees and interest are not considered in cash based\n        \/\/ accounting,\n        this.journalEntryHelper.ensureNoAccountingTransactionsWithTransactionId(\"L\" + transactionId);\n\n        \/\/ REPAYMENT 3\n        LOG.info(\"Repayment 3 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[3], REPAYMENT_AMOUNT[3], loanID);\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        final JournalEntry[] assetAccountThirdEntry = { new JournalEntry(REPAYMENT_AMOUNT[3], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[3], JournalEntry.TransactionType.CREDIT) };\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(3, expected_value, loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[3], assetAccountThirdEntry);\n        LOG.info(\"Repayment 3 Done ......\");\n\n        \/\/ REPAYMENT 4\n        LOG.info(\"Repayment 4 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[4], REPAYMENT_AMOUNT[4], loanID);\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(4, expected_value, loanID);\n        final JournalEntry[] assetAccountFourthEntry = { new JournalEntry(REPAYMENT_AMOUNT[4], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[4], JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[4], assetAccountFourthEntry);\n        LOG.info(\"Repayment 4 Done  ......\");\n\n        \/\/ Repayment 5\n        LOG.info(\"Repayment 5 ......\");\n        final JournalEntry[] assetAccountFifthEntry = { new JournalEntry(REPAYMENT_AMOUNT[5], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[5], JournalEntry.TransactionType.CREDIT) };\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[5], REPAYMENT_AMOUNT[5], loanID);\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(5, expected_value, loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[5], assetAccountFifthEntry);\n        LOG.info(\"Repayment 5 Done  ......\");\n    } END"}
{"prompt":"test Account Number Preferences\n\n###\n\n","completion":"    @Test\n    public void testAccountNumberPreferences() {\n\n        \/* Create Loan and Savings Product *\/\n        this.createLoanAndSavingsProduct();\n\n        \/* Ensure no account number preferences are present in the system *\/\n        this.deleteAllAccountNumberPreferences();\n\n        \/*\n         * Validate the default account number generation rules for clients, loans and savings accounts.\n         *\/\n        this.validateDefaultAccountNumberGeneration();\n\n        \/* Create and Validate account number preferences *\/\n        this.createAccountNumberPreference();\n\n        \/*\n         * Validate account number preference rules apply to Clients,Loans and Saving Accounts\n         *\/\n        this.validateAccountNumberGenerationWithPreferences();\n\n        \/* Validate account number preferences Updation *\/\n        this.updateAccountNumberPreference();\n\n        \/*\n         * Validate account number preference rules apply to Clients,Loans and Saving Accounts after Updation\n         *\/\n        this.validateAccountNumberGenerationWithPreferences();\n\n        \/* Delete all account number preferences *\/\n        this.deleteAllAccountNumberPreferences();\n\n    } END"}
{"prompt":"test From Savings To Savings Account Transfer\n\n###\n\n","completion":"    @Test\n    public void testFromSavingsToSavingsAccountTransfer() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.accountTransferHelper = new AccountTransferHelper(this.requestSpec, this.responseSpec);\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        OfficeHelper officeHelper = new OfficeHelper(this.requestSpec, this.responseSpec);\n        Integer toOfficeId = officeHelper.createOffice(\"01 January 2011\");\n        Assertions.assertNotNull(toOfficeId);\n\n        \/\/ Creating Savings Account to which fund to be Transferred\n        final Integer toClientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2011\",\n                String.valueOf(toOfficeId));\n        Assertions.assertNotNull(toClientID);\n\n        final Integer toSavingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE, assetAccount,\n                incomeAccount, expenseAccount, liabilityAccount);\n        Assertions.assertNotNull(toSavingsProductID);\n\n        final Integer toSavingsID = this.savingsAccountHelper.applyForSavingsApplication(toClientID, toSavingsProductID,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(toSavingsProductID);\n\n        HashMap toSavingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, toSavingsID);\n        SavingsStatusChecker.verifySavingsIsPending(toSavingsStatusHashMap);\n\n        toSavingsStatusHashMap = this.savingsAccountHelper.approveSavings(toSavingsID);\n        SavingsStatusChecker.verifySavingsIsApproved(toSavingsStatusHashMap);\n\n        toSavingsStatusHashMap = this.savingsAccountHelper.activateSavings(toSavingsID);\n        SavingsStatusChecker.verifySavingsIsActive(toSavingsStatusHashMap);\n\n        final HashMap toSavingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(toSavingsID);\n\n        Integer fromOfficeId = officeHelper.createOffice(\"01 January 2011\");\n        Assertions.assertNotNull(fromOfficeId);\n\n        \/\/ Creating Savings Account from which the Fund has to be Transferred\n        final Integer fromClientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2011\",\n                String.valueOf(fromOfficeId));\n        Assertions.assertNotNull(fromClientID);\n\n        final Integer fromSavingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                assetAccount, incomeAccount, expenseAccount, liabilityAccount);\n        Assertions.assertNotNull(fromSavingsProductID);\n\n        final Integer fromSavingsID = this.savingsAccountHelper.applyForSavingsApplication(fromClientID, fromSavingsProductID,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(fromSavingsID);\n\n        HashMap fromSavingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsPending(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.approveSavings(fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsApproved(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.activateSavings(fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsActive(fromSavingsStatusHashMap);\n\n        final HashMap fromSavingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(fromSavingsID);\n\n        Float fromSavingsBalance = Float.valueOf(MINIMUM_OPENING_BALANCE);\n        Float toSavingsBalance = Float.valueOf(MINIMUM_OPENING_BALANCE);\n\n        this.accountTransferHelper.accountTransfer(fromClientID, fromSavingsID, fromClientID, toSavingsID, FROM_SAVINGS_ACCOUNT_TYPE,\n                TO_SAVINGS_ACCOUNT_TYPE, ACCOUNT_TRANSFER_AMOUNT);\n\n        fromSavingsBalance -= Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT);\n        toSavingsBalance += Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT);\n\n        HashMap fromSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(fromSavingsID);\n        assertEquals(fromSavingsBalance, fromSavingsSummaryAfter.get(\"accountBalance\"),\n                \"Verifying From Savings Account Balance after Account Transfer\");\n\n        HashMap toSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(toSavingsID);\n        assertEquals(toSavingsBalance, toSavingsSummaryAfter.get(\"accountBalance\"),\n                \"Verifying To Savings Account Balance after Account Transfer\");\n        final JournalEntry[] office1LiabilityEntries = {\n                new JournalEntry(Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT), JournalEntry.TransactionType.CREDIT) };\n        final JournalEntry[] office2LiabilityEntries = {\n                new JournalEntry(Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT), JournalEntry.TransactionType.DEBIT) };\n\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(fromOfficeId, liabilityTransferAccount,\n                AccountTransferHelper.ACCOUNT_TRANSFER_DATE, office1LiabilityEntries);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(toOfficeId, liabilityTransferAccount,\n                AccountTransferHelper.ACCOUNT_TRANSFER_DATE, office2LiabilityEntries);\n\n    } END"}
{"prompt":"test From Savings To Loan Account Transfer\n\n###\n\n","completion":"    @Test\n    public void testFromSavingsToLoanAccountTransfer() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        final Account loanAssetAccount = this.accountHelper.createAssetAccount();\n        final Account loanIncomeAccount = this.accountHelper.createIncomeAccount();\n        final Account loanExpenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        this.accountTransferHelper = new AccountTransferHelper(this.requestSpec, this.responseSpec);\n\n        OfficeHelper officeHelper = new OfficeHelper(this.requestSpec, this.responseSpec);\n        Integer toOfficeId = officeHelper.createOffice(\"01 January 2011\");\n        Assertions.assertNotNull(toOfficeId);\n\n        \/\/ Creating Loan Account to which fund to be Transferred\n        final Integer toClientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2011\",\n                String.valueOf(toOfficeId));\n        Assertions.assertNotNull(toClientID);\n\n        Account toTransferAccount = accountHelper.createLiabilityAccount();\n        Assertions.assertNotNull(toTransferAccount);\n\n        final Integer toLoanProductID = createLoanProduct(loanAssetAccount, loanIncomeAccount, loanExpenseAccount, overpaymentAccount);\n        Assertions.assertNotNull(toLoanProductID);\n\n        final Integer toLoanID = applyForLoanApplication(toClientID, toLoanProductID);\n        Assertions.assertNotNull(toLoanID);\n\n        HashMap toLoanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, toLoanID);\n        LoanStatusChecker.verifyLoanIsPending(toLoanStatusHashMap);\n\n        toLoanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_APPROVAL_DATE, toLoanID);\n        LoanStatusChecker.verifyLoanIsApproved(toLoanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, toLoanID);\n        toLoanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSAL_DATE, toLoanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(toLoanStatusHashMap);\n\n        Integer fromOfficeId = officeHelper.createOffice(\"01 January 2011\");\n        Assertions.assertNotNull(fromOfficeId);\n\n        \/\/ Creating Savings Account from which the Fund has to be Transferred\n        final Integer fromClientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2011\",\n                String.valueOf(fromOfficeId));\n        Assertions.assertNotNull(fromClientID);\n\n        final Integer fromSavingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                assetAccount, incomeAccount, expenseAccount, liabilityAccount);\n        Assertions.assertNotNull(fromSavingsProductID);\n\n        final Integer fromSavingsID = this.savingsAccountHelper.applyForSavingsApplication(fromClientID, fromSavingsProductID,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(fromSavingsID);\n\n        HashMap fromSavingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsPending(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.approveSavings(fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsApproved(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.activateSavings(fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsActive(fromSavingsStatusHashMap);\n\n        final HashMap fromSavingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(fromSavingsID);\n\n        Float fromSavingsBalance = Float.valueOf(MINIMUM_OPENING_BALANCE);\n\n        this.accountTransferHelper.accountTransfer(fromClientID, fromSavingsID, toClientID, toLoanID, FROM_SAVINGS_ACCOUNT_TYPE,\n                TO_LOAN_ACCOUNT_TYPE, ACCOUNT_TRANSFER_AMOUNT_ADJUST);\n\n        fromSavingsBalance -= TRANSFER_AMOUNT_ADJUST;\n\n        HashMap fromSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(fromSavingsID);\n        assertEquals(fromSavingsBalance, fromSavingsSummaryAfter.get(\"accountBalance\"),\n                \"Verifying From Savings Account Balance after Account Transfer\");\n\n        HashMap toLoanSummaryAfter = this.loanTransactionHelper.getLoanSummary(requestSpec, responseSpec, toLoanID);\n        assertEquals(TRANSFER_AMOUNT_ADJUST, toLoanSummaryAfter.get(\"totalRepayment\"),\n                \"Verifying To Loan Repayment Amount after Account Transfer\");\n\n        final JournalEntry[] office1LiabilityEntries = {\n                new JournalEntry(Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT_ADJUST), JournalEntry.TransactionType.CREDIT) };\n        final JournalEntry[] office2LiabilityEntries = {\n                new JournalEntry(Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT_ADJUST), JournalEntry.TransactionType.DEBIT) };\n\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(fromOfficeId, liabilityTransferAccount,\n                AccountTransferHelper.ACCOUNT_TRANSFER_DATE, office1LiabilityEntries);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(toOfficeId, liabilityTransferAccount,\n                AccountTransferHelper.ACCOUNT_TRANSFER_DATE, office2LiabilityEntries);\n    } END"}
{"prompt":"test From Loan To Savings Account Transfer\n\n###\n\n","completion":"    @Test\n    public void testFromLoanToSavingsAccountTransfer() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        final Account loanAssetAccount = this.accountHelper.createAssetAccount();\n        final Account loanIncomeAccount = this.accountHelper.createIncomeAccount();\n        final Account loanExpenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        this.accountTransferHelper = new AccountTransferHelper(this.requestSpec, this.responseSpec);\n\n        OfficeHelper officeHelper = new OfficeHelper(this.requestSpec, this.responseSpec);\n        Integer toOfficeId = officeHelper.createOffice(\"01 January 2011\");\n        Assertions.assertNotNull(toOfficeId);\n\n        \/\/ Creating Loan Account to which fund to be Transferred\n        final Integer toClientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2011\",\n                String.valueOf(toOfficeId));\n        Assertions.assertNotNull(toClientID);\n\n        final Integer toSavingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE, assetAccount,\n                incomeAccount, expenseAccount, liabilityAccount);\n        Assertions.assertNotNull(toSavingsProductID);\n\n        final Integer toSavingsID = this.savingsAccountHelper.applyForSavingsApplication(toClientID, toSavingsProductID,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(toSavingsID);\n\n        HashMap toSavingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, toSavingsID);\n        SavingsStatusChecker.verifySavingsIsPending(toSavingsStatusHashMap);\n\n        toSavingsStatusHashMap = this.savingsAccountHelper.approveSavings(toSavingsID);\n        SavingsStatusChecker.verifySavingsIsApproved(toSavingsStatusHashMap);\n\n        toSavingsStatusHashMap = this.savingsAccountHelper.activateSavings(toSavingsID);\n        SavingsStatusChecker.verifySavingsIsActive(toSavingsStatusHashMap);\n\n        Integer fromOfficeId = officeHelper.createOffice(\"01 January 2011\");\n        Assertions.assertNotNull(fromOfficeId);\n\n        \/\/ Creating Savings Account from which the Fund has to be Transferred\n        final Integer fromClientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2011\",\n                String.valueOf(fromOfficeId));\n        Assertions.assertNotNull(fromClientID);\n\n        final Integer loanProductID = createLoanProduct(loanAssetAccount, loanIncomeAccount, loanExpenseAccount, overpaymentAccount);\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplication(fromClientID, loanProductID);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_APPROVAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final Integer fromSavingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                assetAccount, incomeAccount, expenseAccount, liabilityAccount);\n        Assertions.assertNotNull(fromSavingsProductID);\n\n        final Integer fromSavingsID = this.savingsAccountHelper.applyForSavingsApplication(fromClientID, fromSavingsProductID,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(fromSavingsID);\n\n        HashMap fromSavingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsPending(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.approveSavings(fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsApproved(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.activateSavings(fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsActive(fromSavingsStatusHashMap);\n\n        final HashMap toSavingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(toSavingsID);\n\n        Float fromSavingsBalance = Float.valueOf(MINIMUM_OPENING_BALANCE);\n\n        this.accountTransferHelper.accountTransfer(fromClientID, fromSavingsID, fromClientID, loanID, FROM_SAVINGS_ACCOUNT_TYPE,\n                TO_LOAN_ACCOUNT_TYPE, ACCOUNT_TRANSFER_AMOUNT);\n\n        fromSavingsBalance -= TRANSFER_AMOUNT;\n\n        HashMap fromSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(fromSavingsID);\n\n        \/\/ Verifying fromSavings Account Balance after Account Transfer\n        assertEquals(fromSavingsBalance, fromSavingsSummaryAfter.get(\"accountBalance\"),\n                \"Verifying From Savings Account Balance after Account Transfer\");\n\n        Float toSavingsBalance = Float.valueOf(MINIMUM_OPENING_BALANCE);\n\n        this.accountTransferHelper.accountTransfer(fromClientID, loanID, toClientID, toSavingsID, FROM_LOAN_ACCOUNT_TYPE,\n                TO_SAVINGS_ACCOUNT_TYPE, ACCOUNT_TRANSFER_AMOUNT_ADJUST);\n\n        toSavingsBalance += TRANSFER_AMOUNT_ADJUST;\n\n        HashMap toSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(toSavingsID);\n\n        \/\/ Verifying toSavings Account Balance after Account Transfer\n        assertEquals(toSavingsBalance, toSavingsSummaryAfter.get(\"accountBalance\"),\n                \"Verifying From Savings Account Balance after Account Transfer\");\n\n        final JournalEntry[] office1LiabilityEntries = {\n                new JournalEntry(Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT_ADJUST), JournalEntry.TransactionType.CREDIT) };\n        final JournalEntry[] office2LiabilityEntries = {\n                new JournalEntry(Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT_ADJUST), JournalEntry.TransactionType.DEBIT) };\n\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(fromOfficeId, liabilityTransferAccount,\n                AccountTransferHelper.ACCOUNT_TRANSFER_DATE, office1LiabilityEntries);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(toOfficeId, liabilityTransferAccount,\n                AccountTransferHelper.ACCOUNT_TRANSFER_DATE, office2LiabilityEntries);\n\n    } END"}
{"prompt":"test Api Docs Access\n\n###\n\n","completion":"    @Test\n    public void testApiDocsAccess() {\n        Utils.performServerGet(requestSpec, responseSpec, \"\/fineract-provider\/legacy-docs\/apiLive.htm\", null);\n    } END"}
{"prompt":"test Audit Search Template\n\n###\n\n","completion":"    @Test\n    public void testAuditSearchTemplate() {\n        \/\/ given\n        \/\/ when\n        LinkedHashMap auditSearchTemplate = this.auditHelper.getAuditSearchTemplate();\n\n        \/\/ then\n        assertNotNull(auditSearchTemplate);\n        assertEquals(4, auditSearchTemplate.size()); \/\/ appUsers, actionNames, entityNames, processingResults\n        assertTrue(((List) auditSearchTemplate.get(\"actionNames\")).size() > 0);\n    } END"}
{"prompt":"audit Shouldbe Created\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void auditShouldbeCreated() {\n        \/\/ Audits recieved after all actions are performed.\n        List<HashMap<String, Object>> auditsRecieved;\n\n        \/\/ Audits recieved before any action is performed, needed in special\n        \/\/ cases eg: reactivate client, close client\n        List<HashMap<String, Object>> auditsRecievedInitial;\n\n        \/\/ When Client is created: Count should be \"1\"\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        auditsRecieved = auditHelper.getAuditDetails(clientId, \"CREATE\", \"CLIENT\");\n        auditHelper.verifyOneAuditOnly(auditsRecieved, clientId, \"CREATE\", \"CLIENT\");\n\n        \/\/ Performs multiple close and reactivate on client\n\n        for (int i = 0; i < 4; i++) {\n            \/\/ Close\n            auditsRecievedInitial = auditHelper.getAuditDetails(clientId, \"CLOSE\", \"CLIENT\");\n            this.clientHelper.closeClient(clientId);\n            auditsRecieved = auditHelper.getAuditDetails(clientId, \"CLOSE\", \"CLIENT\");\n            auditHelper.verifyMultipleAuditsOnserver(auditsRecievedInitial, auditsRecieved, clientId, \"CLOSE\", \"CLIENT\");\n\n            \/\/ Activate\n            auditsRecievedInitial = auditHelper.getAuditDetails(clientId, \"REACTIVATE\", \"CLIENT\");\n            this.clientHelper.reactivateClient(clientId);\n            auditsRecieved = auditHelper.getAuditDetails(clientId, \"REACTIVATE\", \"CLIENT\");\n            auditHelper.verifyMultipleAuditsOnserver(auditsRecievedInitial, auditsRecieved, clientId, \"REACTIVATE\", \"CLIENT\");\n        }\n\n        \/\/ When Office is created\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        int officeId = officeHelper.createOffice(\"22 June 2020\");\n        auditsRecieved = auditHelper.getAuditDetails(officeId, \"CREATE\", \"OFFICE\");\n        auditHelper.verifyOneAuditOnly(auditsRecieved, officeId, \"CREATE\", \"OFFICE\");\n    }\n\n    @Test\n    @SuppressFBWarnings(value = {\n            \"DMI_RANDOM_USED_ONLY_ONCE\" } END"}
{"prompt":"check If Order By Supported\n\n###\n\n","completion":"    @Test\n    public void checkIfOrderBySupported() {\n        final List<String> shouldBeSupportedFor = Arrays.asList(\"checkedOnDate\", \"officeName\", \"resourceId\", \"clientId\", \"processingResult\",\n                \"clientName\", \"maker\", \"subresourceId\", \"checker\", \"savingsAccountNo\", \"loanAccountNo\", \"groupName\", \"entityName\",\n                \"madeOnDate\", \"id\", \"loanId\", \"actionName\");\n\n        for (int i = 0; i < shouldBeSupportedFor.size(); i++) {\n            auditHelper.verifyOrderBysupported(shouldBeSupportedFor.get(i));\n        }\n\n    } END"}
{"prompt":"should Return Status Not Implemented Unknown Command\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReturnStatusNotImplementedUnknownCommand() {\n\n        final BatchRequest br = new BatchRequest();\n        br.setRequestId(4711L);\n        br.setRelativeUrl(\"\/nirvana\");\n        br.setMethod(\"POST\");\n\n        final List<BatchResponse> response = BatchHelper.postWithSingleRequest(this.requestSpec, this.responseSpec, br);\n\n        \/\/ Verify that only 501 is returned as the status code\n        for (BatchResponse resp : response) {\n            Assertions.assertEquals((long) 501, (long) resp.getStatusCode(), \"Verify Status code 501\");\n        }\n    } END"}
{"prompt":"should Return Ok Status For Create Client Command\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReturnOkStatusForCreateClientCommand() {\n\n        final BatchRequest br = BatchHelper.createClientRequest(4712L, \"\");\n\n        final List<BatchResponse> response = BatchHelper.postWithSingleRequest(this.requestSpec, this.responseSpec, br);\n\n        \/\/ Verify that a 200 response is returned as the status code\n        for (BatchResponse resp : response) {\n            Assertions.assertEquals((long) 200, (long) resp.getStatusCode(), \"Verify Status code 200\");\n        }\n    } END"}
{"prompt":"should Roll Back All Transactions On Failure\n\n###\n\n","completion":"     * @see org.apache.fineract.batch.api.BatchApiResource\n     * @see org.apache.fineract.batch.service.BatchApiService\n     *\/\n    @Test\n    public void shouldRollBackAllTransactionsOnFailure() {\n\n        \/\/ Create first client request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4713L, \"TestExtId11\");\n\n        \/\/ Create second client request\n        final BatchRequest br2 = BatchHelper.createClientRequest(4714L, \"TestExtId12\");\n\n        \/\/ Create third client request, having same externalID as second client,\n        \/\/ hence cause of error\n        final BatchRequest br3 = BatchHelper.createClientRequest(4715L, \"TestExtId11\");\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        \/\/ Verifies that none of the client in BatchRequest is created on the\n        \/\/ server\n        BatchHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, \"TestExtId11\");\n        BatchHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, \"TestExtId12\");\n\n        \/\/ Asserts that all the transactions have been successfully rolled back\n        Assertions.assertEquals(1, response.size());\n        Assertions.assertEquals((long) 400, (long) response.get(0).getStatusCode(), \"Verify Status code 400\");\n    } END"}
{"prompt":"should Reflect Changes On Client Update\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReflectChangesOnClientUpdate() {\n\n        \/\/ Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4716L, \"\");\n\n        \/\/ Create a clientUpdate Request\n        final BatchRequest br2 = BatchHelper.updateClientRequest(4717L, 4716L);\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        \/\/ Get the changes parameter from updateClient Response\n        final JsonObject changes = new FromJsonHelper().parse(response.get(1).getBody()).getAsJsonObject().get(\"changes\").getAsJsonObject();\n\n        \/\/ Asserts the client information is successfully updated\n        Assertions.assertEquals(\"TestFirstName\", changes.get(\"firstname\").getAsString());\n        Assertions.assertEquals(\"TestLastName\", changes.get(\"lastname\").getAsString());\n    } END"}
{"prompt":"should Return Ok Status For Apply Loan Command\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReturnOkStatusForApplyLoanCommand() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"10000000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4718L, \"\");\n\n        \/\/ Create a activateClient Request\n        final BatchRequest br2 = BatchHelper.activateClientRequest(4719L, 4718L);\n\n        \/\/ Create a ApplyLoan Request\n        final BatchRequest br3 = BatchHelper.applyLoanRequest(4720L, 4719L, productId, clientCollateralId);\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        \/\/ Get the clientId parameter from createClient Response\n        final JsonElement clientId = new FromJsonHelper().parse(response.get(0).getBody()).getAsJsonObject().get(\"clientId\");\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(1).getStatusCode(),\n                \"Verify Status Code 200\" + clientId.getAsString());\n    } END"}
{"prompt":"should Return Ok Status For Apply Savings Command\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReturnOkStatusForApplySavingsCommand() {\n\n        final SavingsProductHelper savingsProductHelper = new SavingsProductHelper();\n        final String savingsProductJSON = savingsProductHelper \/\/\n                .withInterestCompoundingPeriodTypeAsDaily() \/\/\n                .withInterestPostingPeriodTypeAsMonthly() \/\/\n                .withInterestCalculationPeriodTypeAsDailyBalance() \/\/\n                .withMinimumOpenningBalance(\"5000\").build();\n\n        final Integer productId = SavingsProductHelper.createSavingsProduct(savingsProductJSON, this.requestSpec, this.responseSpec);\n\n        \/\/ Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4720L, \"\");\n\n        \/\/ Create a activateClient Request\n        final BatchRequest br2 = BatchHelper.activateClientRequest(4721L, 4720L);\n\n        \/\/ Create a applySavings Request\n        final BatchRequest br3 = BatchHelper.applySavingsRequest(4722L, 4721L, productId);\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(1).getStatusCode(), \"Verify Status Code 200\");\n    } END"}
{"prompt":"should Return Ok Status For Collect Charges Command\n\n###\n\n","completion":"     * @see org.apache.fineract.batch.command.internal.CreateChargeCommandStrategy\n     *\/\n    @Test\n    public void shouldReturnOkStatusForCollectChargesCommand() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"10000000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4722L, \"\");\n\n        \/\/ Create a activateClient Request\n        final BatchRequest br2 = BatchHelper.activateClientRequest(4723L, 4722L);\n\n        \/\/ Create a ApplyLoan Request\n        final BatchRequest br3 = BatchHelper.applyLoanRequest(4724L, 4723L, productId, clientCollateralId);\n\n        \/\/ Create a Collect Charges Request\n        final BatchRequest br4 = BatchHelper.collectChargesByLoanIdRequest(4725L, 4724L);\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n        batchRequests.add(br4);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(3).getStatusCode(), \"Verify Status Code 200 for Create Loan Charge\");\n    } END"}
{"prompt":"should Return Ok Status For Create And Get Charge By Id Command\n\n###\n\n","completion":"     * @see org.apache.fineract.batch.command.internal.CreateChargeCommandStrategy\n     *\/\n    @Test\n    public void shouldReturnOkStatusForCreateAndGetChargeByIdCommand() {\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"1000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = Long.valueOf(RandomStringUtils.randomNumeric(4));\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long createChargeRequestId = disburseLoanRequestId + 1;\n        final Long getChargeByIdRequestId = createChargeRequestId + 1;\n\n        \/\/ Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        \/\/ Create charge object and get id\n        final Integer chargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON());\n\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        final BatchRequest createChargeRequest = BatchHelper.createChargeByLoanIdRequest(createChargeRequestId, disburseLoanRequestId,\n                chargeId);\n\n        final BatchRequest getChargeByIdRequest = BatchHelper.getChargeByLoanIdChargeId(getChargeByIdRequestId, createChargeRequestId);\n\n        \/\/ Create batch requests list\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest,\n                createChargeRequest, getChargeByIdRequest);\n\n        \/\/ Create batch responses list\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for Create Charge\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(4).getStatusCode(), \"Verify Status Code 200 for Get Charge By Id\");\n    } END"}
{"prompt":"should Return Ok Status On Successful Charge Adjustment\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulChargeAdjustment() {\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"1000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = Long.valueOf(RandomStringUtils.randomNumeric(4));\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long createChargeRequestId = disburseLoanRequestId + 1;\n        final Long adjustChargeRequestId = createChargeRequestId + 1;\n        final Long getTransactionRequestId = adjustChargeRequestId + 1;\n\n        \/\/ Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        \/\/ Create charge object and get id\n        final Integer chargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON());\n\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        final BatchRequest createChargeRequest = BatchHelper.createChargeByLoanIdRequest(createChargeRequestId, disburseLoanRequestId,\n                chargeId);\n\n        final BatchRequest adjustChargeRequest = BatchHelper.adjustChargeRequest(adjustChargeRequestId, createChargeRequestId);\n\n        final BatchRequest getTransactionRequest = BatchHelper.getTransactionByIdRequest(getTransactionRequestId, adjustChargeRequestId,\n                true);\n\n        \/\/ Create batch requests list\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest,\n                createChargeRequest, adjustChargeRequest, getTransactionRequest);\n\n        \/\/ Create batch responses list\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for Create Charge\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(4).getStatusCode(), \"Verify Status Code 200 for Adjust Charge\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(5).getStatusCode(), \"Verify Status Code 200 for Get Transaction By Id\");\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final JsonObject chargeAdjustment = jsonHelper.parse(responses.get(5).getBody()).getAsJsonObject().get(\"type\").getAsJsonObject();\n\n        Assertions.assertEquals(\"Charge Adjustment\", chargeAdjustment.get(\"value\").getAsString());\n        Assertions.assertTrue(chargeAdjustment.get(\"chargeAdjustment\").getAsBoolean());\n    } END"}
{"prompt":"should Return Ok Status For Create And Get Charge By External Id Command\n\n###\n\n","completion":"     * @see org.apache.fineract.batch.command.internal.CreateChargeCommandStrategy\n     *\/\n    @Test\n    public void shouldReturnOkStatusForCreateAndGetChargeByExternalIdCommand() {\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"1000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = Long.valueOf(RandomStringUtils.randomNumeric(4));\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long getLoanRequestId = disburseLoanRequestId + 1;\n        final Long createChargeRequestId = getLoanRequestId + 1;\n        final Long collectChargesRequestId = createChargeRequestId + 1;\n        final Long adjustChargeRequestId = createChargeRequestId + 1;\n        final Long getTransactionByExternalIdRequestId = adjustChargeRequestId + 1;\n        final Long getChargeByIdRequestId = getTransactionByExternalIdRequestId + 1;\n\n        \/\/ Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        \/\/ Create charge object and get id\n        final Integer chargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON());\n\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        final BatchRequest approveLoanRequest = BatchHelper.transistionLoanStateByExternalId(approveLoanRequestId, applyLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(10), \"approve\");\n\n        final BatchRequest disburseLoanRequest = BatchHelper.transistionLoanStateByExternalId(disburseLoanRequestId, approveLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(8), \"disburse\");\n\n        final BatchRequest getLoanRequest = BatchHelper.getLoanByExternalIdRequest(getLoanRequestId, approveLoanRequestId,\n                \"associations=all\");\n\n        final BatchRequest createChargeRequest = BatchHelper.createChargeByLoanExternalIdRequest(createChargeRequestId, getLoanRequestId,\n                chargeId);\n\n        final BatchRequest collectChargesRequest = BatchHelper.collectChargesByLoanExternalIdRequest(collectChargesRequestId,\n                getLoanRequestId);\n\n        \/\/ Create batch requests list\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest, getLoanRequest,\n                createChargeRequest, collectChargesRequest);\n\n        \/\/ Create batch responses list\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for Get Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(4).getStatusCode(), \"Verify Status Code 200 for Create Charge\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(5).getStatusCode(), \"Verify Status Code 200 for Collect charges\");\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final String loanExternalId = jsonHelper.parse(responses.get(3).getBody()).getAsJsonObject().get(\"externalId\").getAsString();\n        final String chargeExternalId = jsonHelper.parse(responses.get(4).getBody()).getAsJsonObject().get(\"resourceExternalId\")\n                .getAsString();\n\n        final BatchRequest adjustChargeByExternalId = BatchHelper.adjustChargeByExternalIdRequest(adjustChargeRequestId, null,\n                loanExternalId, chargeExternalId);\n        final BatchRequest getTransactionByExternalIdRequest = BatchHelper\n                .getTransactionByExternalIdRequest(getTransactionByExternalIdRequestId, adjustChargeRequestId, loanExternalId, true);\n        final BatchRequest getChargeByIdRequest = BatchHelper.getChargeByLoanExternalIdChargeExternalId(getChargeByIdRequestId,\n                getTransactionByExternalIdRequestId, loanExternalId, chargeExternalId);\n\n        \/\/ Create batch responses list\n        final List<BatchResponse> adjustChargeAndGetResponses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec,\n                this.responseSpec,\n                BatchHelper.toJsonString(Arrays.asList(adjustChargeByExternalId, getTransactionByExternalIdRequest, getChargeByIdRequest)));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, adjustChargeAndGetResponses.get(0).getStatusCode(),\n                \"Verify Status Code 200 for Adjust Charge By External Id\");\n        Assertions.assertEquals(HttpStatus.SC_OK, adjustChargeAndGetResponses.get(1).getStatusCode(),\n                \"Verify Status Code 200 for Get Transaction By Id\");\n        Assertions.assertEquals(HttpStatus.SC_OK, adjustChargeAndGetResponses.get(2).getStatusCode(),\n                \"Verify Status Code 200 for Get Charge By Id\");\n\n        final JsonObject chargeAdjustment = jsonHelper.parse(adjustChargeAndGetResponses.get(1).getBody()).getAsJsonObject().get(\"type\")\n                .getAsJsonObject();\n\n        Assertions.assertEquals(\"Charge Adjustment\", chargeAdjustment.get(\"value\").getAsString());\n        Assertions.assertTrue(chargeAdjustment.get(\"chargeAdjustment\").getAsBoolean());\n    } END"}
{"prompt":"should Return Ok Status For Batch Repayment\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReturnOkStatusForBatchRepayment() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"10000000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4730L, \"\");\n\n        \/\/ Create a activateClient Request\n        final BatchRequest br2 = BatchHelper.activateClientRequest(4731L, 4730L);\n\n        \/\/ Create a ApplyLoan Request\n        final BatchRequest br3 = BatchHelper.applyLoanRequest(4732L, 4731L, productId, clientCollateralId);\n\n        \/\/ Create a approveLoan Request\n        final BatchRequest br4 = BatchHelper.approveLoanRequest(4733L, 4732L);\n\n        \/\/ Create a disburseLoan Request\n        final BatchRequest br5 = BatchHelper.disburseLoanRequest(4734L, 4733L);\n\n        \/\/ Create a loanRepay Request\n        final BatchRequest br6 = BatchHelper.repayLoanRequest(4735L, 4734L, \"500\");\n\n        \/\/ Create a loanRepay Request\n        final BatchRequest br7 = BatchHelper.repayLoanRequest(4736L, 4734L, \"500\");\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n        batchRequests.add(br4);\n        batchRequests.add(br5);\n        batchRequests.add(br6);\n        batchRequests.add(br7);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(5).getStatusCode(), \"Verify Status Code 200 for Repayment\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(6).getStatusCode(), \"Verify Status Code 200 for Repayment\");\n    } END"}
{"prompt":"should Return Ok Status For Batch Credit Balance Refund\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReturnOkStatusForBatchCreditBalanceRefund() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"1000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        final Long createActiveClientRequestId = 4730L;\n        final Long applyLoanRequestId = createActiveClientRequestId + 1;\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long repayLoanRequestId = disburseLoanRequestId + 1;\n        final Long creditBalanceRefundRequestId = repayLoanRequestId + 1;\n\n        \/\/ Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createActiveClientRequest(createActiveClientRequestId, \"\");\n\n        \/\/ Create a ApplyLoan Request\n        final BatchRequest br2 = BatchHelper.applyLoanRequest(applyLoanRequestId, createActiveClientRequestId, productId,\n                clientCollateralId);\n\n        \/\/ Create a approveLoan Request\n        final BatchRequest br3 = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        \/\/ Create a disburseLoan Request\n        final BatchRequest br4 = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        \/\/ Create a loanRepay Request which will result in an overpay.\n        final BatchRequest br5 = BatchHelper.repayLoanRequest(repayLoanRequestId, disburseLoanRequestId, \"20000\");\n\n        \/\/ Create a credit balance refund request\n        final BatchRequest br6 = BatchHelper.creditBalanceRefundRequest(creditBalanceRefundRequestId, repayLoanRequestId, \"500\");\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n        batchRequests.add(br4);\n        batchRequests.add(br5);\n        batchRequests.add(br6);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(4).getStatusCode(), \"Verify Status Code 200 for Repayment\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(5).getStatusCode(),\n                \"Verify Status Code 200 for Credit Balance Refund\");\n    } END"}
{"prompt":"partial Fail Test For Batch Request\n\n###\n\n","completion":"    @Test\n    public void partialFailTestForBatchRequest() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"1000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        final Long createActiveClientRequestId = 4730L;\n        final Long applyLoanRequestId = createActiveClientRequestId + 1;\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long fetchLoanInfoRequestId = disburseLoanRequestId + 1;\n\n        \/\/ Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createActiveClientRequest(createActiveClientRequestId, \"\");\n\n        \/\/ Create a ApplyLoan Request\n        final BatchRequest br2 = BatchHelper.applyLoanRequest(applyLoanRequestId, createActiveClientRequestId, productId,\n                clientCollateralId);\n\n        \/\/ Create a wrong approveLoan Request\n        final BatchRequest br3 = BatchHelper.approveLoanWrongRequest(approveLoanRequestId, applyLoanRequestId);\n\n        \/\/ Fetch loan info\n        final BatchRequest br4 = BatchHelper.getLoanByIdRequest(fetchLoanInfoRequestId, applyLoanRequestId, null);\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n        batchRequests.add(br4);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_NOT_IMPLEMENTED, (long) response.get(2).getStatusCode(), \"Resource doesn not exists\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(3).getStatusCode(),\n                \"Verify Status Code 200 for fetch data after the error\");\n    } END"}
{"prompt":"should Return Ok Status For Batch Goodwill Credit\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReturnOkStatusForBatchGoodwillCredit() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"1000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        final Long createActiveClientRequestId = 4730L;\n        final Long applyLoanRequestId = createActiveClientRequestId + 1;\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long goodwillCreditRequestId = disburseLoanRequestId + 1;\n\n        \/\/ Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createActiveClientRequest(createActiveClientRequestId, \"\");\n\n        \/\/ Create a ApplyLoan Request\n        final BatchRequest br2 = BatchHelper.applyLoanRequest(applyLoanRequestId, createActiveClientRequestId, productId,\n                clientCollateralId);\n\n        \/\/ Create a approveLoan Request\n        final BatchRequest br3 = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        \/\/ Create a disburseLoan Request\n        final BatchRequest br4 = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        \/\/ Create a good will credit request.\n        final BatchRequest br5 = BatchHelper.goodwillCreditRequest(goodwillCreditRequestId, disburseLoanRequestId, \"500\");\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n        batchRequests.add(br4);\n        batchRequests.add(br5);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(4).getStatusCode(), \"Verify Status Code 200 for Goodwill credit\");\n    } END"}
{"prompt":"should Return Ok Status On Successful Client Activation\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulClientActivation() {\n\n        \/\/ Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4726L, \"\");\n\n        \/\/ Create an activateClient Request\n        final BatchRequest br2 = BatchHelper.activateClientRequest(4727L, 4726L);\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(0).getStatusCode(), \"Verify Status Code 200 for Create Client\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(1).getStatusCode(), \"Verify Status Code 200 for Activate Client\");\n    } END"}
{"prompt":"should Return Ok Status On Successful Loan Approval And Disburse\n\n###\n\n","completion":"     * @see org.apache.fineract.batch.command.internal.DisburseLoanCommandStrategy\n     *\/\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulLoanApprovalAndDisburse() {\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"10000000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4730L, \"\");\n\n        \/\/ Create a activateClient Request\n        final BatchRequest br2 = BatchHelper.activateClientRequest(4731L, 4730L);\n\n        \/\/ Create an ApplyLoan Request\n        final BatchRequest br3 = BatchHelper.applyLoanRequest(4732L, 4731L, productId, clientCollateralId);\n\n        \/\/ Create an approveLoan Request\n        final BatchRequest br4 = BatchHelper.approveLoanRequest(4733L, 4732L);\n\n        \/\/ Create an disburseLoan Request\n        final BatchRequest br5 = BatchHelper.disburseLoanRequest(4734L, 4733L);\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n        batchRequests.add(br4);\n        batchRequests.add(br5);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(3).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(4).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n    } END"}
{"prompt":"should Return Ok Status On Successful Loan Approval And Disburse With Transaction\n\n###\n\n","completion":"     * @see org.apache.fineract.batch.command.internal.DisburseLoanCommandStrategy\n     *\/\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulLoanApprovalAndDisburseWithTransaction() {\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"10000000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createActiveClientRequest(4740L, \"\");\n\n        \/\/ Create an ApplyLoan Request\n        final BatchRequest br2 = BatchHelper.applyLoanRequest(4742L, 4740L, productId, clientCollateralId);\n\n        \/\/ Create an approveLoan Request\n        final BatchRequest br3 = BatchHelper.approveLoanRequest(4743L, 4742L);\n\n        \/\/ Create a disburseLoan Request\n        final BatchRequest br4 = BatchHelper.disburseLoanRequest(4744L, 4743L);\n\n        final List<BatchRequest> batchRequests = Arrays.asList(br1, br2, br3, br4);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(0).getStatusCode(), \"Verify Status Code 200 for create client\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(1).getStatusCode(), \"Verify Status Code 200 for apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(2).getStatusCode(), \"Verify Status Code 200 for approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(3).getStatusCode(), \"Verify Status Code 200 for disburse Loan\");\n    } END"}
{"prompt":"should Return Ok Status On Successful Disbursement And Get Transaction\n\n###\n\n","completion":"     * @see org.apache.fineract.batch.command.internal.GetTransactionByIdCommandStrategy\n     *\/\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulDisbursementAndGetTransaction() {\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"10000000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = 6730L;\n        final Long approveLoanRequestId = 6731L;\n        final Long disburseLoanRequestId = 6732L;\n        final Long getTransactionRequestId = 6733L;\n\n        \/\/ Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        \/\/ Create an ApplyLoan Request\n        final BatchRequest batchRequest1 = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        \/\/ Create an approveLoan Request\n        final BatchRequest batchRequest2 = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        \/\/ Create a disbursement Request\n        final BatchRequest batchRequest3 = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        \/\/ Create a getTransaction Request\n        final BatchRequest batchRequest4 = BatchHelper.getTransactionByIdRequest(getTransactionRequestId, disburseLoanRequestId, true);\n\n        final List<BatchRequest> batchRequests = Arrays.asList(batchRequest1, batchRequest2, batchRequest3, batchRequest4);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for Get Transaction By Id\");\n    } END"}
{"prompt":"should Return Ok Status On Successful Disbursement And Reschedule Loan\n\n###\n\n","completion":"     * @see org.apache.fineract.batch.command.internal.ApproveLoanRescheduleCommandStrategy\n     *\/\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulDisbursementAndRescheduleLoan() {\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"10000000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long createActiveClientRequestId = 8462L;\n        final Long applyLoanRequestId = createActiveClientRequestId + 1;\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long rescheduleLoanRequestId = disburseLoanRequestId + 1;\n        final Long approveRescheduleLoanRequestId = rescheduleLoanRequestId + 1;\n\n        \/\/ Create product\n        LOG.info(\"LoanProduct {}\", loanProductJSON);\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        \/* Retrieve\/Create Code Values for the Code \"LoanRescheduleReason = 23\" *\/\n        final HashMap<String, Object> codeValue = CodeHelper.retrieveOrCreateCodeValue(23, this.requestSpec, this.responseSpec);\n\n        final Integer codeValueId = (Integer) codeValue.get(\"id\");\n\n        \/\/ Create an ApplyLoan request\n        final BatchRequest applyLoanRequestWithClientId = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        \/\/ Create an approveLoan request\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        \/\/ Create a disbursement request\n        final LocalDate disburseLoanDate = LocalDate.now(ZoneId.systemDefault()).minusDays(1);\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId,\n                disburseLoanDate);\n\n        \/\/ Create a reschedule loan request\n        final BatchRequest rescheduleLoanRequest = BatchHelper.createRescheduleLoanRequest(rescheduleLoanRequestId, disburseLoanRequestId,\n                disburseLoanDate.plusMonths(1), codeValueId);\n\n        \/\/ Approve reschedule loan request\n        final BatchRequest approveRescheduleLoanRequest = BatchHelper.approveRescheduleLoanRequest(approveRescheduleLoanRequestId,\n                rescheduleLoanRequestId);\n\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequestWithClientId, approveLoanRequest, disburseLoanRequest,\n                rescheduleLoanRequest, approveRescheduleLoanRequest);\n\n        LOG.info(\"shouldReturnOkStatusOnSuccessfulDisbursementAndRescheduleLoan Request - {}\", BatchHelper.toJsonString(batchRequests));\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(),\n                \"Verify Status Code 200 for Create Reschedule Loan request\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(4).getStatusCode(),\n                \"Verify Status Code 200 for Approve Reschedule Loan request\");\n    } END"}
{"prompt":"should Return Ok Status On Successful Create Client Create Approve And Get Loan\n\n###\n\n","completion":"     * @see org.apache.fineract.batch.command.internal.ApplyLoanCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.ApproveLoanCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.GetLoanByIdCommandStrategy\n     *\/\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulCreateClientCreateApproveAndGetLoan() {\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"10000000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long createActiveClientRequestId = 4730L;\n        final Long applyLoanRequestId = 4731L;\n        final Long approveLoanRequestId = 4732L;\n        final Long getLoanByIdRequestId = 4733L;\n\n        \/\/ Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create createClient Request\n        final BatchRequest batchRequest1 = BatchHelper.createActiveClientRequest(createActiveClientRequestId, \"\");\n\n        \/\/ Create an ApplyLoan Request\n        final BatchRequest batchRequest2 = BatchHelper.applyLoanRequest(applyLoanRequestId, createActiveClientRequestId, productId, null);\n\n        \/\/ Create an approveLoan Request\n        final BatchRequest batchRequest3 = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        \/\/ Get loan by id Request\n        final BatchRequest batchRequest4 = BatchHelper.getLoanByIdRequest(getLoanByIdRequestId, applyLoanRequestId, null);\n\n        final List<BatchRequest> batchRequests = Arrays.asList(batchRequest1, batchRequest2, batchRequest3, batchRequest4);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Create Client\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for Get Loan By Id\");\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long loanId = jsonHelper.extractLongNamed(\"loanId\", jsonHelper.parse(responses.get(1).getBody()).getAsJsonObject());\n        final Long loanIdInGetResponse = jsonHelper.extractLongNamed(\"id\", jsonHelper.parse(responses.get(3).getBody()).getAsJsonObject());\n        final JsonObject statusInGetResponse = jsonHelper.parse(responses.get(3).getBody()).getAsJsonObject().get(\"status\")\n                .getAsJsonObject();\n\n        Assertions.assertEquals(loanId, loanIdInGetResponse);\n        Assertions.assertEquals(LoanStatus.APPROVED.getCode(), jsonHelper.extractStringNamed(\"code\", statusInGetResponse));\n        Assertions.assertEquals(\"Approved\", jsonHelper.extractStringNamed(\"value\", statusInGetResponse));\n    } END"}
{"prompt":"should Return Ok Status On Successful Create Approve And Get Loan\n\n###\n\n","completion":"     * @see org.apache.fineract.batch.command.internal.ApproveLoanCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.GetLoanByIdCommandStrategy\n     *\/\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulCreateApproveAndGetLoan() {\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"10000000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = 5730L;\n        final Long approveLoanRequestId = 5731L;\n        final Long getLoanByIdRequestId = 5732L;\n        final Long getLoanByIdWithQueryParametersRequestId = 5733L;\n\n        \/\/ Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        \/\/ Create an ApplyLoan Request\n        final BatchRequest batchRequest1 = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        \/\/ Create an approveLoan Request\n        final BatchRequest batchRequest2 = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        \/\/ Get loan by id Request without query param\n        final BatchRequest batchRequest3 = BatchHelper.getLoanByIdRequest(getLoanByIdRequestId, applyLoanRequestId, null);\n\n        \/\/ Get loan by id Request with query param\n        final BatchRequest batchRequest4 = BatchHelper.getLoanByIdRequest(getLoanByIdWithQueryParametersRequestId, applyLoanRequestId,\n                \"associations=repaymentSchedule,transactions\");\n\n        final List<BatchRequest> batchRequests = Arrays.asList(batchRequest1, batchRequest2, batchRequest3, batchRequest4);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(),\n                \"Verify Status Code 200 for Get Loan By Id without query parameter\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(),\n                \"Verify Status Code 200 for Get Loan By Id with query parameter\");\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long loanId = jsonHelper.extractLongNamed(\"loanId\", jsonHelper.parse(responses.get(0).getBody()).getAsJsonObject());\n        final Long loanIdInGetResponse = jsonHelper.extractLongNamed(\"id\", jsonHelper.parse(responses.get(2).getBody()).getAsJsonObject());\n        final JsonObject statusInGetResponse = jsonHelper.parse(responses.get(2).getBody()).getAsJsonObject().get(\"status\")\n                .getAsJsonObject();\n\n        Assertions.assertEquals(loanId, loanIdInGetResponse);\n        Assertions.assertEquals(LoanStatus.APPROVED.getCode(), jsonHelper.extractStringNamed(\"code\", statusInGetResponse));\n        Assertions.assertEquals(\"Approved\", jsonHelper.extractStringNamed(\"value\", statusInGetResponse));\n\n        \/\/ Repayment schedule will not be available in the response\n        Assertions.assertFalse(responses.get(2).getBody().contains(\"repaymentSchedule\"));\n\n        \/\/ Repayment schedule information will be available in the response based on the query parameter\n        Assertions.assertTrue(responses.get(3).getBody().contains(\"repaymentSchedule\"));\n    } END"}
{"prompt":"should Return Ok Status On Successful Get Data Table Entry\n\n###\n\n","completion":"     * @see org.apache.fineract.batch.command.internal.ApproveLoanCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.GetLoanByIdCommandStrategy\n     *\/\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulGetDataTableEntry() {\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long loanId = jsonHelper.extractLongNamed(\"loanId\", jsonHelper.parse(setupAccount()).getAsJsonObject());\n        final String datatableName = this.datatableHelper.createDatatable(LOAN_APP_TABLE_NAME, false);\n        try {\n\n            \/\/ Get loan by id Request with query param\n            final BatchRequest getLoanBatchRequest = BatchHelper.getLoanByIdRequest(loanId, \"associations=repaymentSchedule,transactions\");\n\n            \/\/ Get datatable batch request\n            final BatchRequest getDatatableBatchRequest = BatchHelper.getDatatableByIdRequest(loanId, datatableName,\n                    \"genericResultSet=true\", null);\n\n            final List<BatchRequest> batchRequestsGetLoan = Arrays.asList(getLoanBatchRequest, getDatatableBatchRequest);\n\n            final List<BatchResponse> responsesGetLoan = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec,\n                    this.responseSpec, BatchHelper.toJsonString(batchRequestsGetLoan));\n\n            final String getLoanResponse = responsesGetLoan.get(0).getBody();\n            final String getDatatableResponse = responsesGetLoan.get(1).getBody();\n\n            Assertions.assertEquals(HttpStatus.SC_OK, responsesGetLoan.get(0).getStatusCode(), \"Verify Status Code 200 for get loan\");\n            Assertions.assertEquals(HttpStatus.SC_OK, responsesGetLoan.get(1).getStatusCode(), \"Verify Status Code 200 for datatable\");\n\n            final Long loanIdInGetResponse = jsonHelper.extractLongNamed(\"id\", jsonHelper.parse(getLoanResponse).getAsJsonObject());\n            Assertions.assertEquals(loanId, loanIdInGetResponse);\n\n            \/\/ Repayment schedule information will be available in the response based on the query parameter\n            Assertions.assertTrue(getLoanResponse.contains(\"repaymentSchedule\"));\n\n            \/\/ Transaction will be available in the response based on the query parameter\n            Assertions.assertTrue(getLoanResponse.contains(\"transactions\"));\n\n            \/\/ datatable info will be available in the response based on the query parameter\n            Assertions.assertTrue(getDatatableResponse.contains(\"columnHeaders\"));\n\n            \/\/ datatable info will be available in the response based on the query parameter\n            Assertions.assertTrue(getDatatableResponse.contains(\"data\"));\n        } finally {\n            deleteDatatable(datatableName);\n        }\n    } END"}
{"prompt":"should Return Ok Status On Successful Create Data Table Entry\n\n###\n\n","completion":"     * @see org.apache.fineract.batch.command.internal.UpdateDatatableEntryOneToManyCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.GetDatatableEntryByAppTableIdCommandStrategy\n     * @see GetDatatableEntryByAppTableIdAndDataTableIdCommandStrategy\n     *\/\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulCreateDataTableEntry() {\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long loanId = jsonHelper.extractLongNamed(\"loanId\", jsonHelper.parse(setupAccount()).getAsJsonObject());\n        \/\/ creating datatable with m_loan association\n        final Map<String, Object> columnMap = new HashMap<>();\n        final List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n        final String datatableName = Utils.uniqueRandomStringGenerator(LOAN_APP_TABLE_NAME + \"_\", 5);\n        final String columnName1 = Utils.randomStringGenerator(\"COL1_\", 5);\n        final String columnName2 = Utils.randomStringGenerator(\"COL2_\", 5);\n        columnMap.put(\"datatableName\", datatableName);\n        columnMap.put(\"apptableName\", LOAN_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"PERSON\");\n        columnMap.put(\"multiRow\", true);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, columnName1, \"String\", true, 10, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, columnName2, \"String\", false, 10, null);\n        columnMap.put(\"columns\", datatableColumnsList);\n        final String datatableRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"CreateDataTable map : {}\", datatableRequestJsonString);\n\n        this.datatableHelper.createDatatable(datatableRequestJsonString, \"\");\n\n        \/\/ Create a datatable entry so that it can be updated using BatchApi\n        final Map<String, Object> datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(columnName1, Utils.randomStringGenerator(\"VAL1_\", 3));\n        datatableEntryMap.put(columnName2, Utils.randomStringGenerator(\"VAL2_\", 3));\n        final String datatableEntryRequestJsonString = new Gson().toJson(datatableEntryMap);\n        LOG.info(\"CreateDataTableEntry map : {}\", datatableEntryRequestJsonString);\n\n        final Map<String, Object> datatableEntryResponse = this.datatableHelper.createDatatableEntry(datatableName, loanId.intValue(),\n                false, datatableEntryRequestJsonString);\n        final Integer datatableEntryResourceId = (Integer) datatableEntryResponse.get(\"resourceId\");\n        assertNotNull(datatableEntryResourceId, \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n\n        \/\/ Create datatable entry batch request\n        final BatchRequest createDatatableEntryRequest = BatchHelper.createDatatableEntryRequest(loanId, datatableName,\n                Arrays.asList(columnName1, columnName2));\n\n        \/\/ Update datatable entry batch request\n        final BatchRequest updateDatatableEntryByEntryIdRequest = BatchHelper.updateDatatableEntryByEntryIdRequest(loanId, datatableName,\n                Long.valueOf(datatableEntryResourceId), Arrays.asList(columnName1));\n\n        \/\/ Get datatable entries batch request\n        final BatchRequest getDatatableEntriesRequest = BatchHelper.getDatatableByIdRequest(loanId, datatableName, null,\n                updateDatatableEntryByEntryIdRequest.getReference());\n\n        \/\/ Get datatable entry by app table id batch request\n        final BatchRequest getDatatableEntryByIdRequest = BatchHelper.getDatatableEntryByIdRequest(loanId, datatableName, \"$.resourceId\",\n                null, updateDatatableEntryByEntryIdRequest.getReference());\n\n        final List<BatchRequest> batchRequestsDatatableEntries = Arrays.asList(createDatatableEntryRequest,\n                updateDatatableEntryByEntryIdRequest, getDatatableEntriesRequest, getDatatableEntryByIdRequest);\n        LOG.info(\"Batch Request : {}\", BatchHelper.toJsonString(batchRequestsDatatableEntries));\n\n        final List<BatchResponse> responseDatatableBatch = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec,\n                this.responseSpec, BatchHelper.toJsonString(batchRequestsDatatableEntries));\n\n        LOG.info(\"Batch Response : {}\", new Gson().toJson(responseDatatableBatch));\n\n        final BatchResponse batchResponse1 = responseDatatableBatch.get(0);\n        final BatchResponse batchResponse2 = responseDatatableBatch.get(1);\n        final BatchResponse batchResponse3 = responseDatatableBatch.get(2);\n        final BatchResponse batchResponse4 = responseDatatableBatch.get(3);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, batchResponse1.getStatusCode(), \"Verify Status Code 200 for create datatable entry\");\n        Assertions.assertEquals(HttpStatus.SC_OK, batchResponse2.getStatusCode(), \"Verify Status Code 200 for update datatable entry\");\n        Assertions.assertEquals(HttpStatus.SC_OK, batchResponse3.getStatusCode(), \"Verify Status Code 200 for get datatable entries\");\n        Assertions.assertEquals(HttpStatus.SC_OK, batchResponse4.getStatusCode(), \"Verify Status Code 200 for get datatable entry by id\");\n\n        final String getDatatableEntriesResponse = batchResponse3.getBody();\n\n        final Long createDatatableEntryId = jsonHelper.extractLongNamed(\"resourceId\",\n                jsonHelper.parse(batchResponse1.getBody()).getAsJsonObject());\n\n        final JsonArray datatableEntries = jsonHelper.parse(getDatatableEntriesResponse).getAsJsonArray();\n        Assertions.assertEquals(2, datatableEntries.size());\n\n        \/\/ Ensure both resourceIds are available in response\n        Assertions.assertTrue(getDatatableEntriesResponse.contains(String.format(\"\\\"id\\\": %d\", createDatatableEntryId)));\n        Assertions.assertTrue(getDatatableEntriesResponse.contains(String.format(\"\\\"id\\\": %d\", datatableEntryResourceId)));\n    } END"}
{"prompt":"should Return Ok Status On Successful Get Datatable Entry With No Query Param\n\n###\n\n","completion":"     * @see org.apache.fineract.batch.command.internal.ApproveLoanCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.GetLoanByIdCommandStrategy\n     *\/\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulGetDatatableEntryWithNoQueryParam() {\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long loanId = jsonHelper.extractLongNamed(\"loanId\", jsonHelper.parse(setupAccount()).getAsJsonObject());\n        final String datatableName = this.datatableHelper.createDatatable(LOAN_APP_TABLE_NAME, false);\n        try {\n            \/\/ Get loan by id Request with query param\n            final BatchRequest getLoanBatchRequest = BatchHelper.getLoanByIdRequest(loanId, \"associations=repaymentSchedule,transactions\");\n\n            \/\/ Get datatable batch request\n            final BatchRequest getDatatableBatchRequest = BatchHelper.getDatatableByIdRequest(loanId, datatableName, null, null);\n\n            final List<BatchRequest> batchRequestsGetLoan = Arrays.asList(getLoanBatchRequest, getDatatableBatchRequest);\n\n            final List<BatchResponse> responsesGetLoan = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec,\n                    this.responseSpec, BatchHelper.toJsonString(batchRequestsGetLoan));\n\n            final String getLoanResponse = responsesGetLoan.get(0).getBody();\n\n            Assertions.assertEquals(HttpStatus.SC_OK, responsesGetLoan.get(0).getStatusCode(), \"Verify Status Code 200 for Get Loan\");\n            Assertions.assertEquals(HttpStatus.SC_OK, responsesGetLoan.get(1).getStatusCode(), \"Verify Status Code 200 for Get Datatable\");\n\n            final Long loanIdInGetResponse = jsonHelper.extractLongNamed(\"id\", jsonHelper.parse(getLoanResponse).getAsJsonObject());\n            Assertions.assertEquals(loanId, loanIdInGetResponse);\n\n            Assertions.assertTrue(getLoanResponse.contains(\"repaymentSchedule\"));\n\n            Assertions.assertTrue(getLoanResponse.contains(\"transactions\"));\n        } finally {\n            deleteDatatable(datatableName);\n        }\n\n    } END"}
{"prompt":"should Return Ok Status On Successful Transaction Merchant Issued And Payout Refund\n\n###\n\n","completion":"     * @see org.apache.fineract.batch.command.internal.ApproveLoanCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.DisburseLoanCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.CreateTransactionLoanCommandStrategy\n     *\/\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulTransactionMerchantIssuedAndPayoutRefund() {\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"10000000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = 5730L;\n        final Long approveLoanRequestId = 5731L;\n        final Long disburseLoanRequestId = 5732L;\n        final Long merchantIssuedRefundRequestId = 5733L;\n        final Long payoutRefundRequestId = 5734L;\n\n        \/\/ Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        \/\/ Create an ApplyLoan Request\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        \/\/ Create an approveLoan Request\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        \/\/ Create a disbursement request\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(1));\n\n        \/\/ Create a merchant issued refund request\n        final BatchRequest merchantIssuedRefundRequest = BatchHelper.merchantIssuedRefundRequest(merchantIssuedRefundRequestId,\n                applyLoanRequestId, \"10\");\n\n        \/\/ Create a payout refund request\n        final BatchRequest payoutRefundRequest = BatchHelper.payoutRefundRequest(payoutRefundRequestId, applyLoanRequestId, \"10\");\n\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest,\n                merchantIssuedRefundRequest, payoutRefundRequest);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for merchant issued refund\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(4).getStatusCode(), \"Verify Status Code 200 for payout refund\");\n    } END"}
{"prompt":"should Return Ok Status For Batch Repayment Reversal\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReturnOkStatusForBatchRepaymentReversal() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"10000000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        final LocalDate date = LocalDate.now(Utils.getZoneIdOfTenant());\n        final Long applyLoanRequestId = 5730L;\n        final Long approveLoanRequestId = 5731L;\n        final Long disburseLoanRequestId = 5732L;\n        final Long repayLoanRequestId = 5733L;\n        final Long repayReversalRequestId = 5734L;\n        final Long getLoanRequestId = 5735L;\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        \/\/ Create an apply loan request\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        \/\/ Create an approve loan request\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        \/\/ Create a disburse loan request\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        \/\/ Create a repayment request.\n        final BatchRequest repaymentRequest = BatchHelper.repayLoanRequest(repayLoanRequestId, disburseLoanRequestId, \"500\");\n\n        \/\/ Create a repayment reversal request\n        final BatchRequest repaymentReversalRequest = BatchHelper.createAdjustTransactionRequest(repayReversalRequestId, repayLoanRequestId,\n                \"0\", date);\n\n        \/\/ Get loan transactions request\n        final BatchRequest getLoanTransactionsRequest = BatchHelper.getLoanByIdRequest(getLoanRequestId, applyLoanRequestId,\n                \"associations=transactions\");\n\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest, repaymentRequest,\n                repaymentReversalRequest, getLoanTransactionsRequest);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final JsonObject repayment = jsonHelper.parse(responses.get(5).getBody()).getAsJsonObject().get(\"transactions\").getAsJsonArray()\n                .get(2).getAsJsonObject();\n        final JsonArray dateArray = repayment.get(\"reversedOnDate\").getAsJsonArray();\n        final LocalDate reversedOnDate = LocalDate.of(dateArray.get(0).getAsInt(), dateArray.get(1).getAsInt(),\n                dateArray.get(2).getAsInt());\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) responses.get(4).getStatusCode(), \"Verify Status Code 200 for repayment reversal\");\n        Assertions.assertEquals(\"Repayment\", repayment.get(\"type\").getAsJsonObject().get(\"value\").getAsString());\n        Assertions.assertTrue(repayment.get(\"manuallyReversed\").getAsBoolean());\n        Assertions.assertEquals(date, reversedOnDate);\n    } END"}
{"prompt":"should Return Ok Status For Batch Repayment Reversal Using External Id\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReturnOkStatusForBatchRepaymentReversalUsingExternalId() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"10000000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        final LocalDate date = LocalDate.now(Utils.getZoneIdOfTenant());\n        final Long applyLoanRequestId = Long.valueOf(RandomStringUtils.randomNumeric(4));\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long getLoanBeforeTxnRequestId = disburseLoanRequestId + 1;\n        final Long repayLoanRequestId = getLoanBeforeTxnRequestId + 1;\n        final Long getLoanAfterTxnRequestId = repayLoanRequestId + 1;\n        final Long repayReversalRequestId = getLoanAfterTxnRequestId + 1;\n        final Long getLoanAfterReversal = repayReversalRequestId + 1;\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n        final String loanExternalId = UUID.randomUUID().toString();\n\n        \/\/ Create an apply loan request\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientIdAndExternalId(applyLoanRequestId, clientId, productId,\n                loanExternalId);\n\n        \/\/ Create an approve loan request\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        \/\/ Create a disburse loan request\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        \/\/ Get loan transactions request\n        final BatchRequest getLoanTransactionsRequestBeforeTxn = BatchHelper.getLoanByIdRequest(getLoanBeforeTxnRequestId,\n                disburseLoanRequestId, \"associations=transactions\");\n\n        \/\/ Create a repayment request by external id\n        final BatchRequest repaymentRequest = BatchHelper.createTransactionRequestByLoanExternalId(repayLoanRequestId,\n                getLoanBeforeTxnRequestId, \"repayment\", \"500\", LocalDate.now(ZoneId.systemDefault()));\n\n        \/\/ Get loan transactions request\n        final BatchRequest getLoanTransactionsRequestAfterTxn = BatchHelper.getLoanByIdRequest(getLoanAfterTxnRequestId, repayLoanRequestId,\n                \"associations=transactions\");\n\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest,\n                getLoanTransactionsRequestBeforeTxn, repaymentRequest, getLoanTransactionsRequestAfterTxn);\n\n        \/\/ Because loanExternalId & transactionExternalId are coming from 2 different responses, there is no easy way to\n        \/\/ use them as reference in 1 batch api call.\n        \/\/ So we are splitting repayment & reversal into 2 different batch api invocations\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final String loanExternalIdDisburseLoanResponse = jsonHelper.parse(responses.get(3).getBody()).getAsJsonObject().get(\"externalId\")\n                .getAsString();\n        final Long loanId = jsonHelper.parse(responses.get(3).getBody()).getAsJsonObject().get(\"id\").getAsLong();\n        final String transactionExternalId = jsonHelper.parse(responses.get(4).getBody()).getAsJsonObject().get(\"resourceExternalId\")\n                .getAsString();\n        Assertions.assertNotNull(loanExternalIdDisburseLoanResponse);\n        Assertions.assertEquals(loanExternalId, loanExternalIdDisburseLoanResponse);\n        Assertions.assertNotNull(transactionExternalId);\n\n        \/\/ Create a repayment reversal request by external id\n        final BatchRequest repaymentReversalRequest = BatchHelper.createAdjustTransactionByExternalIdRequest(repayReversalRequestId, null,\n                loanExternalIdDisburseLoanResponse, transactionExternalId, \"0\", date);\n\n        final BatchRequest getLoanByIdWithTransactions = BatchHelper.getLoanByIdRequest(loanId, getLoanAfterReversal,\n                repayReversalRequestId, \"associations=transactions\");\n\n        final List<BatchRequest> reversalAndGetBatchRequest = Arrays.asList(repaymentReversalRequest, getLoanByIdWithTransactions);\n\n        final List<BatchResponse> reversalResponses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec,\n                this.responseSpec, BatchHelper.toJsonString(reversalAndGetBatchRequest));\n\n        final JsonObject repayment = jsonHelper.parse(reversalResponses.get(1).getBody()).getAsJsonObject().get(\"transactions\")\n                .getAsJsonArray().get(2).getAsJsonObject();\n\n        final JsonArray dateArray = repayment.get(\"reversedOnDate\").getAsJsonArray();\n        final LocalDate reversedOnDate = LocalDate.of(dateArray.get(0).getAsInt(), dateArray.get(1).getAsInt(),\n                dateArray.get(2).getAsInt());\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) reversalResponses.get(0).getStatusCode(),\n                \"Verify Status Code 200 for repayment reversal\");\n        Assertions.assertEquals(\"Repayment\", repayment.get(\"type\").getAsJsonObject().get(\"value\").getAsString());\n\n        Assertions.assertTrue(repayment.get(\"manuallyReversed\").getAsBoolean());\n        Assertions.assertEquals(date, reversedOnDate);\n    } END"}
{"prompt":"should Return Ok Status For Batch Repayment Chargeback\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReturnOkStatusForBatchRepaymentChargeback() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"10000000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        final Long applyLoanRequestId = 5730L;\n        final Long approveLoanRequestId = 5731L;\n        final Long disburseLoanRequestId = 5732L;\n        final Long repayLoanRequestId = 5733L;\n        final Long repayReversalRequestId = 5734L;\n        final Long getLoanRequestId = 5735L;\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        \/\/ Create an apply loan request\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        \/\/ Create an approve loan request\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        \/\/ Create a disburse loan request\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        \/\/ Create a repayment request\n        final BatchRequest repaymentRequest = BatchHelper.repayLoanRequest(repayLoanRequestId, disburseLoanRequestId, \"500\");\n\n        \/\/ Create a repayment chargeback request\n        final BatchRequest repaymentChargebackRequest = BatchHelper.createChargebackTransactionRequest(repayReversalRequestId,\n                repayLoanRequestId, \"500\");\n\n        \/\/ Get loan transactions request\n        final BatchRequest getLoanTransactionsRequest = BatchHelper.getLoanByIdRequest(getLoanRequestId, applyLoanRequestId,\n                \"associations=transactions\");\n\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest, repaymentRequest,\n                repaymentChargebackRequest, getLoanTransactionsRequest);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final JsonObject repayment = jsonHelper.parse(responses.get(5).getBody()).getAsJsonObject().get(\"transactions\").getAsJsonArray()\n                .get(2).getAsJsonObject();\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) responses.get(4).getStatusCode(),\n                \"Verify Status Code 200 for repayment chargeback\");\n        Assertions.assertEquals(\"Repayment\", repayment.get(\"type\").getAsJsonObject().get(\"value\").getAsString());\n        final JsonArray transactionRelations = repayment.get(\"transactionRelations\").getAsJsonArray();\n        Assertions.assertEquals(1, transactionRelations.size());\n        Assertions.assertEquals(\"CHARGEBACK\", transactionRelations.get(0).getAsJsonObject().get(\"relationType\").getAsString());\n    } END"}
{"prompt":"should Return Ok Status For Batch Goodwill Credit Reversal\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReturnOkStatusForBatchGoodwillCreditReversal() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"1000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        final LocalDate date = LocalDate.now(Utils.getZoneIdOfTenant());\n        final Long applyLoanRequestId = 5730L;\n        final Long approveLoanRequestId = 5731L;\n        final Long disburseLoanRequestId = 5732L;\n        final Long goodwillCreditRequestId = 5733L;\n        final Long goodwillCreditReversalRequestId = 5734L;\n        final Long getLoanRequestId = 5735L;\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        \/\/ Create an apply loan request\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        \/\/ Create an approve loan request\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        \/\/ Create a disburse loan request\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        \/\/ Create a good will credit request\n        final BatchRequest goodwillCreditRequest = BatchHelper.goodwillCreditRequest(goodwillCreditRequestId, disburseLoanRequestId, \"500\");\n\n        \/\/ Create a good will credit reversal request\n        final BatchRequest goodwillCreditReversalRequest = BatchHelper.createAdjustTransactionRequest(goodwillCreditReversalRequestId,\n                goodwillCreditRequestId, \"0\", date);\n\n        \/\/ Get loan transactions request\n        final BatchRequest getLoanTransactionsRequest = BatchHelper.getLoanByIdRequest(getLoanRequestId, applyLoanRequestId,\n                \"associations=transactions\");\n\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest,\n                goodwillCreditRequest, goodwillCreditReversalRequest, getLoanTransactionsRequest);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final JsonObject goodWillCredit = jsonHelper.parse(responses.get(5).getBody()).getAsJsonObject().get(\"transactions\")\n                .getAsJsonArray().get(2).getAsJsonObject();\n        final JsonArray dateArray = goodWillCredit.get(\"reversedOnDate\").getAsJsonArray();\n        final LocalDate reversedOnDate = LocalDate.of(dateArray.get(0).getAsInt(), dateArray.get(1).getAsInt(),\n                dateArray.get(2).getAsInt());\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) responses.get(4).getStatusCode(),\n                \"Verify Status Code 200 for goodwill credit reversal\");\n        Assertions.assertEquals(\"Goodwill Credit\", goodWillCredit.get(\"type\").getAsJsonObject().get(\"value\").getAsString());\n        Assertions.assertTrue(goodWillCredit.get(\"manuallyReversed\").getAsBoolean());\n        Assertions.assertEquals(date, reversedOnDate);\n    } END"}
{"prompt":"should Return Ok Status On Successful Transaction Merchant Issued And Payout Refund Reversal\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulTransactionMerchantIssuedAndPayoutRefundReversal() {\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"10000000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final LocalDate date = LocalDate.now(Utils.getZoneIdOfTenant());\n        final Long applyLoanRequestId = 5730L;\n        final Long approveLoanRequestId = 5731L;\n        final Long disburseLoanRequestId = 5732L;\n        final Long merchantIssuedRefundRequestId = 5733L;\n        final Long payoutRefundRequestId = 5734L;\n        final Long merchantIssuedRefundReversalRequestId = 5735L;\n        final Long payoutRefundReversalRequestId = 5736L;\n        final Long getLoanRequestId = 5737L;\n\n        \/\/ Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        \/\/ Create an apply loan request\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        \/\/ Create an approve loan request\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        \/\/ Create a disburse loan request\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId,\n                date.minusDays(1));\n\n        \/\/ Create a merchant issued refund request\n        final BatchRequest merchantIssuedRefundRequest = BatchHelper.merchantIssuedRefundRequest(merchantIssuedRefundRequestId,\n                applyLoanRequestId, \"10\");\n\n        \/\/ Create a payout refund request\n        final BatchRequest payoutRefundRequest = BatchHelper.payoutRefundRequest(payoutRefundRequestId, applyLoanRequestId, \"10\");\n\n        \/\/ Create a merchant issued refund reversal request\n        final BatchRequest merchantIssuedRefundReversalRequest = BatchHelper\n                .createAdjustTransactionRequest(merchantIssuedRefundReversalRequestId, merchantIssuedRefundRequestId, \"0\", date);\n\n        \/\/ Create a payout refund reversal request\n        final BatchRequest payoutRefundReversalRequest = BatchHelper.createAdjustTransactionRequest(payoutRefundReversalRequestId,\n                payoutRefundRequestId, \"0\", date);\n\n        \/\/ Get loan transactions request\n        final BatchRequest getLoanTransactionsRequest = BatchHelper.getLoanByIdRequest(getLoanRequestId, applyLoanRequestId,\n                \"associations=transactions\");\n\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest,\n                merchantIssuedRefundRequest, payoutRefundRequest, merchantIssuedRefundReversalRequest, payoutRefundReversalRequest,\n                getLoanTransactionsRequest);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final JsonObject merchantIssuedRefund = jsonHelper.parse(responses.get(7).getBody()).getAsJsonObject().get(\"transactions\")\n                .getAsJsonArray().get(2).getAsJsonObject();\n        final JsonObject payoutRefund = jsonHelper.parse(responses.get(7).getBody()).getAsJsonObject().get(\"transactions\").getAsJsonArray()\n                .get(3).getAsJsonObject();\n        final JsonArray merchantIssuedDateArray = merchantIssuedRefund.get(\"reversedOnDate\").getAsJsonArray();\n        final LocalDate merchantIssuedDate = LocalDate.of(merchantIssuedDateArray.get(0).getAsInt(),\n                merchantIssuedDateArray.get(1).getAsInt(), merchantIssuedDateArray.get(2).getAsInt());\n        final JsonArray payoutRefundDateArray = payoutRefund.getAsJsonObject().get(\"reversedOnDate\").getAsJsonArray();\n        final LocalDate payoutRefundDate = LocalDate.of(payoutRefundDateArray.get(0).getAsInt(), payoutRefundDateArray.get(1).getAsInt(),\n                payoutRefundDateArray.get(2).getAsInt());\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(5).getStatusCode(),\n                \"Verify Status Code 200 for merchant issued refund reversal\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(6).getStatusCode(), \"Verify Status Code 200 for payout refund reversal\");\n        Assertions.assertEquals(\"Merchant Issued Refund\", merchantIssuedRefund.get(\"type\").getAsJsonObject().get(\"value\").getAsString());\n        Assertions.assertEquals(\"Payout Refund\", payoutRefund.get(\"type\").getAsJsonObject().get(\"value\").getAsString());\n        Assertions.assertTrue(merchantIssuedRefund.get(\"manuallyReversed\").getAsBoolean());\n        Assertions.assertTrue(payoutRefund.get(\"manuallyReversed\").getAsBoolean());\n        Assertions.assertEquals(date, merchantIssuedDate);\n        Assertions.assertEquals(date, payoutRefundDate);\n    } END"}
{"prompt":"should Return Ok Status On Modifying Saving Account\n\n###\n\n","completion":"    @Test\n    public void shouldReturnOkStatusOnModifyingSavingAccount() {\n        final String startDate = \"10 April 2022\";\n        final SavingsProductHelper savingsProductHelper = new SavingsProductHelper();\n        final SavingsAccountHelper savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n        final String savingsProductJSON = savingsProductHelper.withInterestCompoundingPeriodTypeAsDaily()\n                .withInterestPostingPeriodTypeAsDaily().withInterestCalculationPeriodTypeAsDailyBalance().build();\n        final Integer savingsProductID = SavingsProductHelper.createSavingsProduct(savingsProductJSON, requestSpec, responseSpec);\n        Assertions.assertNotNull(savingsProductID);\n        final Integer savingsId = savingsAccountHelper.applyForSavingsApplicationOnDate(clientID, savingsProductID, \"INDIVIDUAL\",\n                startDate);\n        Assertions.assertNotNull(savingsId);\n        HashMap savingsStatusHashMap = savingsAccountHelper.approveSavingsOnDate(savingsId, startDate);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n        savingsStatusHashMap = savingsAccountHelper.activateSavingsAccount(savingsId, startDate);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final BatchRequest getSavingAccountRequest = BatchHelper.getSavingAccount(1L, Long.valueOf(savingsId), \"chargeStatus=all\", null);\n        final BatchRequest depositSavingAccountRequest = BatchHelper.depositSavingAccount(2L, 1L);\n        final BatchRequest holdAmountOnSavingAccountRequest = BatchHelper.holdAmountOnSavingAccount(3L, 1L);\n\n        final List<BatchRequest> batchRequests1 = Arrays.asList(getSavingAccountRequest, depositSavingAccountRequest,\n                holdAmountOnSavingAccountRequest);\n        final List<BatchResponse> responses1 = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests1));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses1.get(1).getStatusCode(), \"Verify Status Code 200 for deposit saving account\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses1.get(2).getStatusCode(),\n                \"Verify Status Code 200 for hold amount on saving account\");\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long holdAmountTransactionId = jsonHelper.parse(responses1.get(2).getBody()).getAsJsonObject().get(\"resourceId\").getAsLong();\n\n        final BatchRequest releaseAmountOnSavingAccountRequest = BatchHelper.releaseAmountOnSavingAccount(2L, 1L, holdAmountTransactionId);\n        final BatchRequest withdrawSavingAccountRequest = BatchHelper.withdrawSavingAccount(3L, 1L);\n\n        final List<BatchRequest> batchRequests2 = Arrays.asList(getSavingAccountRequest, releaseAmountOnSavingAccountRequest,\n                withdrawSavingAccountRequest);\n        final List<BatchResponse> responses2 = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests2));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses2.get(1).getStatusCode(),\n                \"Verify Status Code 200 for release amount on saving account\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses2.get(2).getStatusCode(), \"Verify Status Code 200 for withdraw saving account\");\n    } END"}
{"prompt":"should Find One To One Datatable Entry By Query APIAnd Update One Of Its Column\n\n###\n\n","completion":"    @Test\n    public void shouldFindOneToOneDatatableEntryByQueryAPIAndUpdateOneOfItsColumn() {\n        final String datatableName = Utils.uniqueRandomStringGenerator(LOAN_APP_TABLE_NAME + \"_\", 5).toLowerCase();\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long loanId = jsonHelper.extractLongNamed(\"loanId\", jsonHelper.parse(setupAccount()).getAsJsonObject());\n        \/\/ creating datatable with m_loan association\n        final Map<String, Object> columnMap = new HashMap<>();\n        final List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n\n        final String columnName1 = Utils.randomStringGenerator(\"COL1_\", 5).toLowerCase();\n        final String columnName2 = Utils.randomStringGenerator(\"COL2_\", 5).toLowerCase();\n        columnMap.put(\"datatableName\", datatableName);\n        columnMap.put(\"apptableName\", LOAN_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"PERSON\");\n        columnMap.put(\"multiRow\", false);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, columnName1, \"String\", true, 10, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, columnName2, \"String\", false, 10, null);\n        columnMap.put(\"columns\", datatableColumnsList);\n        final String datatableRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"CreateDataTable map : {}\", datatableRequestJsonString);\n\n        this.datatableHelper.createDatatable(datatableRequestJsonString, \"\");\n\n        \/\/ Create a datatable entry so that it can be updated using BatchApi\n        final Map<String, Object> datatableEntryMap = new HashMap<>();\n        String columnValue1 = Utils.randomStringGenerator(\"VAL1_\", 3);\n        String columnValue2 = Utils.randomStringGenerator(\"VAL2_\", 3);\n        datatableEntryMap.put(columnName1, columnValue1);\n        datatableEntryMap.put(columnName2, columnValue2);\n        final String datatableEntryRequestJsonString = new Gson().toJson(datatableEntryMap);\n        LOG.info(\"CreateDataTableEntry map : {}\", datatableEntryRequestJsonString);\n\n        final Map<String, Object> datatableEntryResponse = this.datatableHelper.createDatatableEntry(datatableName, loanId.intValue(),\n                false, datatableEntryRequestJsonString);\n        final Integer datatableEntryResourceId = (Integer) datatableEntryResponse.get(\"resourceId\");\n        assertNotNull(datatableEntryResourceId, \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n\n        final BatchRequest queryDatatableEntriesRequest = BatchHelper.queryDatatableEntries(datatableName, columnName1, columnValue1,\n                \"loan_id\");\n        final BatchRequest updateDatatableEntry = BatchHelper.updateDatatableEntry(datatableName, \"$.[0].loan_id\", columnName2,\n                columnValue2 + \"1\");\n\n        final List<BatchRequest> batchRequestsToQueryAndUpdateDatatableEntries = Arrays.asList(queryDatatableEntriesRequest,\n                updateDatatableEntry);\n        LOG.info(\"Batch Request : {}\", BatchHelper.toJsonString(batchRequestsToQueryAndUpdateDatatableEntries));\n\n        final List<BatchResponse> responseOfQuertAndUpdateDatatableBatch = BatchHelper.postBatchRequestsWithEnclosingTransaction(\n                this.requestSpec, this.responseSpec, BatchHelper.toJsonString(batchRequestsToQueryAndUpdateDatatableEntries));\n\n        LOG.info(\"Batch Response : {}\", new Gson().toJson(responseOfQuertAndUpdateDatatableBatch));\n\n        final BatchResponse batchQueryAndUpdateResponse1 = responseOfQuertAndUpdateDatatableBatch.get(0);\n        final BatchResponse batchQueryAndUpdateResponse2 = responseOfQuertAndUpdateDatatableBatch.get(1);\n        Assertions.assertEquals(HttpStatus.SC_OK, batchQueryAndUpdateResponse1.getStatusCode(),\n                \"Verify Status Code 200 for create datatable entry\");\n        Assertions.assertEquals(HttpStatus.SC_OK, batchQueryAndUpdateResponse2.getStatusCode(),\n                \"Verify Status Code 200 for update datatable entry\");\n\n        final JsonObject changes = jsonHelper.parse(batchQueryAndUpdateResponse2.getBody()).getAsJsonObject().get(\"changes\")\n                .getAsJsonObject();\n        Assertions.assertEquals(changes.get(columnName2).getAsString(), columnValue2 + \"1\");\n    } END"}
{"prompt":"should Find One To Many Datatable Entry By Query APIAnd Update One Of Its Column\n\n###\n\n","completion":"    @Test\n    public void shouldFindOneToManyDatatableEntryByQueryAPIAndUpdateOneOfItsColumn() {\n        final String datatableName = Utils.uniqueRandomStringGenerator(LOAN_APP_TABLE_NAME + \"_\", 5).toLowerCase();\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long loanId = jsonHelper.extractLongNamed(\"loanId\", jsonHelper.parse(setupAccount()).getAsJsonObject());\n        \/\/ creating datatable with m_loan association\n        final Map<String, Object> columnMap = new HashMap<>();\n        final List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n\n        final String columnName1 = Utils.randomStringGenerator(\"COL1_\", 5).toLowerCase();\n        final String columnName2 = Utils.randomStringGenerator(\"COL2_\", 5).toLowerCase();\n        columnMap.put(\"datatableName\", datatableName);\n        columnMap.put(\"apptableName\", LOAN_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"PERSON\");\n        columnMap.put(\"multiRow\", true);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, columnName1, \"String\", true, 10, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, columnName2, \"String\", false, 10, null);\n        columnMap.put(\"columns\", datatableColumnsList);\n        final String datatableRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"CreateDataTable map : {}\", datatableRequestJsonString);\n\n        this.datatableHelper.createDatatable(datatableRequestJsonString, \"\");\n\n        \/\/ Create a datatable entry so that it can be updated using BatchApi\n        final Map<String, Object> datatableEntryMap = new HashMap<>();\n        String columnValue1 = Utils.randomStringGenerator(\"VAL1_\", 3);\n        String columnValue2 = Utils.randomStringGenerator(\"VAL2_\", 3);\n        datatableEntryMap.put(columnName1, columnValue1);\n        datatableEntryMap.put(columnName2, columnValue2);\n        final String datatableEntryRequestJsonString = new Gson().toJson(datatableEntryMap);\n        LOG.info(\"CreateDataTableEntry map : {}\", datatableEntryRequestJsonString);\n\n        final Map<String, Object> datatableEntryResponse = this.datatableHelper.createDatatableEntry(datatableName, loanId.intValue(),\n                false, datatableEntryRequestJsonString);\n        final Integer datatableEntryResourceId = (Integer) datatableEntryResponse.get(\"resourceId\");\n        assertNotNull(datatableEntryResourceId, \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n\n        \/\/ Create datatable entry batch request\n        final BatchRequest createDatatableEntryRequest = BatchHelper.createDatatableEntryRequest(loanId, datatableName,\n                Arrays.asList(columnName1, columnName2));\n\n        \/\/ Get datatable entries batch request\n        final BatchRequest getDatatableEntriesRequest = BatchHelper.getDatatableByIdRequest(loanId, datatableName, null,\n                createDatatableEntryRequest.getReference());\n\n        final List<BatchRequest> batchRequestsDatatableEntries = Arrays.asList(createDatatableEntryRequest, getDatatableEntriesRequest);\n        LOG.info(\"Batch Request : {}\", BatchHelper.toJsonString(batchRequestsDatatableEntries));\n\n        final List<BatchResponse> responseDatatableBatch = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec,\n                this.responseSpec, BatchHelper.toJsonString(batchRequestsDatatableEntries));\n\n        LOG.info(\"Batch Response : {}\", new Gson().toJson(responseDatatableBatch));\n\n        final BatchResponse batchResponse1 = responseDatatableBatch.get(0);\n        final BatchResponse batchResponse2 = responseDatatableBatch.get(1);\n        Assertions.assertEquals(HttpStatus.SC_OK, batchResponse1.getStatusCode(), \"Verify Status Code 200 for create datatable entry\");\n        Assertions.assertEquals(HttpStatus.SC_OK, batchResponse2.getStatusCode(), \"Verify Status Code 200 for update datatable entry\");\n\n        final String getDatatableEntriesResponse = batchResponse2.getBody();\n\n        final Long createDatatableEntryId = jsonHelper.extractLongNamed(\"resourceId\",\n                jsonHelper.parse(batchResponse1.getBody()).getAsJsonObject());\n\n        final JsonArray datatableEntries = jsonHelper.parse(getDatatableEntriesResponse).getAsJsonArray();\n        Assertions.assertEquals(2, datatableEntries.size());\n\n        \/\/ Ensure both resourceIds are available in response\n        Assertions.assertTrue(getDatatableEntriesResponse.contains(String.format(\"\\\"id\\\": %d\", createDatatableEntryId)));\n        Assertions.assertTrue(getDatatableEntriesResponse.contains(String.format(\"\\\"id\\\": %d\", datatableEntryResourceId)));\n\n        final BatchRequest queryDatatableEntriesRequest = BatchHelper.queryDatatableEntries(datatableName, columnName1, columnValue1,\n                \"id,loan_id\");\n        final BatchRequest updateDatatableEntry = BatchHelper.updateDatatableEntry(datatableName, \"$.[0].loan_id\", \"$.[0].id\", columnName2,\n                columnValue2 + \"1\");\n\n        final List<BatchRequest> batchRequestsToQueryAndUpdateDatatableEntries = Arrays.asList(queryDatatableEntriesRequest,\n                updateDatatableEntry);\n        LOG.info(\"Batch Request : {}\", BatchHelper.toJsonString(batchRequestsToQueryAndUpdateDatatableEntries));\n\n        final List<BatchResponse> responseOfQuertAndUpdateDatatableBatch = BatchHelper.postBatchRequestsWithEnclosingTransaction(\n                this.requestSpec, this.responseSpec, BatchHelper.toJsonString(batchRequestsToQueryAndUpdateDatatableEntries));\n\n        LOG.info(\"Batch Response : {}\", new Gson().toJson(responseOfQuertAndUpdateDatatableBatch));\n\n        final BatchResponse batchQueryAndUpdateResponse1 = responseOfQuertAndUpdateDatatableBatch.get(0);\n        final BatchResponse batchQueryAndUpdateResponse2 = responseOfQuertAndUpdateDatatableBatch.get(1);\n        Assertions.assertEquals(HttpStatus.SC_OK, batchQueryAndUpdateResponse1.getStatusCode(),\n                \"Verify Status Code 200 for create datatable entry\");\n        Assertions.assertEquals(HttpStatus.SC_OK, batchQueryAndUpdateResponse2.getStatusCode(),\n                \"Verify Status Code 200 for update datatable entry\");\n\n        final JsonObject changes = jsonHelper.parse(batchQueryAndUpdateResponse2.getBody()).getAsJsonObject().get(\"changes\")\n                .getAsJsonObject();\n        Assertions.assertEquals(changes.get(columnName2).getAsString(), columnValue2 + \"1\");\n    } END"}
{"prompt":"should Reflect Changes On Loan Update\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReflectChangesOnLoanUpdate() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"1000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = RandomUtils.nextLong(100, 1000);\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long updateLoanRequestId = disburseLoanRequestId + 1;\n\n        \/\/ Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        final BatchRequest updateLoanRequest = BatchHelper.createLoanRequestMarkAsFraud(updateLoanRequestId, disburseLoanRequestId);\n\n        \/\/ Create batch requests list\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest,\n                updateLoanRequest);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        \/\/ Get the changes parameter from updateLoan Response\n        final JsonObject changes = new FromJsonHelper().parse(response.get(3).getBody()).getAsJsonObject().get(\"changes\").getAsJsonObject();\n\n        Assertions.assertEquals(HttpStatus.SC_OK, response.get(3).getStatusCode(), \"Verify Status Code 200 for update loan application\");\n        Assertions.assertEquals(\"true\", changes.get(\"fraud\").getAsString());\n    } END"}
{"prompt":"should Reflect Changes On Loan Update By External Id\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shouldReflectChangesOnLoanUpdateByExternalId() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"1000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = RandomUtils.nextLong(100, 1000);\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long updateLoanRequestId = disburseLoanRequestId + 1;\n        final Long getLoanRequestId = updateLoanRequestId + 1;\n\n        \/\/ Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        final BatchRequest approveLoanRequest = BatchHelper.transistionLoanStateByExternalId(approveLoanRequestId, applyLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(10), \"approve\");\n\n        final BatchRequest disburseLoanRequest = BatchHelper.transistionLoanStateByExternalId(disburseLoanRequestId, approveLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(8), \"disburse\");\n\n        final BatchRequest updateLoanRequest = BatchHelper.modifyLoanByExternalIdRequest(updateLoanRequestId, approveLoanRequestId);\n\n        final BatchRequest getLoanRequest = BatchHelper.getLoanByExternalIdRequest(getLoanRequestId, approveLoanRequestId,\n                \"associations=all\");\n\n        \/\/ Create batch requests list\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest, updateLoanRequest,\n                getLoanRequest);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for update loan application\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(4).getStatusCode(), \"Verify Status Code 200 for Get Loan\");\n\n        \/\/ Get the changes parameter from updateLoan Response\n        final JsonObject changes = new FromJsonHelper().parse(responses.get(3).getBody()).getAsJsonObject().get(\"changes\")\n                .getAsJsonObject();\n        Assertions.assertEquals(\"true\", changes.get(\"fraud\").getAsString());\n    } END"}
{"prompt":"shoul Retrieve The Proper Error During Locked Loan Old Relative Path\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shoulRetrieveTheProperErrorDuringLockedLoan_OldRelativePath() {\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(202).build();\n        LoanAccountLockHelper loanAccountLockHelper = new LoanAccountLockHelper(this.requestSpec, responseSpec);\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"1000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = RandomUtils.nextLong(100, 1000);\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long getLoanRequestId = disburseLoanRequestId + 1;\n\n        \/\/ Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        final BatchRequest approveLoanRequest = BatchHelper.transistionLoanStateByExternalId(approveLoanRequestId, applyLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(10), \"approve\");\n\n        final BatchRequest disburseLoanRequest = BatchHelper.transistionLoanStateByExternalId(disburseLoanRequestId, approveLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(8), \"disburse\");\n\n        final BatchRequest getLoanRequest = BatchHelper.getLoanByExternalIdRequest(getLoanRequestId, approveLoanRequestId,\n                \"associations=all\");\n\n        \/\/ Create batch requests list\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest, getLoanRequest);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for Get Loan\");\n\n        final Long loanId = new FromJsonHelper().parse(responses.get(2).getBody()).getAsJsonObject().get(\"resourceId\").getAsLong();\n\n        loanAccountLockHelper.placeSoftLockOnLoanAccount(loanId.intValue(), \"LOAN_COB_CHUNK_PROCESSING\");\n\n        RequestSpecification requestSpec = UserHelper.getSimpleUserWithoutBypassPermission(this.requestSpec, this.responseSpec);\n\n        \/\/ Create a repayment Request\n        final BatchRequest br = new BatchRequest();\n\n        br.setRequestId(1L);\n        br.setRelativeUrl(String.format(\"loans\/\" + loanId + \"\/transactions?command=repayment\"));\n        br.setMethod(\"POST\");\n        String dateString = LocalDate.now(ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(\"dd MMMM yyyy\"));\n        br.setBody(String.format(\n                \"{\\\"locale\\\": \\\"en\\\", \\\"dateFormat\\\": \\\"dd MMMM yyyy\\\", \" + \"\\\"transactionDate\\\": \\\"%s\\\",  \\\"transactionAmount\\\": \\\"500\\\"}\",\n                dateString));\n\n        final String jsonifiedRepaymentRequest = BatchHelper.toJsonString(List.of(br));\n\n        final List<BatchResponse> repaymentResponse = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(requestSpec,\n                this.responseSpec, jsonifiedRepaymentRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_CONFLICT, repaymentResponse.get(0).getStatusCode(), \"Verify Status Code 409 for Locked Loan\");\n    } END"}
{"prompt":"shoul Retrieve The Proper Error During Locked Loan\n\n###\n\n","completion":"     *\/\n    @Test\n    public void shoulRetrieveTheProperErrorDuringLockedLoan() {\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(202).build();\n        LoanAccountLockHelper loanAccountLockHelper = new LoanAccountLockHelper(this.requestSpec, responseSpec);\n        final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                .withPrincipal(\"1000.00\") \/\/\n                .withNumberOfRepayments(\"24\") \/\/\n                .withRepaymentAfterEvery(\"1\") \/\/\n                .withRepaymentTypeAsMonth() \/\/\n                .withinterestRatePerPeriod(\"2\") \/\/\n                .withInterestRateFrequencyTypeAsMonths() \/\/\n                .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                .withInterestTypeAsDecliningBalance() \/\/\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = RandomUtils.nextLong(100, 1000);\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long getLoanRequestId = disburseLoanRequestId + 1;\n\n        \/\/ Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        \/\/ Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        final BatchRequest approveLoanRequest = BatchHelper.transistionLoanStateByExternalId(approveLoanRequestId, applyLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(10), \"approve\");\n\n        final BatchRequest disburseLoanRequest = BatchHelper.transistionLoanStateByExternalId(disburseLoanRequestId, approveLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(8), \"disburse\");\n\n        final BatchRequest getLoanRequest = BatchHelper.getLoanByExternalIdRequest(getLoanRequestId, approveLoanRequestId,\n                \"associations=all\");\n\n        \/\/ Create batch requests list\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest, getLoanRequest);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for Get Loan\");\n\n        final Long loanId = new FromJsonHelper().parse(responses.get(2).getBody()).getAsJsonObject().get(\"resourceId\").getAsLong();\n\n        loanAccountLockHelper.placeSoftLockOnLoanAccount(loanId.intValue(), \"LOAN_COB_CHUNK_PROCESSING\");\n\n        RequestSpecification requestSpec = UserHelper.getSimpleUserWithoutBypassPermission(this.requestSpec, this.responseSpec);\n\n        \/\/ Create a repayment Request\n        final BatchRequest br = new BatchRequest();\n\n        br.setRequestId(1L);\n        br.setRelativeUrl(String.format(\"v1\/loans\/\" + loanId + \"\/transactions?command=repayment\"));\n        br.setMethod(\"POST\");\n        String dateString = LocalDate.now(ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(\"dd MMMM yyyy\"));\n        br.setBody(String.format(\n                \"{\\\"locale\\\": \\\"en\\\", \\\"dateFormat\\\": \\\"dd MMMM yyyy\\\", \" + \"\\\"transactionDate\\\": \\\"%s\\\",  \\\"transactionAmount\\\": \\\"500\\\"}\",\n                dateString));\n\n        final String jsonifiedRepaymentRequest = BatchHelper.toJsonString(List.of(br));\n\n        final List<BatchResponse> repaymentResponse = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(requestSpec,\n                this.responseSpec, jsonifiedRepaymentRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_CONFLICT, repaymentResponse.get(0).getStatusCode(), \"Verify Status Code 409 for Locked Loan\");\n    } END"}
{"prompt":"should Return Ok Status With Idempotency Support\n\n###\n\n","completion":"    @Test\n    public void shouldReturnOkStatusWithIdempotencySupport() {\n\n        \/\/ Generate a random count of number of clients to be created\n        final Integer clientsCount = (int) Math.ceil(secureRandom.nextDouble() * 7) + 3;\n        final Integer[] clientIDs = new Integer[clientsCount];\n\n        \/\/ Create a new group and get its groupId\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n\n        \/\/ Create new clients and add those to this group\n        for (Integer i = 0; i < clientsCount; i++) {\n            clientIDs[i] = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n            groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientIDs[i].toString());\n            LOG.info(\"client {} has been added to the group {}\", clientIDs[i], groupID);\n        }\n\n        \/\/ Generate a random count of number of new loan products to be created\n        final Integer loansCount = (int) Math.ceil(secureRandom.nextDouble() * 4) + 1;\n        final Integer[] loanProducts = new Integer[loansCount];\n\n        \/\/ Create new loan Products\n        LoanTransactionHelper helper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        for (Integer i = 0; i < loansCount; i++) {\n            final String loanProductJSON = new LoanProductTestBuilder() \/\/\n                    .withPrincipal(String.valueOf(10000.00 + Math.ceil(secureRandom.nextDouble() * 1000000.00))) \/\/\n                    .withNumberOfRepayments(String.valueOf(2 + (int) Math.ceil(secureRandom.nextDouble() * 36))) \/\/\n                    .withRepaymentAfterEvery(String.valueOf(1 + (int) Math.ceil(secureRandom.nextDouble() * 3))) \/\/\n                    .withRepaymentTypeAsMonth() \/\/\n                    .withinterestRatePerPeriod(String.valueOf(1 + (int) Math.ceil(secureRandom.nextDouble() * 4))) \/\/\n                    .withInterestRateFrequencyTypeAsMonths() \/\/\n                    .withAmortizationTypeAsEqualPrincipalPayment() \/\/\n                    .withInterestTypeAsDecliningBalance() \/\/\n                    .currencyDetails(\"0\", \"100\").build(null);\n\n            loanProducts[i] = helper.getLoanProductId(loanProductJSON);\n        }\n\n        \/\/ Select anyone of the loan products at random\n        final Integer loanProductID = loanProducts[(int) Math.floor(secureRandom.nextDouble() * (loansCount - 1))];\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        \/\/ Select a few clients from created group at random\n        Integer selClientsCount = (int) Math.ceil(secureRandom.nextDouble() * clientsCount) + 2;\n        for (int i = 0; i < selClientsCount; i++) {\n\n            final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n            Assertions.assertNotNull(collateralId);\n            final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                    String.valueOf(clientIDs[(int) Math.floor(secureRandom.nextDouble() * (clientsCount - 1))]), collateralId);\n            Assertions.assertNotNull(clientCollateralId);\n\n            BatchRequest br = BatchHelper.applyLoanRequest((long) selClientsCount, null, loanProductID, clientCollateralId);\n            br.setBody(br.getBody().replace(\"$.clientId\",\n                    String.valueOf(clientIDs[(int) Math.floor(secureRandom.nextDouble() * (clientsCount - 1))])));\n            br.setHeaders(new HashSet<>());\n            br.getHeaders().add(new Header(\"Idempotency-Key\", UUID.randomUUID().toString()));\n            batchRequests.add(br);\n        }\n\n        \/\/ Send the request to Batch - API\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        \/\/ Verify that each loan has been applied successfully\n        for (BatchResponse res : response) {\n            Assertions.assertFalse(\n                    res.getHeaders().stream()\n                            .anyMatch(header -> header.getName().equals(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER)),\n                    \"First can not be cached!\");\n            Assertions.assertEquals(200L, (long) res.getStatusCode(), \"Verify Status Code 200\");\n        }\n\n        final List<BatchResponse> secondResponse = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec,\n                this.responseSpec, jsonifiedRequest);\n\n        \/\/ Verify that each loan has been applied successfully\n        for (BatchResponse res : secondResponse) {\n            Assertions.assertEquals(\"true\",\n                    res.getHeaders().stream()\n                            .filter(header -> header.getName().equals(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER))\n                            .map(Header::getValue).findAny().get(),\n                    \"Not cached by idempotency key!\");\n            Assertions.assertEquals(200L, (long) res.getStatusCode(), \"Verify Status Code 200\");\n        }\n    } END"}
{"prompt":"should Return Apply Charge To Overdue Loan Step Config\n\n###\n\n","completion":"    @Test\n    public void shouldReturnApplyChargeToOverdueLoanStepConfig() {\n        JobBusinessStepConfigData response = BusinessStepConfigurationHelper.getConfiguredBusinessStepsByJobName(requestSpec, responseSpec,\n                LOAN_JOB_NAME);\n\n        Assertions.assertNotNull(response);\n        assertEquals(LOAN_JOB_NAME, response.getJobName());\n        assertTrue(response.getBusinessSteps().size() > 0);\n        assertTrue(response.getBusinessSteps().stream()\n                .anyMatch(businessStep -> APPLY_CHARGE_TO_OVERDUE_LOANS.equals(businessStep.getStepName())));\n    } END"}
{"prompt":"should Return Apply Charge To Overdue Loan Step Config By Job Category\n\n###\n\n","completion":"    @Test\n    public void shouldReturnApplyChargeToOverdueLoanStepConfigByJobCategory() {\n        JobBusinessStepDetail response = BusinessStepConfigurationHelper.getAvailableBusinessStepsByJobName(requestSpec, responseSpec,\n                LOAN_CATEGORY_NAME);\n\n        Assertions.assertNotNull(response);\n        assertEquals(LOAN_CATEGORY_NAME, response.getJobName());\n        assertTrue(response.getAvailableBusinessSteps().size() > 0);\n        assertTrue(response.getAvailableBusinessSteps().stream()\n                .anyMatch(businessStep -> APPLY_CHARGE_TO_OVERDUE_LOANS.equals(businessStep.getStepName())));\n    } END"}
{"prompt":"should Update Step Order\n\n###\n\n","completion":"    @Test\n    public void shouldUpdateStepOrder() {\n        ResponseSpecification updateResponseSpec = new ResponseSpecBuilder().expectStatusCode(204).build();\n        JobBusinessStepConfigData originalStepConfig = IdempotencyHelper.getConfiguredBusinessStepsByJobName(requestSpec, responseSpec,\n                LOAN_JOB_NAME);\n\n        String idempotencyKeyHeader = UUID.randomUUID().toString();\n\n        List<BusinessStep> requestBody = new ArrayList<>();\n        requestBody.add(getBusinessSteps(1L, APPLY_CHARGE_TO_OVERDUE_LOANS));\n        Response response = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKeyHeader);\n        Response responseSecond = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKeyHeader);\n        Assertions.assertEquals(response.getBody().asString(), responseSecond.getBody().asString());\n        Assertions.assertNull(response.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertNotNull(responseSecond.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n\n        idempotencyKeyHeader = UUID.randomUUID().toString();\n\n        JobBusinessStepConfigData newStepConfig = IdempotencyHelper.getConfiguredBusinessStepsByJobName(requestSpec, responseSpec,\n                LOAN_JOB_NAME);\n        BusinessStep applyChargeStep = newStepConfig.getBusinessSteps().stream()\n                .filter(businessStep -> APPLY_CHARGE_TO_OVERDUE_LOANS.equals(businessStep.getStepName())).findFirst().get();\n        assertEquals(1, newStepConfig.getBusinessSteps().size());\n        assertEquals(1L, applyChargeStep.getOrder());\n\n        requestBody.add(getBusinessSteps(2L, LOAN_DELINQUENCY_CLASSIFICATION));\n\n        Response update = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKeyHeader);\n        Response updateSecond = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKeyHeader);\n        Assertions.assertNull(update.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertNotNull(updateSecond.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertEquals(update.getBody().asString(), updateSecond.getBody().asString());\n\n        newStepConfig = IdempotencyHelper.getConfiguredBusinessStepsByJobName(requestSpec, responseSpec, LOAN_JOB_NAME);\n        applyChargeStep = newStepConfig.getBusinessSteps().stream()\n                .filter(businessStep -> APPLY_CHARGE_TO_OVERDUE_LOANS.equals(businessStep.getStepName())).findFirst().get();\n        BusinessStep loanDelinquencyStep = newStepConfig.getBusinessSteps().stream()\n                .filter(businessStep -> LOAN_DELINQUENCY_CLASSIFICATION.equals(businessStep.getStepName())).findFirst().get();\n        assertEquals(2, newStepConfig.getBusinessSteps().size());\n        assertEquals(1L, applyChargeStep.getOrder());\n        assertEquals(2L, loanDelinquencyStep.getOrder());\n\n        requestBody.remove(1);\n        idempotencyKeyHeader = UUID.randomUUID().toString();\n        update = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKeyHeader);\n        updateSecond = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKeyHeader);\n\n        Assertions.assertNull(update.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertNotNull(updateSecond.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertEquals(update.getBody().asString(), updateSecond.getBody().asString());\n\n        newStepConfig = IdempotencyHelper.getConfiguredBusinessStepsByJobName(requestSpec, responseSpec, LOAN_JOB_NAME);\n        applyChargeStep = newStepConfig.getBusinessSteps().stream()\n                .filter(businessStep -> APPLY_CHARGE_TO_OVERDUE_LOANS.equals(businessStep.getStepName())).findFirst().get();\n        assertEquals(1, newStepConfig.getBusinessSteps().size());\n        assertEquals(1L, applyChargeStep.getOrder());\n\n        idempotencyKeyHeader = UUID.randomUUID().toString();\n\n        update = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(originalStepConfig.getBusinessSteps()), idempotencyKeyHeader);\n        updateSecond = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(originalStepConfig.getBusinessSteps()), idempotencyKeyHeader);\n\n        Assertions.assertNull(update.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertNotNull(updateSecond.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertEquals(update.getBody().asString(), updateSecond.getBody().asString());\n\n    } END"}
{"prompt":"should Throw Error When ABusiness Step Does Not Belong To The Given Job\n\n###\n\n","completion":"    @Test\n    public void shouldThrowErrorWhenABusinessStepDoesNotBelongToTheGivenJob() {\n        ResponseSpecification responseSpecForError = new ResponseSpecBuilder().expectStatusCode(400).build();\n        List<BusinessStep> requestBody = new ArrayList<>();\n        requestBody.add(getBusinessSteps(1L, NOT_BELONGING_BUSINESS_STEP_NAME));\n        ApiParameterError response = BusinessStepConfigurationHelper.updateBusinessStepOrderWithError(requestSpec, responseSpecForError,\n                LOAN_JOB_NAME, BusinessStepConfigurationHelper.toJsonString(requestBody));\n        assertEquals(\"[APPLY_CHARGE_TO_OVERDUE_LOANS_2] Business steps are not configurable for this job.\", response.getDeveloperMessage());\n    } END"}
{"prompt":"should Throw Error When Business Step List Is Empty\n\n###\n\n","completion":"    @Test\n    public void shouldThrowErrorWhenBusinessStepListIsEmpty() {\n        ResponseSpecification responseSpecForError = new ResponseSpecBuilder().expectStatusCode(400).build();\n        List<BusinessStep> requestBody = Collections.emptyList();\n        ApiParameterError response = BusinessStepConfigurationHelper.updateBusinessStepOrderWithError(requestSpec, responseSpecForError,\n                LOAN_JOB_NAME, BusinessStepConfigurationHelper.toJsonString(requestBody));\n        assertEquals(\"A job needs to have 1 business step at least.\", response.getDeveloperMessage());\n    } END"}
{"prompt":"test Basic Center Creation\n\n###\n\n","completion":"    @Test\n    public void testBasicCenterCreation() {\n        int officeId = new OfficeHelper(requestSpec, responseSpec).createOffice(\"01 July 2007\");\n\n        String name = \"TestBasicCreation\" + new Timestamp(new java.util.Date().getTime());\n        int resourceId = CenterHelper.createCenter(name, officeId, requestSpec, responseSpec);\n        CenterDomain center = CenterHelper.retrieveByID(resourceId, requestSpec, responseSpec);\n\n        Assertions.assertNotNull(center);\n        Assertions.assertTrue(center.getName().equals(name));\n        Assertions.assertTrue(center.getOfficeId() == officeId);\n        Assertions.assertTrue(center.isActive() == false);\n\n        \/\/ Test retrieval by listing all centers\n        int id = CenterHelper.listCenters(requestSpec, responseSpec).get(0).getId();\n        Assertions.assertTrue(id > 0);\n\n        CenterDomain retrievedCenter = CenterHelper.retrieveByID(id, requestSpec, responseSpec);\n        Assertions.assertNotNull(retrievedCenter);\n        Assertions.assertNotNull(retrievedCenter.getName());\n        Assertions.assertNotNull(retrievedCenter.getHierarchy());\n        Assertions.assertNotNull(retrievedCenter.getOfficeName());\n\n    } END"}
{"prompt":"test Full Center Creation\n\n###\n\n","completion":"    @Test\n    public void testFullCenterCreation() {\n\n        int officeId = new OfficeHelper(requestSpec, responseSpec).createOffice(\"01 July 2007\");\n        String name = \"TestFullCreation\" + new Timestamp(new java.util.Date().getTime());\n        String externalId = UUID.randomUUID().toString();\n        int staffId = StaffHelper.createStaff(requestSpec, responseSpec);\n        int[] groupMembers = generateGroupMembers(3, officeId);\n        int resourceId = CenterHelper.createCenter(name, officeId, externalId, staffId, groupMembers, requestSpec, responseSpec);\n        CenterDomain center = CenterHelper.retrieveByID(resourceId, requestSpec, responseSpec);\n\n        Assertions.assertNotNull(center);\n        Assertions.assertTrue(center.getName().equals(name));\n        Assertions.assertTrue(center.getOfficeId() == officeId);\n        Assertions.assertTrue(center.getExternalId().equals(externalId));\n        Assertions.assertTrue(center.getStaffId() == staffId);\n        Assertions.assertTrue(center.isActive() == false);\n        Assertions.assertArrayEquals(center.getGroupMembers(), groupMembers);\n    } END"}
{"prompt":"test List Centers\n\n###\n\n","completion":"    @Test\n    public void testListCenters() {\n        ArrayList<CenterDomain> paginatedList = CenterHelper.paginatedListCenters(requestSpec, responseSpec);\n        ArrayList<CenterDomain> list = CenterHelper.listCenters(requestSpec, responseSpec);\n\n        Assertions.assertNotNull(paginatedList);\n        Assertions.assertNotNull(list);\n        Assertions.assertTrue(\n                Arrays.equals(paginatedList.toArray(new CenterDomain[paginatedList.size()]), list.toArray(new CenterDomain[list.size()])));\n    } END"}
{"prompt":"test Void Center Retrieval\n\n###\n\n","completion":"    @Test\n    public void testVoidCenterRetrieval() {\n        ArrayList<CenterDomain> arr = CenterHelper.listCentersOrdered(requestSpec, responseSpec);\n        int id = arr.get(arr.size() - 1).getId() + 1;\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(404).build();\n        CenterDomain center = CenterHelper.retrieveByID(id, requestSpec, responseSpec);\n        Assertions.assertNotNull(center);\n    }\n\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" } END"}
{"prompt":"test Center Update\n\n###\n\n","completion":"    @Test\n    public void testCenterUpdate() {\n        int officeId = new OfficeHelper(requestSpec, responseSpec).createOffice(\"01 July 2007\");\n        String name = \"TestFullCreation\" + new Timestamp(new java.util.Date().getTime());\n        String externalId = UUID.randomUUID().toString();\n        int staffId = StaffHelper.createStaff(requestSpec, responseSpec);\n        int[] groupMembers = generateGroupMembers(3, officeId);\n        int resourceId = CenterHelper.createCenter(name, officeId, externalId, staffId, groupMembers, requestSpec, responseSpec);\n\n        String newName = \"TestCenterUpdateNew\" + new Timestamp(new java.util.Date().getTime());\n        String newExternalId = UUID.randomUUID().toString();\n        int newStaffId = StaffHelper.createStaff(requestSpec, responseSpec);\n        int[] associateGroupMembers = generateGroupMembers(2, officeId);\n\n        int[] associateResponse = CenterHelper.associateGroups(resourceId, associateGroupMembers, requestSpec, responseSpec);\n        Arrays.sort(associateResponse);\n        Arrays.sort(associateGroupMembers);\n        Assertions.assertArrayEquals(associateResponse, associateGroupMembers);\n\n        int[] newGroupMembers = new int[5];\n        for (int i = 0; i < 5; i++) {\n            if (i < 3) {\n                newGroupMembers[i] = groupMembers[i];\n            } else {\n                newGroupMembers[i] = associateGroupMembers[i % 3];\n            }\n        }\n\n        HashMap request = new HashMap();\n        request.put(\"name\", newName);\n        request.put(\"externalId\", newExternalId);\n        request.put(\"staffId\", newStaffId);\n        HashMap response = CenterHelper.updateCenter(resourceId, request, requestSpec, responseSpec);\n        Assertions.assertNotNull(response);\n        Assertions.assertEquals(newName, response.get(\"name\"));\n        Assertions.assertEquals(newExternalId, response.get(\"externalId\"));\n        Assertions.assertEquals(Integer.valueOf(newStaffId), Integer.valueOf(response.get(\"staffId\").toString()));\n\n        CenterDomain center = CenterHelper.retrieveByID(resourceId, requestSpec, responseSpec);\n        Assertions.assertNotNull(center);\n        Assertions.assertEquals(newName, center.getName());\n        Assertions.assertEquals(newExternalId, center.getExternalId());\n        Assertions.assertEquals((Integer) newStaffId, center.getStaffId());\n        Assertions.assertArrayEquals(newGroupMembers, center.getGroupMembers());\n    } END"}
{"prompt":"test Center Deletion\n\n###\n\n","completion":"    @Test\n    public void testCenterDeletion() {\n        int officeId = new OfficeHelper(requestSpec, responseSpec).createOffice(\"01 July 2007\");\n        String name = \"TestBasicCreation\" + new Timestamp(new java.util.Date().getTime());\n        int resourceId = CenterHelper.createCenter(name, officeId, requestSpec, responseSpec);\n\n        CenterHelper.deleteCenter(resourceId, requestSpec, responseSpec);\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(404).build();\n        CenterDomain center = CenterHelper.retrieveByID(resourceId, requestSpec, responseSpec);\n        Assertions.assertNotNull(center);\n    } END"}
{"prompt":"test Staff Assignment During Center Creation\n\n###\n\n","completion":"    @Test\n    public void testStaffAssignmentDuringCenterCreation() {\n\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        LOG.info(\"--------------creating first staff with id------------- {}\", staffId);\n        Assertions.assertNotNull(staffId);\n\n        final int centerWithStaffId = CenterHelper.createCenterWithStaffId(this.requestSpec, this.responseSpec, staffId);\n        final CenterDomain center = CenterHelper.retrieveByID(centerWithStaffId, requestSpec, responseSpec);\n        Assertions.assertNotNull(center);\n        Assertions.assertTrue(center.getId() == centerWithStaffId);\n        Assertions.assertTrue(center.getStaffId().intValue() == staffId);\n        Assertions.assertTrue(center.isActive() == true);\n    } END"}
{"prompt":"test Assign Staff To Center\n\n###\n\n","completion":"    @Test\n    public void testAssignStaffToCenter() {\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        LOG.info(\"--------------creating first staff with id------------- {}\", staffId);\n        Assertions.assertNotNull(staffId);\n\n        final Integer groupID = CenterHelper.createCenter(this.requestSpec, this.responseSpec);\n        CenterHelper.verifyCenterCreatedOnServer(this.requestSpec, this.responseSpec, groupID);\n\n        final HashMap assignStaffToCenterResponseMap = (HashMap) CenterHelper.assignStaff(this.requestSpec, this.responseSpec,\n                groupID.toString(), staffId.longValue());\n        assertEquals(assignStaffToCenterResponseMap.get(\"staffId\"), staffId, \"Verify assigned staff id is the same as id sent\");\n\n        final CenterDomain center = CenterHelper.retrieveByID(groupID, requestSpec, responseSpec);\n        Assertions.assertNotNull(center);\n        Assertions.assertTrue(center.getId().intValue() == groupID);\n        Assertions.assertTrue(center.getStaffId().intValue() == staffId);\n\n    } END"}
{"prompt":"test Unassign Staff To Center\n\n###\n\n","completion":"    @Test\n    public void testUnassignStaffToCenter() {\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        LOG.info(\"--------------creating first staff with id------------- {}\", staffId);\n        Assertions.assertNotNull(staffId);\n\n        final Integer groupID = CenterHelper.createCenter(this.requestSpec, this.responseSpec);\n        CenterHelper.verifyCenterCreatedOnServer(this.requestSpec, this.responseSpec, groupID);\n\n        final HashMap assignStaffToCenterResponseMap = (HashMap) CenterHelper.assignStaff(this.requestSpec, this.responseSpec,\n                groupID.toString(), staffId.longValue());\n        assertEquals(assignStaffToCenterResponseMap.get(\"staffId\"), staffId, \"Verify assigned staff id is the same as id sent\");\n        final CenterDomain centerWithStaffAssigned = CenterHelper.retrieveByID(groupID, requestSpec, responseSpec);\n        Assertions.assertNotNull(centerWithStaffAssigned);\n        Assertions.assertTrue(centerWithStaffAssigned.getId().intValue() == groupID);\n        Assertions.assertTrue(centerWithStaffAssigned.getStaffId().intValue() == staffId);\n\n        final HashMap unassignStaffToCenterResponseMap = (HashMap) CenterHelper.unassignStaff(this.requestSpec, this.responseSpec,\n                groupID.toString(), staffId.longValue());\n        assertEquals(unassignStaffToCenterResponseMap.get(\"staffId\"), null, \"Verify staffId is null after unassigning \");\n        final CenterDomain centerWithStaffUnssigned = CenterHelper.retrieveByID(groupID, requestSpec, responseSpec);\n        Assertions.assertNotNull(centerWithStaffUnssigned);\n        Assertions.assertTrue(centerWithStaffUnssigned.getId().intValue() == groupID);\n        Assertions.assertTrue(centerWithStaffUnssigned.getStaffId() == null);\n\n    } END"}
{"prompt":"test Centers Orphan Groups\n\n###\n\n","completion":"    @Test\n    public void testCentersOrphanGroups() {\n\n        int officeId = new OfficeHelper(requestSpec, responseSpec).createOffice(\"01 July 2007\");\n\n        String name = \"TestBasicCreation\" + new Timestamp(new java.util.Date().getTime());\n        int resourceId = CenterHelper.createCenter(name, officeId, requestSpec, responseSpec);\n        CenterDomain center = CenterHelper.retrieveByID(resourceId, requestSpec, responseSpec);\n\n        Assertions.assertNotNull(center);\n\n        int id = CenterHelper.listCenters(requestSpec, responseSpec).get(0).getId();\n        Assertions.assertTrue(id > 0);\n\n        CenterDomain retrievedCenter = CenterHelper.retrieveByID(id, requestSpec, responseSpec);\n        Assertions.assertNotNull(retrievedCenter);\n        Assertions.assertNotNull(retrievedCenter.getName());\n        Assertions.assertNotNull(retrievedCenter.getHierarchy());\n        Assertions.assertNotNull(retrievedCenter.getOfficeName());\n\n        int[] groupMembers = generateGroupMembers(2, officeId);\n        CenterHelper.associateGroups(resourceId, groupMembers, requestSpec, responseSpec);\n        GroupHelper.verifyOrphanGroupDetails(requestSpec, responseSpec, officeId);\n    } END"}
{"prompt":"test Charges For Savings\n\n###\n\n","completion":"    @Test\n    public void testChargesForSavings() {\n\n        \/\/ Testing Creation, Updation and Deletion of Specified due date Charge\n        final Integer specifiedDueDateChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsSpecifiedDueDateJSON());\n        Assertions.assertNotNull(specifiedDueDateChargeId);\n\n        \/\/ Updating Charge Amount\n        HashMap changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, specifiedDueDateChargeId,\n                ChargesHelper.getModifyChargeJSON());\n\n        HashMap chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, specifiedDueDateChargeId);\n        Assertions.assertEquals(chargeDataAfterChanges.get(\"amount\"), changes.get(\"amount\"), \"Verifying Charge after Modification\");\n\n        Integer chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, specifiedDueDateChargeId);\n        Assertions.assertEquals(specifiedDueDateChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n\n        \/\/ Testing Creation, Updation and Deletion of Savings Activation Charge\n        final Integer savingsActivationChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsActivationFeeJSON());\n        Assertions.assertNotNull(savingsActivationChargeId);\n\n        \/\/ Updating Charge Amount\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, savingsActivationChargeId,\n                ChargesHelper.getModifyChargeJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, savingsActivationChargeId);\n        Assertions.assertEquals(chargeDataAfterChanges.get(\"amount\"), changes.get(\"amount\"), \"Verifying Charge after Modification\");\n\n        chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, savingsActivationChargeId);\n        Assertions.assertEquals(savingsActivationChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n\n        \/\/ Testing Creation, Updation and Deletion of Charge for Withdrawal Fee\n        final Integer withdrawalFeeChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsWithdrawalFeeJSON());\n        Assertions.assertNotNull(withdrawalFeeChargeId);\n\n        \/\/ Updating Charge-Calculation-Type to Withdrawal-Fee\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, withdrawalFeeChargeId,\n                ChargesHelper.getModifyWithdrawalFeeSavingsChargeJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, withdrawalFeeChargeId);\n\n        HashMap chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargeCalculationType\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargeCalculationType\"), \"Verifying Charge after Modification\");\n\n        chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, withdrawalFeeChargeId);\n        Assertions.assertEquals(withdrawalFeeChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n\n        \/\/ Testing Creation, Updation and Deletion of Charge for Annual Fee\n        final Integer annualFeeChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsAnnualFeeJSON());\n        Assertions.assertNotNull(annualFeeChargeId);\n\n        \/\/ Updating Charge Amount\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, annualFeeChargeId, ChargesHelper.getModifyChargeJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, annualFeeChargeId);\n        Assertions.assertEquals(chargeDataAfterChanges.get(\"amount\"), changes.get(\"amount\"), \"Verifying Charge after Modification\");\n\n        chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, annualFeeChargeId);\n        Assertions.assertEquals(annualFeeChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n\n        \/\/ Testing Creation, Updation and Deletion of Charge for Monthly Fee\n        final Integer monthlyFeeChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsMonthlyFeeJSON());\n        Assertions.assertNotNull(monthlyFeeChargeId);\n\n        \/\/ Updating Charge Amount\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, monthlyFeeChargeId, ChargesHelper.getModifyChargeJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, monthlyFeeChargeId);\n        Assertions.assertEquals(chargeDataAfterChanges.get(\"amount\"), changes.get(\"amount\"), \"Verifying Charge after Modification\");\n\n        chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, monthlyFeeChargeId);\n        Assertions.assertEquals(monthlyFeeChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n\n        \/\/ Testing Creation, Updation and Deletion of Charge for Overdraft Fee\n        final Integer overdraftFeeChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsOverdraftFeeJSON());\n        Assertions.assertNotNull(overdraftFeeChargeId);\n\n        \/\/ Updating Charge Amount\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, overdraftFeeChargeId,\n                ChargesHelper.getModifyChargeJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, overdraftFeeChargeId);\n        Assertions.assertEquals(chargeDataAfterChanges.get(\"amount\"), changes.get(\"amount\"), \"Verifying Charge after Modification\");\n\n        chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, overdraftFeeChargeId);\n        Assertions.assertEquals(overdraftFeeChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n    } END"}
{"prompt":"check Audit Dates\n\n###\n\n","completion":"    @Test\n    public void checkAuditDates() throws InterruptedException {\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        String username = Utils.uniqueRandomStringGenerator(\"user\", 8);\n        final Integer userId = (Integer) UserHelper.createUser(this.requestSpec, this.responseSpec, 1, staffId, username, \"P4ssw0rd\",\n                \"resourceId\");\n\n        LOG.info(\"-------------------------Creating Client---------------------------\");\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientID);\n        LOG.info(\"-------------------------Creating Loan---------------------------\");\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProduct(\"0\", \"0\", LoanProductTestBuilder.DEFAULT_STRATEGY, \"2\", assetAccount, incomeAccount,\n                expenseAccount, overpaymentAccount);\n\n        final Integer loanID = applyForLoanApplicationWithPaymentStrategyAndPastMonth(clientID, loanProductID, Collections.emptyList(),\n                null, \"10000\", LoanApplicationTestBuilder.DEFAULT_STRATEGY, \"10 July 2022\");\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"11 July 2022\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"11 July 2022\", loanID, \"10000\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        OffsetDateTime now = OffsetDateTime.now(ZoneId.of(\"Asia\/Kolkata\"));\n        \/\/ Testing in minutes precision, but still need to take care around the end of the actual minute\n        if (now.getSecond() > 56) {\n            Thread.sleep(5000);\n            now = OffsetDateTime.now(ZoneId.of(\"Asia\/Kolkata\"));\n        }\n        HashMap repaymentDetails = this.loanTransactionHelper.makeRepayment(\"11 July 2022\", 100.0f, loanID);\n        Integer transactionId = (Integer) repaymentDetails.get(\"resourceId\");\n        HashMap auditFieldsResponse = LoanTransactionHelper.getLoanTransactionAuditFields(requestSpec, responseSpec, loanID, transactionId,\n                \"\");\n\n        OffsetDateTime createdDate = OffsetDateTime.parse((String) auditFieldsResponse.get(CREATED_DATE),\n                DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n\n        OffsetDateTime lastModifiedDate = OffsetDateTime.parse((String) auditFieldsResponse.get(LAST_MODIFIED_DATE),\n                DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n\n        LOG.info(\"-------------------------Check Audit dates---------------------------\");\n        assertEquals(1, auditFieldsResponse.get(CREATED_BY));\n        assertEquals(now.getYear(), createdDate.getYear());\n        assertEquals(now.getMonth(), createdDate.getMonth());\n        assertEquals(now.getDayOfMonth(), createdDate.getDayOfMonth());\n        assertEquals(now.getHour(), createdDate.getHour());\n        assertEquals(now.getMinute(), createdDate.getMinute());\n\n        assertEquals(1, auditFieldsResponse.get(LAST_MODIFIED_BY));\n        assertEquals(now.getYear(), lastModifiedDate.getYear());\n        assertEquals(now.getMonth(), lastModifiedDate.getMonth());\n        assertEquals(now.getDayOfMonth(), lastModifiedDate.getDayOfMonth());\n        assertEquals(now.getHour(), lastModifiedDate.getHour());\n        assertEquals(now.getMinute(), lastModifiedDate.getMinute());\n\n        Thread.sleep(2000);\n\n        this.requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n        this.requestSpec.header(\"Authorization\",\n                \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey(username, \"P4ssw0rd\"));\n\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        this.loanTransactionHelper.reverseRepayment(loanID, transactionId, \"11 July 2022\");\n\n        now = OffsetDateTime.now(ZoneId.of(\"Asia\/Kolkata\"));\n\n        auditFieldsResponse = LoanTransactionHelper.getLoanTransactionAuditFields(requestSpec, responseSpec, loanID, transactionId, \"\");\n\n        createdDate = OffsetDateTime.parse((String) auditFieldsResponse.get(CREATED_DATE), DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n\n        lastModifiedDate = OffsetDateTime.parse((String) auditFieldsResponse.get(LAST_MODIFIED_DATE),\n                DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n\n        LOG.info(\"-------------------------Check Audit dates---------------------------\");\n        assertEquals(1, auditFieldsResponse.get(CREATED_BY));\n        assertEquals(now.getYear(), createdDate.getYear());\n        assertEquals(now.getMonth(), createdDate.getMonth());\n        assertEquals(now.getDayOfMonth(), createdDate.getDayOfMonth());\n        assertEquals(now.getHour(), createdDate.getHour());\n        assertEquals(now.getMinute(), createdDate.getMinute());\n\n        now = OffsetDateTime.now(ZoneId.of(\"Asia\/Kolkata\"));\n\n        assertEquals(userId, auditFieldsResponse.get(LAST_MODIFIED_BY));\n        assertEquals(now.getYear(), lastModifiedDate.getYear());\n        assertEquals(now.getMonth(), lastModifiedDate.getMonth());\n        assertEquals(now.getDayOfMonth(), lastModifiedDate.getDayOfMonth());\n        assertEquals(now.getHour(), lastModifiedDate.getHour());\n        assertEquals(now.getMinute(), lastModifiedDate.getMinute());\n    } END"}
{"prompt":"create Client Collateral Test\n\n###\n\n","completion":"    @Test\n    public void createClientCollateralTest() {\n        LOG.info(\"-------------------------Creating Client Collateral---------------------------\");\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n    } END"}
{"prompt":"update Client Collateral\n\n###\n\n","completion":"    @Test\n    public void updateClientCollateral() {\n        LOG.info(\"-------------------------Updating Client Collateral---------------------------\");\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        final HashMap changes = CollateralManagementHelper.updateClientCollateral(this.requestSpec, this.responseSpec, clientCollateralId);\n        Assertions.assertEquals(\"1\", changes.get(\"quantity\").toString());\n    } END"}
{"prompt":"when Auto External Id Config Is Off Create Client\n\n###\n\n","completion":"    @Test\n    public void whenAutoExternalIdConfigIsOffCreateClient() {\n        \/\/ given\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n        final String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON,\n                null);\n        \/\/ when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        \/\/ then\n        assertNotNull(clientResponse);\n        assertNull(clientResponse.getResourceExternalId());\n    } END"}
{"prompt":"when Auto External Id Config Is Off Create Client With Value\n\n###\n\n","completion":"    @Test\n    public void whenAutoExternalIdConfigIsOffCreateClientWithValue() {\n        \/\/ given\n        final String externalId = UUID.randomUUID().toString();\n        final String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON,\n                externalId);\n        \/\/ when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        \/\/ then\n        assertNotNull(clientResponse);\n        assertNotNull(clientResponse.getResourceExternalId());\n        assertEquals(externalId, clientResponse.getResourceExternalId());\n\n        fetchClientByExternalId(clientResponse.getResourceExternalId());\n    } END"}
{"prompt":"when Auto External Id Config Is On Create Client\n\n###\n\n","completion":"    @Test\n    public void whenAutoExternalIdConfigIsOnCreateClient() {\n        \/\/ given\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        final String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON,\n                null);\n        \/\/ when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        \/\/ then\n        assertNotNull(clientResponse);\n        assertNotNull(clientResponse.getResourceExternalId());\n        assertEquals(36, clientResponse.getResourceExternalId().length());\n\n        fetchClientByExternalId(clientResponse.getResourceExternalId());\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    } END"}
{"prompt":"when Auto External Id Config Is On Create Client With Value\n\n###\n\n","completion":"    @Test\n    public void whenAutoExternalIdConfigIsOnCreateClientWithValue() {\n        \/\/ given\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        final String externalId = UUID.randomUUID().toString();\n        final String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON,\n                externalId);\n        \/\/ when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        \/\/ then\n        assertNotNull(clientResponse);\n        assertNotNull(clientResponse.getResourceExternalId());\n        assertEquals(externalId, clientResponse.getResourceExternalId());\n\n        fetchClientByExternalId(clientResponse.getResourceExternalId());\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    } END"}
{"prompt":"test Client Status Using External Id\n\n###\n\n","completion":"    @Test\n    public void testClientStatusUsingExternalId() {\n        ClientHelper clientHelper = new ClientHelper(requestSpec, responseSpec);\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON, null);\n        final PostClientsResponse addClientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        final String clientExternalId = addClientResponse.getResourceExternalId();\n        final Long clientId = addClientResponse.getClientId();\n        assertNotNull(clientExternalId);\n        log.info(\"Client data id {} and external Id {}\", clientId, clientExternalId);\n\n        GetClientsClientIdResponse clientResponse = ClientHelper.getClientByExternalId(requestSpec, responseSpec, clientExternalId);\n        ClientStatusChecker.verifyClientStatus(ClientStatus.ACTIVE, clientResponse);\n        log.info(\"Client data id {} and status {}\", clientExternalId, clientResponse.getStatus().getCode());\n\n        \/\/ Close Client action\n        jsonPayload = clientHelper.getCloseClientAsJSON();\n        PostClientsClientIdResponse commandResponse = ClientHelper.performClientActionUsingExternalId(requestSpec, responseSpec,\n                clientExternalId, ClientHelper.CLOSE_CLIENT_COMMAND, jsonPayload);\n        assertNotNull(commandResponse);\n        assertNotNull(commandResponse.getResourceExternalId());\n        assertEquals(clientExternalId, commandResponse.getResourceExternalId());\n        log.info(\"Client data id {} and external Id {}\", commandResponse.getResourceId(), clientExternalId);\n        assertEquals(clientId.intValue(), commandResponse.getResourceId());\n\n        clientResponse = ClientHelper.getClientByExternalId(requestSpec, responseSpec, clientExternalId);\n        ClientStatusChecker.verifyClientStatus(ClientStatus.CLOSED, clientResponse);\n        log.info(\"Client data id {} and status {}\", clientExternalId, clientResponse.getStatus().getCode());\n\n        \/\/ Reactivate Client action\n        jsonPayload = clientHelper.getReactivateClientAsJSON();\n        commandResponse = ClientHelper.performClientActionUsingExternalId(requestSpec, responseSpec, clientExternalId,\n                ClientHelper.REACTIVATE_CLIENT_COMMAND, jsonPayload);\n        assertNotNull(commandResponse);\n        assertNotNull(commandResponse.getResourceExternalId());\n        assertEquals(clientExternalId, commandResponse.getResourceExternalId());\n        log.info(\"Client data id {} and external Id {}\", commandResponse.getResourceId(), clientExternalId);\n        assertEquals(clientId.intValue(), commandResponse.getResourceId());\n\n        clientResponse = ClientHelper.getClientByExternalId(requestSpec, responseSpec, clientExternalId);\n        ClientStatusChecker.verifyClientStatus(ClientStatus.PENDING, clientResponse);\n        log.info(\"Client data id {} and status {}\", clientExternalId, clientResponse.getStatus().getCode());\n\n        \/\/ Reject Client action\n        jsonPayload = clientHelper.getRejectClientAsJSON();\n        commandResponse = ClientHelper.performClientActionUsingExternalId(requestSpec, responseSpec, clientExternalId,\n                ClientHelper.REJECT_CLIENT_COMMAND, jsonPayload);\n        assertNotNull(commandResponse);\n        assertNotNull(commandResponse.getResourceExternalId());\n        assertEquals(clientExternalId, commandResponse.getResourceExternalId());\n        log.info(\"Client data id {} and external Id {}\", commandResponse.getResourceId(), clientExternalId);\n        assertEquals(clientId.intValue(), commandResponse.getResourceId());\n\n        clientResponse = ClientHelper.getClientByExternalId(requestSpec, responseSpec, clientExternalId);\n        ClientStatusChecker.verifyClientStatus(ClientStatus.REJECTED, clientResponse);\n        log.info(\"Client data id {} and status {}\", clientExternalId, clientResponse.getStatus().getCode());\n\n        \/\/ Activate Client action\n        jsonPayload = ClientHelper.getActivateClientAsJSON(ClientHelper.DEFAULT_DATE);\n        commandResponse = ClientHelper.performClientActionUsingExternalId(requestSpec, responseSpec, clientExternalId,\n                ClientHelper.ACTIVATE_CLIENT_COMMAND, jsonPayload);\n        assertNotNull(commandResponse);\n        assertNotNull(commandResponse.getResourceExternalId());\n        assertEquals(clientExternalId, commandResponse.getResourceExternalId());\n        log.info(\"Client data id {} and external Id {}\", commandResponse.getResourceId(), clientExternalId);\n        assertEquals(clientId.intValue(), commandResponse.getResourceId());\n\n        clientResponse = ClientHelper.getClientByExternalId(requestSpec, responseSpec, clientExternalId);\n        ClientStatusChecker.verifyClientStatus(ClientStatus.ACTIVE, clientResponse);\n        log.info(\"Client data id {} and status {}\", clientExternalId, clientResponse.getStatus().getCode());\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    } END"}
{"prompt":"test Update Client Using External Id\n\n###\n\n","completion":"    @Test\n    public void testUpdateClientUsingExternalId() {\n        \/\/ given\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON, null);\n        \/\/ when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        final String clientExternalId = clientResponse.getResourceExternalId();\n        jsonPayload = ClientHelper.getBasicClientAsJSON(null, ClientHelper.LEGALFORM_ID_PERSON, clientExternalId);\n        final PutClientsClientIdResponse clientUpdateResponse = ClientHelper.updateClient(requestSpec, responseSpec, clientExternalId,\n                jsonPayload);\n        \/\/ then\n        assertNotNull(clientUpdateResponse);\n        assertNotNull(clientUpdateResponse.getResourceExternalId());\n        assertEquals(clientExternalId, clientUpdateResponse.getResourceExternalId());\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    } END"}
{"prompt":"test Delete Client Using External Id\n\n###\n\n","completion":"    @Test\n    public void testDeleteClientUsingExternalId() {\n        \/\/ given\n        ClientHelper clientHelper = new ClientHelper(requestSpec, responseSpec);\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON, null);\n        \/\/ when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        final String clientExternalId = clientResponse.getResourceExternalId();\n        jsonPayload = clientHelper.getCloseClientAsJSON();\n        PostClientsClientIdResponse commandResponse = ClientHelper.performClientActionUsingExternalId(requestSpec, responseSpec,\n                clientExternalId, ClientHelper.CLOSE_CLIENT_COMMAND, jsonPayload);\n        jsonPayload = clientHelper.getReactivateClientAsJSON();\n        commandResponse = ClientHelper.performClientActionUsingExternalId(requestSpec, responseSpec, clientExternalId,\n                ClientHelper.REACTIVATE_CLIENT_COMMAND, jsonPayload);\n\n        \/\/ then\n        final DeleteClientsClientIdResponse clientDeleteResponse = ClientHelper.deleteClient(requestSpec, responseSpec, clientExternalId);\n        assertNotNull(clientDeleteResponse);\n        assertNotNull(clientDeleteResponse.getResourceExternalId());\n        assertEquals(clientExternalId, clientDeleteResponse.getResourceExternalId());\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    } END"}
{"prompt":"test Get Client Accounts Using External Id\n\n###\n\n","completion":"    @Test\n    public void testGetClientAccountsUsingExternalId() {\n        \/\/ given\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        final String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON,\n                null);\n        \/\/ when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        final String clientExternalId = clientResponse.getResourceExternalId();\n\n        GetClientsClientIdAccountsResponse clientAccountsResponse = ClientHelper.getClientAccounts(requestSpec, responseSpec,\n                clientExternalId);\n\n        \/\/ then\n        assertNotNull(clientAccountsResponse);\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    } END"}
{"prompt":"test Get Client Transfer Proposal Date\n\n###\n\n","completion":"    @Test\n    public void testGetClientTransferProposalDate() {\n        \/\/ given\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        final String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON,\n                null);\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        ResponseSpecification response204Spec = new ResponseSpecBuilder().expectStatusCode(204).build();\n\n        \/\/ when\n        final String clientExternalId = clientResponse.getResourceExternalId();\n        final GetClientTransferProposalDateResponse transferProposalDateResponse = ClientHelper.getProposedTransferDate(requestSpec,\n                response204Spec, clientExternalId);\n\n        fetchClientByExternalId(clientResponse.getResourceExternalId());\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    } END"}
{"prompt":"test Get Client Obligee Data\n\n###\n\n","completion":"    @Test\n    public void testGetClientObligeeData() {\n        \/\/ given\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        final String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON,\n                null);\n        \/\/ when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        final String clientExternalId = clientResponse.getResourceExternalId();\n        final List<GetObligeeData> obligeeDataResponse = ClientHelper.getObligeeData(requestSpec, responseSpec, clientExternalId);\n\n        \/\/ then\n        assertNotNull(obligeeDataResponse);\n\n        fetchClientByExternalId(clientResponse.getResourceExternalId());\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    } END"}
{"prompt":"check New Client Loan Charge Saves External Id\n\n###\n\n","completion":"    @Test\n    public void checkNewClientLoanChargeSavesExternalId() {\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, null, null, \"12,000.00\", collaterals);\n        HashMap loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID, \"12,000.00\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final Integer charge = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\", false));\n\n        final float amount = 1.0f;\n        final String externalId = \"extId\" + loanID.toString();\n        final Integer chargeID = this.loanTransactionHelper.addChargesForLoan(loanID,\n                getLoanChargeAsJSON(String.valueOf(charge), \"22 September 2011\", String.valueOf(amount), externalId));\n        Assertions.assertNotNull(chargeID);\n\n        HashMap loanChargeMap = this.loanTransactionHelper.getLoanCharge(loanID, chargeID);\n        Assertions.assertNotNull(loanChargeMap.get(\"externalId\"));\n        Assertions.assertEquals(loanChargeMap.get(\"externalId\"), externalId, \"Incorrect External Id Saved\");\n\n    } END"}
{"prompt":"check New Client Loan Charge Finds Duplicate External Id\n\n###\n\n","completion":"    @Test\n    public void checkNewClientLoanChargeFindsDuplicateExternalId() {\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, null, null, \"12,000.00\", collaterals);\n        HashMap loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID, \"12,000.00\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final Integer charge = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\", false));\n\n        final String externalId = \"extId\" + loanID.toString();\n        final float amount = 1.0f;\n        final Integer chargeID = this.loanTransactionHelper.addChargesForLoan(loanID,\n                getLoanChargeAsJSON(String.valueOf(charge), \"22 September 2011\", String.valueOf(amount), externalId));\n        Assertions.assertNotNull(chargeID);\n\n        final float amount2 = 2.0f;\n        ResponseSpecification responseSpec403 = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final Integer chargeID2 = this.loanTransactionHelper.addChargesForLoan(loanID,\n                getLoanChargeAsJSON(String.valueOf(charge), \"23 September 2011\", String.valueOf(amount2), externalId), responseSpec403);\n\n        Assertions.assertNull(chargeID2);\n    } END"}
{"prompt":"full Refund And Reverse Of Paid Charge Succeeds Test Active Active\n\n###\n\n","completion":"    @Test\n    public void fullRefundAndReverseOfPaidChargeSucceedsTest_Active_Active() {\n        testRefundAndReverseOfPaidChargeSucceeds(oneInstallment + fullChargeRefundAmount, fullChargeRefundAmount, ACTIVE, ACTIVE);\n    } END"}
{"prompt":"full Refund And Reverse Of Paid Charge Succeeds Test Active Com\n\n###\n\n","completion":"    @Test\n    public void fullRefundAndReverseOfPaidChargeSucceedsTest_Active_Com() {\n        testRefundAndReverseOfPaidChargeSucceeds(fullLoan, fullChargeRefundAmount, ACTIVE, CLOSED_OBLIGATION_MET);\n    } END"}
{"prompt":"full Refund And Reverse Of Paid Charge Succeeds Test Active Overpaid\n\n###\n\n","completion":"    @Test\n    public void fullRefundAndReverseOfPaidChargeSucceedsTest_Active_Overpaid() {\n        testRefundAndReverseOfPaidChargeSucceeds(fullLoan + 50.00f, fullChargeRefundAmount, ACTIVE, OVERPAID);\n    } END"}
{"prompt":"full Refund And Reverse Of Paid Charge Succeeds Test Com Overpaid\n\n###\n\n","completion":"    @Test\n    public void fullRefundAndReverseOfPaidChargeSucceedsTest_Com_Overpaid() {\n        testRefundAndReverseOfPaidChargeSucceeds(fullLoan + fullChargeRefundAmount, fullChargeRefundAmount, CLOSED_OBLIGATION_MET,\n                OVERPAID);\n    } END"}
{"prompt":"full Refund And Reverse Of Paid Charge Succeeds Test Overpaid Overpaid\n\n###\n\n","completion":"    @Test\n    public void fullRefundAndReverseOfPaidChargeSucceedsTest_Overpaid_Overpaid() {\n        testRefundAndReverseOfPaidChargeSucceeds(fullLoan + fullChargeRefundAmount + 50.00f, fullChargeRefundAmount, OVERPAID, OVERPAID);\n    } END"}
{"prompt":"partial Refund And Reverse Of Paid Charge Succeeds Test Active Active\n\n###\n\n","completion":"    @Test\n    public void partialRefundAndReverseOfPaidChargeSucceedsTest_Active_Active() {\n        testRefundAndReverseOfPaidChargeSucceeds(fullLoan, oneThirdChargeRefundAmount, ACTIVE, ACTIVE);\n    } END"}
{"prompt":"partial Refund And Reverse Of Paid Charge Succeeds Test Active Com\n\n###\n\n","completion":"    @Test\n    public void partialRefundAndReverseOfPaidChargeSucceedsTest_Active_Com() {\n        testRefundAndReverseOfPaidChargeSucceeds(fullLoan + (oneThirdChargeRefundAmount * 2), oneThirdChargeRefundAmount, ACTIVE,\n                CLOSED_OBLIGATION_MET);\n    } END"}
{"prompt":"partial Refund And Reverse Of Paid Charge Succeeds Test Active Overpaid\n\n###\n\n","completion":"    @Test\n    public void partialRefundAndReverseOfPaidChargeSucceedsTest_Active_Overpaid() {\n        testRefundAndReverseOfPaidChargeSucceeds(fullLoan + (oneThirdChargeRefundAmount * 2) + 1.0f, oneThirdChargeRefundAmount, ACTIVE,\n                OVERPAID);\n    } END"}
{"prompt":"refund Of Unpaid Charge Fails Test\n\n###\n\n","completion":"    @Test\n    public void refundOfUnpaidChargeFailsTest() {\n\n        final Float repaymentAmount = 3000.00f; \/\/ pays installment one but none of added charge\n        Integer loanChargeId = disburseAddChargeAndRepay(repaymentAmount, ACTIVE, NONE, false);\n\n        LOG.info(\"-------------Loancharge Refund -----------\");\n        final Float refundAmount = 60.00f;\n        final Integer installmentNumber = null;\n        final String externalId = null;\n        ArrayList<HashMap> errors = (ArrayList<HashMap>) this.loanTransactionHelperValidationError.loanChargeRefund(loanChargeId,\n                installmentNumber, refundAmount, externalId, this.disbursedLoanID, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.loan.charge.transaction.amount.is.more.than.is.refundable\",\n                errors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n    } END"}
{"prompt":"refunding More Than Paid Fails Test\n\n###\n\n","completion":"    @Test\n    public void refundingMoreThanPaidFailsTest() {\n\n        final Float repaymentAmount = 3090.00f; \/\/ pays installment one and 90 (not all) of added charge\n        Integer loanChargeId = disburseAddChargeAndRepay(repaymentAmount, ACTIVE, NONE, false);\n\n        LOG.info(\"-------------Loancharge Refund -----------\");\n        final Float refundAmount = 90.01f; \/\/ 0.01 more than paid.\n        final Integer installmentNumber = null;\n        final String externalId = null;\n        ArrayList<HashMap> errors = (ArrayList<HashMap>) this.loanTransactionHelperValidationError.loanChargeRefund(loanChargeId,\n                installmentNumber, refundAmount, externalId, this.disbursedLoanID, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.loan.charge.transaction.amount.is.more.than.is.refundable\",\n                errors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    } END"}
{"prompt":"ony Refund Element Not Repayment Element Used To Calculate Refundable Amount Test\n\n###\n\n","completion":"    @Test\n    public void onyRefundElementNotRepaymentElementUsedToCalculateRefundableAmountTest() {\n        final Float chargeAmountPaid = 60.00f;\n        final Float repaymentAmount = 3000.00f + chargeAmountPaid;\n        \/\/ covers Installment 1 plus half of 120 charge added to installment 2\n        Integer loanChargeId = disburseAddChargeAndRepay(repaymentAmount, ACTIVE, NONE, false);\n\n        LOG.info(\"-------------Loancharge Refund 1 -----------\");\n        final Float refundAmount = chargeAmountPaid; \/\/ refund charge paid\n        final Integer installmentNumber = null;\n        final String externalId = null;\n        Integer chargeRefundTxnId = (Integer) this.loanTransactionHelper.loanChargeRefund(loanChargeId, installmentNumber, refundAmount,\n                externalId, this.disbursedLoanID, \"resourceId\");\n        HashMap loanDetailsHashMap = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec,\n                disbursedLoanID, \"\");\n        \/\/ refund 60 pays off remainder of charge leaving an amount 60 that could be refunded\n\n        LOG.info(\"-------------Loancharge Refund 2 -----------\");\n        final Float smallRefund = 0.01f;\n        chargeRefundTxnId = (Integer) this.loanTransactionHelper.loanChargeRefund(loanChargeId, installmentNumber, smallRefund, externalId,\n                this.disbursedLoanID, \"resourceId\");\n        loanDetailsHashMap = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, disbursedLoanID, \"\");\n\n    } END"}
{"prompt":"refund Of Partially Paid Charge Can Repay More Of Same Charge Test\n\n###\n\n","completion":"    @Test\n    public void refundOfPartiallyPaidChargeCanRepayMoreOfSameChargeTest() {\n        final Float chargeAmountPaid = 80.00f;\n        final Float chargeAmountFull = 120.00f;\n        final Float chargeAmountOutstanding = chargeAmountFull - chargeAmountPaid;\n        final Float repaymentAmount = 3000.00f + chargeAmountPaid;\n        \/\/ covers Installment 1 plus two thirds of 120 charge added to installment 2\n        Integer loanChargeId = disburseAddChargeAndRepay(repaymentAmount, ACTIVE, NONE, false);\n        Float feeChargesPaid = getLoanDetailsSummaryfeeChargesPaid(disbursedLoanID);\n        Assertions.assertEquals(feeChargesPaid, chargeAmountPaid, \"Incorrect Partial feeChargesPaid\");\n\n        LOG.info(\"-------------Loancharge Refund -----------\");\n        final Float refundAmount = chargeAmountPaid; \/\/ refund charge paid\n        final Integer installmentNumber = null;\n        final String externalId = null;\n        Integer chargeRefundTxnId = (Integer) this.loanTransactionHelper.loanChargeRefund(loanChargeId, installmentNumber, refundAmount,\n                externalId, this.disbursedLoanID, \"resourceId\");\n        feeChargesPaid = getLoanDetailsSummaryfeeChargesPaid(disbursedLoanID);\n        Assertions.assertEquals(feeChargesPaid, chargeAmountFull, \"Incorrect Full feeChargesPaid\");\n\n        ArrayList<HashMap> loanChargePaidByList = (ArrayList<HashMap>) this.loanTransactionHelper.getLoanTransactionDetails(disbursedLoanID,\n                chargeRefundTxnId, \"loanChargePaidByList\");\n        Assertions.assertNotNull(loanChargePaidByList);\n        Assertions.assertEquals(loanChargePaidByList.size(), 2);\n        \/\/ expecting 2 entries 1)-80 refund 2) 40 repayment\n        Float paidByAmount1 = (Float) loanChargePaidByList.get(0).get(\"amount\");\n        Assertions.assertNotNull(paidByAmount1);\n        Assertions.assertNotEquals(paidByAmount1, 0.0f);\n        Float paidByAmount2 = (Float) loanChargePaidByList.get(1).get(\"amount\");\n        Assertions.assertNotNull(paidByAmount2);\n        Assertions.assertNotEquals(paidByAmount2, 0.0f);\n\n        if (paidByAmount1 < 0.0f) {\n            Assertions.assertEquals(paidByAmount1, chargeAmountPaid * -1, \"Refund Element Incorrect\");\n        } else {\n            Assertions.assertEquals(paidByAmount1, chargeAmountOutstanding, \"Repayment Element Incorrect\");\n        }\n        if (paidByAmount2 < 0.0f) {\n            Assertions.assertEquals(paidByAmount2, chargeAmountPaid * -1, \"Refund Element Incorrect\");\n        } else {\n            Assertions.assertEquals(paidByAmount2, chargeAmountOutstanding, \"Repayment Element Incorrect\");\n        }\n\n    } END"}
{"prompt":"charge Refund Creates Correct Journal Entries For Periodic Accruals Fee Test\n\n###\n\n","completion":"    @Test\n    public void chargeRefundCreatesCorrectJournalEntriesForPeriodicAccruals_Fee_Test() {\n        chargeRefundCreatesCorrectJournalEntries(ACCRUAL_PERIODIC, false);\n    } END"}
{"prompt":"charge Refund Creates Correct Journal Entries For Cash Accounting Fee Test\n\n###\n\n","completion":"    @Test\n    public void chargeRefundCreatesCorrectJournalEntriesForCashAccounting_Fee_Test() {\n        chargeRefundCreatesCorrectJournalEntries(CASH_BASED, false);\n    } END"}
{"prompt":"charge Refund Creates Correct Journal Entries For Periodic Accruals Penalty Test\n\n###\n\n","completion":"    @Test\n    public void chargeRefundCreatesCorrectJournalEntriesForPeriodicAccruals_Penalty_Test() {\n        chargeRefundCreatesCorrectJournalEntries(ACCRUAL_PERIODIC, true);\n    } END"}
{"prompt":"charge Refund Creates Correct Journal Entries For Cash Accounting Penalty Test\n\n###\n\n","completion":"    @Test\n    public void chargeRefundCreatesCorrectJournalEntriesForCashAccounting_Penalty_Test() {\n        chargeRefundCreatesCorrectJournalEntries(CASH_BASED, true);\n    } END"}
{"prompt":"repayment Reversal Disallowed If Later Charge Refund Test\n\n###\n\n","completion":"    @Test\n    public void repaymentReversalDisallowedIfLaterChargeRefundTest() {\n\n        \/\/ repayment covers 2 installments plus charge\n        final Float repaymentAmount = oneInstallment + oneInstallment + fullChargeRefundAmount;\n        final Integer loanChargeId = disburseAddChargeAndRepay(repaymentAmount, ACTIVE, ACCRUAL_PERIODIC, false);\n        final Integer repayment1Id = createdRepaymentTypeResourceId;\n\n        final String repayment2Date = \"20 January 2022\";\n        final Float repayment2Amount = oneInstallment; \/\/ installment 3\n        makeRepaymentType(MAKE_REPAYMENT_COMMAND, repayment2Date, repayment2Amount);\n        Integer repayment2Id = createdRepaymentTypeResourceId;\n\n        LOG.info(\"-------------Loancharge Refund -----------\");\n        final Integer installmentNumber = null;\n        final String externalId = null;\n        final Integer chargeRefundTxnId = (Integer) this.loanTransactionHelper.loanChargeRefund(loanChargeId, installmentNumber,\n                oneThirdChargeRefundAmount, externalId, this.disbursedLoanID, \"resourceId\");\n\n        final String reverseDate = getTodaysDate();\n        final Float adjustmentAmount = 0.0f;\n        LOG.info(\"-------------Reverse Repayment 2  -----------\");\n        ArrayList<HashMap> errors = (ArrayList<HashMap>) this.loanTransactionHelperValidationError.adjustLoanTransaction(disbursedLoanID,\n                repayment2Id, reverseDate, adjustmentAmount.toString(), CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.loan.transaction.cant.be.reversed.because.later.charge.refund.exists\",\n                errors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n    } END"}
{"prompt":"repayment Not Allowed If Later Charge Refund Test\n\n###\n\n","completion":"    @Test\n    public void repaymentNotAllowedIfLaterChargeRefundTest() {\n\n        \/\/ repayment covers 2 installments plus charge\n        final Float repaymentAmount = oneInstallment + oneInstallment + fullChargeRefundAmount;\n        final Integer loanChargeId = disburseAddChargeAndRepay(repaymentAmount, ACTIVE, ACCRUAL_PERIODIC, false);\n\n        LOG.info(\"-------------Loancharge Refund -----------\");\n        final Integer installmentNumber = null;\n        final String externalId = null;\n        final Integer chargeRefundTxnId = (Integer) this.loanTransactionHelper.loanChargeRefund(loanChargeId, installmentNumber,\n                oneThirdChargeRefundAmount, externalId, this.disbursedLoanID, \"resourceId\");\n\n        final String repayment2Date = \"20 January 2022\";\n        final Float repayment2Amount = oneInstallment; \/\/ installment 3\n        ArrayList<HashMap> errors = (ArrayList<HashMap>) this.loanTransactionHelperValidationError.makeRepaymentTypePayment(\n                MAKE_REPAYMENT_COMMAND, repayment2Date, repayment2Amount, this.disbursedLoanID, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.loan.transaction.cant.be.created.because.later.charge.refund.exists\",\n                errors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    } END"}
{"prompt":"credit Balance Refund Can Only Be Applied Where Loan Status Is Overpaid Test\n\n###\n\n","completion":"    @Test\n    public void creditBalanceRefundCanOnlyBeAppliedWhereLoanStatusIsOverpaidTest() {\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanStatusHashMap = makeRepayment(\"06 January 2022\", 2000.00f); \/\/ not full payment\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        final Float refund = 1000.00f;\n        final String externalId = null;\n        ArrayList<HashMap> cbrErrors = (ArrayList<HashMap>) loanTransactionHelperValidationError\n                .creditBalanceRefund(creditBalanceRefundDate, refund, externalId, disbursedLoanID, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.loan.credit.balance.refund.account.is.not.overpaid\",\n                cbrErrors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    } END"}
{"prompt":"cant Refund More Than Overpaid Test\n\n###\n\n","completion":"    @Test\n    public void cantRefundMoreThanOverpaidTest() {\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanStatusHashMap = makeRepayment(\"06 January 2022\", 20000.00f); \/\/ overpayment\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        Float refund = 10000.00f;\n        final String externalId = null;\n        ArrayList<HashMap> cbrErrors = (ArrayList<HashMap>) loanTransactionHelperValidationError\n                .creditBalanceRefund(creditBalanceRefundDate, refund, externalId, disbursedLoanID, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.transactionAmount.invalid.must.be.>zero.and<=overpaidamount\",\n                cbrErrors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        refund = (float) -1.00;\n        cbrErrors = (ArrayList<HashMap>) loanTransactionHelperValidationError.creditBalanceRefund(creditBalanceRefundDate, refund,\n                externalId, disbursedLoanID, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"validation.msg.loan.transaction.transactionAmount.not.greater.than.zero\",\n                cbrErrors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    } END"}
{"prompt":"full Refund Changes Status To Closed Obligation Met Test\n\n###\n\n","completion":"    @Test\n    public void fullRefundChangesStatusToClosedObligationMetTest() {\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanStatusHashMap = makeRepayment(\"06 January 2022\", 20000.00f); \/\/ overpayment\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n        final Float totalOverpaid = (Float) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, disbursedLoanID,\n                \"totalOverpaid\");\n\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        final String externalId = null;\n        loanTransactionHelper.creditBalanceRefund(creditBalanceRefundDate, totalOverpaid, externalId, disbursedLoanID, null);\n        loanStatusHashMap = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, disbursedLoanID,\n                \"status\");\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n        final Float floatZero = 0.0f;\n        Float totalOverpaidAtEnd = (Float) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, disbursedLoanID,\n                \"totalOverpaid\");\n        if (totalOverpaidAtEnd == null) {\n            totalOverpaidAtEnd = floatZero;\n        }\n        assertEquals(totalOverpaidAtEnd, floatZero);\n\n    } END"}
{"prompt":"partial Refund Keeps Overpaid Status Test\n\n###\n\n","completion":"    @Test\n    public void partialRefundKeepsOverpaidStatusTest() {\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanStatusHashMap = makeRepayment(\"06 January 2022\", 20000.00f); \/\/ overpayment\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n        final Float refund = 5000.00f; \/\/ partial refund\n\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        final String externalId = null;\n        loanTransactionHelper.creditBalanceRefund(creditBalanceRefundDate, refund, externalId, disbursedLoanID, null);\n        loanStatusHashMap = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, disbursedLoanID,\n                \"status\");\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n    } END"}
{"prompt":"new Credit Balance Refund Saves External Id Test\n\n###\n\n","completion":"    @Test\n    public void newCreditBalanceRefundSavesExternalIdTest() {\n\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanStatusHashMap = makeRepayment(\"06 January 2022\", 20000.00f); \/\/ overpayment\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n        final Float refund = 1000.00f; \/\/ partial refund\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        final String externalId = \"cbrextID\" + disbursedLoanID.toString();\n        Integer resourceId = (Integer) loanTransactionHelper.creditBalanceRefund(creditBalanceRefundDate, refund, externalId,\n                disbursedLoanID, \"resourceId\");\n        Assertions.assertNotNull(resourceId);\n\n        HashMap creditBalanceRefundMap = (HashMap) this.loanTransactionHelper.getLoanTransactionDetails(disbursedLoanID, resourceId, \"\");\n        Assertions.assertNotNull(creditBalanceRefundMap.get(\"externalId\"));\n        Assertions.assertEquals(creditBalanceRefundMap.get(\"externalId\"), externalId, \"Incorrect External Id Saved\");\n\n    } END"}
{"prompt":"new Credit Balance Refund Finds Duplicate External Id Test\n\n###\n\n","completion":"    @Test\n    public void newCreditBalanceRefundFindsDuplicateExternalIdTest() {\n\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanStatusHashMap = makeRepayment(\"06 January 2022\", 20000.00f); \/\/ overpayment\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n        final Float refund = 1000.00f; \/\/ partial refund\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        final String externalId = \"cbrextID\" + disbursedLoanID.toString();\n        final Integer resourceId = (Integer) loanTransactionHelper.creditBalanceRefund(creditBalanceRefundDate, refund, externalId,\n                disbursedLoanID, \"resourceId\");\n        Assertions.assertNotNull(resourceId);\n\n        final Float refund2 = 10.00f; \/\/ partial refund\n        final String creditBalanceRefundDate2 = \"10 January 2022\";\n        ArrayList<HashMap> cbrErrors = (ArrayList<HashMap>) loanTransactionHelperValidationError\n                .creditBalanceRefund(creditBalanceRefundDate2, refund2, externalId, disbursedLoanID, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.loan.creditBalanceRefund.duplicate.externalId\",\n                cbrErrors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    } END"}
{"prompt":"new Credit Balance Refund Creates Correct Journal Entries For Periodic Accruals Test\n\n###\n\n","completion":"    @Test\n    public void newCreditBalanceRefundCreatesCorrectJournalEntriesForPeriodicAccrualsTest() {\n\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanStatusHashMap = makeRepayment(\"06 January 2022\", 20000.00f); \/\/ overpayment\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n        final Float refund = 1000.00f; \/\/ partial refund\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        final String externalId = null;\n        final Integer resourceId = (Integer) loanTransactionHelper.creditBalanceRefund(creditBalanceRefundDate, refund, externalId,\n                disbursedLoanID, \"resourceId\");\n        Assertions.assertNotNull(resourceId);\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, creditBalanceRefundDate,\n                new JournalEntry(refund, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, creditBalanceRefundDate,\n                new JournalEntry(refund, JournalEntry.TransactionType.DEBIT));\n\n    } END"}
{"prompt":"new Credit Balance Refund Creates Correct Journal Entries For Cash Accounting Test\n\n###\n\n","completion":"    @Test\n    public void newCreditBalanceRefundCreatesCorrectJournalEntriesForCashAccountingTest() {\n\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanStatusHashMap = makeRepayment(\"08 January 2022\", 20000.00f); \/\/ overpayment\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n        final Float refund = 1000.00f; \/\/ partial refund\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        final String externalId = null;\n        final Integer resourceId = (Integer) loanTransactionHelper.creditBalanceRefund(creditBalanceRefundDate, refund, externalId,\n                disbursedLoanID, \"resourceId\");\n        Assertions.assertNotNull(resourceId);\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, creditBalanceRefundDate,\n                new JournalEntry(refund, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, creditBalanceRefundDate,\n                new JournalEntry(refund, JournalEntry.TransactionType.DEBIT));\n\n    } END"}
{"prompt":"repayment Transaction Type Matches Test\n\n###\n\n","completion":"    @Test\n    public void repaymentTransactionTypeMatchesTest() {\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        verifyRepaymentTransactionTypeMatches(MERCHANT_ISSUED_REFUND);\n        verifyRepaymentTransactionTypeMatches(PAYOUT_REFUND);\n        verifyRepaymentTransactionTypeMatches(GOODWILL_CREDIT);\n\n    } END"}
{"prompt":"repayment Transaction Type When Paid Test\n\n###\n\n","completion":"    @Test\n    public void repaymentTransactionTypeWhenPaidTest() {\n        verifyRepaymentTransactionTypeWhenPaid(MERCHANT_ISSUED_REFUND);\n        verifyRepaymentTransactionTypeWhenPaid(PAYOUT_REFUND);\n        verifyRepaymentTransactionTypeWhenPaid(GOODWILL_CREDIT);\n        verifyRepaymentTransactionTypeWhenPaid(REPAYMENT);\n\n    } END"}
{"prompt":"good Will Credit Will Close The Loan Correctly\n\n###\n\n","completion":"    @Test\n    public void goodWillCreditWillCloseTheLoanCorrectly() {\n\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        \/\/ pay off all of principal, interest (no fees or penalties)\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float goodwillAmount = totalOutstanding;\n        final String goodwillDate = \"09 March 2022\";\n        HashMap loanStatusHashMap = (HashMap) this.loanTransactionHelper.makeRepaymentTypePayment(GOODWILL_CREDIT, goodwillDate,\n                goodwillAmount, this.disbursedLoanID, \"\");\n\n        GetLoansLoanIdResponse details = this.loanTransactionHelper.getLoan(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        Assertions.assertNull(details.getSummary().getInArrears());\n        Assertions.assertTrue(details.getStatus().getClosedObligationsMet());\n    } END"}
{"prompt":"payment Refund Will Close The Loan Correctly\n\n###\n\n","completion":"    @Test\n    public void paymentRefundWillCloseTheLoanCorrectly() {\n\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        \/\/ pay off all of principal, interest (no fees or penalties)\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float goodwillAmount = totalOutstanding;\n        final String goodwillDate = \"09 March 2022\";\n        HashMap loanStatusHashMap = (HashMap) this.loanTransactionHelper.makeRepaymentTypePayment(PAYOUT_REFUND, goodwillDate,\n                goodwillAmount, this.disbursedLoanID, \"\");\n\n        GetLoansLoanIdResponse details = this.loanTransactionHelper.getLoan(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        Assertions.assertNull(details.getSummary().getInArrears());\n        Assertions.assertTrue(details.getStatus().getClosedObligationsMet());\n    } END"}
{"prompt":"new Goodwill Credit Creates Correct Journal Entries For Periodic Accruals Test\n\n###\n\n","completion":"    @Test\n    public void newGoodwillCreditCreatesCorrectJournalEntriesForPeriodicAccrualsTest() {\n\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        \/\/ pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float goodwillAmount = totalOutstanding + overpaidAmount;\n        final Float goodwillAmountInExpense = principalOutstanding + overpaidAmount;\n        final String goodwillDate = \"09 January 2022\";\n        HashMap loanStatusHashMap = (HashMap) this.loanTransactionHelper.makeRepaymentTypePayment(GOODWILL_CREDIT, goodwillDate,\n                goodwillAmount, this.disbursedLoanID, \"\");\n\n        \/\/ only a single credit for principal and interest as test sets up same GL account for both (summed up)\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, goodwillDate,\n                new JournalEntry(totalOutstanding, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, goodwillDate,\n                new JournalEntry(overpaidAmount, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, goodwillDate,\n                new JournalEntry(goodwillAmountInExpense, JournalEntry.TransactionType.DEBIT));\n\n    } END"}
{"prompt":"new Goodwill Credit Creates Correct Journal Entries For Cash Accounting Test\n\n###\n\n","completion":"    @Test\n    public void newGoodwillCreditCreatesCorrectJournalEntriesForCashAccountingTest() {\n\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        \/\/ pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float goodwillAmount = totalOutstanding + overpaidAmount;\n        final Float goodwillAmountInExpense = principalOutstanding + overpaidAmount;\n        final String goodwillDate = \"09 January 2022\";\n        HashMap loanStatusHashMap = (HashMap) this.loanTransactionHelper.makeRepaymentTypePayment(GOODWILL_CREDIT, goodwillDate,\n                goodwillAmount, this.disbursedLoanID, \"\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, goodwillDate,\n                new JournalEntry(principalOutstanding, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, goodwillDate,\n                new JournalEntry(interestOutstanding, JournalEntry.TransactionType.CREDIT));\n\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, goodwillDate,\n                new JournalEntry(overpaidAmount, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, goodwillDate,\n                new JournalEntry(goodwillAmountInExpense, JournalEntry.TransactionType.DEBIT));\n\n    } END"}
{"prompt":"undo Good Will Credit Transaction Test\n\n###\n\n","completion":"    @Test\n    public void undoGoodWillCreditTransactionTest() {\n        \/\/ Given\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        \/\/ pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float transactionAmount = totalOutstanding + overpaidAmount;\n        final String transactionDate = \"09 January 2022\";\n        PostLoansLoanIdTransactionsResponse loanTransactionResponse = loanTransactionHelper.makeLoanRepayment(GOODWILL_CREDIT,\n                transactionDate, transactionAmount, this.disbursedLoanID);\n        Assertions.assertNotNull(loanTransactionResponse);\n        Assertions.assertNotNull(loanTransactionResponse.getResourceId());\n\n        \/\/ Then\n        loanTransactionHelper.reverseLoanTransaction(this.disbursedLoanID, loanTransactionResponse.getResourceId(), transactionDate,\n                responseSpec);\n    } END"}
{"prompt":"undo Payout Refund Transaction Test\n\n###\n\n","completion":"    @Test\n    public void undoPayoutRefundTransactionTest() {\n        \/\/ Given\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        \/\/ pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float transactionAmount = totalOutstanding + overpaidAmount;\n        final String transactionDate = \"09 January 2022\";\n        PostLoansLoanIdTransactionsResponse loanTransactionResponse = loanTransactionHelper.makeLoanRepayment(PAYOUT_REFUND,\n                transactionDate, transactionAmount, this.disbursedLoanID);\n        Assertions.assertNotNull(loanTransactionResponse);\n        Assertions.assertNotNull(loanTransactionResponse.getResourceId());\n\n        \/\/ Then\n        loanTransactionHelper.reverseLoanTransaction(this.disbursedLoanID, loanTransactionResponse.getResourceId(), transactionDate,\n                responseSpec);\n    } END"}
{"prompt":"undo Merchant Issued Refund Transaction Test\n\n###\n\n","completion":"    @Test\n    public void undoMerchantIssuedRefundTransactionTest() {\n        \/\/ Given\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        \/\/ pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float transactionAmount = totalOutstanding + overpaidAmount;\n        final String transactionDate = \"09 January 2022\";\n        PostLoansLoanIdTransactionsResponse loanTransactionResponse = loanTransactionHelper.makeLoanRepayment(MERCHANT_ISSUED_REFUND,\n                transactionDate, transactionAmount, this.disbursedLoanID);\n        Assertions.assertNotNull(loanTransactionResponse);\n        Assertions.assertNotNull(loanTransactionResponse.getResourceId());\n\n        \/\/ Then\n        loanTransactionHelper.reverseLoanTransaction(this.disbursedLoanID, loanTransactionResponse.getResourceId(), transactionDate,\n                responseSpec);\n    } END"}
{"prompt":"adjust Good Will Credit Transaction Test\n\n###\n\n","completion":"    @Test\n    public void adjustGoodWillCreditTransactionTest() {\n        \/\/ Given\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        \/\/ pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float transactionAmount = totalOutstanding + overpaidAmount;\n        final String transactionDate = \"09 January 2022\";\n        PostLoansLoanIdTransactionsResponse loanTransactionResponse = loanTransactionHelper.makeLoanRepayment(GOODWILL_CREDIT,\n                transactionDate, transactionAmount, this.disbursedLoanID);\n        Assertions.assertNotNull(loanTransactionResponse);\n        Assertions.assertNotNull(loanTransactionResponse.getResourceId());\n\n        \/\/ Then\n        loanTransactionHelper.adjustLoanTransaction(this.disbursedLoanID, loanTransactionResponse.getResourceId(), transactionDate,\n                responseSpec403);\n    } END"}
{"prompt":"adjust Payout Refund Transaction Test\n\n###\n\n","completion":"    @Test\n    public void adjustPayoutRefundTransactionTest() {\n        \/\/ Given\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        \/\/ pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float transactionAmount = totalOutstanding + overpaidAmount;\n        final String transactionDate = \"09 January 2022\";\n        PostLoansLoanIdTransactionsResponse loanTransactionResponse = loanTransactionHelper.makeLoanRepayment(PAYOUT_REFUND,\n                transactionDate, transactionAmount, this.disbursedLoanID);\n        Assertions.assertNotNull(loanTransactionResponse);\n        Assertions.assertNotNull(loanTransactionResponse.getResourceId());\n\n        \/\/ Then\n        loanTransactionHelper.adjustLoanTransaction(this.disbursedLoanID, loanTransactionResponse.getResourceId(), transactionDate,\n                responseSpec403);\n    } END"}
{"prompt":"adjust Merchant Issued Refund Transaction Test\n\n###\n\n","completion":"    @Test\n    public void adjustMerchantIssuedRefundTransactionTest() {\n        \/\/ Given\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        \/\/ pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float transactionAmount = totalOutstanding + overpaidAmount;\n        final String transactionDate = \"09 January 2022\";\n        PostLoansLoanIdTransactionsResponse loanTransactionResponse = loanTransactionHelper.makeLoanRepayment(MERCHANT_ISSUED_REFUND,\n                transactionDate, transactionAmount, this.disbursedLoanID);\n        Assertions.assertNotNull(loanTransactionResponse);\n        Assertions.assertNotNull(loanTransactionResponse.getResourceId());\n\n        \/\/ Then\n        loanTransactionHelper.adjustLoanTransaction(this.disbursedLoanID, loanTransactionResponse.getResourceId(), transactionDate,\n                responseSpec403);\n    } END"}
{"prompt":"check Client Loan Create And Disburse Flow\n\n###\n\n","completion":"    @Test\n    public void checkClientLoanCreateAndDisburseFlow() {\n        \/\/ CREATE CLIENT\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, DATE_OF_JOINING);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        \/\/ CREATE LOAN PRODUCT\n        final Integer loanProductID = createLoanProduct();\n        \/\/ APPLY FOR LOAN\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"28 September 2010\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        \/\/ UNDO APPROVAL\n        loanStatusHashMap = this.loanTransactionHelper.undoApproval(loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------RE-APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 October 2010\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        \/\/ DISBURSE\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        \/\/ PERFORM REPAYMENTS AND CHECK LOAN STATUS\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(1, 4000.0F, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 January 2011\", 540.0f, loanID);\n\n        \/\/ UNDO DISBURSE LOAN\n        loanStatusHashMap = this.loanTransactionHelper.undoDisbursal(loanID);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        \/\/ DIBURSE AGAIN\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        \/\/ MAKE REPAYMENTS\n        final float repayment_with_interest = 540.0f;\n        final float repayment_without_interest = 500.0f;\n\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(1, 4000.0F, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 January 2011\", repayment_with_interest, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 March 2011\", repayment_with_interest, loanID);\n        this.loanTransactionHelper.waiveInterest(\"01 May 2011\", INTEREST_VALUE_AMOUNT, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 May 2011\", repayment_without_interest, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 July 2011\", repayment_with_interest, loanID);\n        this.loanTransactionHelper.waiveInterest(\"01 September 2011\", INTEREST_VALUE_AMOUNT, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 September 2011\", repayment_without_interest, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 November 2011\", repayment_with_interest, loanID);\n        this.loanTransactionHelper.waiveInterest(\"01 January 2012\", INTEREST_VALUE_AMOUNT, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 January 2012\", repayment_without_interest, loanID);\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(7, 1000.0f, loanID);\n\n        \/\/ WRITE OFF LOAN AND CHECK ACCOUNT IS CLOSED\n        LoanStatusChecker.verifyLoanAccountIsClosed(this.loanTransactionHelper.writeOffLoan(\"01 March 2012\", loanID));\n\n    } END"}
{"prompt":"validate Client Loan With Unique External Id\n\n###\n\n","completion":"    @Test\n    public void validateClientLoanWithUniqueExternalId() {\n        \/\/ Given\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification responseSpec403 = new ResponseSpecBuilder().expectStatusCode(403).build();\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        final String externalId = UUID.randomUUID().toString();\n\n        \/\/ When\n        final Integer loanID = applyForLoanApplicationWithExternalId(this.requestSpec, this.responseSpec, clientID, loanProductID,\n                \"12,000.00\", externalId);\n\n        \/\/ Then\n        assertNotNull(loanID);\n        applyForLoanApplicationWithExternalId(this.requestSpec, responseSpec403, clientID, loanProductID, \"12,000.00\", externalId);\n    } END"}
{"prompt":"test Adding Loan Charge Includes Loan Id In The Response\n\n###\n\n","completion":"    @Test\n    public void testAddingLoanChargeIncludesLoanIdInTheResponse() {\n        \/\/ given\n        loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Integer loanProductId = createLoanProduct(false, NONE);\n        Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientId), collateralId);\n        List<HashMap> collaterals = List.of(collaterals(clientCollateralId, BigDecimal.ONE));\n\n        Integer chargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\"));\n        List<HashMap> charges = List.of(charges(chargeId, \"1\", null));\n        \/\/ when\n        Integer loanId = applyForLoanApplication(clientId, loanProductId, charges, null, \"12,000.00\", collaterals);\n        \/\/ then\n        List<HashMap> loanCharges = loanTransactionHelper.getLoanCharges(loanId);\n        Integer loanChargeId = (Integer) loanCharges.get(0).get(\"id\");\n        HashMap loanChargeDetail = loanTransactionHelper.getLoanCharge(loanId, loanChargeId);\n        assertEquals(loanId, loanChargeDetail.get(\"loanId\"));\n    } END"}
{"prompt":"test Loan Charges DISBURSEMENT FEE\n\n###\n\n","completion":"    @Test\n    public void testLoanCharges_DISBURSEMENT_FEE() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        List<HashMap> charges = new ArrayList<>();\n        Integer flatDisbursement = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper.getLoanDisbursementJSON());\n\n        Integer amountPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\"));\n        addCharges(charges, amountPercentage, \"1\", null);\n        Integer amountPlusInterestPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\"));\n        addCharges(charges, amountPlusInterestPercentage, \"1\", null);\n        Integer interestPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_INTEREST, \"1\"));\n        addCharges(charges, interestPercentage, \"1\", null);\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap disbursementDetail = loanSchedule.get(0);\n\n        List<HashMap> loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n\n        validateCharge(amountPercentage, loanCharges, \"1.0\", \"120.0\", \"0.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"1.0\", \"6.06\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"1.0\", \"126.06\", \"0.0\", \"0.0\");\n\n        validateNumberForEqual(\"252.12\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getDisbursementChargesForLoanAsJSON(String.valueOf(flatDisbursement)));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        disbursementDetail = loanSchedule.get(0);\n\n        validateCharge(flatDisbursement, loanCharges, \"100.0\", \"100.0\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"352.12\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        this.loanTransactionHelper.updateChargesForLoan(loanID, (Integer) getloanCharge(amountPercentage, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"2\"));\n        this.loanTransactionHelper.updateChargesForLoan(loanID, (Integer) getloanCharge(interestPercentage, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"2\"));\n        this.loanTransactionHelper.updateChargesForLoan(loanID,\n                (Integer) getloanCharge(amountPlusInterestPercentage, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"2\"));\n        this.loanTransactionHelper.updateChargesForLoan(loanID, (Integer) getloanCharge(flatDisbursement, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"150\"));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        disbursementDetail = loanSchedule.get(0);\n        validateCharge(amountPercentage, loanCharges, \"2.0\", \"240.0\", \"0.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"2.0\", \"12.12\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"2.0\", \"252.12\", \"0.0\", \"0.0\");\n        validateCharge(flatDisbursement, loanCharges, \"150.0\", \"150.0\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"654.24\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        this.loanTransactionHelper.updateLoan(loanID,\n                updateLoanJson(clientID, loanProductID, copyChargesForUpdate(loanCharges, null, null), null, collaterals));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        disbursementDetail = loanSchedule.get(0);\n        validateCharge(amountPercentage, loanCharges, \"2.0\", \"200.0\", \"0.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"2.0\", \"10.1\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"2.0\", \"210.1\", \"0.0\", \"0.0\");\n        validateCharge(flatDisbursement, loanCharges, \"150.0\", \"150.0\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"570.2\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        this.loanTransactionHelper.updateLoan(loanID,\n                updateLoanJson(clientID, loanProductID, copyChargesForUpdate(loanCharges, flatDisbursement, \"1\"), null, collaterals));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        disbursementDetail = loanSchedule.get(0);\n        validateCharge(amountPercentage, loanCharges, \"1.0\", \"100.0\", \"0.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"1.0\", \"5.05\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"1.0\", \"105.05\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"210.1\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        charges.clear();\n        addCharges(charges, flatDisbursement, \"100\", null);\n        this.loanTransactionHelper.updateLoan(loanID, updateLoanJson(clientID, loanProductID, charges, null, collaterals));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        disbursementDetail = loanSchedule.get(0);\n        validateCharge(flatDisbursement, loanCharges, \"100.0\", \"100.0\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"100.0\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        this.loanTransactionHelper.deleteChargesForLoan(loanID, (Integer) getloanCharge(flatDisbursement, loanCharges).get(\"id\"));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        disbursementDetail = loanSchedule.get(0);\n        Assertions.assertEquals(0, loanCharges.size());\n        validateNumberForEqual(\"0.0\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n    } END"}
{"prompt":"test Loan Charges DISBURSEMENT FEE WITH AMOUNT CHANGE\n\n###\n\n","completion":"    @Test\n    public void testLoanCharges_DISBURSEMENT_FEE_WITH_AMOUNT_CHANGE() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        List<HashMap> charges = new ArrayList<>();\n        Integer amountPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\"));\n        addCharges(charges, amountPercentage, \"1\", null);\n        Integer amountPlusInterestPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\"));\n        addCharges(charges, amountPlusInterestPercentage, \"1\", null);\n        Integer interestPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_INTEREST, \"1\"));\n        addCharges(charges, interestPercentage, \"1\", null);\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap disbursementDetail = loanSchedule.get(0);\n\n        List<HashMap> loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n\n        validateCharge(amountPercentage, loanCharges, \"1.0\", \"120.0\", \"0.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"1.0\", \"6.06\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"1.0\", \"126.06\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"252.12\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        \/\/ DISBURSE\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID, \"10000\",\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        disbursementDetail = loanSchedule.get(0);\n\n        validateCharge(amountPercentage, loanCharges, \"1.0\", \"0.0\", \"100.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"1.0\", \"0.0\", \"5.05\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"1.0\", \"0.0\", \"105.05\", \"0.0\");\n        validateNumberForEqual(\"210.1\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n    } END"}
{"prompt":"test Loan Disbursed Today Is Retrieved\n\n###\n\n","completion":"    @Test\n    public void testLoanDisbursedTodayIsRetrieved() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"5\", null);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        \/\/ DISBURSE on todays date so that loan can't be in arrears\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID, \"10000\",\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        \/\/ Test added because loans created without arrears were failing to be retrieved (associations=all) due to inner\n        \/\/ join on m_loan_arrears_aging (now left join)\n        Assertions.assertNotNull(loanDetails, \"Empty Loan Details\");\n        Assertions.assertNotNull(JsonPath.from(loanDetails).get(\"id\"), \"No id Found\");\n\n    } END"}
{"prompt":"test Loan Charges DISBURSEMENT TO SAVINGS\n\n###\n\n","completion":"    @Test\n    public void testLoanCharges_DISBURSEMENT_TO_SAVINGS() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        final Integer savingsId = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID,\n                MINIMUM_OPENING_BALANCE);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, null, savingsId.toString(), \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        HashMap summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(MINIMUM_OPENING_BALANCE);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        \/\/ DISBURSE\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanToSavings(SavingsAccountHelper.TRANSACTION_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(MINIMUM_OPENING_BALANCE) + Float.parseFloat(\"12000\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        loanStatusHashMap = this.loanTransactionHelper.undoDisbursal(loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(MINIMUM_OPENING_BALANCE);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n    } END"}
{"prompt":"test Loan Charges DISBURSEMENT WITH TRANCHES\n\n###\n\n","completion":"    @Test\n    public void testLoanCharges_DISBURSEMENT_WITH_TRANCHES() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(true, NONE);\n\n        List<HashMap> tranches = new ArrayList<>();\n        tranches.add(createTrancheDetail(\"01 March 2014\", \"25000\"));\n        tranches.add(createTrancheDetail(\"23 April 2014\", \"20000\"));\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, null, null, \"45,000.00\", tranches, collaterals);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 March 2014\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        \/\/ DISBURSE first Tranche\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 March 2014\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        \/\/ DISBURSE Second Tranche\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"23 April 2014\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.undoDisbursal(loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n    } END"}
{"prompt":"test Loan Charges DISBURSEMENT TO SAVINGS WITH TRANCHES\n\n###\n\n","completion":"    @Test\n    public void testLoanCharges_DISBURSEMENT_TO_SAVINGS_WITH_TRANCHES() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(true, NONE);\n\n        final Integer savingsId = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID,\n                MINIMUM_OPENING_BALANCE);\n\n        List<HashMap> tranches = new ArrayList<>();\n        tranches.add(createTrancheDetail(\"01 March 2014\", \"25000\"));\n        tranches.add(createTrancheDetail(\"23 April 2014\", \"20000\"));\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, null, savingsId.toString(), \"45,000.00\",\n                tranches, collaterals);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 March 2014\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        HashMap summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(MINIMUM_OPENING_BALANCE);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        \/\/ DISBURSE first Tranche\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanToSavings(\"01 March 2014\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(MINIMUM_OPENING_BALANCE) + Float.parseFloat(\"25000\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        \/\/ DISBURSE Second Tranche\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanToSavings(\"23 April 2014\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(MINIMUM_OPENING_BALANCE) + Float.parseFloat(\"25000\") + Float.parseFloat(\"20000\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        loanStatusHashMap = this.loanTransactionHelper.undoDisbursal(loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(MINIMUM_OPENING_BALANCE);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n    } END"}
{"prompt":"test Client Loan Schedule With Currency Details\n\n###\n\n","completion":"    @Test\n    public void testClientLoanScheduleWithCurrencyDetails() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanProductID = createLoanProduct(\"100\", \"0\", LoanProductTestBuilder.DEFAULT_STRATEGY);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, null, collaterals);\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec,\n                loanID);\n        verifyLoanRepaymentScheduleForEqualPrincipal(loanSchedule);\n\n    } END"}
{"prompt":"test Client Loan Schedule With Currency Details with grace\n\n###\n\n","completion":"    @Test\n    public void testClientLoanScheduleWithCurrencyDetails_with_grace() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanProductID = createLoanProduct(\"100\", \"0\", LoanProductTestBuilder.DEFAULT_STRATEGY);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"5\", collaterals);\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec,\n                loanID);\n        verifyLoanRepaymentScheduleForEqualPrincipalWithGrace(loanSchedule);\n\n    } END"}
{"prompt":"test RBIPayment Strategy\n\n###\n\n","completion":"    @Test\n    public void testRBIPaymentStrategy() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        \/***\n         * Create loan product with RBI strategy\n         *\/\n        final Integer loanProductID = createLoanProduct(\"100\", \"0\", LoanProductTestBuilder.RBI_INDIA_STRATEGY);\n        Assertions.assertNotNull(loanProductID);\n\n        \/***\n         * Apply for loan application and verify loan status\n         *\/\n        final String savingsId = null;\n        final String principal = \"12,000.00\";\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplicationWithPaymentStrategy(clientID, loanProductID, null, savingsId, principal,\n                LoanApplicationTestBuilder.RBI_INDIA_STRATEGY, collaterals);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"3200\", String.valueOf(firstInstallment.get(\"totalOutstandingForPeriod\")));\n\n        \/***\n         * Make payment for installment #1\n         *\/\n        this.loanTransactionHelper.makeRepayment(\"20 October 2011\", Float.parseFloat(\"3200\"), loanID);\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"0.00\", String.valueOf(firstInstallment.get(\"totalOutstandingForPeriod\")));\n\n        \/***\n         * Verify 2nd and 3rd repayments dues before making excess payment for installment no 2\n         *\/\n        HashMap secondInstallment = loanSchedule.get(2);\n        HashMap thirdInstallment = loanSchedule.get(3);\n\n        validateNumberForEqual(\"3200\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n        validateNumberForEqual(\"3200\", String.valueOf(thirdInstallment.get(\"totalOutstandingForPeriod\")));\n\n        validateNumberForEqual(\"3000\", String.valueOf(secondInstallment.get(\"principalOutstanding\")));\n        validateNumberForEqual(\"3100\", String.valueOf(thirdInstallment.get(\"principalOutstanding\")));\n\n        \/***\n         * Make payment for installment #2\n         *\/\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3200\"), loanID);\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        \/***\n         * Verify 2nd and 3rd repayments after making excess payment for installment no 2\n         *\/\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"0.00\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        \/***\n         * According to RBI Excess payment should go to principal portion of next installment, but as interest\n         * recalculation is not implemented, it wont make any difference to schedule even though if we made excess\n         * payment, so excess payments will behave the same as regular payment with the excess amount\n         *\/\n        thirdInstallment = loanSchedule.get(3);\n        validateNumberForEqual(\"3200\", String.valueOf(thirdInstallment.get(\"totalOutstandingForPeriod\")));\n        validateNumberForEqual(\"3100\", String.valueOf(thirdInstallment.get(\"principalOutstanding\")));\n        validateNumberForEqual(\"0\", String.valueOf(thirdInstallment.get(\"principalPaid\")));\n        validateNumberForEqual(\"0\", String.valueOf(thirdInstallment.get(\"interestPaid\")));\n        validateNumberForEqual(\"100.00\", String.valueOf(thirdInstallment.get(\"interestOutstanding\")));\n\n        \/***\n         * Make payment with due amount of 3rd installment on 4th installment date\n         *\/\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"3200\"), loanID);\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n\n        \/***\n         * Verify overdue interests are deducted first and then remaining amount for interest portion of due installment\n         *\/\n        thirdInstallment = loanSchedule.get(3);\n        HashMap fourthInstallment = loanSchedule.get(4);\n\n        validateNumberForEqual(\"100\", String.valueOf(thirdInstallment.get(\"totalOutstandingForPeriod\")));\n        validateNumberForEqual(\"100\", String.valueOf(thirdInstallment.get(\"principalOutstanding\")));\n\n        validateNumberForEqual(\"2900\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n        validateNumberForEqual(\"100\", String.valueOf(fourthInstallment.get(\"interestPaid\")));\n        validateNumberForEqual(\"0.00\", String.valueOf(fourthInstallment.get(\"interestOutstanding\")));\n\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"3000\"), loanID);\n\n        \/***\n         * verify loan is closed as we paid full amount\n         *\/\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation WITH REST SAME AS REPAYMENT INTEREST COMPOUND NONE STRATEGY REDUCE EMI\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_SAME_AS_REPAYMENT_INTEREST_COMPOUND_NONE_STRATEGY_REDUCE_EMI() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.DEFAULT_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_EMI_AMOUN,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD, \"0\", null,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, null, null);\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE, null,\n                LoanApplicationTestBuilder.DEFAULT_STRATEGY, new ArrayList<HashMap>(0));\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2528.81\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        Float earlyPayment = Float.parseFloat(\"4000\");\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -5);\n        final String LOAN_SECOND_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(LOAN_SECOND_REPAYMENT_DATE, earlyPayment, loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"3965.31\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"1771.88\", \"16.39\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"1780.05\", \"8.22\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        validateNumberForEqualWithMsg(\"verify pre-close amount\", \"3551.93\", prepayAmount);\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation WITH REST SAME AS REPAYMENT INTEREST COMPOUND NONE STRATEGY REDUCE EMI PRE CLOSE INTEREST PRE CLOSE DATE\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_SAME_AS_REPAYMENT_INTEREST_COMPOUND_NONE_STRATEGY_REDUCE_EMI_PRE_CLOSE_INTEREST_PRE_CLOSE_DATE() {\n        String preCloseInterestStrategy = LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE;\n        String preCloseAmount = \"7561.84\";\n        testLoanScheduleWithInterestRecalculation_WITH_REST_SAME_AS_REPAYMENT_INTEREST_COMPOUND_NONE_STRATEGY_REDUCE_EMI_PRE_CLOSE_INTEREST(\n                preCloseInterestStrategy, preCloseAmount);\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation WITH REST SAME AS REPAYMENT INTEREST COMPOUND NONE STRATEGY REDUCE EMI PRE CLOSE INTEREST REST DATE\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_SAME_AS_REPAYMENT_INTEREST_COMPOUND_NONE_STRATEGY_REDUCE_EMI_PRE_CLOSE_INTEREST_REST_DATE() {\n        String preCloseInterestStrategy = LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_REST_DATE;\n        String preCloseAmount = \"7586.62\";\n        testLoanScheduleWithInterestRecalculation_WITH_REST_SAME_AS_REPAYMENT_INTEREST_COMPOUND_NONE_STRATEGY_REDUCE_EMI_PRE_CLOSE_INTEREST(\n                preCloseInterestStrategy, preCloseAmount);\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation WITH REST SAME AS REPAYMENT INTEREST COMPOUND NONE STRATEGY REDUCE EMI WITH INSTALLMENT CHARGE\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_SAME_AS_REPAYMENT_INTEREST_COMPOUND_NONE_STRATEGY_REDUCE_EMI_WITH_INSTALLMENT_CHARGE() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.DEFAULT_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_EMI_AMOUN,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD, \"0\", null,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, null, null);\n\n        List<HashMap> charges = new ArrayList<>();\n        Integer installmentCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_INTEREST, \"10\", false));\n        addCharges(charges, installmentCharge, \"10\", null);\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE, null,\n                LoanApplicationTestBuilder.DEFAULT_STRATEGY, charges);\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"4.62\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"3.47\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"2.32\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"1.16\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"4.62\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.76\", \"46.15\", \"4.62\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"2.32\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2528.81\", \"11.67\", \"1.17\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"4.62\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"3.47\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"2.32\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"1.16\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        Float earlyPayment = Float.parseFloat(\"4000\");\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -5);\n        final String LOAN_SECOND_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(LOAN_SECOND_REPAYMENT_DATE, earlyPayment, loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"4.62\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"3961.84\", \"34.69\", \"3.47\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"1773.61\", \"16.41\", \"1.64\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"1781.79\", \"8.22\", \"0.82\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation WITH REST DAILY INTEREST COMPOUND INTEREST STRATEGY REDUCE NUMBER OF INSTALLMENTS\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_DAILY_INTEREST_COMPOUND_INTEREST_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Integer dayOfWeek = getDayOfWeek(todaysDate);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.RBI_INDIA_STRATEGY, LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_INTEREST,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_WEEKLY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, null, dayOfWeek, null, dayOfWeek);\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE,\n                LoanApplicationTestBuilder.RBI_INDIA_STRATEGY, new ArrayList<HashMap>(0));\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.54\", \"46.37\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        loanSchedule = this.loanTransactionHelper.getLoanFutureRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, 0, false, \"4965.3\", \"92.52\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues, 0);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        Float earlyPayment = Float.parseFloat(\"4000\");\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -5);\n        final String LOAN_SECOND_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(LOAN_SECOND_REPAYMENT_DATE, earlyPayment, loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        Calendar today = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        Map<String, Object> paymentday = new HashMap<>(3);\n        paymentday.put(\"dueDate\", getDateAsArray(today, -5, Calendar.DAY_OF_MONTH));\n        paymentday.put(\"principalDue\", \"3990.09\");\n        paymentday.put(\"interestDue\", \"9.91\");\n        paymentday.put(\"feeChargesDue\", \"0\");\n        paymentday.put(\"penaltyChargesDue\", \"0\");\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        expectedvalues.add(paymentday);\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.31\", \"11.6\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"1009.84\", \"4.66\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n    } END"}
{"prompt":"test Interoperation Loan Repayment API\n\n###\n\n","completion":"    @Test\n    public void testInteroperationLoanRepaymentAPI() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"42\", true);\n        Calendar startDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        startDate.add(Calendar.MONTH, -8);\n\n        Calendar firstRepaymentDate = (Calendar) startDate.clone();\n        firstRepaymentDate.add(Calendar.MONTH, 1);\n        firstRepaymentDate.add(Calendar.DAY_OF_MONTH, firstRepaymentDate.getActualMaximum(Calendar.DAY_OF_MONTH) - Calendar.DAY_OF_MONTH);\n        String firstRepayment = dateFormat.format(firstRepaymentDate.getTime());\n\n        final String loanDisbursementDate = dateFormat.format(startDate.getTime());\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, \"12\");\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, loanDisbursementDate,\n                LoanApplicationTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY, firstRepayment);\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        Assertions.assertNotNull(loanSchedule);\n        startDate.add(Calendar.DAY_OF_MONTH, 2);\n        String loanFirstRepaymentDate = dateFormat.format(startDate.getTime());\n\n        Float earlyPayment = Float.parseFloat(\"3000\");\n        String accountNo = JsonPath.from(loanDetails).get(\"accountNo\").toString();\n\n        HashMap loanRepayment = this.loanTransactionHelper.makeRepaymentWithAccountNo(loanFirstRepaymentDate, earlyPayment, accountNo);\n        assertNotNull(loanRepayment);\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation WITH REST WEEKLY INTEREST COMPOUND INTEREST FEE STRATEGY REDUCE NEXT INSTALLMENTS\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_WEEKLY_INTEREST_COMPOUND_INTEREST_FEE_STRATEGY_REDUCE_NEXT_INSTALLMENTS() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        Integer compoundingDayOfMonth = getDayOfMonth(todaysDate);\n        Integer compoundingDayOfWeek = getDayOfWeek(todaysDate);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -2);\n        Integer restDayOfMonth = getDayOfMonth(todaysDate);\n        Integer restDayOfWeek = getDayOfWeek(todaysDate);\n        final String REST_START_DATE = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        todaysDate.add(Calendar.DAY_OF_MONTH, 2);\n        final String LOAN_FLAT_CHARGE_DATE = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.DAY_OF_MONTH, 14);\n        final String LOAN_INTEREST_CHARGE_DATE = dateFormat.format(todaysDate.getTime());\n        List<HashMap> charges = new ArrayList<>(2);\n        Integer flat = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"100\", false));\n        Integer principalPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"2\", false));\n\n        addCharges(charges, flat, \"100\", LOAN_FLAT_CHARGE_DATE);\n        addCharges(charges, principalPercentage, \"2\", LOAN_INTEREST_CHARGE_DATE);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.DEFAULT_STRATEGY, LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_INTEREST_AND_FEE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_RESCHEDULE_NEXT_REPAYMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_WEEKLY, \"1\", REST_START_DATE,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_WEEKLY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, compoundingDayOfMonth, compoundingDayOfWeek,\n                restDayOfMonth, restDayOfWeek);\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE,\n                LOAN_DISBURSEMENT_DATE, LoanApplicationTestBuilder.DEFAULT_STRATEGY, charges);\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"100.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"200\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"100.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.08\", \"46.83\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"200\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.49\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        Calendar repaymentDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        repaymentDate.add(Calendar.DAY_OF_MONTH, -7);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(repaymentDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"100.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"200\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        Float earlyPayment = Float.parseFloat(\"5100\");\n        repaymentDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        repaymentDate.add(Calendar.DAY_OF_MONTH, -5);\n        final String LOAN_SECOND_REPAYMENT_DATE = dateFormat.format(repaymentDate.getTime());\n        this.loanTransactionHelper.makeRepayment(LOAN_SECOND_REPAYMENT_DATE, earlyPayment, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"100.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"5065.31\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"0\", \"11.32\", \"200\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2451.93\", \"11.32\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation WITH REST WEEKLY INTEREST COMPOUND INTEREST FEE STRATEGY REDUCE NEXT INSTALLMENTS PRE CLOSE INTEREST PRE CLOSE DATE\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_WEEKLY_INTEREST_COMPOUND_INTEREST_FEE_STRATEGY_REDUCE_NEXT_INSTALLMENTS_PRE_CLOSE_INTEREST_PRE_CLOSE_DATE() {\n        String preCloseInterestStrategy = LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE;\n        String preCloseAmount = \"7761.89\";\n        testLoanScheduleWithInterestRecalculation_WITH_REST_WEEKLY_INTEREST_COMPOUND_INTEREST_FEE_STRATEGY_REDUCE_NEXT_INSTALLMENTS_PRE_CLOSE_INTEREST(\n                preCloseInterestStrategy, preCloseAmount);\n\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation WITH REST WEEKLY INTEREST COMPOUND INTEREST FEE STRATEGY REDUCE NEXT INSTALLMENTS PRE CLOSE INTEREST REST DATE\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_WEEKLY_INTEREST_COMPOUND_INTEREST_FEE_STRATEGY_REDUCE_NEXT_INSTALLMENTS_PRE_CLOSE_INTEREST_REST_DATE() {\n        String preCloseInterestStrategy = LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_REST_DATE;\n        String preCloseAmount = \"7786.79\";\n        testLoanScheduleWithInterestRecalculation_WITH_REST_WEEKLY_INTEREST_COMPOUND_INTEREST_FEE_STRATEGY_REDUCE_NEXT_INSTALLMENTS_PRE_CLOSE_INTEREST(\n                preCloseInterestStrategy, preCloseAmount);\n\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation WITH REST DAILY INTEREST COMPOUND INTEREST FEE STRATEGY WITH OVERDUE CHARGE\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_DAILY_INTEREST_COMPOUND_INTEREST_FEE_STRATEGY_WITH_OVERDUE_CHARGE()\n            throws InterruptedException {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7 * 3);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -2);\n        final String REST_START_DATE = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n\n        Integer overdueFeeChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"10\"));\n        Assertions.assertNotNull(overdueFeeChargeId);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final String recalculationCompoundingFrequencyInterval = null;\n        final String recalculationCompoundingFrequencyDate = null;\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.DEFAULT_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_INTEREST_AND_FEE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_RESCHEDULE_NEXT_REPAYMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"1\", REST_START_DATE,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD, recalculationCompoundingFrequencyInterval,\n                recalculationCompoundingFrequencyDate, LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null,\n                overdueFeeChargeId.toString(), false, null, null, null, null);\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE,\n                REST_START_DATE, LoanApplicationTestBuilder.DEFAULT_STRATEGY, null);\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -2, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n\n        addRepaymentValues(expectedvalues, todaysDate, -2, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.54\", \"46.37\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.33\", \"46.58\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2552.37\", \"11.78\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        String JobName = \"Apply penalty to overdue loans\";\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -2, false, \"2482.76\", \"46.15\", \"0.0\", \"252.89\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2481.38\", \"47.53\", \"0.0\", \"252.89\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2479.99\", \"48.92\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2555.87\", \"11.8\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        Calendar repaymentDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        repaymentDate.add(Calendar.DAY_OF_MONTH, -7 * 2);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(repaymentDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        totalDueForCurrentPeriod = totalDueForCurrentPeriod - Float.parseFloat(\"252.89\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -2, false, \"2482.76\", \"46.15\", \"0.0\", \"252.89\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2493.05\", \"35.86\", \"0.0\", \"252.89\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2491.72\", \"37.19\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2532.47\", \"11.69\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        repaymentDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        repaymentDate.add(Calendar.DAY_OF_MONTH, -3);\n        final String LOAN_SECOND_REPAYMENT_DATE = dateFormat.format(repaymentDate.getTime());\n        totalDueForCurrentPeriod = (Float) loanSchedule.get(2).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_SECOND_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -2, false, \"2482.76\", \"46.15\", \"0.0\", \"252.89\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2493.05\", \"35.86\", \"0.0\", \"252.89\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2497.22\", \"31.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2526.97\", \"11.66\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation WITH PERIODIC ACCOUNTING\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_PERIODIC_ACCOUNTING() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        this.periodicAccrualAccountingHelper = new PeriodicAccrualAccountingHelper(this.requestSpec, this.responseSpec);\n        this.journalEntryHelper = new JournalEntryHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        LOG.info(\"Disbursal Date Calendar {}\", todaysDate.getTime());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        Account[] accounts = { assetAccount, incomeAccount, expenseAccount, overpaymentAccount };\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.DEFAULT_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_EMI_AMOUN,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD, \"0\", null,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, accounts, null, null);\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE, null,\n                LoanApplicationTestBuilder.DEFAULT_STRATEGY, new ArrayList<HashMap>(0));\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        LOG.info(\"Date during repayment schedule {}\", todaysDate.getTime());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2528.81\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(10000.0f, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(10000.0f, JournalEntry.TransactionType.DEBIT), };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, LOAN_DISBURSEMENT_DATE, assetAccountInitialEntry);\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        String runOndate = dateFormat.format(todaysDate.getTime());\n        LOG.info(\"runOndate : {}\", runOndate);\n        this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(runOndate);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(Utils.getLocalDateOfTenant().minusDays(7), 46.15f, 0f, 0f, loanID);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(Utils.getLocalDateOfTenant(), 46.15f, 0f, 0f, loanID);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(runOndate);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(Utils.getLocalDateOfTenant().minusDays(7), 46.15f, 0f, 0f, loanID);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(Utils.getLocalDateOfTenant(), 34.69f, 0f, 0f, loanID);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(Utils.getLocalDateOfTenant().minusDays(7), 46.15f, 0f, 0f, loanID);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(Utils.getLocalDateOfTenant(), 34.69f, 0f, 0f, loanID);\n\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation WITH CURRENT REPAYMENT BASED ARREARS AGEING\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_CURRENT_REPAYMENT_BASED_ARREARS_AGEING() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.RBI_INDIA_STRATEGY, LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_INTEREST,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_RESCHEDULE_NEXT_REPAYMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, getDayOfMonth(todaysDate),\n                getDayOfWeek(todaysDate), getDayOfMonth(todaysDate), getDayOfWeek(todaysDate));\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE,\n                LOAN_DISBURSEMENT_DATE, LoanApplicationTestBuilder.RBI_INDIA_STRATEGY, new ArrayList<HashMap>(0));\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.54\", \"46.37\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        HashMap loanSummary = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, loanID);\n        List dates = (List) loanSummary.get(\"overdueSinceDate\");\n        assertEquals(todaysDate.get(Calendar.YEAR), dates.get(0));\n        assertEquals(todaysDate.get(Calendar.MONTH) + 1, dates.get(1));\n        assertEquals(todaysDate.get(Calendar.DAY_OF_MONTH), dates.get(2));\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -8);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        loanSummary = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, loanID);\n        dates = (List) loanSummary.get(\"overdueSinceDate\");\n        assertEquals(todaysDate.get(Calendar.YEAR), dates.get(0));\n        assertEquals(todaysDate.get(Calendar.MONTH) + 1, dates.get(1));\n        assertEquals(todaysDate.get(Calendar.DAY_OF_MONTH), dates.get(2));\n\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation WITH ORIGINAL REPAYMENT BASED ARREARS AGEING\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_ORIGINAL_REPAYMENT_BASED_ARREARS_AGEING() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        LOG.info(\"----timeeeeeeeeeeeeee------> {}\", dateFormat.format(todaysDate.getTime()));\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final String recalculationCompoundingFrequencyInterval = null;\n        final String recalculationCompoundingFrequencyDate = null;\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.RBI_INDIA_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_INTEREST,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_RESCHEDULE_NEXT_REPAYMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD, recalculationCompoundingFrequencyInterval,\n                recalculationCompoundingFrequencyDate, LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, null,\n                true, null, null, getDayOfMonth(todaysDate), getDayOfWeek(todaysDate));\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE,\n                LOAN_DISBURSEMENT_DATE, LoanApplicationTestBuilder.RBI_INDIA_STRATEGY, new ArrayList<HashMap>(0));\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.54\", \"46.37\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        HashMap loanSummary = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, loanID);\n        List dates = (List) loanSummary.get(\"overdueSinceDate\");\n        assertEquals(todaysDate.get(Calendar.YEAR), dates.get(0));\n        assertEquals(todaysDate.get(Calendar.MONTH) + 1, dates.get(1));\n        assertEquals(todaysDate.get(Calendar.DAY_OF_MONTH), dates.get(2));\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -8);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        loanSummary = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, loanID);\n        dates = (List) loanSummary.get(\"overdueSinceDate\");\n        Assertions.assertNull(dates);\n\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation FOR PRE CLOSE WITH MORATORIUM INTEREST APPLICABLE STRATEGY ON PRE CLOSE DATE\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_FOR_PRE_CLOSE_WITH_MORATORIUM_INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE() {\n        testLoanScheduleWithInterestRecalculation_FOR_PRE_CLOSE_WITH_MORATORIUM(\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, \"10006.59\");\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation FOR PRE CLOSE WITH MORATORIUM INTEREST APPLICABLE STRATEGY REST DATE\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_FOR_PRE_CLOSE_WITH_MORATORIUM_INTEREST_APPLICABLE_STRATEGY_REST_DATE() {\n        testLoanScheduleWithInterestRecalculation_FOR_PRE_CLOSE_WITH_MORATORIUM(\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_REST_DATE, \"10046.15\");\n    } END"}
{"prompt":"test Loan Product Configuration\n\n###\n\n","completion":"    @Test\n    public void testLoanProductConfiguration() {\n        final String proposedAmount = \"5000\";\n        JsonObject loanProductConfigurationAsTrue = new JsonObject();\n        loanProductConfigurationAsTrue = this.createLoanProductConfigurationDetail(loanProductConfigurationAsTrue, true);\n\n        JsonObject loanProductConfigurationAsFalse = new JsonObject();\n        loanProductConfigurationAsFalse = this.createLoanProductConfigurationDetail(loanProductConfigurationAsFalse, false);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        Integer loanProductID = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withAmortizationTypeAsEqualInstallments().withRepaymentTypeAsMonth()\n                        .withRepaymentAfterEvery(\"1\").withRepaymentStrategy(LoanProductTestBuilder.DEFAULT_STRATEGY)\n                        .withInterestTypeAsDecliningBalance().withInterestCalculationPeriodTypeAsDays().withInArrearsTolerance(\"10\")\n                        .withMoratorium(\"2\", \"3\").withLoanProductConfiguration(loanProductConfigurationAsTrue).build(null));\n        LOG.info(\"-----------------------LOAN PRODUCT CREATED WITH ATTRIBUTE CONFIGURATION AS TRUE-------------------------- {}\",\n                loanProductID);\n        Integer loanID = applyForLoanApplicationWithProductConfigurationAsTrue(clientID, loanProductID, proposedAmount);\n        LOG.info(\"------------------------LOAN CREATED WITH ID------------------------------{}\", loanID);\n\n        loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().withAmortizationTypeAsEqualInstallments()\n                .withRepaymentTypeAsMonth().withRepaymentAfterEvery(\"1\").withRepaymentStrategy(LoanProductTestBuilder.DEFAULT_STRATEGY)\n                .withInterestTypeAsDecliningBalance().withInterestCalculationPeriodTypeAsDays().withInArrearsTolerance(\"10\")\n                .withMoratorium(\"2\", \"3\").withLoanProductConfiguration(loanProductConfigurationAsFalse).build(null));\n        LOG.info(\"-------------------LOAN PRODUCT CREATED WITH ATTRIBUTE CONFIGURATION AS FALSE---------------------- {}\", loanProductID);\n        \/*\n         * Try to override attribute values in loan account when attribute configurations are set to false at product\n         * level\n         *\/\n        loanID = applyForLoanApplicationWithProductConfigurationAsFalse(clientID, loanProductID, proposedAmount);\n        LOG.info(\"--------------------------LOAN CREATED WITH ID------------------------- {}\", loanID);\n        this.validateIfValuesAreNotOverridden(loanID, loanProductID);\n    } END"}
{"prompt":"test Loan Foreclosure\n\n###\n\n","completion":"    @Test\n    public void testLoanForeclosure() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        List<HashMap> charges = new ArrayList<>();\n\n        Integer flatAmountChargeOne = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n        addCharges(charges, flatAmountChargeOne, \"50\", \"01 October 2011\");\n        Integer flatAmountChargeTwo = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"100\", true));\n        addCharges(charges, flatAmountChargeTwo, \"100\", \"15 December 2011\");\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"10,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"----------------------------------- APPROVE LOAN -----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"----------------------------------- DISBURSE LOAN ----------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID, \"10,000.00\",\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        LOG.info(\"---------------------------------- Make repayment 1 --------------------------------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 October 2011\", Float.parseFloat(\"2676.24\"), loanID);\n\n        LOG.info(\"---------------------------------- FORECLOSE LOAN ----------------------------------------\");\n        this.loanTransactionHelper.forecloseLoan(\"08 November 2011\", loanID);\n\n        \/\/ retrieving the loan status\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        \/\/ verifying the loan status is closed\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n        \/\/ retrieving the loan sub-status\n        loanStatusHashMap = LoanStatusChecker.getSubStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        \/\/ verifying the loan sub-status is foreclosed\n        LoanStatusChecker.verifyLoanAccountForeclosed(loanStatusHashMap);\n\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation WITH INTEREST FIRST STRATEGY AND REST DAILY INTEREST COMPOUND INTEREST STRATEGY REDUCE NUMBER OF INSTALLMENTS\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_INTEREST_FIRST_STRATEGY_AND_REST_DAILY_INTEREST_COMPOUND_INTEREST_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Integer dayOfWeek = getDayOfWeek(todaysDate);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_INTEREST,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_WEEKLY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, null, dayOfWeek, null, dayOfWeek);\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE,\n                LoanApplicationTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY, new ArrayList<HashMap>(0));\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.54\", \"46.37\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        loanSchedule = this.loanTransactionHelper.getLoanFutureRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, 0, false, \"4965.3\", \"92.52\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues, 0);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        Float earlyPayment = Float.parseFloat(\"4000\");\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -5);\n        final String LOAN_SECOND_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(LOAN_SECOND_REPAYMENT_DATE, earlyPayment, loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        Calendar today = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        Map<String, Object> paymentday = new HashMap<>(3);\n        paymentday.put(\"dueDate\", getDateAsArray(today, -5, Calendar.DAY_OF_MONTH));\n        paymentday.put(\"principalDue\", \"3990.09\");\n        paymentday.put(\"interestDue\", \"9.91\");\n        paymentday.put(\"feeChargesDue\", \"0\");\n        paymentday.put(\"penaltyChargesDue\", \"0\");\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        expectedvalues.add(paymentday);\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.31\", \"11.6\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"1009.84\", \"4.66\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation WITH INTEREST FIRST STRATEGY AND REST DAILY INTEREST COMPOUND INTEREST STRATEGY REDUCE NUMBER OF INSTALLMENTS EARLY REPAYMENT\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_INTEREST_FIRST_STRATEGY_AND_REST_DAILY_INTEREST_COMPOUND_INTEREST_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS_EARLY_REPAYMENT() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Integer dayOfWeek = getDayOfWeek(todaysDate);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_INTEREST,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_WEEKLY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, null, dayOfWeek, null, dayOfWeek);\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE,\n                LoanApplicationTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY, new ArrayList<HashMap>(0));\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.54\", \"46.37\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        loanSchedule = this.loanTransactionHelper.getLoanFutureRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, 0, false, \"4965.3\", \"92.52\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues, 0);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        \/\/ early repayment - pay exact due amount 2 days before due date\n        Float earlyPayment = Float.parseFloat(\"2528.91\");\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -2);\n        final String LOAN_SECOND_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(LOAN_SECOND_REPAYMENT_DATE, earlyPayment, loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        Calendar today = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        \/\/ early-repayment\n        addRepaymentValues(expectedvalues, todaysDate, 5, true, \"2504.13\", \"24.78\", \"0.0\", \"0.0\");\n\n        addRepaymentValues(expectedvalues, todaysDate, 2, true, \"2522.33\", \"6.58\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2490.78\", \"11.5\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation Make Prepayment After Repayment\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculationMakePrepaymentAfterRepayment() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"42\", true);\n        Calendar startDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        Calendar currentDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        startDate.add(Calendar.MONTH, -8);\n\n        Calendar firstRepaymentDate = (Calendar) startDate.clone();\n        firstRepaymentDate.add(Calendar.MONTH, 1);\n        firstRepaymentDate.add(Calendar.DAY_OF_MONTH, firstRepaymentDate.getActualMaximum(Calendar.DAY_OF_MONTH) - Calendar.DAY_OF_MONTH);\n        String firstRepayment = dateFormat.format(firstRepaymentDate.getTime());\n\n        final String loanDisbursementDate = dateFormat.format(startDate.getTime());\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, \"12\");\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, loanDisbursementDate,\n                LoanApplicationTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY, firstRepayment);\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        Assertions.assertNotNull(loanSchedule);\n        startDate.add(Calendar.DAY_OF_MONTH, 2);\n        String loanFirstRepaymentDate = dateFormat.format(startDate.getTime());\n        \/\/\n        Float earlyPayment = Float.parseFloat(\"3000\");\n        this.loanTransactionHelper.makeRepayment(loanFirstRepaymentDate, earlyPayment, loanID);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        String loanPrepaymentDate = dateFormat.format(currentDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanPrepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"42\", false);\n    } END"}
{"prompt":"test Loan Schedule With Interest Recalculation Make Advance Payment Till Settlement\n\n###\n\n","completion":"    @Test\n    public void testLoanScheduleWithInterestRecalculationMakeAdvancePaymentTillSettlement() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final LoanTransactionHelper validationErrorHelper = new LoanTransactionHelper(this.requestSpec, errorResponse);\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"42\", true);\n        Calendar startDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        Calendar currentDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        startDate.add(Calendar.MONTH, -8);\n\n        Calendar firstRepaymentDate = (Calendar) startDate.clone();\n        firstRepaymentDate.add(Calendar.MONTH, 1);\n        firstRepaymentDate.add(Calendar.DAY_OF_MONTH, firstRepaymentDate.getActualMaximum(Calendar.DAY_OF_MONTH) - Calendar.DAY_OF_MONTH);\n        String firstRepayment = dateFormat.format(firstRepaymentDate.getTime());\n\n        final String loanDisbursementDate = dateFormat.format(startDate.getTime());\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, \"12\");\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, loanDisbursementDate,\n                LoanApplicationTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY, firstRepayment);\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        Assertions.assertNotNull(loanSchedule);\n        Calendar repaymentDate = (Calendar) firstRepaymentDate.clone();\n        startDate.add(Calendar.DAY_OF_MONTH, 2);\n        String loanFirstRepaymentDate = dateFormat.format(startDate.getTime());\n        \/\/\n        Float earlyPayment = Float.parseFloat(\"3000\");\n        String retrieveDueDate = null;\n        Float amount = null;\n        this.loanTransactionHelper.makeRepayment(loanFirstRepaymentDate, earlyPayment, loanID);\n        for (int i = 1; i < loanSchedule.size(); i++) {\n\n            retrieveDueDate = dateFormat.format(repaymentDate.getTime());\n            amount = (Float) loanSchedule.get(i).get(\"principalOriginalDue\") + (Float) loanSchedule.get(i).get(\"interestOriginalDue\");\n            if (currentDate.after(repaymentDate)) {\n                this.loanTransactionHelper.makeRepayment(retrieveDueDate, amount, loanID);\n            } else {\n                break;\n            }\n            repaymentDate.add(Calendar.MONTH, 1);\n        }\n        HashMap savingsAccountErrorData = validationErrorHelper.makeRepayment(retrieveDueDate, amount, loanID);\n        ArrayList<HashMap> error = (ArrayList<HashMap>) savingsAccountErrorData.get(\"errors\");\n        assertEquals(\"error.msg.loan.transaction.cannot.be.a.future.date\", error.get(0).get(\"userMessageGlobalisationCode\"));\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"42\", false);\n    } END"}
{"prompt":"test Collateral Data Is Available When Requested\n\n###\n\n","completion":"    @Test\n    public void testCollateralDataIsAvailableWhenRequested() {\n        \/\/ given\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        List<HashMap> collaterals = new ArrayList<>();\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientId), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        Integer loanProductId = createLoanProduct(false, NONE);\n\n        \/\/ when\n        Integer loanId = applyForLoanApplication(clientId, loanProductId, null, null, \"12,000.00\", collaterals);\n\n        \/\/ then\n        List<Integer> clientCollateralIds = (List<Integer>) loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanId,\n                \"collateral.clientCollateralId\");\n        Integer clientCollateralIdResult = clientCollateralIds.get(0);\n        assertEquals(clientCollateralId, clientCollateralIdResult);\n    } END"}
{"prompt":"undo Waived Charge Transaction Does Not Exist\n\n###\n\n","completion":"    @Test\n    public void undoWaivedChargeTransactionDoesNotExist() {\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(404).build();\n        LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, responseSpec);\n        HashMap response = loanTransactionHelper.undoWaiveChargesForLoan(-1, -2, \"\");\n        assertEquals(\"error.msg.loan.transaction.id.invalid\",\n                ((Map) ((List) response.get(\"errors\")).get(0)).get(\"userMessageGlobalisationCode\"));\n        assertEquals(\"Transaction with identifier -2 does not exist for loan with identifier -1.\",\n                ((Map) ((List) response.get(\"errors\")).get(0)).get(\"defaultUserMessage\"));\n    } END"}
{"prompt":"charge Adjustment Charge Wrong Params\n\n###\n\n","completion":"    @Test\n    public void chargeAdjustmentChargeWrongParams() {\n        CallFailedRuntimeException exception = assertThrows(CallFailedRuntimeException.class,\n                () -> loanTransactionHelper.chargeAdjustment(0L, 0L, new PostLoansLoanIdChargesChargeIdRequest().amount(0.0)));\n        assertEquals(400, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"validation.msg.loan.charge.adjustment.request.amount.not.greater.than.zero\"));\n        assertTrue(exception.getMessage().contains(\"validation.msg.loan.charge.adjustment.request.loanId.not.greater.than.zero\"));\n        assertTrue(exception.getMessage().contains(\"validation.msg.loan.charge.adjustment.request.loanChargeId.not.greater.than.zero\"));\n        exception = assertThrows(CallFailedRuntimeException.class,\n                () -> loanTransactionHelper.chargeAdjustment(1L, 0L, new PostLoansLoanIdChargesChargeIdRequest().amount(0.0)));\n        assertEquals(400, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"validation.msg.loan.charge.adjustment.request.amount.not.greater.than.zero\"));\n        assertTrue(exception.getMessage().contains(\"validation.msg.loan.charge.adjustment.request.loanChargeId.not.greater.than.zero\"));\n        exception = assertThrows(CallFailedRuntimeException.class,\n                () -> loanTransactionHelper.chargeAdjustment(1L, 1L, new PostLoansLoanIdChargesChargeIdRequest().amount(0.0)));\n        assertEquals(400, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"validation.msg.loan.charge.adjustment.request.amount.not.greater.than.zero\"));\n    } END"}
{"prompt":"charge Adjustment Charge Does Not Exist\n\n###\n\n","completion":"    @Test\n    public void chargeAdjustmentChargeDoesNotExist() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        CallFailedRuntimeException exception = assertThrows(CallFailedRuntimeException.class,\n                () -> loanTransactionHelper.chargeAdjustment((long) loanID, 1L, new PostLoansLoanIdChargesChargeIdRequest().amount(1.0)));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loanCharge.id.invalid\"));\n    } END"}
{"prompt":"charge Adjustment Charge Does Not Exist For Loan\n\n###\n\n","completion":"    @Test\n    public void chargeAdjustmentChargeDoesNotExistForLoan() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n        LocalDate targetDate = LocalDate.of(2022, 9, 7);\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        final Integer loanID2 = applyForLoanApplication(clientID, loanProductID);\n\n        CallFailedRuntimeException exception = assertThrows(CallFailedRuntimeException.class, () -> loanTransactionHelper\n                .chargeAdjustment((long) loanID2, (long) penalty1LoanChargeId, new PostLoansLoanIdChargesChargeIdRequest().amount(1.0)));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loanCharge.id.invalid.for.given.loan\"));\n    } END"}
{"prompt":"undo Waived Charge Waive Transaction Does Not Exist\n\n###\n\n","completion":"    @Test\n    public void undoWaivedChargeWaiveTransactionDoesNotExist() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        final Integer loanTransactionId = (Integer) ((Map) ((List) JsonPath.from(loanDetails).get(\"transactions\")).get(0)).get(\"id\");\n\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(403).build();\n        LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, responseSpec);\n        HashMap response = loanTransactionHelper.undoWaiveChargesForLoan(loanID, loanTransactionId, \"\");\n        assertEquals(\"error.msg.loan.transaction.undo.waive.charge\",\n                ((Map) ((List) response.get(\"errors\")).get(0)).get(\"userMessageGlobalisationCode\"));\n        assertEquals(\"Transaction is not a waive charge type.\", ((Map) ((List) response.get(\"errors\")).get(0)).get(\"defaultUserMessage\"));\n    } END"}
{"prompt":"test Close Open Maturity Date\n\n###\n\n","completion":"    @Test\n    public void testCloseOpenMaturityDate() {\n        GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, true);\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n        LocalDate expectedMaturityDate = loanDetails.getTimeline().getExpectedMaturityDate();\n        LocalDate actualMaturityDate = loanDetails.getTimeline().getActualMaturityDate();\n\n        assertTrue(expectedMaturityDate.isEqual(actualMaturityDate));\n\n        this.loanTransactionHelper.makeRepayment(\"04 September 2022\", Float.parseFloat(\"500\"), loanID);\n        this.loanTransactionHelper.makeRepayment(\"05 September 2022\", Float.parseFloat(\"700\"), loanID);\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n        expectedMaturityDate = loanDetails.getTimeline().getExpectedMaturityDate();\n        actualMaturityDate = loanDetails.getTimeline().getActualMaturityDate();\n\n        assertNotNull(expectedMaturityDate);\n        assertNull(actualMaturityDate);\n\n        this.loanTransactionHelper.reverseLoanTransaction((long) loanID, loanDetails.getTransactions().get(1).getId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"04 September 2022\")\n                        .transactionAmount(0.0).locale(\"en\"));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n        expectedMaturityDate = loanDetails.getTimeline().getExpectedMaturityDate();\n        actualMaturityDate = loanDetails.getTimeline().getActualMaturityDate();\n\n        assertNotNull(expectedMaturityDate);\n        assertNotNull(actualMaturityDate);\n\n        assertTrue(expectedMaturityDate.isEqual(actualMaturityDate));\n\n    } END"}
{"prompt":"test Reverse Replay\n\n###\n\n","completion":"    @Test\n    public void testReverseReplay() {\n        try {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, true);\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount,\n                    expenseAccount, overpaymentAccount);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            this.loanTransactionHelper.makeRepayment(\"04 September 2022\", Float.parseFloat(\"500\"), loanID);\n            this.loanTransactionHelper.makeRepayment(\"05 September 2022\", Float.parseFloat(\"10\"), loanID);\n            this.loanTransactionHelper.makeRepayment(\"06 September 2022\", Float.parseFloat(\"400\"), loanID);\n            this.loanTransactionHelper.makeRepayment(\"07 September 2022\", Float.parseFloat(\"390\"), loanID);\n\n            GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            assertEquals(300.0, loanDetails.getTotalOverpaid());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n\n            assertEquals(10.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(10.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(2).getDate());\n\n            assertEquals(400.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(400.0, loanDetails.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 6), loanDetails.getTransactions().get(3).getDate());\n\n            assertEquals(390.0, loanDetails.getTransactions().get(4).getAmount());\n            assertEquals(90.0, loanDetails.getTransactions().get(4).getPrincipalPortion());\n            assertEquals(300.0, loanDetails.getTransactions().get(4).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 7), loanDetails.getTransactions().get(4).getDate());\n\n            this.loanTransactionHelper.reverseLoanTransaction((long) loanID, loanDetails.getTransactions().get(2).getId(),\n                    new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"05 September 2022\")\n                            .transactionAmount(0.0).locale(\"en\"));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            assertEquals(290.0, loanDetails.getTotalOverpaid());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n\n            assertEquals(10.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(10.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(2).getDate());\n            assertTrue(loanDetails.getTransactions().get(2).getManuallyReversed());\n\n            assertEquals(400.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(400.0, loanDetails.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 6), loanDetails.getTransactions().get(3).getDate());\n\n            assertEquals(390.0, loanDetails.getTransactions().get(4).getAmount());\n            assertEquals(100.0, loanDetails.getTransactions().get(4).getPrincipalPortion());\n            assertEquals(290.0, loanDetails.getTransactions().get(4).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 7), loanDetails.getTransactions().get(4).getDate());\n\n            this.loanTransactionHelper.reverseLoanTransaction((long) loanID, loanDetails.getTransactions().get(1).getId(),\n                    new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"05 September 2022\")\n                            .transactionAmount(0.0).locale(\"en\"));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            assertEquals(210.0, loanDetails.getSummary().getTotalOutstanding());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n            assertTrue(loanDetails.getTransactions().get(2).getManuallyReversed());\n\n            assertEquals(10.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(10.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(2).getDate());\n            assertTrue(loanDetails.getTransactions().get(2).getManuallyReversed());\n\n            assertEquals(400.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(400.0, loanDetails.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 6), loanDetails.getTransactions().get(3).getDate());\n\n            assertEquals(390.0, loanDetails.getTransactions().get(4).getAmount());\n            assertEquals(390.0, loanDetails.getTransactions().get(4).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 7), loanDetails.getTransactions().get(4).getDate());\n\n            this.loanTransactionHelper.makeRepayment(\"04 September 2022\", Float.parseFloat(\"500\"), loanID);\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            assertEquals(290.0, loanDetails.getTotalOverpaid());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n            assertTrue(loanDetails.getTransactions().get(1).getManuallyReversed());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(2).getDate());\n\n            assertEquals(10.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(10.0, loanDetails.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(3).getDate());\n            assertTrue(loanDetails.getTransactions().get(3).getManuallyReversed());\n\n            assertEquals(400.0, loanDetails.getTransactions().get(4).getAmount());\n            assertEquals(400.0, loanDetails.getTransactions().get(4).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 6), loanDetails.getTransactions().get(4).getDate());\n\n            assertEquals(390.0, loanDetails.getTransactions().get(5).getAmount());\n            assertEquals(100.0, loanDetails.getTransactions().get(5).getPrincipalPortion());\n            assertEquals(290.0, loanDetails.getTransactions().get(5).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 7), loanDetails.getTransactions().get(5).getDate());\n        } finally {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, false);\n        }\n    } END"}
{"prompt":"test Credit Balance Refund After Maturity With Reverse Replay Of Repayments\n\n###\n\n","completion":"    @Test\n    public void testCreditBalanceRefundAfterMaturityWithReverseReplayOfRepayments() {\n        try {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, true);\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(this.requestSpec, this.responseSpec, true);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2022.10.10\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount,\n                    expenseAccount, overpaymentAccount);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            this.loanTransactionHelper.makeRepayment(\"04 September 2022\", Float.parseFloat(\"100\"), loanID);\n            this.loanTransactionHelper.makeRepayment(\"05 September 2022\", Float.parseFloat(\"1100\"), loanID);\n\n            GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(200.0, loanDetails.getTotalOverpaid());\n            assertTrue(loanDetails.getStatus().getOverpaid());\n\n            this.loanTransactionHelper.makeCreditBalanceRefund((long) loanID, new PostLoansLoanIdTransactionsRequest()\n                    .transactionAmount(200.0).transactionDate(\"10 October 2022\").dateFormat(\"dd MMMM yyyy\").locale(\"en\").paymentTypeId(1L));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            assertTrue(loanDetails.getStatus().getClosedObligationsMet());\n\n            assertEquals(2, loanDetails.getRepaymentSchedule().getPeriods().size());\n            assertEquals(1000, loanDetails.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n\n            assertEquals(100.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(100.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n            assertEquals(900.0, loanDetails.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(1100.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(900.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(200.0, loanDetails.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(2).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(2).getOutstandingLoanBalance());\n            assertEquals(200.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(200.0, loanDetails.getTransactions().get(3).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 10, 10), loanDetails.getTransactions().get(3).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(3).getOutstandingLoanBalance());\n            assertEquals(1L, loanDetails.getTransactions().get(3).getPaymentDetailData().getPaymentType().getId());\n            GetJournalEntriesTransactionIdResponse journalEntriesForTransaction = journalEntryHelper\n                    .getJournalEntries(\"L\" + loanDetails.getTransactions().get(3).getId());\n            List<JournalEntryTransactionItem> journalItems = journalEntriesForTransaction.getPageItems();\n            assertEquals(2, journalItems.size());\n            assertEquals(200.0,\n                    journalItems.stream()\n                            .filter(j -> \"DEBIT\".equalsIgnoreCase(j.getEntryType().getValue())\n                                    && j.getGlAccountId().equals(overpaymentAccount.getAccountID().longValue()))\n                            .findFirst().get().getAmount());\n            assertEquals(200.0, journalItems.stream().filter(j -> \"CREDIT\".equalsIgnoreCase(j.getEntryType().getValue())\n                    && j.getGlAccountId().equals(assetAccount.getAccountID().longValue())).findFirst().get().getAmount());\n\n            this.loanTransactionHelper.reverseLoanTransaction(loanDetails.getId(), loanDetails.getTransactions().get(1).getId(),\n                    new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\").transactionAmount(0.0)\n                            .transactionDate(\"10 October 2022\").locale(\"en\"));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            assertEquals(100.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(100.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n            assertTrue(loanDetails.getTransactions().get(1).getManuallyReversed());\n\n            assertEquals(1100.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(1000.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(100.0, loanDetails.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(2).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(2).getOutstandingLoanBalance());\n            assertEquals(1, loanDetails.getTransactions().get(2).getTransactionRelations().size());\n\n            assertEquals(200.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(100.0, loanDetails.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(100.0, loanDetails.getTransactions().get(3).getOverpaymentPortion());\n            assertEquals(100.0, loanDetails.getTransactions().get(3).getOutstandingLoanBalance());\n            assertEquals(LocalDate.of(2022, 10, 10), loanDetails.getTransactions().get(3).getDate());\n            assertEquals(1, loanDetails.getTransactions().get(3).getTransactionRelations().size());\n\n            assertTrue(loanDetails.getStatus().getActive());\n\n            assertEquals(3, loanDetails.getRepaymentSchedule().getPeriods().size());\n            assertEquals(1000, loanDetails.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertTrue(loanDetails.getRepaymentSchedule().getPeriods().get(1).getComplete());\n            assertEquals(200, loanDetails.getRepaymentSchedule().getPeriods().get(2).getPrincipalDue());\n            assertFalse(loanDetails.getRepaymentSchedule().getPeriods().get(2).getComplete());\n            assertEquals(100.0, loanDetails.getRepaymentSchedule().getPeriods().get(2).getPrincipalPaid());\n            assertEquals(100.0, loanDetails.getRepaymentSchedule().getPeriods().get(2).getPrincipalOutstanding());\n\n            journalEntriesForTransaction = journalEntryHelper.getJournalEntries(\"L\" + loanDetails.getTransactions().get(3).getId());\n            journalItems = journalEntriesForTransaction.getPageItems();\n            assertEquals(3, journalItems.size());\n            assertEquals(1,\n                    journalItems.stream().filter(item -> item.getAmount() == 200.0d)\n                            .filter(j -> \"CREDIT\".equalsIgnoreCase(j.getEntryType().getValue())\n                                    && j.getGlAccountId().equals(assetAccount.getAccountID().longValue()))\n                            .count());\n            assertEquals(1,\n                    journalItems.stream().filter(item -> item.getAmount() == 100.0d)\n                            .filter(j -> \"DEBIT\".equalsIgnoreCase(j.getEntryType().getValue())\n                                    && j.getGlAccountId().equals(overpaymentAccount.getAccountID().longValue()))\n                            .count());\n            assertEquals(1,\n                    journalItems.stream().filter(item -> item.getAmount() == 100.0d)\n                            .filter(j -> \"DEBIT\".equalsIgnoreCase(j.getEntryType().getValue())\n                                    && j.getGlAccountId().equals(assetAccount.getAccountID().longValue()))\n                            .count());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, false);\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(this.requestSpec, this.responseSpec, false);\n        }\n    } END"}
{"prompt":"test Credit Balance Refund Before Maturity With Reverse Replay Of Repayments And Refund\n\n###\n\n","completion":"    @Test\n    public void testCreditBalanceRefundBeforeMaturityWithReverseReplayOfRepaymentsAndRefund() {\n        try {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, true);\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(this.requestSpec, this.responseSpec, true);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2022.10.10\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount,\n                    expenseAccount, overpaymentAccount);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            this.loanTransactionHelper.makeRepayment(\"04 September 2022\", Float.parseFloat(\"500\"), loanID);\n            this.loanTransactionHelper.makeRepayment(\"05 September 2022\", Float.parseFloat(\"700\"), loanID);\n\n            GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(200.0, loanDetails.getTotalOverpaid());\n            assertTrue(loanDetails.getStatus().getOverpaid());\n\n            this.loanTransactionHelper.makeCreditBalanceRefund((long) loanID, new PostLoansLoanIdTransactionsRequest()\n                    .transactionAmount(200.0).transactionDate(\"06 September 2022\").dateFormat(\"dd MMMM yyyy\").locale(\"en\"));\n\n            this.loanTransactionHelper.makeMerchantIssuedRefund((long) loanID, new PostLoansLoanIdTransactionsRequest().locale(\"en\")\n                    .dateFormat(\"dd MMMM yyyy\").transactionDate(\"07 September 2022\").transactionAmount(500.0));\n\n            this.loanTransactionHelper.makeCreditBalanceRefund((long) loanID, new PostLoansLoanIdTransactionsRequest()\n                    .transactionAmount(500.0).transactionDate(\"08 September 2022\").dateFormat(\"dd MMMM yyyy\").locale(\"en\"));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            assertTrue(loanDetails.getStatus().getClosedObligationsMet());\n\n            assertEquals(2, loanDetails.getRepaymentSchedule().getPeriods().size());\n            assertEquals(1000, loanDetails.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getOutstandingLoanBalance());\n\n            assertEquals(700.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(200.0, loanDetails.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(2).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(2).getOutstandingLoanBalance());\n\n            assertEquals(200.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(200.0, loanDetails.getTransactions().get(3).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 6), loanDetails.getTransactions().get(3).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(3).getOutstandingLoanBalance());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(4).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(4).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 7), loanDetails.getTransactions().get(4).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(4).getOutstandingLoanBalance());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(5).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(5).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 8), loanDetails.getTransactions().get(5).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(5).getOutstandingLoanBalance());\n\n            this.loanTransactionHelper.reverseLoanTransaction(loanDetails.getId(), loanDetails.getTransactions().get(2).getId(),\n                    new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\").transactionAmount(0.0)\n                            .transactionDate(\"07 September 2022\").locale(\"en\"));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getOutstandingLoanBalance());\n\n            assertEquals(700.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(200.0, loanDetails.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(2).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(2).getOutstandingLoanBalance());\n            assertTrue(loanDetails.getTransactions().get(2).getManuallyReversed());\n\n            assertEquals(200.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(200.0, loanDetails.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 6), loanDetails.getTransactions().get(3).getDate());\n            assertEquals(700.0, loanDetails.getTransactions().get(3).getOutstandingLoanBalance());\n            assertEquals(1, loanDetails.getTransactions().get(3).getTransactionRelations().size());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(4).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(4).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 7), loanDetails.getTransactions().get(4).getDate());\n            assertEquals(200.0, loanDetails.getTransactions().get(4).getOutstandingLoanBalance());\n            assertEquals(1, loanDetails.getTransactions().get(4).getTransactionRelations().size());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(5).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(5).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 8), loanDetails.getTransactions().get(5).getDate());\n            assertEquals(700.0, loanDetails.getTransactions().get(5).getOutstandingLoanBalance());\n            assertEquals(1, loanDetails.getTransactions().get(5).getTransactionRelations().size());\n\n            assertTrue(loanDetails.getStatus().getActive());\n\n            assertEquals(2, loanDetails.getRepaymentSchedule().getPeriods().size());\n            assertEquals(1700, loanDetails.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertFalse(loanDetails.getRepaymentSchedule().getPeriods().get(1).getComplete());\n            assertEquals(1000.0, loanDetails.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(700.0, loanDetails.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, false);\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(this.requestSpec, this.responseSpec, false);\n        }\n    } END"}
{"prompt":"accrual Is Calculated When The Loan Is Closed\n\n###\n\n","completion":"    @Test\n    public void accrualIsCalculatedWhenTheLoanIsClosed() {\n        try {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, true);\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(this.requestSpec, this.responseSpec, true);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2022.10.10\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount,\n                    expenseAccount, overpaymentAccount);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n            List<HashMap> charges = new ArrayList<>();\n            Integer installmentFee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n            addCharges(charges, installmentFee, \"10\", null);\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges);\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            this.loanTransactionHelper.makeRepayment(\"04 September 2022\", Float.parseFloat(\"5\"), loanID);\n\n            this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(\"04 September 2022\");\n\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"11\", true));\n            LocalDate targetDate = LocalDate.of(2022, 9, 6);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"11\"));\n\n            this.loanTransactionHelper.waiveLoanCharge((long) loanID, (long) penalty1LoanChargeId,\n                    new PostLoansLoanIdChargesChargeIdRequest());\n\n            this.loanTransactionHelper.makeRepayment(\"08 September 2022\", Float.parseFloat(\"1010\"), loanID);\n\n            GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            GetLoansLoanIdTransactions lastAccrualTransaction = loanDetails.getTransactions().stream()\n                    .filter(t -> Boolean.TRUE.equals(t.getType().getAccrual())).findFirst().get();\n            assertEquals(15, lastAccrualTransaction.getAmount());\n            assertEquals(5, lastAccrualTransaction.getPenaltyChargesPortion());\n            assertEquals(10, lastAccrualTransaction.getFeeChargesPortion());\n\n            GetLoansLoanIdTransactionsTransactionIdResponse accrualTransactionDetails = this.loanTransactionHelper\n                    .getLoanTransactionDetails((long) loanID, lastAccrualTransaction.getId());\n\n            assertEquals(2, accrualTransactionDetails.getLoanChargePaidByList().size());\n            accrualTransactionDetails.getLoanChargePaidByList().forEach(loanCharge -> {\n                if (loanCharge.getChargeId().equals((long) penalty1LoanChargeId)) {\n                    assertEquals(5, loanCharge.getAmount());\n                } else {\n                    assertEquals(10, loanCharge.getAmount());\n                }\n            });\n\n        } finally {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, false);\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(this.requestSpec, this.responseSpec, false);\n        }\n    } END"}
{"prompt":"check That All Multi Disbursals Appear On Loan Schedule And Out Standing Balance Is Zero Test\n\n###\n\n","completion":"    @Test\n    public void checkThatAllMultiDisbursalsAppearOnLoanScheduleAndOutStandingBalanceIsZeroTest() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        \/***\n         * Create loan product with allowing multiple disbursals\n         *\/\n        boolean allowMultipleDisbursals = true;\n        final Integer loanProductID = createLoanProduct(allowMultipleDisbursals);\n        Assertions.assertNotNull(loanProductID);\n\n        \/***\n         * Apply for loan application and verify loan status\n         *\/\n        final String savingsId = null;\n        final String principal = \"12,000.00\";\n\n        LOG.info(\"-----------------------------------10 Tranches--------------------------------------\");\n        List<HashMap> tranches = new ArrayList<>();\n        tranches.add(createTrancheDetail(\"01 January 2021\", \"1\"));\n        tranches.add(createTrancheDetail(\"02 January 2021\", \"2\"));\n        tranches.add(createTrancheDetail(\"03 January 2021\", \"4\"));\n        tranches.add(createTrancheDetail(\"04 January 2021\", \"8\"));\n        tranches.add(createTrancheDetail(\"05 January 2021\", \"16\"));\n        tranches.add(createTrancheDetail(\"06 January 2021\", \"32\"));\n        tranches.add(createTrancheDetail(\"07 January 2021\", \"64\"));\n        tranches.add(createTrancheDetail(\"08 January 2021\", \"128\"));\n        tranches.add(createTrancheDetail(\"09 January 2021\", \"256\"));\n        tranches.add(createTrancheDetail(\"10 January 2021\", \"512\"));\n        String submitDate = \"01 January 2021\";\n\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, savingsId, principal, tranches, submitDate);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 January 2021\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE 8 LOANS -------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"12 January 2021\", loanID, \"1\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"12 January 2021\", loanID, \"2\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"12 January 2021\", loanID, \"4\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"13 January 2021\", loanID, \"8\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"14 January 2021\", loanID, \"16\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"14 January 2021\", loanID, \"32\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"15 January 2021\", loanID, \"64\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"15 January 2021\", loanID, \"128\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        final int loanScheduleLineCount = loanSchedule.size();\n        final int expectedLoanScheduleLineCount = 9;\n        final int expectedDisbursals = 8;\n        final BigDecimal val255 = BigDecimal.valueOf(255.0);\n        final BigDecimal expectedTotalPrincipalDisbursed = val255;\n        final BigDecimal expectedPrincipalDue = val255;\n        final BigDecimal expectedPrincipalLoanBalanceOutstanding = BigDecimal.valueOf(0.0);\n\n        assertEquals(expectedLoanScheduleLineCount, loanScheduleLineCount, \"Checking nine lines in schedule\");\n\n        int disbursalCount = 0;\n        BigDecimal totalPrincipalDisbursed = BigDecimal.ZERO;\n        \/\/ First 8 lines should be disbursals\n        for (int i = 0; i < loanScheduleLineCount - 1; i++) {\n            final Integer period = (Integer) loanSchedule.get(i).get(\"period\");\n            final BigDecimal principalDisbursed = BigDecimal\n                    .valueOf(Double.parseDouble(loanSchedule.get(i).get(\"principalDisbursed\").toString()));\n\n            if (period == null) {\n                disbursalCount += 1;\n                totalPrincipalDisbursed = totalPrincipalDisbursed.add(principalDisbursed);\n            }\n        }\n        assertEquals(expectedDisbursals, disbursalCount, \"Checking for eight disbursals\");\n        assertEquals(expectedTotalPrincipalDisbursed, totalPrincipalDisbursed, \"Checking Principal Disburse is 255\");\n\n        final BigDecimal principalDue = BigDecimal.valueOf(Double.parseDouble(loanSchedule.get(8).get(\"principalDue\").toString()));\n        assertEquals(expectedPrincipalDue, principalDue, \"Checking Principal Due is 255\");\n\n        final BigDecimal principalLoanBalanceOutstanding = BigDecimal\n                .valueOf(Double.parseDouble(loanSchedule.get(8).get(\"principalLoanBalanceOutstanding\").toString()));\n        assertEquals(expectedPrincipalLoanBalanceOutstanding, principalLoanBalanceOutstanding,\n                \"Checking Principal Loan Balance Outstanding is zero\");\n\n    } END"}
{"prompt":"check That All Multi Disbursals Appear On Loan Schedule And Out Standing Balance Is Zero But Loan Got Reopened Test\n\n###\n\n","completion":"    @Test\n    public void checkThatAllMultiDisbursalsAppearOnLoanScheduleAndOutStandingBalanceIsZeroButLoanGotReopenedTest() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        \/***\n         * Create loan product with allowing multiple disbursals\n         *\/\n        boolean allowMultipleDisbursals = true;\n        final Integer loanProductID = createLoanProduct(allowMultipleDisbursals);\n        Assertions.assertNotNull(loanProductID);\n\n        \/***\n         * Apply for loan application and verify loan status\n         *\/\n        final String savingsId = null;\n        final String principal = \"12,000.00\";\n\n        LOG.info(\"-----------------------------------2 Tranches--------------------------------------\");\n        List<HashMap> tranches = new ArrayList<>();\n        tranches.add(createTrancheDetail(\"01 January 2021\", \"1\"));\n        tranches.add(createTrancheDetail(\"02 January 2021\", \"2\"));\n        String submitDate = \"01 January 2021\";\n\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, savingsId, principal, tranches, submitDate);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 January 2021\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\n                \"-------------------------------DISBURSE 1, repay fully, disburse again LOANS -------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithTransactionAmount(\"12 January 2021\", loanID, \"1\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        HashMap repaymentDetails = this.loanTransactionHelper.makeRepayment(\"13 January 2021\", 1.0f, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"status\");\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithTransactionAmount(\"14 January 2021\", loanID, \"2\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        final int loanScheduleLineCount = loanSchedule.size();\n        final int expectedLoanScheduleLineCount = 3;\n        final int expectedDisbursals = 2;\n        final BigDecimal expectedTotalPrincipalDisbursed = BigDecimal.valueOf(3.0);\n        final BigDecimal expectedPrincipalDue = BigDecimal.valueOf(3.0);\n        final BigDecimal expectedPrincipalPaid = BigDecimal.valueOf(1.0);\n        final BigDecimal expectedPrincipalOutstanding = BigDecimal.valueOf(2.0);\n        final BigDecimal expectedPrincipalLoanBalanceOutstanding = BigDecimal.valueOf(0.0);\n\n        assertEquals(expectedLoanScheduleLineCount, loanScheduleLineCount, \"Checking 3 lines in schedule\");\n\n        int disbursalCount = 0;\n        BigDecimal totalPrincipalDisbursed = BigDecimal.ZERO;\n        \/\/ First 8 lines should be disbursals\n        for (int i = 0; i < loanScheduleLineCount - 1; i++) {\n            final Integer period = (Integer) loanSchedule.get(i).get(\"period\");\n            final BigDecimal principalDisbursed = BigDecimal\n                    .valueOf(Double.parseDouble(loanSchedule.get(i).get(\"principalDisbursed\").toString()));\n\n            if (period == null) {\n                disbursalCount += 1;\n                totalPrincipalDisbursed = totalPrincipalDisbursed.add(principalDisbursed);\n            }\n            \/\/ LOG.info(loanSchedule.get(i).toString());\n        }\n        assertEquals(expectedDisbursals, disbursalCount, \"Checking for 2 disbursals\");\n        assertEquals(expectedTotalPrincipalDisbursed, totalPrincipalDisbursed, \"Checking Principal Disburse is 3\");\n\n        final BigDecimal principalDue = BigDecimal.valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalDue\").toString()));\n        assertEquals(expectedPrincipalDue, principalDue, \"Checking Principal Due is 3\");\n        final BigDecimal principalPaid = BigDecimal.valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalPaid\").toString()));\n        assertEquals(expectedPrincipalPaid, principalPaid, \"Checking Principal Paid is 1\");\n        final BigDecimal principalOutstanding = BigDecimal\n                .valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalOutstanding\").toString()));\n        assertEquals(expectedPrincipalOutstanding, principalOutstanding, \"Checking Principal Due is 2\");\n\n        final BigDecimal principalLoanBalanceOutstanding = BigDecimal\n                .valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalLoanBalanceOutstanding\").toString()));\n        assertEquals(expectedPrincipalLoanBalanceOutstanding, principalLoanBalanceOutstanding,\n                \"Checking Principal Loan Balance Outstanding is zero\");\n\n    } END"}
{"prompt":"check That All Multi Disbursals Appear On Loan Schedule And Out Standing Balance Is Zero But Loan Got Reopened From Over Paid Test\n\n###\n\n","completion":"    @Test\n    public void checkThatAllMultiDisbursalsAppearOnLoanScheduleAndOutStandingBalanceIsZeroButLoanGotReopenedFromOverPaidTest() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        \/***\n         * Create loan product with allowing multiple disbursals\n         *\/\n        boolean allowMultipleDisbursals = true;\n        final Integer loanProductID = createLoanProduct(allowMultipleDisbursals);\n        Assertions.assertNotNull(loanProductID);\n\n        \/***\n         * Apply for loan application and verify loan status\n         *\/\n        final String savingsId = null;\n        final String principal = \"12,000.00\";\n\n        LOG.info(\"-----------------------------------2 Tranches--------------------------------------\");\n        List<HashMap> tranches = new ArrayList<>();\n        tranches.add(createTrancheDetail(\"01 January 2021\", \"1\"));\n        tranches.add(createTrancheDetail(\"02 January 2021\", \"2\"));\n        String submitDate = \"01 January 2021\";\n\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, savingsId, principal, tranches, submitDate);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 January 2021\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\n                \"-------------------------------DISBURSE 1, repay fully, disburse again LOANS -------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithTransactionAmount(\"12 January 2021\", loanID, \"1\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        HashMap repaymentDetails = this.loanTransactionHelper.makeRepayment(\"13 January 2021\", 2.0f, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"status\");\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithTransactionAmount(\"14 January 2021\", loanID, \"2\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        final int loanScheduleLineCount = loanSchedule.size();\n        final int expectedLoanScheduleLineCount = 3;\n        final int expectedDisbursals = 2;\n        final BigDecimal expectedTotalPrincipalDisbursed = BigDecimal.valueOf(3.0);\n        final BigDecimal expectedPrincipalDue = BigDecimal.valueOf(3.0);\n        final BigDecimal expectedPrincipalPaid = BigDecimal.valueOf(2.0);\n        final BigDecimal expectedPrincipalOutstanding = BigDecimal.valueOf(1.0);\n        final BigDecimal expectedPrincipalLoanBalanceOutstanding = BigDecimal.valueOf(0.0);\n\n        assertEquals(expectedLoanScheduleLineCount, loanScheduleLineCount, \"Checking nine lines in schedule\");\n\n        int disbursalCount = 0;\n        BigDecimal totalPrincipalDisbursed = BigDecimal.ZERO;\n        \/\/ First 8 lines should be disbursals\n        for (int i = 0; i < loanScheduleLineCount - 1; i++) {\n            final Integer period = (Integer) loanSchedule.get(i).get(\"period\");\n            final BigDecimal principalDisbursed = BigDecimal\n                    .valueOf(Double.parseDouble(loanSchedule.get(i).get(\"principalDisbursed\").toString()));\n\n            if (period == null) {\n                disbursalCount += 1;\n                totalPrincipalDisbursed = totalPrincipalDisbursed.add(principalDisbursed);\n            }\n            \/\/ LOG.info(loanSchedule.get(i).toString());\n        }\n        assertEquals(expectedDisbursals, disbursalCount, \"Checking for 2 disbursals\");\n        assertEquals(expectedTotalPrincipalDisbursed, totalPrincipalDisbursed, \"Checking Principal Disburse is 3\");\n\n        final BigDecimal principalDue = BigDecimal.valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalDue\").toString()));\n        assertEquals(expectedPrincipalDue, principalDue, \"Checking Principal Due is 3\");\n        final BigDecimal principalPaid = BigDecimal.valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalPaid\").toString()));\n        assertEquals(expectedPrincipalPaid, principalPaid, \"Checking Principal Paid is 1\");\n        final BigDecimal principalOutstanding = BigDecimal\n                .valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalOutstanding\").toString()));\n        assertEquals(expectedPrincipalOutstanding, principalOutstanding, \"Checking Principal Due is 2\");\n\n        final BigDecimal principalLoanBalanceOutstanding = BigDecimal\n                .valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalLoanBalanceOutstanding\").toString()));\n        assertEquals(expectedPrincipalLoanBalanceOutstanding, principalLoanBalanceOutstanding,\n                \"Checking Principal Loan Balance Outstanding is zero\");\n\n    } END"}
{"prompt":"check That Non Tranche Multi Disbursals Create ASchedule On First Disbursal Test\n\n###\n\n","completion":"    @Test\n    public void checkThatNonTrancheMultiDisbursalsCreateAScheduleOnFirstDisbursalTest() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        \/***\n         * Create loan product allowing non-tranche multiple disbursals with interest recalculation\n         *\/\n        boolean isInterestRecalculationEnabled = true;\n        final Integer loanProductID = createLoanProduct(isInterestRecalculationEnabled);\n        Assertions.assertNotNull(loanProductID);\n\n        \/***\n         * Apply for loan application and verify loan status\n         *\/\n        final String savingsId = null;\n        String submitDate = \"01 January 2021\";\n        Integer repaymentsNo = 3;\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, savingsId, APPLIED_FOR_PRINCIPAL, submitDate,\n                repaymentsNo.toString());\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        final Float approved = 9000.00f;\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(submitDate, null, approved.toString(), loanID, null);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n\n        LOG.info(\"-------------------------------DISBURSE non-tranch multi-disbursal loan       ----------\");\n        final String netDisbursedAmt = null;\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithTransactionAmount(submitDate, loanID, approved.toString());\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        Assertions.assertNotNull(getLoansLoanIdResponse);\n\n        this.loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        Integer loanScheduleLineCount = loanSchedule.size() - 1;\n        Assertions.assertEquals(repaymentsNo, loanScheduleLineCount);\n\n        HashMap loanSummary = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, loanID);\n        Assertions.assertEquals(approved, loanSummary.get(\"principalDisbursed\"));\n        Assertions.assertEquals(approved, loanSummary.get(\"principalOutstanding\"));\n\n        LOG.info(\"------------------------------- 2nd DISBURSE non-tranch multi-disbursal loan       ----------\");\n        final Float anotherDisbursalAmount = 900.00f;\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(submitDate, loanID,\n                anotherDisbursalAmount.toString(), netDisbursedAmt);\n\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanScheduleLineCount = loanSchedule.size() - 2;\n        Assertions.assertEquals(repaymentsNo, loanScheduleLineCount);\n\n        loanSummary = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, loanID);\n        Float disbursedSum = approved + anotherDisbursalAmount;\n        Assertions.assertEquals(disbursedSum, loanSummary.get(\"principalDisbursed\"));\n        Assertions.assertEquals(disbursedSum, loanSummary.get(\"principalOutstanding\"));\n\n        LOG.info(\"------------------------------- 3rd DISBURSE non-tranch multi-disbursal loan       ----------\");\n        final Float thirdDisbursalAmount = 500.00f;\n        String thirdDisbursalDate = \"03 February 2021\";\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(thirdDisbursalDate, loanID,\n                thirdDisbursalAmount.toString(), netDisbursedAmt);\n\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanScheduleLineCount = loanSchedule.size() - 3;\n        Assertions.assertEquals(repaymentsNo, loanScheduleLineCount);\n\n        loanSummary = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, loanID);\n        disbursedSum = disbursedSum + thirdDisbursalAmount;\n        Assertions.assertEquals(disbursedSum, loanSummary.get(\"principalDisbursed\"));\n        Assertions.assertEquals(disbursedSum, loanSummary.get(\"principalOutstanding\"));\n\n    } END"}
{"prompt":"check That Non Tranche Multi Disbursals Create ASchedule On Submit And Approval Test\n\n###\n\n","completion":"    @Test\n    public void checkThatNonTrancheMultiDisbursalsCreateAScheduleOnSubmitAndApprovalTest() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        \/***\n         * Create loan product allowing non-tranche multiple disbursals with interest recalculation\n         *\/\n        boolean isInterestRecalculationEnabled = true;\n        final Integer loanProductID = createLoanProduct(isInterestRecalculationEnabled);\n        Assertions.assertNotNull(loanProductID);\n\n        \/***\n         * Apply for loan application and verify loan status\n         *\/\n        final String savingsId = null;\n        String submitDate = \"01 January 2022\";\n        Integer repaymentsNo = 3;\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, savingsId, APPLIED_FOR_PRINCIPAL, submitDate,\n                repaymentsNo.toString());\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        Integer loanScheduleLineCount = loanSchedule.size() - 1; \/\/ exclude disbursement line\n        Assertions.assertEquals(repaymentsNo, loanScheduleLineCount);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        final Float approved = 9000.00f;\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(submitDate, null, approved.toString(), loanID, null);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanScheduleLineCount = loanSchedule.size() - 1;\n        Assertions.assertEquals(repaymentsNo, loanScheduleLineCount);\n\n    } END"}
{"prompt":"test Savings Account\n\n###\n\n","completion":"    @Test\n    public void testSavingsAccount() {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(groupID, savingsProductID, savingsId, ACCOUNT_TYPE_GROUP);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Assertions.assertFalse(summaryBefore.equals(summary));\n\n        final Object savingsInterest = this.savingsAccountHelper.getSavingsInterest(savingsId);\n\n    } END"}
{"prompt":"test Savings Last Transaction And Running Balance Update\n\n###\n\n","completion":"    @Test\n    public void testSavingsLastTransactionAndRunningBalanceUpdate() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n\n        HashMap summaryAfterPosting = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Assertions.assertNotNull(summaryAfterPosting.get(\"interestPostedTillDate\"));\n    } END"}
{"prompt":"test Savings Backed Dated Transactions Not Allowed\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsBackedDatedTransactionsNotAllowed() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n\n        HashMap summaryAfterPosting = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Assertions.assertNotNull(summaryAfterPosting.get(\"interestPostedTillDate\"));\n\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"38\", false);\n\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        SimpleDateFormat sdf = new SimpleDateFormat(CommonConstants.DATE_FORMAT, Locale.US);\n        Calendar cal = Calendar.getInstance();\n        List dates = (List) summaryAfterPosting.get(\"interestPostedTillDate\");\n        cal.set(Calendar.YEAR, (Integer) dates.get(0));\n        cal.set(Calendar.MONTH, (Integer) dates.get(1) - 1);\n        cal.set(Calendar.DAY_OF_MONTH, (Integer) dates.get(2) - 1);\n        final String depositDate = sdf.format(cal.getTime());\n        LOG.info(\"-------------------- BackDated Transaction -----------------------------\");\n        List<HashMap> error = (List<HashMap>) validationErrorHelper.depositToSavingsAccount(savingsId, \"3000\", depositDate,\n                CommonConstants.RESPONSE_ERROR);\n\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"38\", true);\n\n        \/\/ LOG.info(savingsAccountErrorData.get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE).toString());\n        assertEquals(\"error.msg.savings.transaction.is.not.allowed\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    } END"}
{"prompt":"test Savings Account With Min Balance For Interest Calculation\n\n###\n\n","completion":"    @Test\n    public void testSavingsAccountWithMinBalanceForInterestCalculation() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = \"5000\";\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        \/\/ These two fields are getting updated after an interest posting\n        summary.remove(\"interestPostedTillDate\");\n\n        assertEquals(summaryBefore, summary);\n\n        final Object savingsInterest = this.savingsAccountHelper.getSavingsInterest(savingsId);\n        Assertions.assertNull(savingsInterest);\n\n    } END"}
{"prompt":"test Savings Account CLOSE APPLICATION\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccount_CLOSE_APPLICATION() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"1000.0\";\n        final String enforceMinRequiredBalance = \"true\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        final String CLOSEDON_DATE = dateFormat.format(todaysDate.getTime());\n        String withdrawBalance = \"false\";\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper\n                .closeSavingsAccountAndGetBackRequiredField(savingsId, withdrawBalance, CommonConstants.RESPONSE_ERROR, CLOSEDON_DATE);\n        assertEquals(\"validation.msg.savingsaccount.close.results.in.balance.not.zero\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        withdrawBalance = \"true\";\n        savingsStatusHashMap = this.savingsAccountHelper.closeSavingsAccount(savingsId, withdrawBalance);\n        SavingsStatusChecker.verifySavingsAccountIsClosed(savingsStatusHashMap);\n\n    } END"}
{"prompt":"test Savings Account WITH ENFORCE MIN BALANCE\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccount_WITH_ENFORCE_MIN_BALANCE() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"1500.0\";\n        final String openningBalance = \"1600\";\n        final String enforceMinRequiredBalance = \"true\";\n        final boolean allowOverdraft = false;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, openningBalance,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        final Integer savingsActivationChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsActivationFeeJSON());\n        Assertions.assertNotNull(savingsActivationChargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, savingsActivationChargeId, true);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(openningBalance);\n        Float chargeAmt = 100f;\n        balance -= chargeAmt;\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate.getTime());\n        final String withdrawAmt = \"800\";\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper.withdrawalFromSavingsAccount(savingsId,\n                withdrawAmt, TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n        assertEquals(balance, depositTransaction.get(\"runningBalance\"), \"Verifying Balance after Deposit\");\n\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, withdrawAmt,\n                TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(withdrawAmt);\n        assertEquals(Float.parseFloat(withdrawAmt), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n        assertEquals(balance, withdrawTransaction.get(\"runningBalance\"), \"Verifying Balance after Withdrawal\");\n    } END"}
{"prompt":"test Savings Account DELETE APPLICATION\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccount_DELETE_APPLICATION() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        List<HashMap> error1 = (List<HashMap>) savingsAccountHelperValidationError.deleteSavingsApplication(savingsId,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"validation.msg.savingsaccount.delete.not.in.submittedandpendingapproval.state\",\n                error1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        savingsStatusHashMap = this.savingsAccountHelper.undoApproval(savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        this.savingsAccountHelper.deleteSavingsApplication(savingsId, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        List<HashMap> error = savingsAccountHelperValidationError.getSavingsCollectionAttribute(savingsId, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.saving.account.id.invalid\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    } END"}
{"prompt":"test Savings Account REJECT APPLICATION\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccount_REJECT_APPLICATION() {\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        List<HashMap> error1 = savingsAccountHelperValidationError.rejectApplicationWithErrorCode(savingsId,\n                SavingsAccountHelper.CREATED_DATE_PLUS_ONE);\n        assertEquals(\"validation.msg.savingsaccount.reject.not.in.submittedandpendingapproval.state\",\n                error1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        savingsStatusHashMap = this.savingsAccountHelper.undoApproval(savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        error1 = savingsAccountHelperValidationError.rejectApplicationWithErrorCode(savingsId, SavingsAccountHelper.getFutureDate());\n        assertEquals(\"validation.msg.savingsaccount.reject.cannot.be.a.future.date\",\n                error1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error1 = savingsAccountHelperValidationError.rejectApplicationWithErrorCode(savingsId, SavingsAccountHelper.CREATED_DATE_MINUS_ONE);\n        assertEquals(\"validation.msg.savingsaccount.reject.cannot.be.before.submittal.date\",\n                error1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        savingsStatusHashMap = this.savingsAccountHelper.rejectApplication(savingsId);\n        SavingsStatusChecker.verifySavingsIsRejected(savingsStatusHashMap);\n\n    } END"}
{"prompt":"test Savings Account WITHDRAW APPLICATION\n\n###\n\n","completion":"    @Test\n    public void testSavingsAccount_WITHDRAW_APPLICATION() {\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.withdrawApplication(savingsId);\n        SavingsStatusChecker.verifySavingsIsWithdrawn(savingsStatusHashMap);\n\n    } END"}
{"prompt":"test Savings Account Transactions\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountTransactions() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        List<HashMap> error = (List) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"100\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.account.is.not.active\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error = (List) savingsAccountHelperValidationError.depositToSavingsAccount(savingsId, \"100\", SavingsAccountHelper.TRANSACTION_DATE,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.account.is.not.active\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.valueOf(MINIMUM_OPENING_BALANCE);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.valueOf(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n        assertEquals(balance, depositTransaction.get(\"runningBalance\"), \"Verifying Balance after Deposit\");\n\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, WITHDRAW_AMOUNT,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(WITHDRAW_AMOUNT);\n        assertEquals(Float.valueOf(WITHDRAW_AMOUNT), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n        assertEquals(balance, withdrawTransaction.get(\"runningBalance\"), \"Verifying Balance after Withdrawal\");\n\n        Integer newWithdrawTransactionId = this.savingsAccountHelper.updateSavingsAccountTransaction(savingsId, withdrawTransactionId,\n                WITHDRAW_AMOUNT_ADJUSTED);\n        HashMap newWithdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, newWithdrawTransactionId);\n        balance = balance + Float.parseFloat(WITHDRAW_AMOUNT) - Float.parseFloat(WITHDRAW_AMOUNT_ADJUSTED);\n        assertEquals(Float.valueOf(WITHDRAW_AMOUNT_ADJUSTED), newWithdrawTransaction.get(\"amount\"), \"Verifying adjusted Amount\");\n        assertEquals(balance, newWithdrawTransaction.get(\"runningBalance\"), \"Verifying Balance after adjust\");\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Adjusted Balance\");\n        withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        Assertions.assertTrue((Boolean) withdrawTransaction.get(\"reversed\"));\n\n        this.savingsAccountHelper.undoSavingsAccountTransaction(savingsId, newWithdrawTransactionId);\n        newWithdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        Assertions.assertTrue((Boolean) newWithdrawTransaction.get(\"reversed\"));\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        balance += Float.parseFloat(WITHDRAW_AMOUNT_ADJUSTED);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance After Undo Transaction\");\n\n        error = (List) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"5000\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error = (List) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"5000\",\n                SavingsAccountHelper.getFutureDate(), CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.in.the.future\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error = (List) savingsAccountHelperValidationError.depositToSavingsAccount(savingsId, \"5000\", SavingsAccountHelper.getFutureDate(),\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.in.the.future\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error = (List) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"5000\",\n                SavingsAccountHelper.CREATED_DATE_MINUS_ONE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.before.activation.date\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error = (List) savingsAccountHelperValidationError.depositToSavingsAccount(savingsId, \"5000\",\n                SavingsAccountHelper.CREATED_DATE_MINUS_ONE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.before.activation.date\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    } END"}
{"prompt":"test Savings Account Charges\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountCharges() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        final Integer withdrawalChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsWithdrawalFeeJSON());\n        Assertions.assertNotNull(withdrawalChargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, withdrawalChargeId, false);\n        ArrayList<HashMap> chargesPendingState = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertEquals(1, chargesPendingState.size());\n\n        Integer savingsChargeId = (Integer) chargesPendingState.get(0).get(\"id\");\n        HashMap chargeChanges = this.savingsAccountHelper.updateCharges(savingsChargeId, savingsId);\n        Assertions.assertTrue(chargeChanges.containsKey(\"amount\"));\n\n        Integer deletedChargeId = this.savingsAccountHelper.deleteCharge(savingsChargeId, savingsId);\n        assertEquals(savingsChargeId, deletedChargeId);\n\n        chargesPendingState = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertTrue(chargesPendingState == null || chargesPendingState.size() == 0);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final Integer chargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec, ChargesHelper.getSavingsAnnualFeeJSON());\n        Assertions.assertNotNull(chargeId);\n\n        ArrayList<HashMap> charges = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertTrue(charges == null || charges.size() == 0);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, chargeId, true);\n        charges = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertEquals(1, charges.size());\n\n        HashMap savingsChargeForPay = charges.get(0);\n        SimpleDateFormat sdf = new SimpleDateFormat(CommonConstants.DATE_FORMAT, Locale.US);\n        Calendar cal = Calendar.getInstance();\n        List dates = (List) savingsChargeForPay.get(\"dueDate\");\n        cal.set(Calendar.YEAR, (Integer) dates.get(0));\n        cal.set(Calendar.MONTH, (Integer) dates.get(1) - 1);\n        cal.set(Calendar.DAY_OF_MONTH, (Integer) dates.get(2));\n\n        this.savingsAccountHelper.payCharge((Integer) savingsChargeForPay.get(\"id\"), savingsId,\n                ((Float) savingsChargeForPay.get(\"amount\")).toString(), sdf.format(cal.getTime()));\n        HashMap paidCharge = this.savingsAccountHelper.getSavingsCharge(savingsId, (Integer) savingsChargeForPay.get(\"id\"));\n        assertEquals(savingsChargeForPay.get(\"amount\"), paidCharge.get(\"amountPaid\"));\n\n        final Integer monthlyFeechargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsMonthlyFeeJSON());\n        Assertions.assertNotNull(monthlyFeechargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, monthlyFeechargeId, true);\n        charges = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertEquals(2, charges.size());\n\n        HashMap savingsChargeForWaive = charges.get(1);\n        this.savingsAccountHelper.waiveCharge((Integer) savingsChargeForWaive.get(\"id\"), savingsId);\n        HashMap waiveCharge = this.savingsAccountHelper.getSavingsCharge(savingsId, (Integer) savingsChargeForWaive.get(\"id\"));\n        assertEquals(savingsChargeForWaive.get(\"amount\"), waiveCharge.get(\"amountWaived\"));\n\n        this.savingsAccountHelper.waiveCharge((Integer) savingsChargeForWaive.get(\"id\"), savingsId);\n        waiveCharge = this.savingsAccountHelper.getSavingsCharge(savingsId, (Integer) savingsChargeForWaive.get(\"id\"));\n        BigDecimal totalWaiveAmount = BigDecimal.valueOf(Double.valueOf((Float) savingsChargeForWaive.get(\"amount\")));\n        totalWaiveAmount = totalWaiveAmount.add(totalWaiveAmount);\n        assertEquals(totalWaiveAmount.floatValue(), waiveCharge.get(\"amountWaived\"));\n\n        final Integer weeklyFeeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsWeeklyFeeJSON());\n        Assertions.assertNotNull(weeklyFeeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, weeklyFeeId, true);\n        charges = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertEquals(3, charges.size());\n\n        savingsChargeForPay = charges.get(2);\n        cal = Calendar.getInstance();\n        dates = (List) savingsChargeForPay.get(\"dueDate\");\n        cal.set(Calendar.YEAR, (Integer) dates.get(0));\n        cal.set(Calendar.MONTH, (Integer) dates.get(1) - 1);\n        cal.set(Calendar.DAY_OF_MONTH, (Integer) dates.get(2));\n\n        \/\/ Depositing huge amount as scheduler job deducts the fee amount\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"100000\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(depositTransactionId);\n\n        this.savingsAccountHelper.payCharge((Integer) savingsChargeForPay.get(\"id\"), savingsId,\n                ((Float) savingsChargeForPay.get(\"amount\")).toString(), sdf.format(cal.getTime()));\n        paidCharge = this.savingsAccountHelper.getSavingsCharge(savingsId, (Integer) savingsChargeForPay.get(\"id\"));\n        assertEquals(savingsChargeForPay.get(\"amount\"), paidCharge.get(\"amountPaid\"));\n        List nextDueDates = (List) paidCharge.get(\"dueDate\");\n        LocalDate nextDueDate = LocalDate.of((Integer) nextDueDates.get(0), (Integer) nextDueDates.get(1), (Integer) nextDueDates.get(2));\n        LocalDate expectedNextDueDate = LocalDate.of((Integer) dates.get(0), (Integer) dates.get(1), (Integer) dates.get(2))\n                .plusWeeks((Integer) paidCharge.get(\"feeInterval\"));\n        assertEquals(expectedNextDueDate, nextDueDate);\n\n        this.savingsAccountHelper.closeSavingsAccountAndGetBackRequiredField(savingsId, \"true\", null,\n                Utils.getLocalDateOfTenant().format(Utils.dateFormatter));\n\n    } END"}
{"prompt":"test Savings Account With Overdraft\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountWithOverdraft() {\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        \/***\n         * Create a client to apply for savings account (overdraft account).\n         *\/\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n\n        \/***\n         * Create savings product with zero opening balance and overdraft enabled\n         *\/\n        final String zeroOpeningBalance = \"0.0\";\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = true;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, zeroOpeningBalance,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        \/***\n         * Apply for Savings account\n         *\/\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        \/***\n         * Approve the savings account\n         *\/\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n        todaysDate = todaysDate.withDayOfMonth(1);\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n        final Integer lastDayOfMonth = todaysDate.lengthOfMonth();\n        todaysDate = todaysDate.withDayOfMonth(lastDayOfMonth);\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate);\n\n        \/***\n         * Activate the application and verify account status\n         *\n         * @param activationDate\n         *            this value is every time first day of previous month\n         *\/\n        savingsStatusHashMap = activateSavingsAccount(savingsId, ACTIVATION_DATE);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        \/***\n         * Verify the account summary\n         *\/\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        Float balance = Float.parseFloat(zeroOpeningBalance);\n\n        \/***\n         * Perform withdraw transaction, verify account balance(account balance will go to negative as no deposits are\n         * there prior to this transaction)\n         *\/\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, WITHDRAW_AMOUNT,\n                ACTIVATION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(WITHDRAW_AMOUNT);\n        assertEquals(Float.parseFloat(WITHDRAW_AMOUNT), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n        assertEquals(balance, withdrawTransaction.get(\"runningBalance\"), \"Verifying Balance after Withdrawal\");\n\n        \/***\n         * Perform Deposit transaction on last day of month and verify account balance.\n         *\n         * @param transactionDate\n         *            this value is every time last day of previous month\n         *\/\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n        assertEquals(balance, depositTransaction.get(\"runningBalance\"), \"Verifying Balance after Deposit\");\n\n        \/***\n         * Perform Post interest transaction and verify the posted amount\n         *\/\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        HashMap accountDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountDetails.get(\"summary\");\n        Float actualInterestPosted = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        \/***\n         * Calculate expected interest to be posted, interest should be posted for one day only because deposit\n         * transaction happened on last day of month before this account balance is negative.\n         *\/\n        final Float nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        final HashMap interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        final Integer daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        double interestRateInFraction = nominalAnnualInterest \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        double interestPerDay = interestRateInFraction * perDay;\n        Float interestPosted = (float) (interestPerDay * balance * 1);\n\n        \/***\n         * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n         *\/\n        DecimalFormat decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalFormat.applyPattern(\"#.###\");\n        interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n        actualInterestPosted = Float.parseFloat(decimalFormat.format(actualInterestPosted));\n        assertEquals(interestPosted, actualInterestPosted, \"Verifying interest posted\");\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        final String CLOSEDON_DATE = dateFormat.format(todaysDate);\n        String withdrawBalance = \"false\";\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper\n                .closeSavingsAccountAndGetBackRequiredField(savingsId, withdrawBalance, CommonConstants.RESPONSE_ERROR, CLOSEDON_DATE);\n        assertEquals(\"validation.msg.savingsaccount.close.results.in.balance.not.zero\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    } END"}
{"prompt":"test Savings Account Post Interest With Overdraft\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountPostInterestWithOverdraft() {\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n\n        \/***\n         * Create a client to apply for savings account (overdraft account).\n         *\/\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n\n        \/***\n         * Create savings product with zero opening balance and overdraft enabled\n         *\/\n        final String zeroOpeningBalance = \"0.0\";\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = true;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, zeroOpeningBalance,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        \/***\n         * Apply for Savings account\n         *\/\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        \/***\n         * Approve the savings account\n         *\/\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n        todaysDate = todaysDate.withDayOfMonth(1);\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n        final Integer lastDayOfMonth = todaysDate.lengthOfMonth();\n        todaysDate = todaysDate.withDayOfMonth(lastDayOfMonth);\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate);\n\n        LocalDate postedDate = Utils.getLocalDateOfTenant();\n        postedDate = postedDate.withDayOfMonth(2);\n\n        final String POSTED_TRANSACTION_DATE = dateFormat.format(postedDate);\n\n        \/***\n         * Activate the application and verify account status\n         *\n         * @param activationDate\n         *            this value is every time first day of previous month\n         *\/\n        savingsStatusHashMap = activateSavingsAccount(savingsId, ACTIVATION_DATE);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        \/***\n         * Verify the account summary\n         *\/\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        Float balance = Float.parseFloat(zeroOpeningBalance);\n\n        \/***\n         * Perform withdraw transaction, verify account balance(account balance will go to negative as no deposits are\n         * there prior to this transaction)\n         *\/\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, WITHDRAW_AMOUNT,\n                ACTIVATION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(WITHDRAW_AMOUNT);\n        assertEquals(Float.parseFloat(WITHDRAW_AMOUNT), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n        assertEquals(balance, withdrawTransaction.get(\"runningBalance\"), \"Verifying Balance after Withdrawal\");\n\n        \/***\n         * Perform Deposit transaction on last day of month and verify account balance.\n         *\n         * @param transactionDate\n         *            this value is every time last day of previous month\n         *\/\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n        assertEquals(balance, depositTransaction.get(\"runningBalance\"), \"Verifying Balance after Deposit\");\n\n        \/***\n         * Perform Post interest transaction and verify the posted amount\n         *\/\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        HashMap accountDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountDetails.get(\"summary\");\n        Float actualInterestPosted = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        \/***\n         * Calculate expected interest to be posted, interest should be posted for one day only because deposit\n         * transaction happened on last day of month before this account balance is negative.\n         *\/\n        this.savingsAccountHelper.postInterestAsOnSavings(savingsId, POSTED_TRANSACTION_DATE);\n        HashMap accountDetailsPostInterest = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountDetails.get(\"summary\");\n        ArrayList interestPostingTransaction = (ArrayList) ((HashMap) ((ArrayList) accountDetails.get(\"transactions\")).get(0)).get(\"date\");\n        Float accountDetailsPostInterestPosted = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        \/***\n         * Calculate expected interest to be posted, interest should be posted for one day only because deposit\n         * transaction happened on last day of month before this account balance is negative.\n         *\/\n        final Float nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        final HashMap interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        final Integer daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        double interestRateInFraction = nominalAnnualInterest \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        double interestPerDay = interestRateInFraction * perDay;\n        Float interestPosted = (float) (interestPerDay * balance * 1);\n\n        \/***\n         * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n         *\/\n        DecimalFormat decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalFormat.applyPattern(\"#.###\");\n        interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n        \/\/ actualInterestPosted =\n        \/\/ Float.parseFloat(decimalFormat.format(accountDetailsPostInterestPosted));\n        assertEquals(interestPosted, accountDetailsPostInterestPosted, \"Verifying interest posted\");\n        LOG.info(\"------Post Interest As On After doing a post interest Successfully worked--------\");\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        final String CLOSEDON_DATE = dateFormat.format(todaysDate);\n\n        LocalDate interestPostingDate = LocalDate.of((int) interestPostingTransaction.get(0), (int) interestPostingTransaction.get(1),\n                (int) interestPostingTransaction.get(2));\n        LocalDate todysDate = Utils.getLocalDateOfTenant();\n\n        final String INTEREST_POSTING_DATE = dateFormat.format(interestPostingDate);\n        final String TODYS_POSTING_DATE = dateFormat.format(todysDate);\n        String withdrawBalance = \"true\";\n\n        if (TODYS_POSTING_DATE.equalsIgnoreCase(INTEREST_POSTING_DATE)) {\n            final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, responseSpec);\n            validationErrorHelper.closeSavingsAccountPostInterestAndGetBackRequiredField(savingsId, withdrawBalance,\n                    CommonConstants.RESPONSE_ERROR, CLOSEDON_DATE);\n        } else {\n            final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n            ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper\n                    .closeSavingsAccountPostInterestAndGetBackRequiredField(savingsId, withdrawBalance, CommonConstants.RESPONSE_ERROR,\n                            CLOSEDON_DATE);\n            assertEquals(\"error.msg.postInterest.notDone\", savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n        }\n    } END"}
{"prompt":"test Post Interest As On Savings Account With Overdraft\n\n###\n\n","completion":"    @Test\n    public void testPostInterestAsOnSavingsAccountWithOverdraft() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        \/\/ final ResponseSpecification errorResponse = new\n        \/\/ ResponseSpecBuilder().expectStatusCode(400).build();\n        \/\/ final SavingsAccountHelper validationErrorHelper = new\n        \/\/ SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        \/***\n         * Create a client to apply for savings account (overdraft account).\n         *\/\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n\n        \/***\n         * Create savings product with zero opening balance and overdraft enabled\n         *\/\n        final String zeroOpeningBalance = \"0.0\";\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = true;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, zeroOpeningBalance,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        \/***\n         * Apply for Savings account\n         *\/\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        \/***\n         * Approve the savings account\n         *\/\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n        todaysDate = todaysDate.withDayOfMonth(1);\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n        final Integer lastDayOfMonth = todaysDate.lengthOfMonth();\n        todaysDate = todaysDate.withDayOfMonth(lastDayOfMonth);\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate);\n\n        LocalDate postedDate = Utils.getLocalDateOfTenant();\n        postedDate = postedDate.withDayOfMonth(1);\n\n        final String POSTED_TRANSACTION_DATE = dateFormat.format(postedDate);\n        LocalDate postedLastDate = Utils.getLocalDateOfTenant();\n        int countOfDate = postedDate.lengthOfMonth();\n        LOG.info(\"count Of Date---> {}\", countOfDate);\n        postedLastDate.withDayOfMonth(countOfDate);\n        final String POSTED_LAST_TRANSACTION_DATE = dateFormat.format(postedLastDate);\n\n        \/***\n         * Activate the application and verify account status\n         *\n         * @param activationDate\n         *            this value is every time first day of previous month\n         *\/\n        savingsStatusHashMap = activateSavingsAccount(savingsId, ACTIVATION_DATE);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        \/***\n         * Verify the account summary\n         *\/\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        Float balance = Float.parseFloat(zeroOpeningBalance);\n\n        \/***\n         * Perform withdraw transaction, verify account balance(account balance will go to negative as no deposits are\n         * there prior to this transaction)\n         *\/\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, WITHDRAW_AMOUNT,\n                ACTIVATION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(WITHDRAW_AMOUNT);\n        assertEquals(Float.parseFloat(WITHDRAW_AMOUNT), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n        assertEquals(balance, withdrawTransaction.get(\"runningBalance\"), \"Verifying Balance after Withdrawal\");\n\n        \/***\n         * Perform Deposit transaction on last day of month and verify account balance.\n         *\n         * @param transactionDate\n         *            this value is every time last day of previous month\n         *\/\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n        assertEquals(balance, depositTransaction.get(\"runningBalance\"), \"Verifying Balance after Deposit\");\n\n        \/***\n         * Perform Post interest transaction and verify the posted amount\n         *\/\n        this.savingsAccountHelper.postInterestAsOnSavings(savingsId, POSTED_TRANSACTION_DATE);\n        HashMap accountDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountDetails.get(\"summary\");\n        Float actualInterestPosted = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        \/***\n         * Calculate expected interest to be posted, interest should be posted for one day only because deposit\n         * transaction happened on last day of month before this account balance is negative.\n         *\/\n        final Float nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        final HashMap interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        final Integer daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        double interestRateInFraction = nominalAnnualInterest \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        double interestPerDay = interestRateInFraction * perDay;\n        Float interestPosted = (float) (interestPerDay * balance * 1);\n\n        \/***\n         * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n         *\/\n        DecimalFormat decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalFormat.applyPattern(\"#.###\");\n        interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n        actualInterestPosted = Float.parseFloat(decimalFormat.format(actualInterestPosted));\n        assertEquals(interestPosted, actualInterestPosted, \"Verifying interest posted\");\n        LOG.info(\"------Post Interest As On Successful Worked--------\");\n\n        this.savingsAccountHelper.postInterestAsOnSavings(savingsId, POSTED_LAST_TRANSACTION_DATE);\n        HashMap accountLastDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountLastDetails.get(\"summary\");\n        Float actualLastInterestPosted = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        final Float nominalLastAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        final HashMap interestLastCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        final Integer daysLastInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        double interestLastRateInFraction = nominalAnnualInterest \/ 100;\n        double perLastDay = (double) 1 \/ daysInYear;\n        double interestLastPerDay = interestLastRateInFraction * perLastDay;\n        Float interestLastPosted = (float) (interestLastPerDay * balance * 1);\n\n        DecimalFormat decimalLastFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalLastFormat.applyPattern(\"#.###\");\n        interestLastPosted = Float.parseFloat(decimalLastFormat.format(interestLastPosted));\n        actualInterestPosted = Float.parseFloat(decimalFormat.format(actualInterestPosted));\n        assertEquals(interestLastPosted, actualInterestPosted, \"Verifying interest posted\");\n        LOG.info(\"------Post Interest As On Successful Worked--------\");\n\n    } END"}
{"prompt":"test Savings Account WITH WITHHOLD TAX\n\n###\n\n","completion":"    @Test\n    public void testSavingsAccount_WITH_WITHHOLD_TAX() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final String percentage = \"10\";\n        final Integer taxGroupId = createTaxGroup(percentage);\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft, String.valueOf(taxGroupId),\n                false);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Assertions.assertFalse(summaryBefore.equals(summary));\n        Assertions.assertNotNull(summary.get(\"totalWithholdTax\"));\n        Float expected = (Float) summary.get(\"totalDeposits\") + (Float) summary.get(\"totalInterestPosted\")\n                - (Float) summary.get(\"totalWithholdTax\");\n        Float actual = (Float) summary.get(\"accountBalance\");\n        Assertions.assertEquals(expected, actual, 1);\n\n    } END"}
{"prompt":"test Savings Account WITH WITHHOLD TAX DISABLE AT ACCOUNT LEVEL\n\n###\n\n","completion":"    @Test\n    public void testSavingsAccount_WITH_WITHHOLD_TAX_DISABLE_AT_ACCOUNT_LEVEL() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final String percentage = \"10\";\n        final Integer taxGroupId = createTaxGroup(percentage);\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft, String.valueOf(taxGroupId),\n                false);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        final HashMap changes = this.savingsAccountHelper.updateSavingsAccountWithHoldTaxStatus(savingsId, false);\n        Assertions.assertTrue(changes.containsKey(\"withHoldTax\"));\n\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Assertions.assertFalse(summaryBefore.equals(summary));\n        Assertions.assertNull(summary.get(\"totalWithholdTax\"));\n        Float expected = (Float) summary.get(\"totalDeposits\") + (Float) summary.get(\"totalInterestPosted\");\n        Float actual = (Float) summary.get(\"accountBalance\");\n        Assertions.assertEquals(expected, actual, 1);\n\n    } END"}
{"prompt":"test Savings Account Dormancy Tracking\n\n###\n\n","completion":"    @Test\n    public void testSavingsAccount_DormancyTracking() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final String percentage = \"10\";\n        final Integer taxGroupId = createTaxGroup(percentage);\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft, String.valueOf(taxGroupId),\n                true);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsNoActivityFeeJSON());\n        Assertions.assertNotNull(savingsChargeId);\n\n        ArrayList<Integer> savingsList = new ArrayList<>();\n\n        for (int i = 0; i < 5; i++) {\n            final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID,\n                    ACCOUNT_TYPE_INDIVIDUAL);\n            Assertions.assertNotNull(savingsProductID);\n\n            HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                    ACCOUNT_TYPE_INDIVIDUAL);\n            Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n            this.savingsAccountHelper.addChargesForSavings(savingsId, savingsChargeId, false);\n\n            HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n            SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n            savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n            SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n            savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n            SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n            savingsList.add(savingsId);\n        }\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsList.add(savingsId);\n\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant());\n        for (int i = 0; i < 4; i++) {\n            String transactionDateValue = formatter.format(transactionDate);\n            Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsList.get(i), DEPOSIT_AMOUNT,\n                    transactionDateValue, CommonConstants.RESPONSE_RESOURCE_ID);\n            transactionDate = transactionDate.minusDays(30);\n        }\n\n        LOG.info(\"Savings account IDs: {}\", savingsList);\n        SchedulerJobHelper jobHelper = new SchedulerJobHelper(this.requestSpec);\n        jobHelper.executeAndAwaitJob(\"Update Savings Dormant Accounts\");\n\n        \/\/ VERIFY WITHIN PROVIDED RANGE DOESN'T INACTIVATE\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(0));\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(0));\n        SavingsStatusChecker.verifySavingsSubStatusNone(savingsStatusHashMap);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsList.get(0));\n        Float balance = 3000f;\n        Float chargeAmt = 0f;\n        balance -= chargeAmt;\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account Balance\");\n\n        \/\/ VERIFY INACTIVE\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(1));\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(1));\n        SavingsStatusChecker.verifySavingsSubStatusInactive(savingsStatusHashMap);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsList.get(1));\n        balance = 3000f;\n        chargeAmt = 100f;\n        balance -= chargeAmt;\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account Balance\");\n\n        String transactionDateValue = formatter.format(LocalDate.now(Utils.getZoneIdOfTenant()));\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsList.get(1), DEPOSIT_AMOUNT,\n                transactionDateValue, CommonConstants.RESPONSE_RESOURCE_ID);\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(1));\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(1));\n        SavingsStatusChecker.verifySavingsSubStatusNone(savingsStatusHashMap);\n\n        \/\/ VERIFY DORMANT\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(2));\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(2));\n        SavingsStatusChecker.verifySavingsSubStatusDormant(savingsStatusHashMap);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsList.get(2));\n        balance = 3000f;\n        chargeAmt = 100f;\n        balance -= chargeAmt;\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account Balance\");\n\n        transactionDateValue = formatter.format(LocalDate.now(Utils.getZoneIdOfTenant()));\n        depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsList.get(2), DEPOSIT_AMOUNT,\n                transactionDateValue, CommonConstants.RESPONSE_RESOURCE_ID);\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(2));\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(2));\n        SavingsStatusChecker.verifySavingsSubStatusNone(savingsStatusHashMap);\n\n        \/\/ VERIFY ESCHEAT DUE TO OLD TRANSACTION\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(3));\n        SavingsStatusChecker.verifySavingsAccountIsClosed(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(3));\n        SavingsStatusChecker.verifySavingsSubStatusEscheat(savingsStatusHashMap);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsList.get(3));\n        assertEquals(2900f, summary.get(\"accountBalance\"), \"Verifying account Balance\");\n\n        \/\/ VERIFY ESCHEAT DUE NO TRANSACTION FROM ACTIVATION\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(4));\n        SavingsStatusChecker.verifySavingsAccountIsClosed(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(4));\n        SavingsStatusChecker.verifySavingsSubStatusEscheat(savingsStatusHashMap);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsList.get(4));\n        assertEquals(900f, summary.get(\"accountBalance\"), \"Verifying account Balance\");\n\n        \/\/ VERIFY NON ACTIVE ACCOUNTS ARE NOT AFFECTED\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(5));\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(5));\n        SavingsStatusChecker.verifySavingsSubStatusNone(savingsStatusHashMap);\n\n    } END"}
{"prompt":"test Savings Account Block Status\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountBlockStatus() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(MINIMUM_OPENING_BALANCE);\n\n        savingsStatusHashMap = this.savingsAccountHelper.blockSavings(savingsId);\n        SavingsStatusChecker.verifySavingsSubStatusblock(savingsStatusHashMap);\n\n        List<HashMap> error = (List) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"100\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.saving.account.blocked.transaction.not.allowed\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error = (List) savingsAccountHelperValidationError.depositToSavingsAccount(savingsId, \"100\", SavingsAccountHelper.TRANSACTION_DATE,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.saving.account.blocked.transaction.not.allowed\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        savingsStatusHashMap = this.savingsAccountHelper.unblockSavings(savingsId);\n        SavingsStatusChecker.verifySavingsSubStatusIsNone(savingsStatusHashMap);\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n\n        savingsStatusHashMap = this.savingsAccountHelper.blockDebit(savingsId);\n        SavingsStatusChecker.verifySavingsSubStatusIsDebitBlocked(savingsStatusHashMap);\n        error = (List) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"100\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savings.account.debit.transaction.not.allowed\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n\n        savingsStatusHashMap = this.savingsAccountHelper.unblockDebit(savingsId);\n        SavingsStatusChecker.verifySavingsSubStatusIsNone(savingsStatusHashMap);\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, WITHDRAW_AMOUNT,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(WITHDRAW_AMOUNT);\n        assertEquals(Float.parseFloat(WITHDRAW_AMOUNT), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n\n        savingsStatusHashMap = this.savingsAccountHelper.blockCredit(savingsId);\n        SavingsStatusChecker.verifySavingsSubStatusIsCreditBlocked(savingsStatusHashMap);\n        error = (List) savingsAccountHelperValidationError.depositToSavingsAccount(savingsId, \"100\", SavingsAccountHelper.TRANSACTION_DATE,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savings.account.credit.transaction.not.allowed\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, WITHDRAW_AMOUNT,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(WITHDRAW_AMOUNT);\n        assertEquals(Float.parseFloat(WITHDRAW_AMOUNT), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n\n        savingsStatusHashMap = this.savingsAccountHelper.unblockCredit(savingsId);\n        SavingsStatusChecker.verifySavingsSubStatusIsNone(savingsStatusHashMap);\n        depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n\n        Integer holdTransactionId = (Integer) this.savingsAccountHelper.holdAmountInSavingsAccount(savingsId, String.valueOf(balance - 100),\n                false, SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        error = (List) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"300\",\n                SavingsAccountHelper.TRANSACTION_DATE_PLUS_ONE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer releaseTransactionId = this.savingsAccountHelper.releaseAmount(savingsId, holdTransactionId);\n        Date today = Date.from(Utils.getLocalDateOfTenant().atStartOfDay(Utils.getZoneIdOfTenant()).toInstant());\n        String todayDate = today.toString();\n        SimpleDateFormat dt1 = new SimpleDateFormat(\"dd MMM yyyy\");\n        todayDate = dt1.format(today).toString();\n        withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"300\", todayDate,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(\"300\");\n        assertEquals(Float.parseFloat(\"300\"), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n\n    } END"}
{"prompt":"test Savings Account Lien Allowed At Product Level With Enforce Balance\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountLienAllowedAtProductLevelWithEnforceBalance() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final boolean enforceMinRequiredBalance = true;\n        final boolean allowOverdraft = false;\n        final boolean lienAllowed = true;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, enforceMinRequiredBalance, allowOverdraft, lienAllowed);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        List<HashMap> error = (List) savingsAccountHelperValidationError.holdAmountInSavingsAccount(savingsId, \"2000\", false,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"validation.msg.savingsaccount.insufficient.balance\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer lienHoldTransactionId = (Integer) this.savingsAccountHelper.holdAmountInSavingsAccount(savingsId, \"2000\", true,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Float balance = Float.parseFloat(\"-1000\");\n\n        assertEquals(balance, summary.get(\"availableBalance\"), \"Verifying available Balance is -1000\");\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"1200\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate.getTime());\n\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper.withdrawalFromSavingsAccount(savingsId,\n                \"200\", TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", TRANSACTION_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Assertions.assertNotNull(withdrawTransactionId);\n    } END"}
{"prompt":"test Savings Account Lien Allowed At Product Level With Over Draft Limit\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountLienAllowedAtProductLevelWithOverDraftLimit() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final boolean enforceMinRequiredBalance = false;\n        final boolean allowOverdraft = true;\n        final boolean lienAllowed = true;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, enforceMinRequiredBalance, allowOverdraft, lienAllowed);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        List<HashMap> error = (List) savingsAccountHelperValidationError.holdAmountInSavingsAccount(savingsId, \"2000\", false,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"validation.msg.savingsaccount.insufficient.balance\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer lienHoldTransactionId = (Integer) this.savingsAccountHelper.holdAmountInSavingsAccount(savingsId, \"2000\", true,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Float balance = Float.parseFloat(\"-1000\");\n\n        assertEquals(balance, summary.get(\"availableBalance\"), \"Verifying available Balance is -1000\");\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"1200\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate.getTime());\n\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper.withdrawalFromSavingsAccount(savingsId,\n                \"300\", TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"200\", TRANSACTION_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Assertions.assertNotNull(withdrawTransactionId);\n    } END"}
{"prompt":"test Savings Account Lien Allowed At Product Level With No Config\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountLienAllowedAtProductLevelWithNoConfig() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final boolean enforceMinRequiredBalance = false;\n        final boolean allowOverdraft = false;\n        final boolean lienAllowed = true;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, enforceMinRequiredBalance, allowOverdraft, lienAllowed);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        List<HashMap> error = (List) savingsAccountHelperValidationError.holdAmountInSavingsAccount(savingsId, \"2000\", false,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"validation.msg.savingsaccount.insufficient.balance\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer lienHoldTransactionId = (Integer) this.savingsAccountHelper.holdAmountInSavingsAccount(savingsId, \"2000\", true,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Float balance = Float.parseFloat(\"-1000\");\n\n        assertEquals(balance, summary.get(\"availableBalance\"), \"Verifying available Balance is -1000\");\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"1100\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate.getTime());\n\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper.withdrawalFromSavingsAccount(savingsId,\n                \"200\", TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\/\/ withdrawable amount = 200;\n\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", TRANSACTION_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Assertions.assertNotNull(withdrawTransactionId);\n\n    } END"}
{"prompt":"test Savings Account Without Lien Allowed\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountWithoutLienAllowed() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final boolean enforceMinRequiredBalance = false;\n        final boolean allowOverdraft = true;\n        final boolean lienAllowed = false;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, enforceMinRequiredBalance, allowOverdraft, lienAllowed);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        List<HashMap> error = (List) savingsAccountHelperValidationError.holdAmountInSavingsAccount(savingsId, \"2000\", true,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"validation.msg.savingsaccount.lien.is.not.allowed.in.product.level\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer lienHoldTransactionId = (Integer) this.savingsAccountHelper.holdAmountInSavingsAccount(savingsId, \"1500\", false,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\/\/ as per overdraft limit\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Float balance = Float.parseFloat(\"-500\"); \/\/ opening balance\n\n        assertEquals(balance, summary.get(\"availableBalance\"), \"Verifying available Balance is -500\");\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"2000\", \/\/ available\n                                                                                                                      \/\/ to\n                                                                                                                      \/\/ use\n                                                                                                                      \/\/ 1100\n                                                                                                                      \/\/ and\n                                                                                                                      \/\/ another\n                                                                                                                      \/\/ 1000\n                                                                                                                      \/\/ on\n                                                                                                                      \/\/ transactional\n                                                                                                                      \/\/ hold\n\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate.getTime());\n\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper.withdrawalFromSavingsAccount(savingsId,\n                \"1600\", TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\/\/ can not withdraw: amount on transactional\n                                                                          \/\/ hold\n\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"1500\",\n                TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Assertions.assertNotNull(withdrawTransactionId);\n\n    } END"}
{"prompt":"test Savings Account Lien Allowed At Product Level With Over Draft Limit Greater Than Lien Limit\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountLienAllowedAtProductLevelWithOverDraftLimitGreaterThanLienLimit() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final boolean enforceMinRequiredBalance = false;\n        final boolean allowOverdraft = true;\n        final String overDraftLimit = \"2000.0\";\n        final boolean lienAllowed = true;\n        final String lineAllowedLimit = \"1000.0\";\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, errorResponse, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, enforceMinRequiredBalance, allowOverdraft, overDraftLimit, lienAllowed, lineAllowedLimit);\n        Assertions.assertNull(savingsProductID);\n\n    } END"}
{"prompt":"test Account Balance After Transaction Reversal\n\n###\n\n","completion":"    @Test\n    public void testAccountBalanceAfterTransactionReversal() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        \/\/ SavingsAccountHelper savingsAccountHelperValidationError = new\n        \/\/ SavingsAccountHelper(this.requestSpec,new\n        \/\/ ResponseSpecBuilder().build());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"500\";\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = true;\n        final String MINIMUM_OPENING_BALANCE = \"0\";\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"500\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        String chargeAmount = \"300\";\n        String chargeCurrency = \"USD\";\n\n        final Integer savingsChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsJSON(chargeAmount, chargeCurrency, ChargeTimeType.SPECIFIED_DUE_DATE));\n\n        Assertions.assertNotNull(savingsChargeId);\n\n        Integer amount = 300;\n\n        final Integer chargeId = this.savingsAccountHelper.addChargesForSavingsWithDueDate(savingsId, savingsChargeId,\n                SavingsAccountHelper.TRANSACTION_DATE, amount);\n\n        Assertions.assertNotNull(chargeId);\n\n        final Integer payChargeId = this.savingsAccountHelper.payCharge(chargeId, savingsId, chargeAmount,\n                SavingsAccountHelper.TRANSACTION_DATE);\n\n        final Integer undoSavingsTransaction = this.savingsAccountHelper.undoSavingsAccountTransaction(savingsId, depositTransactionId);\n        HashMap reversedDepositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        Assertions.assertTrue((Boolean) reversedDepositTransaction.get(\"reversed\"));\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Float balance = Float.parseFloat(\"-300\");\n\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance is -300\");\n\n    } END"}
{"prompt":"test Savings Account Withdrawal Charges On Payment Types\n\n###\n\n","completion":"    @Test\n    public void testSavingsAccountWithdrawalChargesOnPaymentTypes() {\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final String MINIMUM_OPENING_BALANCE = \"10000\";\n        final String withdrawalAmountOne = \"1000\";\n        final String withdrawalAmountTwo = \"2000\";\n        final Integer withdrawalChargeOne = 10;\n        final Integer withdrawalChargeTwo = 20;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        String name = PaymentTypeHelper.randomNameGenerator(\"P_T\", 5);\n        String description = PaymentTypeHelper.randomNameGenerator(\"PT_Desc\", 15);\n        Boolean isCashPayment = false;\n        Integer position = 1;\n\n        Integer paymentTypeIdOne = PaymentTypeHelper.createPaymentType(requestSpec, responseSpec, name, description, isCashPayment,\n                position);\n        Assertions.assertNotNull(paymentTypeIdOne);\n\n        final Integer chargeIdOne = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.paymentTypeCharge(withdrawalChargeOne, true, paymentTypeIdOne));\n        Assertions.assertNotNull(chargeIdOne);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, chargeIdOne, false, BigDecimal.valueOf(withdrawalChargeOne));\n\n        Integer withdrawTransactionIdOne = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccountWithPaymentType(savingsId,\n                withdrawalAmountOne, SavingsAccountHelper.TRANSACTION_DATE, paymentTypeIdOne.toString(),\n                CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Float balance = Float.parseFloat(\"8990\");\n        \/\/ Withdraw charge from paymentType 1 is 10 So balance should be 10,000(deposit)-1000(wd)-\"10(charge)\" = 8990\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance after withdrawal charge \");\n\n        String paymentTypeNameTwo = PaymentTypeHelper.randomNameGenerator(\"P_T\", 5);\n\n        Integer paymentTypeIdTwo = PaymentTypeHelper.createPaymentType(requestSpec, responseSpec, paymentTypeNameTwo, description,\n                isCashPayment, position);\n        Assertions.assertNotNull(paymentTypeIdTwo);\n\n        final Integer chargeIdTwo = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.paymentTypeCharge(withdrawalChargeTwo, true, paymentTypeIdTwo));\n        Assertions.assertNotNull(chargeIdTwo);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, chargeIdTwo, false, BigDecimal.valueOf(withdrawalChargeTwo));\n\n        Integer withdrawTransactionIdTwo = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccountWithPaymentType(savingsId,\n                withdrawalAmountTwo, SavingsAccountHelper.TRANSACTION_DATE, paymentTypeIdTwo.toString(),\n                CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Float balanceAfterChargeTwo = Float.parseFloat(\"6970\");\n        \/\/ Withdraw charge from paymentType 2 is 20 So balance should be 8990(balance)-2000(wd)-\"20(charge)\" = 6970\n\n        HashMap summaryTwo = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(balanceAfterChargeTwo, summaryTwo.get(\"accountBalance\"), \"Verifying Balance after withdrawal charge two \");\n    } END"}
{"prompt":"test Account Balance After Savings Transaction Reversal Posting\n\n###\n\n","completion":"    @Test\n    public void testAccountBalanceAfterSavingsTransactionReversalPosting() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"0\";\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = true;\n        final String MINIMUM_OPENING_BALANCE = \"0\";\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"500\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        this.savingsAccountHelper.reverseSavingsAccountTransaction(savingsId, depositTransactionId);\n\n        HashMap reversedDepositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n\n        Assertions.assertTrue((Boolean) reversedDepositTransaction.get(\"reversed\"));\n\n        List<HashMap> transactions = this.savingsAccountHelper.getSavingsTransactions(savingsId);\n\n        HashMap reversalDepositTransaction = transactions.get(0);\n\n        Assertions.assertTrue((Boolean) reversalDepositTransaction.get(\"isReversal\"));\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Float balance = Float.parseFloat(\"0.0\");\n\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance is 500\");\n\n    } END"}
{"prompt":"test Reversal When Is Bulk Is True\n\n###\n\n","completion":"    @Test\n    public void testReversalWhenIsBulkIsTrue() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"0\";\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final boolean isBulk = true;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsId);\n        final Integer withdrawalChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsWithdrawalFeeJSON());\n        Assertions.assertNotNull(withdrawalChargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, withdrawalChargeId, false);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        Integer withdrawalTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"500\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(\"400.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account balance is 400\");\n        LOG.info(\"------------------------When Bulk transaction is true------------------------\");\n        this.savingsAccountHelper.reverseSavingsAccountTransaction(savingsId, withdrawalTransactionId, isBulk);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(\"1000.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account balance is 1000\");\n    } END"}
{"prompt":"test Reversal When Is Bulk Is False\n\n###\n\n","completion":"    @Test\n    public void testReversalWhenIsBulkIsFalse() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"0\";\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final boolean isBulk = false;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsId);\n        final Integer withdrawalChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsWithdrawalFeeJSON());\n        Assertions.assertNotNull(withdrawalChargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, withdrawalChargeId, false);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        Integer withdrawalTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"500\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(\"400.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account balance is 400\");\n        LOG.info(\"------------------------When Bulk transaction is false------------------------\");\n        this.savingsAccountHelper.reverseSavingsAccountTransaction(savingsId, withdrawalTransactionId, isBulk);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(\"900.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account balance is 900\");\n    } END"}
{"prompt":"test Account Balance And Transaction Running Balance With Config On\n\n###\n\n","completion":"    @Test\n    public void testAccountBalanceAndTransactionRunningBalanceWithConfigOn() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        configurationForBackdatedTransaction();\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"0\";\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = true;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, \"0\", minBalanceForInterestCalculation,\n                minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(5);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n        \/\/ withdrawal transaction 1\n        Integer withdrawalTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"500\", startDate,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(\"-500.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account balance is -500\");\n\n        \/\/ withdrawal transaction 2\n        withdrawalTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"500\", startDate,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(\"-1000.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account balance is -1000\");\n\n        \/\/ Check for last transactions running balance\n        Object transactionObj = this.savingsAccountHelper.getSavingsDetails(savingsId, \"transactions\");\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) transactionObj;\n        HashMap<String, Object> requestedTransaction = transactions.get(transactions.size() - 2);\n        balance = Float.parseFloat(\"-1000.0\");\n        assertEquals(balance.toString(), requestedTransaction.get(\"runningBalance\").toString(), \"Equality check for Balance\");\n    } END"}
{"prompt":"test Savings Account Charges Back Date\n\n###\n\n","completion":"    @Test\n    public void testSavingsAccountChargesBackDate() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, \"0\", minBalanceForInterestCalculation,\n                minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final Integer chargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsSpecifiedDueDateJSON());\n        Assertions.assertNotNull(chargeId);\n\n        ArrayList<HashMap> charges = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertTrue(charges == null || charges.size() == 0);\n\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"100\", \"05 March 2013\", CommonConstants.RESPONSE_RESOURCE_ID);\n\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"100\", \"07 March 2013\", CommonConstants.RESPONSE_RESOURCE_ID);\n\n        final Integer savingsChargeId = this.savingsAccountHelper.addChargesForSavingsWithDueDate(savingsId, chargeId, \"07 March 2013\",\n                200);\n\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) savingsAccountHelperValidationError\n                .payChargeToSavingsAccount(savingsId, savingsChargeId, \"200\", \"06 March 2013\", CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        final Integer payChargeId = this.savingsAccountHelper.payCharge(savingsChargeId, savingsId, \"200\", \"07 March 2013\");\n\n        Assertions.assertNotNull(payChargeId);\n    } END"}
{"prompt":"test Running Balance After Withdrawal With Backdate Configuration On\n\n###\n\n","completion":"    @Test\n    public void testRunningBalanceAfterWithdrawalWithBackdateConfigurationOn() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsProductHelper = new SavingsProductHelper();\n        this.scheduleJobHelper = new SchedulerJobHelper(requestSpec);\n        configurationForBackdatedTransaction();\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(5);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n        String secondTrx = formatter.format(transactionDate.plusDays(1));\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"100\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"200\", secondTrx, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap<String, Object> summaryObj = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        assertEquals(\"-100.0822\", summaryObj.get(\"availableBalance\").toString(), \"Equality check for Balance\");\n    } END"}
{"prompt":"test Running Balance After Deposit With Backdate Configuration On\n\n###\n\n","completion":"    @Test\n    public void testRunningBalanceAfterDepositWithBackdateConfigurationOn() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsProductHelper = new SavingsProductHelper();\n        this.scheduleJobHelper = new SchedulerJobHelper(requestSpec);\n        configurationForBackdatedTransaction();\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(5);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n        String secondTrx = formatter.format(transactionDate.plusDays(1));\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"200\", secondTrx, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap<String, Object> summaryObj = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(\"100.0822\", summaryObj.get(\"availableBalance\").toString(), \"Equality check for Balance\");\n    } END"}
{"prompt":"test Running Balance After Withdrawal Reversal With Backdate Configuration On\n\n###\n\n","completion":"    @Test\n    public void testRunningBalanceAfterWithdrawalReversalWithBackdateConfigurationOn() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsProductHelper = new SavingsProductHelper();\n        this.scheduleJobHelper = new SchedulerJobHelper(requestSpec);\n        configurationForBackdatedTransaction();\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(5);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n        String secondTrx = formatter.format(transactionDate.plusDays(1));\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"100\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n\n        Integer withdrawalToReverse = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"200\", secondTrx,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        this.savingsAccountHelper.reverseSavingsAccountTransaction(savingsId, withdrawalToReverse);\n        HashMap<String, Object> summaryObj = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        assertEquals(\"100.137\", summaryObj.get(\"availableBalance\").toString(), \"Equality check for Balance\");\n    } END"}
{"prompt":"test Running Balance After Deposit Reversal With Backdate Configuration On\n\n###\n\n","completion":"    @Test\n    public void testRunningBalanceAfterDepositReversalWithBackdateConfigurationOn() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsProductHelper = new SavingsProductHelper();\n        this.scheduleJobHelper = new SchedulerJobHelper(requestSpec);\n        configurationForBackdatedTransaction();\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(5);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n        String secondTrx = formatter.format(transactionDate.plusDays(1));\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        Integer depositToReverse = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"200\", secondTrx,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        this.savingsAccountHelper.reverseSavingsAccountTransaction(savingsId, depositToReverse);\n\n        HashMap<String, Object> summaryObj = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(\"-100.137\", summaryObj.get(\"availableBalance\").toString(), \"Equality check for Balance\");\n    } END"}
{"prompt":"test To Perform Transaction Before Pivot Date\n\n###\n\n","completion":"    @Test\n    public void testToPerformTransactionBeforePivotDate() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsProductHelper = new SavingsProductHelper();\n        this.scheduleJobHelper = new SchedulerJobHelper(requestSpec);\n\n        configurationForBackdatedTransaction();\n\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(10);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"200\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        final String jobName = \"Post Interest For Savings\";\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n        List<HashMap> error = (List<HashMap>) validationErrorHelper.depositToSavingsAccount(savingsId, \"300\", startDate,\n                CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.savings.transaction.is.not.allowed\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n    } END"}
{"prompt":"test Reversal Entries After System Reversing Transaction With Reversal Config On\n\n###\n\n","completion":"    @Test\n    public void testReversalEntriesAfterSystemReversingTransactionWithReversalConfigOn() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsProductHelper = new SavingsProductHelper();\n        this.scheduleJobHelper = new SchedulerJobHelper(requestSpec);\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"46\", true);\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(5);\n        LocalDate nextTransactionDate = transactionDate.plusDays(2);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n        String nxtTransaction = formatter.format(nextTransactionDate);\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", nxtTransaction, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        List<HashMap> transactions = this.savingsAccountHelper.getSavingsTransactions(savingsId);\n        boolean reversalFlag = false;\n        for (int i = 0; i < transactions.size(); i++) {\n            boolean isReversal = (boolean) transactions.get(i).get(\"isReversal\");\n            if (isReversal) {\n                reversalFlag = true;\n                break;\n            }\n        }\n        Assertions.assertTrue(reversalFlag);\n    } END"}
{"prompt":"test Reversal Entries After System Reversing Transaction With Reversal Config Off\n\n###\n\n","completion":"    @Test\n    public void testReversalEntriesAfterSystemReversingTransactionWithReversalConfigOff() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsProductHelper = new SavingsProductHelper();\n        this.scheduleJobHelper = new SchedulerJobHelper(requestSpec);\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"46\", false);\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(5);\n        LocalDate nextTransactionDate = transactionDate.plusDays(2);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n        String nxtTransaction = formatter.format(nextTransactionDate);\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", nxtTransaction, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        List<HashMap> transactions = this.savingsAccountHelper.getSavingsTransactions(savingsId);\n        boolean reversalFlag = false;\n        for (int i = 0; i < transactions.size(); i++) {\n            boolean isReversal = (boolean) transactions.get(i).get(\"isReversal\");\n            if (isReversal) {\n                reversalFlag = true;\n                break;\n            }\n        }\n        Assertions.assertFalse(reversalFlag);\n    } END"}
{"prompt":"test Savings Account Deposit After Hold Amount\n\n###\n\n","completion":"    @Test\n    public void testSavingsAccountDepositAfterHoldAmount() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final boolean enforceMinRequiredBalance = false;\n        final boolean allowOverdraft = true;\n        final boolean lienAllowed = false;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, \"0\", minBalanceForInterestCalculation,\n                enforceMinRequiredBalance, allowOverdraft, lienAllowed);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        this.savingsAccountHelper.holdAmountInSavingsAccount(savingsId, \"100\", lienAllowed, SavingsAccountHelper.TRANSACTION_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"200\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Assertions.assertNotNull(depositTransactionId);\n        List<HashMap> error = (List) validationErrorHelper.withdrawalFromSavingsAccount(savingsId, \"200\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    } END"}
{"prompt":"test Client Status\n\n###\n\n","completion":"    @Test\n    public void testClientStatus() {\n        final Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientId);\n\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientIsActive(status);\n\n        HashMap<String, Object> clientStatusHashMap = clientHelper.closeClient(clientId);\n        ClientStatusChecker.verifyClientClosed(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.reactivateClient(clientId);\n        ClientStatusChecker.verifyClientPending(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.rejectClient(clientId);\n        ClientStatusChecker.verifyClientRejected(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.activateClient(clientId);\n        ClientStatusChecker.verifyClientActiavted(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.closeClient(clientId);\n        ClientStatusChecker.verifyClientClosed(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.reactivateClient(clientId);\n        ClientStatusChecker.verifyClientPending(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(clientStatusHashMap);\n\n    } END"}
{"prompt":"test Client As Person Status\n\n###\n\n","completion":"    @Test\n    public void testClientAsPersonStatus() {\n        final Integer clientId = ClientHelper.createClientAsPerson(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientId);\n\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientIsActive(status);\n\n        HashMap<String, Object> clientStatusHashMap = clientHelper.closeClient(clientId);\n        ClientStatusChecker.verifyClientClosed(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.reactivateClient(clientId);\n        ClientStatusChecker.verifyClientPending(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.rejectClient(clientId);\n        ClientStatusChecker.verifyClientRejected(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.activateClient(clientId);\n        ClientStatusChecker.verifyClientActiavted(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.closeClient(clientId);\n        ClientStatusChecker.verifyClientClosed(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.reactivateClient(clientId);\n        ClientStatusChecker.verifyClientPending(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(clientStatusHashMap);\n\n    } END"}
{"prompt":"test Client As Entity Status\n\n###\n\n","completion":"    @Test\n    public void testClientAsEntityStatus() {\n        final Integer clientId = ClientHelper.createClientAsEntity(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientId);\n\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientIsActive(status);\n\n        HashMap<String, Object> clientStatusHashMap = clientHelper.closeClient(clientId);\n        ClientStatusChecker.verifyClientClosed(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.reactivateClient(clientId);\n        ClientStatusChecker.verifyClientPending(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.rejectClient(clientId);\n        ClientStatusChecker.verifyClientRejected(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.activateClient(clientId);\n        ClientStatusChecker.verifyClientActiavted(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.closeClient(clientId);\n        ClientStatusChecker.verifyClientClosed(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.reactivateClient(clientId);\n        ClientStatusChecker.verifyClientPending(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(clientStatusHashMap);\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    @SuppressFBWarnings(value = {\n            \"DMI_RANDOM_USED_ONLY_ONCE\" } END"}
{"prompt":"test Client Address Creation Works\n\n###\n\n","completion":"    @Test\n    public void testClientAddressCreationWorks() {\n        \/\/ given\n        GlobalConfigurationPropertyData addressEnabledConfig = GlobalConfigurationHelper.getGlobalConfigurationByName(requestSpec,\n                responseSpec, \"Enable-Address\");\n        Long configId = addressEnabledConfig.getId();\n\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(requestSpec, responseSpec, configId, true);\n        GlobalConfigurationPropertyData updatedAddressEnabledConfig = GlobalConfigurationHelper.getGlobalConfigurationByName(requestSpec,\n                responseSpec, \"Enable-Address\");\n        boolean isAddressEnabled = BooleanUtils.toBoolean(updatedAddressEnabledConfig.getEnabled());\n        assertThat(isAddressEnabled).isTrue();\n\n        Integer addressTypeId = CodeHelper.createAddressTypeCodeValue(requestSpec, responseSpec,\n                Utils.randomStringGenerator(\"Residential address\", 4), 0);\n        Integer countryId = CodeHelper.createCountryCodeValue(requestSpec, responseSpec, Utils.randomStringGenerator(\"Hungary\", 4), 0);\n        Integer stateId = CodeHelper.createStateCodeValue(requestSpec, responseSpec, Utils.randomStringGenerator(\"Budapest\", 4), 0);\n        String city = \"Budapest\";\n        boolean addressIsActive = true;\n        long postalCode = 1000L;\n\n        \/\/ when\n        PostClientsAddressRequest addressRequest = new PostClientsAddressRequest().postalCode(postalCode).city(city).countryId(countryId)\n                .stateProvinceId(stateId).addressTypeId(addressTypeId.longValue()).isActive(addressIsActive);\n        PostClientsRequest request = ClientHelper.defaultClientCreationRequest().address(List.of(addressRequest));\n        final Integer clientId = ClientHelper.createClient(requestSpec, responseSpec, request);\n\n        \/\/ then\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientId);\n        List<GetClientClientIdAddressesResponse> clientAddresses = ClientHelper.getClientAddresses(requestSpec, responseSpec, clientId);\n        GetClientClientIdAddressesResponse addressResponse = clientAddresses.get(0);\n        assertThat(addressResponse.getCity()).isEqualTo(city);\n        assertThat(addressResponse.getCountryId()).isEqualTo(countryId);\n        assertThat(addressResponse.getStateProvinceId()).isEqualTo(stateId);\n        assertThat(addressResponse.getAddressTypeId()).isEqualTo(addressTypeId);\n        assertThat(addressResponse.getIsActive()).isEqualTo(addressIsActive);\n        assertThat(addressResponse.getPostalCode()).isEqualTo(postalCode);\n    } END"}
{"prompt":"test Client Address Creation Works After Client Is Created\n\n###\n\n","completion":"    @Test\n    public void testClientAddressCreationWorksAfterClientIsCreated() {\n        \/\/ given\n        Integer addressTypeId = CodeHelper.createAddressTypeCodeValue(requestSpec, responseSpec,\n                Utils.randomStringGenerator(\"Residential address\", 4), 0);\n        Integer countryId = CodeHelper.createCountryCodeValue(requestSpec, responseSpec, Utils.randomStringGenerator(\"Hungary\", 4), 0);\n        Integer stateId = CodeHelper.createStateCodeValue(requestSpec, responseSpec, Utils.randomStringGenerator(\"Budapest\", 4), 0);\n        String city = \"Budapest\";\n        boolean addressIsActive = true;\n        long postalCode = 1000L;\n\n        PostClientsRequest clientRequest = ClientHelper.defaultClientCreationRequest();\n        final Integer clientId = ClientHelper.createClient(requestSpec, responseSpec, clientRequest);\n        \/\/ when\n        PostClientClientIdAddressesRequest request = new PostClientClientIdAddressesRequest().postalCode(postalCode).city(city)\n                .countryId(countryId).stateProvinceId(stateId).isActive(addressIsActive);\n        PostClientClientIdAddressesResponse response = ClientHelper.createClientAddress(requestSpec, responseSpec, clientId.longValue(),\n                addressTypeId, request);\n        \/\/ then\n        assertThat(response.getResourceId()).isNotNull();\n        List<GetClientClientIdAddressesResponse> clientAddresses = ClientHelper.getClientAddresses(requestSpec, responseSpec, clientId);\n        GetClientClientIdAddressesResponse addressResponse = clientAddresses.get(0);\n        assertThat(addressResponse.getCity()).isEqualTo(city);\n        assertThat(addressResponse.getCountryId()).isEqualTo(countryId);\n        assertThat(addressResponse.getStateProvinceId()).isEqualTo(stateId);\n        assertThat(addressResponse.getAddressTypeId()).isEqualTo(addressTypeId);\n        assertThat(addressResponse.getIsActive()).isEqualTo(addressIsActive);\n        assertThat(addressResponse.getPostalCode()).isEqualTo(postalCode);\n    } END"}
{"prompt":"client Undo Reject Integration Test\n\n###\n\n","completion":"    @Test\n    public void clientUndoRejectIntegrationTest() {\n\n        \/\/ CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n        \/\/ Assertions.assertNotNull(clientId);\n\n        \/\/ GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.rejectClient(clientId);\n        ClientStatusChecker.verifyClientRejected(status);\n\n        status = this.clientHelper.undoReject(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n\n    } END"}
{"prompt":"test Client Undo Reject With Date Before Reject Date\n\n###\n\n","completion":"    @Test\n    public void testClientUndoRejectWithDateBeforeRejectDate() {\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n\n        \/\/ CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/\/ GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.rejectClient(clientId);\n        ClientStatusChecker.verifyClientRejected(status);\n\n        ArrayList<HashMap<String, Object>> clientErrorData = validationErrorHelper.undoRejectedclient(clientId,\n                CommonConstants.RESPONSE_ERROR, ClientHelper.CREATED_DATE);\n        assertEquals(\"error.msg.client.reopened.date.cannot.before.client.rejected.date\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        status = this.clientHelper.undoReject(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" } END"}
{"prompt":"test Client Undo Reject Without Reject\n\n###\n\n","completion":"    @Test\n    public void testClientUndoRejectWithoutReject() {\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n\n        \/\/ CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/\/ GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientPending(status);\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        final String undoRejectDate = todaysDate.format(Utils.dateFormatter);\n\n        ArrayList<HashMap<String, Object>> clientErrorData = validationErrorHelper.undoRejectedclient(clientId,\n                CommonConstants.RESPONSE_ERROR, undoRejectDate);\n        assertEquals(\"error.msg.client.undorejection.on.nonrejected.account\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientPending(status);\n\n    } END"}
{"prompt":"test Client Undo Reject With Future Date\n\n###\n\n","completion":"    @Test\n    public void testClientUndoRejectWithFutureDate() {\n\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n\n        \/\/ CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/\/ GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.rejectClient(clientId);\n        ClientStatusChecker.verifyClientRejected(status);\n        LocalDate tomorrowsDate = Utils.getLocalDateOfTenant().plusDays(1);\n        final String undoRejectDate = tomorrowsDate.format(Utils.dateFormatter);\n        ArrayList<HashMap<String, Object>> clientErrorData = validationErrorHelper.undoRejectedclient(clientId,\n                CommonConstants.RESPONSE_ERROR, undoRejectDate);\n        assertEquals(\"validation.msg.client.reopenedDate.is.greater.than.date\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        status = this.clientHelper.undoReject(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n\n    } END"}
{"prompt":"client Undo With Drawn Integration Test\n\n###\n\n","completion":"    @Test\n    public void clientUndoWithDrawnIntegrationTest() {\n\n        \/\/ CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/\/ GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(status);\n\n        status = this.clientHelper.undoWithdrawn(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n\n    } END"}
{"prompt":"test Client Undo With Drawn With Date Before Withdrawal\n\n###\n\n","completion":"    @Test\n    public void testClientUndoWithDrawnWithDateBeforeWithdrawal() {\n\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n\n        \/\/ CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/\/ GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(status);\n\n        ArrayList<HashMap<String, Object>> clientErrorData = validationErrorHelper.undoWithdrawclient(clientId,\n                CommonConstants.RESPONSE_ERROR, ClientHelper.CREATED_DATE);\n        assertEquals(\"error.msg.client.reopened.date.cannot.before.client.withdrawal.date\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        status = this.clientHelper.undoWithdrawn(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" } END"}
{"prompt":"test Client Undo With Drawn Without Withdrawal\n\n###\n\n","completion":"    @Test\n    public void testClientUndoWithDrawnWithoutWithdrawal() {\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n        \/\/ CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/\/ GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        final String undoWithdrawDate = todaysDate.format(Utils.dateFormatter);\n\n        ArrayList<HashMap<String, Object>> clientErrorData = validationErrorHelper.undoWithdrawclient(clientId,\n                CommonConstants.RESPONSE_ERROR, undoWithdrawDate);\n        assertEquals(\"error.msg.client.undoWithdrawal.on.nonwithdrawal.account\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientPending(status);\n\n    } END"}
{"prompt":"test Client Undo With Drawn With Future Date\n\n###\n\n","completion":"    @Test\n    public void testClientUndoWithDrawnWithFutureDate() {\n\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n\n        \/\/ CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/\/ GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(status);\n        LocalDate tomorrowsDate = Utils.getLocalDateOfTenant().plusDays(1);\n        final String undoWithdrawDate = tomorrowsDate.format(Utils.dateFormatter);\n        ArrayList<HashMap<String, Object>> clientErrorData = validationErrorHelper.undoWithdrawclient(clientId,\n                CommonConstants.RESPONSE_ERROR, undoWithdrawDate);\n        assertEquals(\"validation.msg.client.reopenedDate.is.greater.than.date\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        status = this.clientHelper.undoWithdrawn(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" } END"}
{"prompt":"test Validate Reopened Date\n\n###\n\n","completion":"    @Test\n    public void testValidateReopenedDate() {\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n\n        \/\/ CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n        \/\/ GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(status);\n        status = this.clientHelper.undoWithdrawn(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n        ArrayList<HashMap<String, Object>> clientErrorData = validationErrorHelper.activateClient(clientId, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.clients.submittedOnDate.after.reopened.date\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    } END"}
{"prompt":"test Reopened Date\n\n###\n\n","completion":"    @Test\n    public void testReopenedDate() {\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n        \/\/ final ClientHelper validationErrorHelper = new\n        \/\/ ClientHelper(this.requestSpec, errorResponse);\n\n        \/\/ CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n        \/\/ GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(status);\n        status = this.clientHelper.undoWithdrawn(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n        status = this.clientHelper.activateClientWithDiffDateOption(clientId, ClientHelper.CREATED_DATE_PLUS_TWO);\n\n    } END"}
{"prompt":"create Collateral Product Test\n\n###\n\n","completion":"    @Test\n    public void createCollateralProductTest() {\n        LOG.info(\"-------------------------Creating Collateral Product---------------------------\");\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n    } END"}
{"prompt":"update Collateral Product Test\n\n###\n\n","completion":"    @Test\n    public void updateCollateralProductTest() {\n        LOG.info(\"-------------------------Updating Collateral Product---------------------------\");\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer resourceId = CollateralManagementHelper.updateCollateralProduct(this.requestSpec, this.responseSpec, collateralId);\n\n        Assertions.assertEquals(collateralId, resourceId);\n    } END"}
{"prompt":"verify Concurrent Loan Repayments\n\n###\n\n","completion":"    @Test\n    public void verifyConcurrentLoanRepayments() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(false, NO_ACCOUNTING);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"12,000.00\");\n        this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID, \"12,000.00\",\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        ExecutorService executor = Executors.newFixedThreadPool(MYTHREADS);\n        Calendar date = Calendar.getInstance();\n        date.set(2011, 9, 20);\n        Float repaymentAmount = 100.0f;\n        for (int i = 0; i < 10; i++) {\n            LOG.info(\"Starting concurrent transaction number {}\", i);\n            date.add(Calendar.DAY_OF_MONTH, 1);\n            repaymentAmount = repaymentAmount + 100;\n            Runnable worker = new LoanRepaymentExecutor(loanTransactionHelper, loanID, repaymentAmount, date);\n            executor.execute(worker);\n        }\n\n        executor.shutdown();\n        \/\/ Wait until all threads are finish\n        while (!executor.isTerminated()) {\n\n        }\n        LOG.info(\"\\nFinished all threads\");\n\n    } END"}
{"prompt":"credit Bureau Configuration Test\n\n###\n\n","completion":"    @Test\n    public void creditBureauConfigurationTest() {\n\n        \/\/ create creditBureauConfiguration\n        final Integer configurationId = CreditBureauConfigurationHelper.createCreditBureauConfiguration(this.requestSpec, this.responseSpec,\n                Utils.randomStringGenerator(\"testConfigKey_\", 5));\n        Assertions.assertNotNull(configurationId);\n\n        \/\/ update creditBureauConfiguration\n        final String updateconfiguration = CreditBureauConfigurationHelper.updateCreditBureauConfiguration(this.requestSpec,\n                this.responseSpec, configurationId);\n\n        Assertions.assertEquals(\"updateConfigKeyValue\", updateconfiguration);\n    } END"}
{"prompt":"credit Bureau Integration Test\n\n###\n\n","completion":"    @Test\n    public void creditBureauIntegrationTest() throws JsonProcessingException {\n        ObjectNode jsonResponse = MAPPER.createObjectNode();\n        jsonResponse.put(\"access_token\", \"AccessToken\");\n        jsonResponse.put(\"expires_in\", 3600);\n        jsonResponse.put(\"token_type\", \"Bearer\");\n        jsonResponse.put(\"userName\", \"testUser\");\n        jsonResponse.put(\".issued\", \"sample\");\n        jsonResponse.put(\".expires\", ZonedDateTime.now(ZoneId.systemDefault()).plusSeconds(3600)\n                .format(new DateTimeFormatterBuilder().appendPattern(\"EEE, dd MMM yyyy kk:mm:ss zzz\").toFormatter()));\n        wm.stubFor(WireMock.post(\"\/token\/\").willReturn(WireMock.jsonResponse(MAPPER.writeValueAsString(jsonResponse), 200)));\n        wm.stubFor(WireMock.post(\"\/search\/NRC213\")\n                .willReturn(WireMock.jsonResponse(\"{\\\"ResponseMessage\\\":\\\"OK\\\",\\\"Data\\\":[{\\\"UniqueID\\\":\\\"123456\\\"}]}\", 200)));\n        wm.stubFor(WireMock.get(\"\/report\/123456\").willReturn(\n                WireMock.jsonResponse(\"{\\\"ResponseMessage\\\":\\\"OK\\\",\\\"Data\\\":{\" + \"\\\"BorrowerInfo\\\":{\" + \"\\\"Name\\\":\\\"Test Name\\\",\"\n                        + \"\\\"Gender\\\":\\\"male\\\",\" + \"\\\"Address\\\":\\\"Test Address\\\"\" + \"},\" + \"\\\"CreditScore\\\": {\\\"Score\\\":  \\\"500\\\"},\"\n                        + \"\\\"ActiveLoans\\\": [\\\"Loan1\\\", \\\"Loan2\\\"],\" + \"\\\"WriteOffLoans\\\": [\\\"Loan3\\\", \\\"Loan4\\\"]\" + \"}}\", 200)));\n\n        Object serviceResult = CreditBureauIntegrationHelper.getCreditReport(this.requestSpec, this.responseSpec, \"1\", \"NRC213\");\n        Assertions.assertNotNull(serviceResult);\n        Gson gson = new Gson();\n        CreditBureauReportData responseData = gson.fromJson(\n                gson.toJson(JsonParser.parseString(String.valueOf(serviceResult)).getAsJsonObject().get(\"creditBureauReportData\")),\n                CreditBureauReportData.class);\n        Assertions.assertEquals(\"\\\"Test Name\\\"\", responseData.getName());\n        Assertions.assertEquals(\"{\\\"Score\\\":\\\"500\\\"}\", responseData.getCreditScore());\n\n        Assertions.assertEquals(\"\\\"male\\\"\", responseData.getGender());\n        Assertions.assertEquals(\"\\\"Test Address\\\"\", responseData.getAddress());\n\n        Assertions.assertEquals(2, responseData.getClosedAccounts().length);\n        Assertions.assertEquals(2, responseData.getOpenAccounts().length);\n        Assertions.assertEquals(\"\\\"Loan3\\\"\", responseData.getClosedAccounts()[0]);\n        Assertions.assertEquals(\"\\\"Loan4\\\"\", responseData.getClosedAccounts()[1]);\n        Assertions.assertEquals(\"\\\"Loan1\\\"\", responseData.getOpenAccounts()[0]);\n        Assertions.assertEquals(\"\\\"Loan2\\\"\", responseData.getOpenAccounts()[1]);\n    } END"}
{"prompt":"credit Bureau No Loan Test\n\n###\n\n","completion":"    @Test\n    public void creditBureauNoLoanTest() throws JsonProcessingException {\n        ObjectNode jsonResponse = MAPPER.createObjectNode();\n        jsonResponse.put(\"access_token\", \"AccessToken\");\n        jsonResponse.put(\"expires_in\", 3600);\n        jsonResponse.put(\"token_type\", \"Bearer\");\n        jsonResponse.put(\"userName\", \"testUser\");\n        jsonResponse.put(\".issued\", \"sample\");\n        jsonResponse.put(\".expires\", ZonedDateTime.now(ZoneId.systemDefault()).plusSeconds(3600)\n                .format(new DateTimeFormatterBuilder().appendPattern(\"EEE, dd MMM yyyy kk:mm:ss zzz\").toFormatter()));\n        wm.stubFor(WireMock.post(\"\/token\/\").willReturn(WireMock.jsonResponse(MAPPER.writeValueAsString(jsonResponse), 200)));\n        wm.stubFor(WireMock.post(\"\/search\/NRC213\")\n                .willReturn(WireMock.jsonResponse(\"{\\\"ResponseMessage\\\":\\\"OK\\\",\\\"Data\\\":[{\\\"UniqueID\\\":\\\"123456\\\"}]}\", 200)));\n        wm.stubFor(WireMock.get(\"\/report\/123456\")\n                .willReturn(WireMock.jsonResponse(\"{\\\"ResponseMessage\\\":\\\"OK\\\",\\\"Data\\\":{\" + \"\\\"BorrowerInfo\\\":{\"\n                        + \"\\\"Name\\\":\\\"Test Name\\\",\" + \"\\\"Gender\\\":\\\"male\\\",\" + \"\\\"Address\\\":\\\"Test Address\\\"\" + \"},\"\n                        + \"\\\"CreditScore\\\": {\\\"Score\\\":  \\\"500\\\"},\" + \"\\\"ActiveLoans\\\": [],\" + \"\\\"WriteOffLoans\\\": []\" + \"}}\", 200)));\n\n        Object serviceResult = CreditBureauIntegrationHelper.getCreditReport(this.requestSpec, this.responseSpec, \"1\", \"NRC213\");\n        Assertions.assertNotNull(serviceResult);\n        Gson gson = new Gson();\n        CreditBureauReportData responseData = gson.fromJson(\n                gson.toJson(JsonParser.parseString(String.valueOf(serviceResult)).getAsJsonObject().get(\"creditBureauReportData\")),\n                CreditBureauReportData.class);\n        Assertions.assertEquals(\"\\\"Test Name\\\"\", responseData.getName());\n        Assertions.assertEquals(\"{\\\"Score\\\":\\\"500\\\"}\", responseData.getCreditScore());\n\n        Assertions.assertEquals(\"\\\"male\\\"\", responseData.getGender());\n        Assertions.assertEquals(\"\\\"Test Address\\\"\", responseData.getAddress());\n\n        Assertions.assertEquals(0, responseData.getClosedAccounts().length);\n        Assertions.assertEquals(0, responseData.getOpenAccounts().length);\n    } END"}
{"prompt":"test Currency Elements\n\n###\n\n","completion":"    @Test\n    public void testCurrencyElements() {\n\n        CurrencyDomain currency = CurrenciesHelper.getCurrencybyCode(requestSpec, responseSpec, \"USD\");\n        CurrencyDomain usd = CurrencyDomain.create(\"USD\", \"US Dollar\", 2, \"$\", \"currency.USD\", \"US Dollar ($)\").build();\n\n        Assertions.assertTrue(currency.getDecimalPlaces() >= 0);\n        Assertions.assertNotNull(currency.getName());\n        Assertions.assertNotNull(currency.getDisplaySymbol());\n        Assertions.assertNotNull(currency.getDisplayLabel());\n        Assertions.assertNotNull(currency.getNameCode());\n\n        Assertions.assertEquals(usd, currency);\n    } END"}
{"prompt":"test Update Currency Selection\n\n###\n\n","completion":"    @Test\n    public void testUpdateCurrencySelection() {\n\n        \/\/ Test updation\n        ArrayList<String> currenciestoUpdate = new ArrayList<String>();\n        currenciestoUpdate.add(\"KES\");\n        currenciestoUpdate.add(\"BND\");\n        currenciestoUpdate.add(\"LBP\");\n        currenciestoUpdate.add(\"GHC\");\n        currenciestoUpdate.add(\"USD\");\n        currenciestoUpdate.add(\"INR\");\n\n        ArrayList<String> currenciesOutput = CurrenciesHelper.updateSelectedCurrencies(this.requestSpec, this.responseSpec,\n                currenciestoUpdate);\n        Assertions.assertNotNull(currenciesOutput);\n\n        Assertions.assertEquals(currenciestoUpdate, currenciesOutput, \"Verifying Do Outputed Currencies Match after Updation\");\n\n        \/\/ Test that output matches updation\n        ArrayList<CurrencyDomain> currenciesBeforeUpdate = new ArrayList<CurrencyDomain>();\n        for (String e : currenciestoUpdate) {\n            currenciesBeforeUpdate.add(CurrenciesHelper.getCurrencybyCode(requestSpec, responseSpec, e));\n        }\n        Collections.sort(currenciesBeforeUpdate);\n\n        ArrayList<CurrencyDomain> currenciesAfterUpdate = CurrenciesHelper.getSelectedCurrencies(requestSpec, responseSpec);\n        Assertions.assertNotNull(currenciesAfterUpdate);\n\n        Assertions.assertEquals(currenciesBeforeUpdate, currenciesAfterUpdate, \"Verifying Do Selected Currencies Match after Updation\");\n    } END"}
{"prompt":"test Loan Classification Step As Part Of COB\n\n###\n\n","completion":"    @Test\n    public void testLoanClassificationStepAsPartOfCOB() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            LocalDate bussinesLocalDate = Utils.getDateAsLocalDate(\"01 April 2012\");\n            log.info(\"Current date {}\", bussinesLocalDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, bussinesLocalDate);\n\n            \/\/ Given\n            final LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n\n            ArrayList<Integer> rangeIds = new ArrayList<>();\n            String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n            PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec,\n                    responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n            final GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                    delinquencyRangeResponse.getResourceId());\n            final String classificationExpected = range.getClassification();\n            log.info(\"Expected Delinquency Range classification {}\", classificationExpected);\n\n            jsonRange = DelinquencyRangesHelper.getAsJSON(4, 60);\n            delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n\n            String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n            PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                    responseSpec, jsonBucket);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketResponse.getResourceId());\n\n            \/\/ Client and Loan account creation\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                    delinquencyBucket.getId());\n            assertNotNull(getLoanProductsProductResponse);\n            log.info(\"Loan Product Bucket Name: {}\", getLoanProductsProductResponse.getDelinquencyBucket().getName());\n            assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n\n            \/\/ Older date to have more than one overdue installment\n            final LocalDate transactionDate = bussinesLocalDate.minusDays(31);\n            String operationDate = Utils.dateFormatter.format(transactionDate);\n\n            \/\/ Create Loan Account\n            final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                    getLoanProductsProductResponse.getId().toString(), operationDate);\n\n            \/\/ COB Step Validation\n            final JobBusinessStepConfigData jobBusinessStepConfigData = BusinessStepConfigurationHelper\n                    .getConfiguredBusinessStepsByJobName(requestSpec, responseSpec, BusinessConfigurationApiTest.LOAN_JOB_NAME);\n            assertNotNull(jobBusinessStepConfigData);\n            assertEquals(BusinessConfigurationApiTest.LOAN_JOB_NAME, jobBusinessStepConfigData.getJobName());\n            assertTrue(jobBusinessStepConfigData.getBusinessSteps().size() > 0);\n            assertTrue(jobBusinessStepConfigData.getBusinessSteps().stream().anyMatch(\n                    businessStep -> BusinessConfigurationApiTest.LOAN_DELINQUENCY_CLASSIFICATION.equals(businessStep.getStepName())));\n\n            \/\/ Run first time the Loan COB Job\n            final String jobName = \"Loan COB\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            \/\/ Get loan details expecting to have not a delinquency classification\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            final GetDelinquencyRangesResponse firstTestCase = getLoansLoanIdResponse.getDelinquencyRange();\n            log.info(\"Loan Delinquency Range is null {}\", (firstTestCase == null));\n            GetLoansLoanIdRepaymentSchedule getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n            if (getLoanRepaymentSchedule != null) {\n                log.info(\"Loan with {} periods\", getLoanRepaymentSchedule.getPeriods().size());\n                for (GetLoansLoanIdRepaymentPeriod period : getLoanRepaymentSchedule.getPeriods()) {\n                    log.info(\"Period number {} for due date {} and outstanding {}\", period.getPeriod(), period.getDueDate(),\n                            period.getTotalOutstandingForPeriod());\n                }\n            }\n\n            \/\/ Move the Business date to get older the loan and to have an overdue loan\n            LocalDate lastLoanCOBBusinessDate = bussinesLocalDate;\n            bussinesLocalDate = bussinesLocalDate.plusDays(3);\n            schedulerJobHelper.fastForwardTime(lastLoanCOBBusinessDate, bussinesLocalDate, jobName, responseSpec);\n            log.info(\"Current date {}\", bussinesLocalDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, bussinesLocalDate);\n            \/\/ Run Second time the Job\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            \/\/ Get loan details expecting to have a delinquency classification\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n            final GetDelinquencyRangesResponse secondTestCase = getLoansLoanIdResponse.getDelinquencyRange();\n            assertNotNull(secondTestCase);\n            log.info(\"Loan Delinquency Range is {}\", secondTestCase.getClassification());\n\n            \/\/ Then\n            assertNotNull(delinquencyBucketResponse);\n            assertNotNull(getLoanProductsProductResponse);\n            assertNull(firstTestCase);\n            assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n            assertEquals(secondTestCase.getClassification(), classificationExpected);\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Loan Classification Step As Part Of COBRepeated\n\n###\n\n","completion":"    @Test\n    public void testLoanClassificationStepAsPartOfCOBRepeated() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            List<LocalDate> expectedDates = new ArrayList();\n\n            LocalDate businessDate = LocalDate.parse(\"2022-01-01\", DateUtils.DEFAULT_DATE_FORMATTER);\n            log.info(\"Current Business date {}\", businessDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n            \/\/ Delinquency Bucket\n            final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketId);\n\n            \/\/ Client and Loan account creation\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                    delinquencyBucket.getId());\n            assertNotNull(getLoanProductsProductResponse);\n\n            \/\/ Older date to have more than one overdue installment\n            String operationDate = Utils.dateFormatter.format(businessDate);\n            log.info(\"Operation date  {}\", businessDate);\n\n            \/\/ Create Loan Account\n            final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                    getLoanProductsProductResponse.getId().toString(), operationDate, \"3\");\n\n            \/\/ Move the Business date 1 month to apply the first repayment\n            businessDate = businessDate.plusMonths(1);\n            expectedDates.add(businessDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n            log.info(\"Current Business date {}\", businessDate);\n\n            String amountVal = \"400.00\";\n            Float transactionAmount = Float.valueOf(amountVal);\n            operationDate = Utils.dateFormatter.format(businessDate);\n            PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate,\n                    transactionAmount, loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            Long transactionId = loanIdTransactionsResponse.getResourceId();\n            loanTransactionHelper.reviewLoanTransactionRelations(loanId, transactionId, 0);\n\n            \/\/ Move the Business date 1 month more to apply the second repayment\n            businessDate = businessDate.plusMonths(1);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n            log.info(\"Current Business date {}\", businessDate);\n\n            operationDate = Utils.dateFormatter.format(businessDate);\n            expectedDates.add(businessDate);\n            loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, transactionAmount, loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            transactionId = loanIdTransactionsResponse.getResourceId();\n            loanTransactionHelper.reviewLoanTransactionRelations(loanId, transactionId, 0);\n\n            \/\/ Get loan details expecting to have not a delinquency classification and 1,000 as Outstanding\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            validateLoanAccount(getLoansLoanIdResponse, \"0.00\", \"400.00\", 0, doubleZERO);\n\n            \/\/ Move the Business date n days to apply the chargeback for the previous repayment\n            businessDate = businessDate.plusDays(15);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n            log.info(\"Current Business date {}\", businessDate);\n\n            \/\/ Apply the Chargeback transaction\n            final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, amountVal, 0,\n                    responseSpec);\n            loanTransactionHelper.reviewLoanTransactionRelations(loanId, transactionId, 1);\n\n            \/\/ Validate the account expecting to have an adjustment for 100.00 and Outstanding 1,100\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            \/\/ Past Due Days in Zero because the Charge back transaction exists and It was done with the current date\n            validateLoanAccount(getLoansLoanIdResponse, amountVal, \"800.00\", 0, Double.valueOf(\"0.00\"));\n\n            \/\/ Move the Business date n days to run the COB\n            businessDate = businessDate.plusDays(23);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n            log.info(\"Current Business date {}\", businessDate);\n\n            \/\/ Run the Loan COB Job\n            final String jobName = \"Loan COB\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            \/\/ Get loan details expecting to have a delinquency classification\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            validateLoanAccount(getLoansLoanIdResponse, amountVal, \"800.00\", 23, Double.valueOf(\"800.00\"));\n\n            \/\/ Move the Business date few days to apply the repayment for Chargeback\n            businessDate = LocalDate.parse(\"2022-03-20\", DateUtils.DEFAULT_DATE_FORMATTER);\n            expectedDates.add(businessDate);\n            operationDate = Utils.dateFormatter.format(businessDate);\n            loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, transactionAmount, loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            transactionId = loanIdTransactionsResponse.getResourceId();\n            loanTransactionHelper.reviewLoanTransactionRelations(loanId, transactionId, 0);\n\n            \/\/ Get loan details expecting to have a delinquency classification\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            validateLoanAccount(getLoansLoanIdResponse, amountVal, \"400.00\", 7, Double.valueOf(\"400.00\"));\n\n            \/\/ Pay the Loan to get this as Closed\n            loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, transactionAmount, loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertEquals(LoanStatus.CLOSED_OBLIGATIONS_MET.getValue(), getLoansLoanIdResponse.getStatus().getId());\n            log.info(\"Loan id {} with status {}\", loanId, getLoansLoanIdResponse.getStatus().getCode());\n\n            \/\/ Evaluate Installments\n            GetLoansLoanIdRepaymentSchedule getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n            assertNotNull(getLoanRepaymentSchedule);\n            log.info(\"Loan with {} periods\", getLoanRepaymentSchedule.getPeriods().size());\n\n            for (GetLoansLoanIdRepaymentPeriod period : getLoanRepaymentSchedule.getPeriods()) {\n                if (period.getPeriod() != null) {\n                    log.info(\"Period number {} completed on date {}\", period.getPeriod(), period.getObligationsMetOnDate());\n                    assertNotNull(period.getObligationsMetOnDate());\n                    assertEquals(expectedDates.get(period.getPeriod() - 1), period.getObligationsMetOnDate());\n                    assertTrue(period.getComplete());\n                }\n            }\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Create Delinquency Ranges\n\n###\n\n","completion":"    @Test\n    public void testCreateDelinquencyRanges() {\n        \/\/ given\n        final String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n\n        \/\/ when\n        final PostDelinquencyRangeResponse delinquencyRangeResponse01 = DelinquencyRangesHelper.createDelinquencyRange(requestSpec,\n                responseSpec, jsonRange);\n        final ArrayList<GetDelinquencyRangesResponse> ranges = DelinquencyRangesHelper.getDelinquencyRanges(requestSpec, responseSpec);\n\n        \/\/ then\n        assertNotNull(delinquencyRangeResponse01);\n        assertNotNull(ranges);\n        assertEquals(1, ranges.get(0).getMinimumAgeDays(), \"Expected Min Age Days to 1\");\n        assertEquals(3, ranges.get(0).getMaximumAgeDays(), \"Expected Max Age Days to 3\");\n    } END"}
{"prompt":"test Update Delinquency Ranges\n\n###\n\n","completion":"    @Test\n    public void testUpdateDelinquencyRanges() {\n        \/\/ given\n        String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n        final PostDelinquencyRangeResponse delinquencyRangeResponse01 = DelinquencyRangesHelper.createDelinquencyRange(requestSpec,\n                responseSpec, jsonRange);\n        jsonRange = DelinquencyRangesHelper.getAsJSON(1, 7);\n        assertNotNull(delinquencyRangeResponse01);\n\n        \/\/ when\n        final PutDelinquencyRangeResponse delinquencyRangeResponse02 = DelinquencyRangesHelper.updateDelinquencyRange(requestSpec,\n                responseSpec, delinquencyRangeResponse01.getResourceId(), jsonRange);\n        final GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                delinquencyRangeResponse01.getResourceId());\n        final DeleteDelinquencyRangeResponse deleteDelinquencyRangeResponse = DelinquencyRangesHelper.deleteDelinquencyRange(requestSpec,\n                responseSpec, delinquencyRangeResponse01.getResourceId());\n\n        \/\/ then\n        assertNotNull(delinquencyRangeResponse02);\n        assertNotNull(deleteDelinquencyRangeResponse);\n        assertNotNull(range);\n        assertNotEquals(3, range.getMaximumAgeDays());\n        assertEquals(1, range.getMinimumAgeDays());\n        assertEquals(7, range.getMaximumAgeDays());\n    } END"}
{"prompt":"test Delinquency Buckets\n\n###\n\n","completion":"    @Test\n    public void testDelinquencyBuckets() {\n        \/\/ given\n        ArrayList<Integer> rangeIds = new ArrayList<>();\n        String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n        PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec,\n                jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        jsonRange = DelinquencyRangesHelper.getAsJSON(4, 30);\n        \/\/ Create\n        delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n        PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                responseSpec, jsonBucket);\n        \/\/ Update\n        jsonRange = DelinquencyRangesHelper.getAsJSON(31, 60);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n        PutDelinquencyBucketResponse updateDelinquencyBucketResponse = DelinquencyBucketsHelper.updateDelinquencyBucket(requestSpec,\n                responseSpec, delinquencyBucketResponse.getResourceId(), jsonBucket);\n        delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        \/\/ Read\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketResponse.getResourceId());\n\n        \/\/ when\n        final ArrayList<GetDelinquencyBucketsResponse> bucketList = DelinquencyBucketsHelper.getDelinquencyBuckets(requestSpec,\n                responseSpec);\n\n        \/\/ then\n        assertNotNull(bucketList);\n        assertNotNull(delinquencyBucket);\n        assertEquals(2, delinquencyBucket.getRanges().size());\n        assertNotNull(delinquencyBucketResponse);\n        assertNotNull(updateDelinquencyBucketResponse);\n    } END"}
{"prompt":"test Delinquency Bucket Delete\n\n###\n\n","completion":"    @Test\n    public void testDelinquencyBucketDelete() {\n        \/\/ given\n        ArrayList<Integer> rangeIds = new ArrayList<>();\n        String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n        PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec,\n                jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        jsonRange = DelinquencyRangesHelper.getAsJSON(4, 30);\n        \/\/ Create\n        delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n        PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                responseSpec, jsonBucket);\n        \/\/ Delete\n        DeleteDelinquencyBucketResponse deleteDelinquencyBucketResponse = DelinquencyBucketsHelper.deleteDelinquencyBucket(requestSpec,\n                responseSpec, delinquencyBucketResponse.getResourceId());\n\n        \/\/ when\n        final ArrayList<GetDelinquencyBucketsResponse> bucketList = DelinquencyBucketsHelper.getDelinquencyBuckets(requestSpec,\n                responseSpec);\n\n        \/\/ then\n        assertNotNull(bucketList);\n        assertNotNull(delinquencyBucketResponse);\n        assertNotNull(deleteDelinquencyBucketResponse);\n    } END"}
{"prompt":"test Delinquency Buckets Range Age Overlaped\n\n###\n\n","completion":"    @Test\n    public void testDelinquencyBucketsRangeAgeOverlaped() {\n        \/\/ Given\n        ArrayList<Integer> rangeIds = new ArrayList<>();\n        String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n        PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec,\n                jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        jsonRange = DelinquencyRangesHelper.getAsJSON(3, 30);\n        \/\/ Create\n        delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n        final ResponseSpecification response403Spec = new ResponseSpecBuilder().expectStatusCode(403).build();\n\n        \/\/ When\n        DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, response403Spec, jsonBucket);\n    } END"}
{"prompt":"test Delinquency Buckets Name Duplication\n\n###\n\n","completion":"    @Test\n    public void testDelinquencyBucketsNameDuplication() {\n        \/\/ Given\n        ArrayList<Integer> rangeIds = new ArrayList<>();\n        String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n        PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec,\n                jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        jsonRange = DelinquencyRangesHelper.getAsJSON(4, 30);\n        \/\/ Create\n        delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n        final ResponseSpecification response403Spec = new ResponseSpecBuilder().expectStatusCode(403).build();\n\n        \/\/ When\n        DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec, jsonBucket);\n\n        \/\/ Then\n        DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, response403Spec, jsonBucket);\n    } END"}
{"prompt":"test Loan Classification Realtime\n\n###\n\n","completion":"    @Test\n    public void testLoanClassificationRealtime() {\n        try {\n            \/\/ Given\n            final LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            final LocalDate bussinesLocalDate = Utils.getDateAsLocalDate(\"01 March 2012\");\n            log.info(\"Current date {}\", bussinesLocalDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, bussinesLocalDate);\n            final BusinessDateResponse businessDateResponse = this.businessDateHelper.getBusinessDateByType(requestSpec, responseSpec,\n                    BusinessDateType.BUSINESS_DATE);\n\n            ArrayList<Integer> rangeIds = new ArrayList<>();\n            \/\/ First Range\n            String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n            PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec,\n                    responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n            jsonRange = DelinquencyRangesHelper.getAsJSON(4, 60);\n\n            GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                    delinquencyRangeResponse.getResourceId());\n\n            \/\/ Second Range\n            delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n\n            range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec, delinquencyRangeResponse.getResourceId());\n            final String classificationExpected = range.getClassification();\n            log.info(\"Expected Delinquency Range classification after Disbursement {}\", classificationExpected);\n\n            String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n            PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                    responseSpec, jsonBucket);\n            assertNotNull(delinquencyBucketResponse);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketResponse.getResourceId());\n\n            \/\/ Client and Loan account creation\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                    delinquencyBucket.getId());\n            assertNotNull(getLoanProductsProductResponse);\n            log.info(\"Loan Product Bucket Name: {}\", getLoanProductsProductResponse.getDelinquencyBucket().getName());\n            assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n\n            \/\/ Older date to have more than one overdue installment\n            final LocalDate transactionDate = bussinesLocalDate.minusDays(50);\n            String operationDate = Utils.dateFormatter.format(transactionDate);\n\n            \/\/ Create Loan Account\n            final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                    getLoanProductsProductResponse.getId().toString(), operationDate);\n\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            assertNotNull(getLoansLoanIdResponse.getDelinquencyRange());\n            log.info(\"Loan Delinquency Range after Disbursement {}\", getLoansLoanIdResponse.getDelinquencyRange().getClassification());\n            \/\/ First Loan Delinquency Classification after Disbursement command\n            assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected);\n\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            \/\/ Apply a partial repayment\n            operationDate = Utils.dateFormatter.format(bussinesLocalDate);\n            loanTransactionHelper.makeLoanRepayment(operationDate, 100.0f, loanId);\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            log.info(\"Loan Delinquency Range after Repayment {}\", getLoansLoanIdResponse.getDelinquencyRange());\n            assertNotNull(getLoansLoanIdResponse.getDelinquencyRange());\n            \/\/ First Loan Delinquency Classification remains after Repayment because the installment is not fully paid\n            assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected);\n\n            \/\/ Apply a repayment to get a full paid installment\n            loanTransactionHelper.makeLoanRepayment(operationDate, 1000.0f, loanId);\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            log.info(\"Loan Delinquency Range after Repayment {}\", getLoansLoanIdResponse.getDelinquencyRange());\n            assertNotNull(getLoansLoanIdResponse);\n            \/\/ The Loan Delinquency Classification after Repayment command must be null\n            assertNull(getLoansLoanIdResponse.getDelinquencyRange());\n            \/\/ Get the Delinquency Tags\n            ArrayList<GetDelinquencyTagHistoryResponse> getDelinquencyTagsHistory = loanTransactionHelper\n                    .getLoanDelinquencyTags(requestSpec, responseSpec, loanId);\n            assertNotNull(getDelinquencyTagsHistory);\n            log.info(\"Delinquency Tag History items {}\", getDelinquencyTagsHistory.size());\n            assertEquals(1, getDelinquencyTagsHistory.size());\n            assertNotNull(getDelinquencyTagsHistory.get(0).getLiftedOnDate());\n            assertEquals(getDelinquencyTagsHistory.get(0).getAddedOnDate(), businessDateResponse.getDate());\n            assertEquals(getDelinquencyTagsHistory.get(0).getLiftedOnDate(), businessDateResponse.getDate());\n            assertEquals(getDelinquencyTagsHistory.get(0).getDelinquencyRange().getClassification(), classificationExpected);\n            log.info(\"Delinquency Tag Item with Lifted On {}\", getDelinquencyTagsHistory.get(0).getLiftedOnDate());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Loan Classification Realtime With Charges\n\n###\n\n","completion":"    @Test\n    public void testLoanClassificationRealtimeWithCharges() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            final LocalDate bussinesLocalDate = Utils.getDateAsLocalDate(\"01 April 2012\");\n            log.info(\"Current date {}\", bussinesLocalDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, bussinesLocalDate);\n\n            \/\/ Given\n            final LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n            ArrayList<Integer> rangeIds = new ArrayList<>();\n            \/\/ First Range\n            String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n            PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec,\n                    responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n            jsonRange = DelinquencyRangesHelper.getAsJSON(4, 60);\n\n            GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                    delinquencyRangeResponse.getResourceId());\n\n            \/\/ Second Range\n            delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n\n            range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec, delinquencyRangeResponse.getResourceId());\n            final String classificationExpected = range.getClassification();\n            log.info(\"Expected Delinquency Range classification after Disbursement {}\", classificationExpected);\n\n            String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n            PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                    responseSpec, jsonBucket);\n            assertNotNull(delinquencyBucketResponse);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketResponse.getResourceId());\n\n            \/\/ Client and Loan account creation\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                    delinquencyBucket.getId());\n            assertNotNull(getLoanProductsProductResponse);\n            log.info(\"Loan Product Bucket Name: {}\", getLoanProductsProductResponse.getDelinquencyBucket().getName());\n            assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n\n            \/\/ Older date to have more than one overdue installment\n            LocalDate transactionDate = bussinesLocalDate.minusMonths(2).minusDays(5);\n            String operationDate = Utils.dateFormatter.format(transactionDate);\n\n            \/\/ Create Loan Account\n            final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                    getLoanProductsProductResponse.getId().toString(), operationDate);\n\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            log.info(\"Loan Delinquency Range after Disbursement {}\", getLoansLoanIdResponse.getDelinquencyRange().getClassification());\n            assertNotNull(getLoansLoanIdResponse);\n            \/\/ First Loan Delinquency Classification after Disbursement command\n            assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected);\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            \/\/ Apply a repayment to get a full paid installment\n            operationDate = Utils.dateFormatter.format(bussinesLocalDate);\n            loanTransactionHelper.makeLoanRepayment(operationDate, 2049.99f, loanId);\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            \/\/ The Loan Delinquency Classification after Repayment command must be null\n            log.info(\"Loan Delinquency Range after Repayment {}\", getLoansLoanIdResponse.getDelinquencyRange());\n            assertNull(getLoansLoanIdResponse.getDelinquencyRange());\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            transactionDate = bussinesLocalDate.minusDays(18);\n            operationDate = Utils.dateFormatter.format(transactionDate);\n\n            \/\/ Create and apply Charge for Specific Due Date\n            final Integer chargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(1, \"30\", false));\n            assertNotNull(chargeId);\n            final Integer loanChargeId = loanTransactionHelper.addChargesForLoan(loanId, getChargeApplyJSON(chargeId, operationDate),\n                    responseSpec);\n            assertNotNull(loanChargeId);\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            log.info(\"Loan Delinquency Range after add Loan Charge {}\", getLoansLoanIdResponse.getDelinquencyRange());\n            assertNotNull(getLoansLoanIdResponse.getDelinquencyRange());\n            \/\/ Evaluate a Delinquency Tag set after add charge to the Loan\n            assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected);\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Loan Classification Realtime Older Loan\n\n###\n\n","completion":"    @Test\n    public void testLoanClassificationRealtimeOlderLoan() {\n\n        \/\/ Given\n        final LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        ArrayList<Integer> rangeIds = new ArrayList<>();\n        \/\/ First Range\n        String jsonRange = DelinquencyRangesHelper.getAsJSON(4, 30);\n        PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec,\n                jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                delinquencyRangeResponse.getResourceId());\n        final String classificationExpected02 = range.getClassification();\n        log.info(\"Expected Delinquency Range classification after first repayment {}\", classificationExpected02);\n\n        \/\/ Second Range\n        jsonRange = DelinquencyRangesHelper.getAsJSON(31, 60);\n        delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n\n        range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec, delinquencyRangeResponse.getResourceId());\n        final String classificationExpected01 = range.getClassification();\n        log.info(\"Expected Delinquency Range classification after Disbursement {}\", classificationExpected01);\n\n        \/\/ Third Range\n        jsonRange = DelinquencyRangesHelper.getAsJSON(61, 90);\n        delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n\n        range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec, delinquencyRangeResponse.getResourceId());\n\n        String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n        PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                responseSpec, jsonBucket);\n        assertNotNull(delinquencyBucketResponse);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketResponse.getResourceId());\n\n        \/\/ Client and Loan account creation\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucket.getId());\n        assertNotNull(getLoanProductsProductResponse);\n        log.info(\"Loan Product Bucket Name: {}\", getLoanProductsProductResponse.getDelinquencyBucket().getName());\n        assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        \/\/ Older date to have more than one overdue installment\n        LocalDate transactionDate = todaysDate.minusDays(85);\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n\n        \/\/ Create Loan Account\n        final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                getLoanProductsProductResponse.getId().toString(), operationDate);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Delinquency Range after Disbursement in null? {}\", (getLoansLoanIdResponse.getDelinquencyRange() == null));\n        assertNotNull(getLoansLoanIdResponse.getDelinquencyRange());\n        log.info(\"Loan Delinquency Range after Disbursement {}\", getLoansLoanIdResponse.getDelinquencyRange());\n        \/\/ First Loan Delinquency Classification after Disbursement command\n        assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected01);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        \/\/ Apply a repayment to get a first full paid installment\n        transactionDate = todaysDate.minusDays(1);\n        operationDate = Utils.dateFormatter.format(transactionDate);\n        PostLoansLoanIdTransactionsResponse loansLoanIdTransactions = loanTransactionHelper.makeLoanRepayment(operationDate, 1050.0f,\n                loanId);\n        assertNotNull(loansLoanIdTransactions);\n        log.info(\"Loan repayment transaction id {}\", loansLoanIdTransactions.getResourceId());\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        log.info(\"Loan Delinquency Range after first Repayment {}\", getLoansLoanIdResponse.getDelinquencyRange());\n        assertNotNull(getLoansLoanIdResponse.getDelinquencyRange());\n        \/\/ First Loan Delinquency Classification remains after Repayment because the installment is not fully paid\n        assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected02);\n\n        ArrayList<GetDelinquencyTagHistoryResponse> getDelinquencyTagsHistory = loanTransactionHelper.getLoanDelinquencyTags(requestSpec,\n                responseSpec, loanId);\n        assertNotNull(getDelinquencyTagsHistory);\n        log.info(\"Delinquency Tag History items {}\", getDelinquencyTagsHistory.size());\n        log.info(\"Delinquency Tag Item with Lifted On {}\", getDelinquencyTagsHistory.get(0).getLiftedOnDate());\n        assertEquals(getDelinquencyTagsHistory.get(0).getAddedOnDate(), Utils.getLocalDateOfTenant());\n        assertEquals(getDelinquencyTagsHistory.get(0).getLiftedOnDate(), Utils.getLocalDateOfTenant());\n        assertEquals(getDelinquencyTagsHistory.get(0).getDelinquencyRange().getClassification(), classificationExpected01);\n        log.info(\"Loan Id {} with Loan status {}\", getLoansLoanIdResponse.getId(), getLoansLoanIdResponse.getStatus().getCode());\n\n        \/\/ Apply a repayment to get a second full paid installment\n        loansLoanIdTransactions = loanTransactionHelper.makeLoanRepayment(operationDate, 1020.0f, loanId);\n        assertNotNull(loansLoanIdTransactions);\n        log.info(\"Loan repayment transaction id {}\", loansLoanIdTransactions.getResourceId());\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        log.info(\"Loan Delinquency Range after second Repayment {}\", getLoansLoanIdResponse.getDelinquencyRange());\n        assertNotNull(getLoansLoanIdResponse);\n        \/\/ The Loan Delinquency Classification after Repayment command must be null\n        assertNull(getLoansLoanIdResponse.getDelinquencyRange());\n\n        getDelinquencyTagsHistory = loanTransactionHelper.getLoanDelinquencyTags(requestSpec, responseSpec, loanId);\n        assertNotNull(getDelinquencyTagsHistory);\n        log.info(\"Delinquency Tag History items {}\", getDelinquencyTagsHistory.size());\n        log.info(\"Delinquency Tag Item with Lifted On {}\", getDelinquencyTagsHistory.get(1).getLiftedOnDate());\n        assertEquals(getDelinquencyTagsHistory.get(1).getAddedOnDate(), Utils.getLocalDateOfTenant());\n        assertEquals(getDelinquencyTagsHistory.get(1).getLiftedOnDate(), Utils.getLocalDateOfTenant());\n        assertEquals(getDelinquencyTagsHistory.get(1).getDelinquencyRange().getClassification(), classificationExpected02);\n        log.info(\"Loan Id {} with final Loan status {}\", getLoansLoanIdResponse.getId(), getLoansLoanIdResponse.getStatus().getCode());\n    } END"}
{"prompt":"test Loan Classification Realtime With Reversed Repayment\n\n###\n\n","completion":"    @Test\n    public void testLoanClassificationRealtimeWithReversedRepayment() {\n        \/\/ Given\n        final LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        ArrayList<Integer> rangeIds = new ArrayList<>();\n        \/\/ First Range\n        String jsonRange = DelinquencyRangesHelper.getAsJSON(4, 30);\n        PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec,\n                jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                delinquencyRangeResponse.getResourceId());\n        final String classificationExpected = range.getClassification();\n        log.info(\"Expected Delinquency Range classification after first repayment {}\", classificationExpected);\n\n        String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n        PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                responseSpec, jsonBucket);\n        assertNotNull(delinquencyBucketResponse);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketResponse.getResourceId());\n\n        \/\/ Client and Loan account creation\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucket.getId());\n        assertNotNull(getLoanProductsProductResponse);\n        log.info(\"Loan Product Bucket Name: {}\", getLoanProductsProductResponse.getDelinquencyBucket().getName());\n        assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        log.info(\"Local date of Tenant: {}\", todaysDate);\n\n        \/\/ Older date to have more than one overdue installment\n        final LocalDate transactionDate = todaysDate.minusDays(50);\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n\n        \/\/ Create Loan Account\n        final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                getLoanProductsProductResponse.getId().toString(), operationDate);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n        loanTransactionHelper.printDelinquencyData(getLoansLoanIdResponse);\n\n        log.info(\"Loan Delinquency Range after Disbursement in null? {}\", (getLoansLoanIdResponse.getDelinquencyRange() == null));\n        assertNotNull(getLoansLoanIdResponse);\n        assertNotNull(getLoansLoanIdResponse.getDelinquencyRange());\n        log.info(\"Loan Delinquency Range after Disbursement {}\", getLoansLoanIdResponse.getDelinquencyRange());\n        \/\/ First Loan Delinquency Classification after Disbursement command\n        assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        \/\/ Apply a repayment to get a full paid installment\n        operationDate = Utils.dateFormatter.format(todaysDate);\n        PostLoansLoanIdTransactionsResponse loansLoanIdTransactions = loanTransactionHelper.makeLoanRepayment(operationDate, 1050.0f,\n                loanId);\n        assertNotNull(loansLoanIdTransactions);\n        log.info(\"Loan repayment transaction id {}\", loansLoanIdTransactions.getResourceId());\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        log.info(\"Loan Delinquency Range after Repayment {}\", getLoansLoanIdResponse.getDelinquencyRange());\n        \/\/ Loan Delinquency Classification removed after Repayment because the installment is fully paid\n        assertNull(getLoansLoanIdResponse.getDelinquencyRange());\n\n        ArrayList<GetDelinquencyTagHistoryResponse> getDelinquencyTagsHistory = loanTransactionHelper.getLoanDelinquencyTags(requestSpec,\n                responseSpec, loanId);\n        assertNotNull(getDelinquencyTagsHistory);\n        log.info(\"Delinquency Tag History items {}\", getDelinquencyTagsHistory.size());\n        log.info(\"Delinquency Tag Item with Lifted On {}\", getDelinquencyTagsHistory.get(0).getLiftedOnDate());\n        assertEquals(getDelinquencyTagsHistory.get(0).getAddedOnDate(), Utils.getLocalDateOfTenant());\n        assertEquals(getDelinquencyTagsHistory.get(0).getLiftedOnDate(), Utils.getLocalDateOfTenant());\n        assertEquals(getDelinquencyTagsHistory.get(0).getDelinquencyRange().getClassification(), classificationExpected);\n        log.info(\"Loan Id {} with Loan status {}\", getLoansLoanIdResponse.getId(), getLoansLoanIdResponse.getStatus().getCode());\n\n        \/\/ Reverse the Previous Loan Repayment\n        PostLoansLoanIdTransactionsResponse loansLoanIdReverseTransactions = loanTransactionHelper.reverseLoanTransaction(loanId,\n                loansLoanIdTransactions.getResourceId(), operationDate, responseSpec);\n        assertNotNull(loansLoanIdReverseTransactions);\n        log.info(\"Loan repayment reverse transaction id {}\", loansLoanIdReverseTransactions.getResourceId());\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        log.info(\"Loan Delinquency Range after Reverse Repayment {}\", getLoansLoanIdResponse.getDelinquencyRange());\n        \/\/ Loan Delinquency Classification goes back after Repayment because the installment is not paid\n        assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected);\n\n        getDelinquencyTagsHistory = loanTransactionHelper.getLoanDelinquencyTags(requestSpec, responseSpec, loanId);\n        assertNotNull(getDelinquencyTagsHistory);\n        log.info(\"Delinquency Tag History items {}\", getDelinquencyTagsHistory.size());\n        log.info(\"Delinquency Tag Item with Lifted On {}\", getDelinquencyTagsHistory.get(1).getLiftedOnDate());\n        assertEquals(getDelinquencyTagsHistory.get(1).getAddedOnDate(), Utils.getLocalDateOfTenant());\n        \/\/ Second record is open with liftedOn in null\n        assertNull(getDelinquencyTagsHistory.get(1).getLiftedOnDate());\n        assertEquals(getDelinquencyTagsHistory.get(1).getDelinquencyRange().getClassification(), classificationExpected);\n        log.info(\"Loan Id {} with final Loan status {}\", getLoansLoanIdResponse.getId(), getLoansLoanIdResponse.getStatus().getCode());\n    } END"}
{"prompt":"test Loan Classification Job\n\n###\n\n","completion":"    @Test\n    public void testLoanClassificationJob() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            LocalDate businessDate = Utils.getLocalDateOfTenant();\n            businessDate = businessDate.minusDays(37);\n            log.info(\"Current date {}\", businessDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n\n            final LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n\n            ArrayList<Integer> rangeIds = new ArrayList<>();\n            String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n            PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec,\n                    responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n            jsonRange = DelinquencyRangesHelper.getAsJSON(4, 60);\n            \/\/ Create\n            delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n\n            final GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                    delinquencyRangeResponse.getResourceId());\n            final String classificationExpected = range.getClassification();\n            log.info(\"Expected Delinquency Range classification {}\", classificationExpected);\n\n            String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n            PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                    responseSpec, jsonBucket);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketResponse.getResourceId());\n\n            \/\/ Client and Loan account creation\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                    delinquencyBucket.getId());\n            assertNotNull(getLoanProductsProductResponse);\n            log.info(\"Loan Product Bucket Name: {}\", getLoanProductsProductResponse.getDelinquencyBucket().getName());\n            assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n\n            final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n            \/\/ Older date to have more than one overdue installment\n            final LocalDate transactionDate = todaysDate.minusDays(57);\n            String operationDate = Utils.dateFormatter.format(transactionDate);\n\n            \/\/ Create Loan Account\n            final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                    getLoanProductsProductResponse.getId().toString(), operationDate);\n\n            \/\/ Run first time the Job\n            final String jobName = \"Loan Delinquency Classification\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            \/\/ Get loan details expecting to have not a delinquency classification\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.printDelinquencyData(getLoansLoanIdResponse);\n            final GetDelinquencyRangesResponse firstTestCase = getLoansLoanIdResponse.getDelinquencyRange();\n            log.info(\"Loan Delinquency Range is null {}\", (firstTestCase == null));\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            \/\/ Move the Business date to get older the loan and to have an overdue loan\n            businessDate = businessDate.plusMonths(1);\n            log.info(\"Current date {}\", businessDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n            \/\/ Run Second time the Job\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            \/\/ Get loan details expecting to have a delinquency classification\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n            loanTransactionHelper.printDelinquencyData(getLoansLoanIdResponse);\n\n            final GetDelinquencyRangesResponse secondTestCase = getLoansLoanIdResponse.getDelinquencyRange();\n            assertNotNull(secondTestCase);\n            log.info(\"Loan Delinquency Range is {}\", secondTestCase.getClassification());\n\n            \/\/ Then\n            assertNotNull(delinquencyBucketResponse);\n            assertNotNull(getLoanProductsProductResponse);\n            assertNull(firstTestCase);\n            assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n            assertEquals(secondTestCase.getClassification(), classificationExpected);\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Reschedule JLGLoan Synk\n\n###\n\n","completion":"    @Test\n    public void testRescheduleJLGLoanSynk() {\n        \/\/ system.out.println(\"---------------------------------STARTING\n        \/\/ RESCHEDULE JLG\n        \/\/ LOAN TEST ------------------------------------------\");\n\n        Calendar meetingCalendar = Calendar.getInstance();\n        meetingCalendar.setFirstDayOfWeek(Calendar.MONDAY);\n        meetingCalendar.setTime(new java.util.Date());\n\n        int today = meetingCalendar.get(Calendar.DAY_OF_WEEK);\n        \/\/ making sure that the meeting calendar is set for the coming monday.\n        if (today >= Calendar.MONDAY) {\n            meetingCalendar.add(Calendar.DAY_OF_YEAR, +(Calendar.MONDAY - today + 7));\n        } else {\n            meetingCalendar.add(Calendar.DAY_OF_YEAR, +(Calendar.MONDAY - today));\n        }\n\n        Calendar groupMeetingChangeCalendar = (Calendar) meetingCalendar.clone();\n\n        meetingCalendar.add(Calendar.WEEK_OF_YEAR, -3);\n\n        final String groupMeetingDate = this.dateFormatterStandard.format(meetingCalendar.getTime());\n\n        final String disbursalDate = groupMeetingDate; \/\/ first meeting date\n        \/\/ after group creation\n\n        final String rescheduleSubmittedDate = this.dateFormatterStandard.format(new java.util.Date());\n\n        final String loanType = \"jlg\";\n        final String rescheduleInterestRate = \"28.0\";\n        groupMeetingChangeCalendar.add(Calendar.DAY_OF_YEAR, 1);\n        final String groupMeetingNewStartDate = this.dateFormatterStandard.format(groupMeetingChangeCalendar.getTime());\n        \/\/ The date\n        \/\/ from\n        \/\/ which we\n        \/\/ start the\n        \/\/ new group\n        \/\/ meeting\n        \/\/ occasion,\n        \/\/ this is a\n        \/\/ tuesday.\n        groupMeetingChangeCalendar.add(Calendar.WEEK_OF_YEAR, 2);\n        final String rescheduleDate = this.dateFormatterStandard.format(groupMeetingChangeCalendar.getTime());\n\n        this.requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n        this.requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n        this.requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n        this.responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n        this.generalResponseSpec = new ResponseSpecBuilder().build();\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        this.loanRescheduleRequestHelper = new LoanRescheduleRequestHelper(this.requestSpec, this.responseSpec);\n        \/\/ system.out.println(\"---------------------------------CREATING\n        \/\/ ENTITIES AND\n        \/\/ JLG LOAN ------------------------------------------\");\n        \/\/ create all required entities\n        this.createRequiredEntitiesForJLGLoanSync(groupMeetingDate);\n\n        final String loanApplicationJSON = new LoanApplicationTestBuilder().withPrincipal(loanPrincipalAmount).withLoanTermFrequency(\"24\")\n                .withLoanTermFrequencyAsWeeks().withNumberOfRepayments(\"12\").withRepaymentEveryAfter(\"2\")\n                .withRepaymentFrequencyTypeAsMonths().withAmortizationTypeAsEqualInstallments().withInterestCalculationPeriodTypeAsDays()\n                .withInterestRatePerPeriod(interestRatePerPeriod).withRepaymentFrequencyTypeAsWeeks().withSubmittedOnDate(disbursalDate)\n                .withExpectedDisbursementDate(disbursalDate).withLoanType(loanType).withSyncDisbursementWithMeetin()\n                .withCalendarID(this.groupCalendarId.toString())\n                .build(this.clientId.toString(), this.groupId.toString(), this.loanProductId.toString(), null);\n\n        this.loanId = this.loanTransactionHelper.getLoanId(loanApplicationJSON);\n\n        \/\/ Test for loan account is created\n        Assertions.assertNotNull(this.loanId);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        \/\/ Test for loan account is created, can be approved\n        this.loanTransactionHelper.approveLoan(disbursalDate, this.loanId);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        \/\/ Test for loan account approved can be disbursed\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, this.loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(disbursalDate, this.loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        \/\/ system.out.println(\"---------------------------------CHANGING GROUP\n        \/\/ MEETING\n        \/\/ DATE ------------------------------------------\");\n        CalendarHelper.updateMeetingCalendarForGroup(this.requestSpec, this.responseSpec, this.groupId, this.groupCalendarId.toString(),\n                groupMeetingNewStartDate, \"2\", \"2\", \"2\"); \/\/ New\n                                                          \/\/ meeting\n                                                          \/\/ dates\n                                                          \/\/ will be\n                                                          \/\/ the\n                                                          \/\/ tuesday\n                                                          \/\/ after the\n        \/\/ coming\n        \/\/ monday\n\n        ArrayList loanRepaymnetSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, generalResponseSpec,\n                this.loanId);\n\n        ArrayList dueDateLoanSchedule = (ArrayList) ((HashMap) loanRepaymnetSchedule.get(2)).get(\"dueDate\");\n        Calendar dueDateCalendar = Calendar.getInstance();\n        dueDateCalendar.setFirstDayOfWeek(Calendar.MONDAY);\n        dueDateCalendar.set((Integer) dueDateLoanSchedule.get(0), (Integer) dueDateLoanSchedule.get(1) - 1,\n                (Integer) dueDateLoanSchedule.get(2));\n        assertEquals(3, dueDateCalendar.get(Calendar.DAY_OF_WEEK), \"AFTER MEETING CHANGE DATE THE NEXT REPAYMENT SHOULD BE ON TUESDAY\");\n\n        \/\/ system.out.println(\"---------------------------------CREATING LOAN\n        \/\/ RESCHEDULE\n        \/\/ REQUEST------------------------------------------\");\n\n        String requestJSON = new LoanRescheduleRequestTestBuilder().updateGraceOnInterest(\"2\").updateGraceOnPrincipal(\"2\")\n                .updateNewInterestRate(rescheduleInterestRate).updateRescheduleFromDate(rescheduleDate)\n                .updateSubmittedOnDate(rescheduleSubmittedDate).build(this.loanId.toString());\n\n        this.loanRescheduleRequestId = this.loanRescheduleRequestHelper.createLoanRescheduleRequest(requestJSON);\n        this.loanRescheduleRequestHelper.verifyCreationOfLoanRescheduleRequest(this.loanRescheduleRequestId);\n\n        loanRepaymnetSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, generalResponseSpec, this.loanId);\n        dueDateLoanSchedule = (ArrayList) ((HashMap) loanRepaymnetSchedule.get(2)).get(\"dueDate\");\n        dueDateCalendar.set((Integer) dueDateLoanSchedule.get(0), (Integer) dueDateLoanSchedule.get(1) - 1,\n                (Integer) dueDateLoanSchedule.get(2));\n        assertEquals(3, dueDateCalendar.get(Calendar.DAY_OF_WEEK),\n                \"AFTER MEETING CHANGE DATE THE NEXT REPAYMENT SHOULD BE ON TUESDAY, EVEN AFTER LOAN RESCHEDULE REQUEST WAS SENT\");\n\n        \/\/ system.out.println(\"Successfully created loan reschedule request (ID:\n        \/\/ \" +\n        \/\/ this.loanRescheduleRequestId + \")\");\n\n        \/\/ system.out.println(\"-----------------------------APPROVING LOAN\n        \/\/ RESCHEDULE\n        \/\/ REQUEST--------------------------\");\n\n        requestJSON = new LoanRescheduleRequestTestBuilder().updateSubmittedOnDate(rescheduleSubmittedDate)\n                .getApproveLoanRescheduleRequestJSON();\n        this.loanRescheduleRequestHelper.approveLoanRescheduleRequest(this.loanRescheduleRequestId, requestJSON);\n\n        final HashMap response = (HashMap) this.loanRescheduleRequestHelper.getLoanRescheduleRequest(loanRescheduleRequestId, \"statusEnum\");\n        assertTrue((Boolean) response.get(\"approved\"));\n\n        loanRepaymnetSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, generalResponseSpec, this.loanId);\n\n        dueDateLoanSchedule = (ArrayList) ((HashMap) loanRepaymnetSchedule.get(2)).get(\"dueDate\");\n        dueDateCalendar.set((Integer) dueDateLoanSchedule.get(0), (Integer) dueDateLoanSchedule.get(1) - 1,\n                (Integer) dueDateLoanSchedule.get(2));\n        assertEquals(3, dueDateCalendar.get(Calendar.DAY_OF_WEEK),\n                \"AFTER MEETING CHANGE DATE THE NEXT REPAYMENT SHOULD BE ON TUESDAY, EVEN AFTER RESCHEDULE\");\n        \/\/ system.out.println(\"Successfully changed group meeting date (CAELNDAR\n        \/\/ ID: \" +\n        \/\/ this.groupCalendarId\n        \/\/ + \") and rescheduled loan (RESCHEDULE ID: \" +\n        \/\/ this.loanRescheduleRequestId +\n        \/\/ \")\");\n\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpecForStatusCode403);\n    } END"}
{"prompt":"test Change Group Meeting Matured On Date\n\n###\n\n","completion":"    @Test\n    public void testChangeGroupMeetingMaturedOnDate() {\n        \/\/ system.out\n        \/\/ .println(\"---------------------------------STARTING GROUP LOAN\n        \/\/ MEETING CHANGE\n        \/\/ DATE EXPECTED MATURED\n        \/\/ CHANGE------------------------------------------\");\n\n        Calendar meetingCalendar = Calendar.getInstance();\n        meetingCalendar.setFirstDayOfWeek(Calendar.MONDAY);\n        meetingCalendar.setTime(new java.util.Date());\n\n        int today = meetingCalendar.get(Calendar.DAY_OF_WEEK);\n        \/\/ making sure that the meeting calendar is set for the coming monday.\n        if (today >= Calendar.MONDAY) {\n            meetingCalendar.add(Calendar.DAY_OF_YEAR, +(Calendar.MONDAY - today + 7));\n        } else {\n            meetingCalendar.add(Calendar.DAY_OF_YEAR, +(Calendar.MONDAY - today));\n        }\n\n        Calendar groupMeetingChangeCalendar = (Calendar) meetingCalendar.clone();\n\n        meetingCalendar.add(Calendar.WEEK_OF_YEAR, -3);\n\n        final String groupMeetingDate = this.dateFormatterStandard.format(meetingCalendar.getTime());\n\n        final String disbursalDate = groupMeetingDate; \/\/ first meeting date\n                                                       \/\/ after group creation\n\n        final String loanType = \"jlg\";\n        groupMeetingChangeCalendar.add(Calendar.DAY_OF_YEAR, 1);\n        final String groupMeetingNewStartDate = this.dateFormatterStandard.format(groupMeetingChangeCalendar.getTime());\n        \/\/ The date\n        \/\/ from\n        \/\/ which we\n        \/\/ start the\n        \/\/ new group\n        \/\/ meeting\n        \/\/ occasion,\n        \/\/ this is a\n        \/\/ tuesday.\n\n        this.requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n        this.requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n        this.requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n        this.responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n        this.generalResponseSpec = new ResponseSpecBuilder().build();\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        this.loanRescheduleRequestHelper = new LoanRescheduleRequestHelper(this.requestSpec, this.responseSpec);\n        \/\/ system.out.println(\"---------------------------------CREATING\n        \/\/ ENTITIES AND\n        \/\/ JLG LOAN ------------------------------------------\");\n        \/\/ create all required entities\n        this.createRequiredEntitiesForJLGLoanSync(groupMeetingDate);\n\n        final String loanApplicationJSON = new LoanApplicationTestBuilder().withPrincipal(loanPrincipalAmount).withLoanTermFrequency(\"24\")\n                .withLoanTermFrequencyAsWeeks().withNumberOfRepayments(\"12\").withRepaymentEveryAfter(\"2\")\n                .withRepaymentFrequencyTypeAsMonths().withAmortizationTypeAsEqualInstallments().withInterestCalculationPeriodTypeAsDays()\n                .withInterestRatePerPeriod(interestRatePerPeriod).withRepaymentFrequencyTypeAsWeeks().withSubmittedOnDate(disbursalDate)\n                .withExpectedDisbursementDate(disbursalDate).withLoanType(loanType).withSyncDisbursementWithMeetin()\n                .withCalendarID(this.groupCalendarId.toString())\n                .build(this.clientId.toString(), this.groupId.toString(), this.loanProductId.toString(), null);\n\n        this.loanId = this.loanTransactionHelper.getLoanId(loanApplicationJSON);\n\n        \/\/ Test for loan account is created\n        Assertions.assertNotNull(this.loanId);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        \/\/ Test for loan account is created, can be approved\n        this.loanTransactionHelper.approveLoan(disbursalDate, this.loanId);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        \/\/ Test for loan account approved can be disbursed\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, this.loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(disbursalDate, this.loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        \/\/ system.out.println(\"---------------------------------CHANGING GROUP\n        \/\/ MEETING\n        \/\/ DATE ------------------------------------------\");\n        CalendarHelper.updateMeetingCalendarForGroup(this.requestSpec, this.responseSpec, this.groupId, this.groupCalendarId.toString(),\n                groupMeetingNewStartDate, \"2\", \"2\", \"2\"); \/\/ New\n                                                          \/\/ meeting\n                                                          \/\/ dates\n                                                          \/\/ will be\n                                                          \/\/ the\n                                                          \/\/ tuesday\n                                                          \/\/ after the\n                                                          \/\/ coming\n                                                          \/\/ monday\n\n        Calendar expectedMaturityCalendar = Calendar.getInstance();\n        expectedMaturityCalendar.setFirstDayOfWeek(Calendar.MONDAY);\n        ArrayList expectedMaturityDate = ((ArrayList) ((HashMap) this.loanTransactionHelper.getLoanDetail(requestSpec, generalResponseSpec,\n                this.loanId, \"timeline\")).get(\"expectedMaturityDate\"));\n\n        expectedMaturityCalendar.set((Integer) expectedMaturityDate.get(0), (Integer) expectedMaturityDate.get(1) - 1,\n                (Integer) expectedMaturityDate.get(2));\n\n        assertEquals(3, expectedMaturityCalendar.get(Calendar.DAY_OF_WEEK),\n                \"AFTER MEETING CHANGE DATE THE EXPECTED MATURITY SHOULD BE ON TUESDAY\");\n\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpecForStatusCode403);\n    } END"}
{"prompt":"scenario1\n\n###\n\n","completion":"    @Test\n    public void scenario1() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.02.01\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", true));\n            final Integer loanProductID = createLoanProductWithNoAccountingNoInterest(\"1000\", \"1\", \"1\", \"0\",\n                    LoanProductTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2023\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"1000\", \"1\", \"1\", \"1\", \"0\",\n                    LoanApplicationTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    \"01 January 2023\", \"01 January 2023\");\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 January 2023\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithTransactionAmount(\"01 January 2023\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            Integer firstRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"10 January 2023\", Float.parseFloat(\"500.00\"), loanID)\n                    .get(\"resourceId\");\n            Integer firstChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), \"20 January 2023\", \"50\"));\n            Integer secondRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"17 January 2023\", Float.parseFloat(\"450.00\"), loanID)\n                    .get(\"resourceId\");\n\n            Integer thirdRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"21 January 2023\", Float.parseFloat(\"50.00\"), loanID)\n                    .get(\"resourceId\");\n\n            GetLoansLoanIdResponse response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(50.0, response.getSummary().getTotalOutstanding());\n            assertEquals(50.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(950.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertNull(response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(500.0, response.getTransactions().get(1).getAmount());\n            assertEquals(500.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(500.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(secondRepaymentId, response.getTransactions().get(2).getId().intValue());\n            assertNull(response.getTransactions().get(2).getReversedOnDate());\n            assertTrue(response.getTransactions().get(2).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(2).getType().getRepayment());\n            assertEquals(450.0, response.getTransactions().get(2).getAmount());\n            assertEquals(450.0, response.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getFeeChargesPortion());\n            assertEquals(50.0, response.getTransactions().get(2).getOutstandingLoanBalance());\n            assertEquals(thirdRepaymentId, response.getTransactions().get(3).getId().intValue());\n            assertNull(response.getTransactions().get(3).getReversedOnDate());\n            assertTrue(response.getTransactions().get(3).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(3).getType().getRepayment());\n            assertEquals(50.0, response.getTransactions().get(3).getAmount());\n            assertEquals(0.0, response.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(50.0, response.getTransactions().get(3).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getFeeChargesPortion());\n            assertEquals(50.0, response.getTransactions().get(3).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(3).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(3).getLoanChargePaidByList().size());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"scenario2\n\n###\n\n","completion":"    @Test\n    public void scenario2() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.02.01\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", true));\n\n            Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n            final Integer loanProductID = createLoanProductWithNoAccountingNoInterest(\"1000\", \"1\", \"1\", \"0\",\n                    LoanProductTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2023\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"1000\", \"1\", \"1\", \"1\", \"0\",\n                    LoanApplicationTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    \"01 January 2023\", \"01 January 2023\");\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 January 2023\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithTransactionAmount(\"01 January 2023\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            Integer firstRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"10 January 2023\", Float.parseFloat(\"500.00\"), loanID)\n                    .get(\"resourceId\");\n            Integer firstChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), \"20 January 2023\", \"50\"));\n            Integer secondRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"17 January 2023\", Float.parseFloat(\"100.00\"), loanID)\n                    .get(\"resourceId\");\n\n            Integer secondChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), \"23 January 2023\", \"10\"));\n\n            Integer thirdRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"20 January 2023\", Float.parseFloat(\"100.00\"), loanID)\n                    .get(\"resourceId\");\n\n            GetLoansLoanIdResponse response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(360.0, response.getSummary().getTotalOutstanding());\n            assertEquals(360.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(10.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(10.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(650.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(350.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertNull(response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(500.0, response.getTransactions().get(1).getAmount());\n            assertEquals(500.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(500.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(secondRepaymentId, response.getTransactions().get(2).getId().intValue());\n            assertNull(response.getTransactions().get(2).getReversedOnDate());\n            assertTrue(response.getTransactions().get(2).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(2).getType().getRepayment());\n            assertEquals(100.0, response.getTransactions().get(2).getAmount());\n            assertEquals(100.0, response.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getFeeChargesPortion());\n            assertEquals(400.0, response.getTransactions().get(2).getOutstandingLoanBalance());\n            assertEquals(thirdRepaymentId, response.getTransactions().get(3).getId().intValue());\n            assertNull(response.getTransactions().get(3).getReversedOnDate());\n            assertTrue(response.getTransactions().get(3).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(3).getType().getRepayment());\n            assertEquals(100.0, response.getTransactions().get(3).getAmount());\n            assertEquals(50.0, response.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(50.0, response.getTransactions().get(3).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getPenaltyChargesPortion());\n            assertEquals(350.0, response.getTransactions().get(3).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(3).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(3).getLoanChargePaidByList().size());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"scenario3\n\n###\n\n","completion":"    @Test\n    public void scenario3() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.02.01\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n            final Integer loanProductID = createLoanProductWithNoAccountingNoInterest(\"1000\", \"1\", \"1\", \"0\",\n                    LoanProductTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2023\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"1000\", \"1\", \"1\", \"1\", \"0\",\n                    LoanApplicationTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    \"01 January 2023\", \"01 January 2023\");\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 January 2023\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithTransactionAmount(\"01 January 2023\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            Integer firstRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"10 January 2023\", Float.parseFloat(\"500.00\"), loanID)\n                    .get(\"resourceId\");\n            Integer firstChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), \"20 January 2023\", \"50\"));\n            Integer secondRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"17 January 2023\", Float.parseFloat(\"550.00\"), loanID)\n                    .get(\"resourceId\");\n\n            GetLoansLoanIdResponse response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(0.0, response.getSummary().getTotalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getClosedObligationsMet());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertNull(response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(500.0, response.getTransactions().get(1).getAmount());\n            assertEquals(500.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(500.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n\n            int repaymentOrderNo;\n            int accrualOrderNo;\n\n            if (response.getTransactions().get(2).getType().getAccrual()) {\n                accrualOrderNo = 2;\n                repaymentOrderNo = 3;\n            } else {\n                accrualOrderNo = 3;\n                repaymentOrderNo = 2;\n            }\n\n            assertNull(response.getTransactions().get(accrualOrderNo).getReversedOnDate());\n            assertTrue(response.getTransactions().get(accrualOrderNo).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(accrualOrderNo).getType().getAccrual());\n            assertEquals(50.0, response.getTransactions().get(accrualOrderNo).getAmount());\n            assertEquals(0.0, response.getTransactions().get(accrualOrderNo).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(accrualOrderNo).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(accrualOrderNo).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(accrualOrderNo).getInterestPortion());\n            assertEquals(50.0, response.getTransactions().get(accrualOrderNo).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(accrualOrderNo).getOutstandingLoanBalance());\n            assertEquals(firstChargeId,\n                    response.getTransactions().get(accrualOrderNo).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(accrualOrderNo).getLoanChargePaidByList().size());\n\n            assertEquals(secondRepaymentId, response.getTransactions().get(repaymentOrderNo).getId().intValue());\n            assertNull(response.getTransactions().get(repaymentOrderNo).getReversedOnDate());\n            assertTrue(response.getTransactions().get(repaymentOrderNo).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(repaymentOrderNo).getType().getRepayment());\n            assertEquals(550.0, response.getTransactions().get(repaymentOrderNo).getAmount());\n            assertEquals(500.0, response.getTransactions().get(repaymentOrderNo).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(repaymentOrderNo).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(repaymentOrderNo).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(repaymentOrderNo).getInterestPortion());\n            assertEquals(50.0, response.getTransactions().get(repaymentOrderNo).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(repaymentOrderNo).getOutstandingLoanBalance());\n            assertEquals(firstChargeId,\n                    response.getTransactions().get(repaymentOrderNo).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(repaymentOrderNo).getLoanChargePaidByList().size());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"scenario4\n\n###\n\n","completion":"    @Test\n    public void scenario4() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.02.01\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n            final Integer loanProductID = createLoanProductWithNoAccountingNoInterest(\"1000\", \"1\", \"3\", \"0\",\n                    LoanProductTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2023\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"1000\", \"3\", \"1\", \"3\", \"0\",\n                    LoanApplicationTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    \"01 January 2023\", \"01 January 2023\");\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 January 2023\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithTransactionAmount(\"01 January 2023\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            Integer firstChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), \"20 January 2023\", \"50\"));\n\n            Integer firstRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"10 January 2023\", Float.parseFloat(\"500.00\"), loanID)\n                    .get(\"resourceId\");\n\n            GetLoansLoanIdResponse response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(550.0, response.getSummary().getTotalOutstanding());\n            assertEquals(550.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(333.33, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(333.33, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesOutstanding());\n            assertEquals(333.33, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalDue());\n            assertEquals(116.67, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalPaid());\n            assertEquals(216.66, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertNull(response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(500.0, response.getTransactions().get(1).getAmount());\n            assertEquals(450.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(50.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(550.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(1).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(1).getLoanChargePaidByList().size());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"scenario6\n\n###\n\n","completion":"    @Test\n    public void scenario6() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.03.01\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"20\", false));\n            final Integer loanProductID = createLoanProductWithNoAccountingNoInterest(\"1000\", \"1\", \"1\", \"0\",\n                    LoanProductTestBuilder.DUE_PENALTY_INTEREST_PRINCIPAL_FEE_IN_ADVANCE_PENALTY_INTEREST_PRINCIPAL_FEE_STRATEGY,\n                    assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2023\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"1000\", \"1\", \"1\", \"1\", \"0\",\n                    LoanApplicationTestBuilder.DUE_PENALTY_INTEREST_PRINCIPAL_FEE_IN_ADVANCE_PENALTY_INTEREST_PRINCIPAL_FEE_STRATEGY,\n                    \"01 January 2023\", \"01 January 2023\");\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 January 2023\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithTransactionAmount(\"01 January 2023\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            Integer firstChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), \"25 January 2023\", \"20\"));\n            Integer firstRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"01 March 2023\", Float.parseFloat(\"1010.00\"), loanID)\n                    .get(\"resourceId\");\n\n            GetLoansLoanIdResponse response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(10.0, response.getSummary().getTotalOutstanding());\n            assertEquals(10.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(10.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(10.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertNull(response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(1010.0, response.getTransactions().get(1).getAmount());\n            assertEquals(1000.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(10.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(1).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(1).getLoanChargePaidByList().size());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"scenario7\n\n###\n\n","completion":"    @Test\n    public void scenario7() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.01.28\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"15\", true));\n            final Integer loanProductID = createLoanProductWithNoAccountingNoInterest(\"1000\", \"1\", \"1\", \"0\",\n                    LoanProductTestBuilder.DUE_PENALTY_INTEREST_PRINCIPAL_FEE_IN_ADVANCE_PENALTY_INTEREST_PRINCIPAL_FEE_STRATEGY,\n                    assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2023\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"1000\", \"1\", \"1\", \"1\", \"0\",\n                    LoanApplicationTestBuilder.DUE_PENALTY_INTEREST_PRINCIPAL_FEE_IN_ADVANCE_PENALTY_INTEREST_PRINCIPAL_FEE_STRATEGY,\n                    \"01 January 2023\", \"01 January 2023\");\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 January 2023\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithTransactionAmount(\"01 January 2023\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            Integer firstRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"25 January 2023\", Float.parseFloat(\"1000.00\"), loanID)\n                    .get(\"resourceId\");\n\n            GetLoansLoanIdResponse response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(0.0, response.getSummary().getTotalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getClosedObligationsMet());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertNull(response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(1000.0, response.getTransactions().get(1).getAmount());\n            assertEquals(1000.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(0, response.getTransactions().get(1).getLoanChargePaidByList().size());\n\n            PostLoansLoanIdTransactionsResponse reverseRepayment = loanTransactionHelper.reverseLoanTransaction((long) loanID,\n                    (long) firstRepaymentId, new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\")\n                            .transactionDate(\"28 January 2023\").transactionAmount(0.0).locale(\"en\"));\n\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.01.31\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(1000.0, response.getSummary().getTotalOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertEquals(LocalDate.of(2023, 1, 28), response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getManuallyReversed());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(1000.0, response.getTransactions().get(1).getAmount());\n            assertEquals(1000.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(0, response.getTransactions().get(1).getLoanChargePaidByList().size());\n\n            Integer firstChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), \"28 January 2023\", \"15\"));\n            Integer secondRepayment = (Integer) loanTransactionHelper.makeRepayment(\"31 January 2023\", Float.parseFloat(\"1010.00\"), loanID)\n                    .get(\"resourceId\");\n\n            response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(5.0, response.getSummary().getTotalOutstanding());\n            assertEquals(5.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(995.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(5.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(secondRepayment, response.getTransactions().get(2).getId().intValue());\n            assertNull(response.getTransactions().get(2).getReversedOnDate());\n            assertTrue(response.getTransactions().get(2).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(2).getType().getRepayment());\n            assertEquals(1010.0, response.getTransactions().get(2).getAmount());\n            assertEquals(995.0, response.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(15.0, response.getTransactions().get(2).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getFeeChargesPortion());\n            assertEquals(5.0, response.getTransactions().get(2).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(2).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(2).getLoanChargePaidByList().size());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"get External Event Configurations\n\n###\n\n","completion":"    @Test\n    public void getExternalEventConfigurations() {\n        final ArrayList<Map<String, Object>> externalEventConfigurations = ExternalEventConfigurationHelper\n                .getAllExternalEventConfigurations(requestSpec, responseSpec);\n        Assertions.assertNotNull(externalEventConfigurations);\n        final ArrayList<Map<String, Object>> defaultConfigurations = ExternalEventConfigurationHelper\n                .getDefaultExternalEventConfigurations();\n        Assertions.assertEquals(defaultConfigurations.size(), externalEventConfigurations.size());\n        verifyAllEventConfigurations(externalEventConfigurations, defaultConfigurations);\n\n    } END"}
{"prompt":"update External Event Configurations\n\n###\n\n","completion":"    @Test\n    public void updateExternalEventConfigurations() {\n        String updateRequestJson = ExternalEventConfigurationHelper.getExternalEventConfigurationsForUpdateJSON();\n        final Map<String, Boolean> updatedConfigurations = ExternalEventConfigurationHelper.updateExternalEventConfigurations(requestSpec,\n                responseSpec, updateRequestJson);\n        Assertions.assertEquals(updatedConfigurations.size(), 2);\n        Assertions.assertTrue(updatedConfigurations.containsKey(\"CentersCreateBusinessEvent\"));\n        Assertions.assertTrue(updatedConfigurations.containsKey(\"ClientActivateBusinessEvent\"));\n        Assertions.assertTrue(updatedConfigurations.get(\"CentersCreateBusinessEvent\"));\n        Assertions.assertTrue(updatedConfigurations.get(\"ClientActivateBusinessEvent\"));\n\n    } END"}
{"prompt":"test\n\n###\n\n","completion":"    @Disabled\n    @Test\n    public void test() {\n\n        final HashMap<String, String> metadata = new HashMap<>();\n        metadata.put(\"user\", \"resource_url\");\n        final HashMap<String, Object> map = new HashMap<>();\n        map.put(\"name\", \"foo\");\n        map.put(\"text\", \"Hello {{template}}\");\n        map.put(\"mappers\", metadata);\n\n        ArrayList<?> get = Utils.performServerGet(this.requestSpec, this.responseSpec, GET_TEMPLATES_URL, \"\");\n        final int entriesBeforeTest = get.size();\n\n        final Integer id = Utils.performServerPost(this.requestSpec, this.responseSpec, GET_TEMPLATES_URL, new Gson().toJson(map),\n                \"resourceId\");\n\n        final String templateUrlForId = String.format(\"\/fineract-provider\/api\/v1\/templates\/%s?tenantIdentifier=default\", id);\n\n        final String getrequest2 = Utils.performServerGet(this.requestSpec, this.responseSpec, templateUrlForId, RESPONSE_ATTRIBUTE_NAME);\n\n        Assertions.assertTrue(getrequest2.equals(\"foo\"));\n\n        Utils.performServerDelete(this.requestSpec, this.responseSpec, templateUrlForId, \"\");\n\n        get = Utils.performServerGet(this.requestSpec, this.responseSpec, GET_TEMPLATES_URL, \"\");\n        final int entriesAfterTest = get.size();\n\n        Assertions.assertEquals(entriesBeforeTest, entriesAfterTest);\n    } END"}
{"prompt":"test External Services Configuration\n\n###\n\n","completion":"    @Test\n    public void testExternalServicesConfiguration() {\n        this.externalServicesConfigurationHelper = new ExternalServicesConfigurationHelper(this.requestSpec, this.responseSpec);\n\n        \/\/ Checking for S3\n        String configName = \"s3_access_key\";\n        ArrayList<HashMap> externalServicesConfig = ExternalServicesConfigurationHelper\n                .getExternalServicesConfigurationByServiceName(requestSpec, responseSpec, \"S3\");\n        Assertions.assertNotNull(externalServicesConfig);\n        for (Integer configIndex = 0; configIndex < externalServicesConfig.size(); configIndex++) {\n            String name = (String) externalServicesConfig.get(configIndex).get(\"name\");\n            String value = null;\n            if (name.equals(configName)) {\n                value = (String) externalServicesConfig.get(configIndex).get(\"value\");\n                if (value == null) {\n                    value = \"testnull\";\n                }\n                String newValue = \"test\";\n                LOG.info(\"{} : {}\", name, value);\n                HashMap arrayListValue = ExternalServicesConfigurationHelper.updateValueForExternaServicesConfiguration(requestSpec,\n                        responseSpec, \"S3\", name, newValue);\n                Assertions.assertNotNull(arrayListValue.get(\"value\"));\n                Assertions.assertEquals(arrayListValue.get(\"value\"), newValue);\n                HashMap arrayListValue1 = ExternalServicesConfigurationHelper.updateValueForExternaServicesConfiguration(requestSpec,\n                        responseSpec, \"S3\", name, value);\n                Assertions.assertNotNull(arrayListValue1.get(\"value\"));\n                Assertions.assertEquals(arrayListValue1.get(\"value\"), value);\n            }\n\n        }\n\n        \/\/ Checking for SMTP:\n\n        configName = \"username\";\n        externalServicesConfig = ExternalServicesConfigurationHelper.getExternalServicesConfigurationByServiceName(requestSpec,\n                responseSpec, \"SMTP\");\n        Assertions.assertNotNull(externalServicesConfig);\n\n        for (Integer configIndex = 0; configIndex < externalServicesConfig.size(); configIndex++) {\n            String name = (String) externalServicesConfig.get(configIndex).get(\"name\");\n            String value = null;\n            if (name.equals(configName)) {\n                value = (String) externalServicesConfig.get(configIndex).get(\"value\");\n                if (value == null) {\n                    value = \"testnull\";\n                }\n                String newValue = \"test\";\n                LOG.info(\"{} : {}\", name, value);\n                HashMap arrayListValue = ExternalServicesConfigurationHelper.updateValueForExternaServicesConfiguration(requestSpec,\n                        responseSpec, \"SMTP\", name, newValue);\n                Assertions.assertNotNull(arrayListValue.get(\"value\"));\n                Assertions.assertEquals(arrayListValue.get(\"value\"), newValue);\n                HashMap arrayListValue1 = ExternalServicesConfigurationHelper.updateValueForExternaServicesConfiguration(requestSpec,\n                        responseSpec, \"SMTP\", name, value);\n                Assertions.assertNotNull(arrayListValue1.get(\"value\"));\n                Assertions.assertEquals(arrayListValue1.get(\"value\"), value);\n            }\n\n        }\n\n    } END"}
{"prompt":"test Financial Activity Accounts\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testFinancialActivityAccounts() {\n\n        \/** Create a Liability and an Asset Transfer Account **\/\n        Account liabilityTransferAccount = accountHelper.createLiabilityAccount();\n        Account assetTransferAccount = accountHelper.createAssetAccount();\n        Assertions.assertNotNull(assetTransferAccount);\n        Assertions.assertNotNull(liabilityTransferAccount);\n\n        \/*** Create A Financial Activity to Account Mapping **\/\n        Integer financialActivityAccountId = (Integer) financialActivityAccountHelper.createFinancialActivityAccount(\n                LIABILITY_TRANSFER_FINANCIAL_ACTIVITY_ID, liabilityTransferAccount.getAccountID(), responseSpec,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(financialActivityAccountId);\n\n        \/***\n         * Fetch Created Financial Activity to Account Mapping and validate created values\n         **\/\n        assertFinancialActivityAccountCreation(financialActivityAccountId, LIABILITY_TRANSFER_FINANCIAL_ACTIVITY_ID,\n                liabilityTransferAccount);\n\n        \/**\n         * Update Existing Financial Activity to Account Mapping and assert changes\n         **\/\n        Account newLiabilityTransferAccount = accountHelper.createLiabilityAccount();\n        Assertions.assertNotNull(newLiabilityTransferAccount);\n\n        HashMap changes = (HashMap) financialActivityAccountHelper.updateFinancialActivityAccount(financialActivityAccountId,\n                LIABILITY_TRANSFER_FINANCIAL_ACTIVITY_ID, newLiabilityTransferAccount.getAccountID(), responseSpec,\n                CommonConstants.RESPONSE_CHANGES);\n        Assertions.assertEquals(newLiabilityTransferAccount.getAccountID(), changes.get(\"glAccountId\"));\n\n        \/** Validate update works correctly **\/\n        assertFinancialActivityAccountCreation(financialActivityAccountId, LIABILITY_TRANSFER_FINANCIAL_ACTIVITY_ID,\n                newLiabilityTransferAccount);\n\n        \/** Update with Invalid Financial Activity should fail **\/\n        List<HashMap> invalidFinancialActivityUpdateError = (List<HashMap>) financialActivityAccountHelper.updateFinancialActivityAccount(\n                financialActivityAccountId, 232, newLiabilityTransferAccount.getAccountID(), responseSpecForValidationError,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"validation.msg.financialactivityaccount.financialActivityId.is.not.one.of.expected.enumerations\",\n                invalidFinancialActivityUpdateError.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        \/** Creating Duplicate Financial Activity should fail **\/\n        List<HashMap> duplicateFinancialActivityAccountError = (List<HashMap>) financialActivityAccountHelper\n                .createFinancialActivityAccount(LIABILITY_TRANSFER_FINANCIAL_ACTIVITY_ID, liabilityTransferAccount.getAccountID(),\n                        responseSpecForDomainRuleViolation, CommonConstants.RESPONSE_ERROR);\n        assertEquals(DuplicateFinancialActivityAccountFoundException.getErrorcode(),\n                duplicateFinancialActivityAccountError.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        \/**\n         * Associating incorrect GL account types with a financial activity should fail\n         **\/\n        List<HashMap> invalidFinancialActivityAccountError = (List<HashMap>) financialActivityAccountHelper.updateFinancialActivityAccount(\n                financialActivityAccountId, assetTransferFinancialActivityId, newLiabilityTransferAccount.getAccountID(),\n                responseSpecForDomainRuleViolation, CommonConstants.RESPONSE_ERROR);\n        assertEquals(FinancialActivityAccountInvalidException.getErrorcode(),\n                invalidFinancialActivityAccountError.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        \/** Should be able to delete a Financial Activity to Account Mapping **\/\n        Integer deletedFinancialActivityAccountId = financialActivityAccountHelper\n                .deleteFinancialActivityAccount(financialActivityAccountId, responseSpec, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(deletedFinancialActivityAccountId);\n        Assertions.assertEquals(financialActivityAccountId, deletedFinancialActivityAccountId);\n\n        \/*** Trying to fetch a Deleted Account Mapping should give me a 404 **\/\n        financialActivityAccountHelper.getFinancialActivityAccount(deletedFinancialActivityAccountId, responseSpecForResourceNotFoundError);\n    } END"}
{"prompt":"test Fixed Deposit Product Creation\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositProductCreation() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n\n        \/***\n         * Create GL Accounts for product account mapping\n         *\/\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        final String accountingRule = CASH_BASED;\n        \/***\n         * Create FD product with charts (must be 200 OK)\n         *\/\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount, liabilityAccount,\n                incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        \/***\n         * Create FD product without charts (must be 400 Bad Request)\n         *\/\n        this.responseSpec = new ResponseSpecBuilder().expectStatusCode(400).build();\n        createFixedDepositProductWithoutCharts(VALID_FROM, VALID_TO, accountingRule, assetAccount, liabilityAccount, incomeAccount,\n                expenseAccount);\n    } END"}
{"prompt":"test Fixed Deposit Account With Premature Closure Type Withdrawal\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithPrematureClosureTypeWithdrawal() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        \/***\n         * Create GL Accounts for product account mapping\n         *\/\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        final String CLOSED_ON_DATE = dateFormat.format(Calendar.getInstance().getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/***\n         * Create FD product with CashBased accounting enabled\n         *\/\n        final String accountingRule = CASH_BASED;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount, liabilityAccount,\n                incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        \/***\n         * Apply for FD account with created product and verify status\n         *\/\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        \/***\n         * Approve the FD account and verify whether account is approved\n         *\/\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        \/***\n         * Activate the FD Account and verify whether account is activated\n         *\/\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n\n        Float depositAmount = (Float) accountSummary.get(\"totalDeposits\");\n\n        \/***\n         * Verify journal entries posted for initial deposit transaction which happened at activation time\n         *\/\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, ACTIVATION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, ACTIVATION_DATE, liablilityAccountInitialEntry);\n\n        \/***\n         * Update interest earned of FD account\n         *\/\n        fixedDepositAccountId = this.fixedDepositAccountHelper.calculateInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        \/***\n         * Post interest and verify the account summary\n         *\/\n        Integer transactionIdForPostInterest = this.fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n\n        \/***\n         * Verify journal entries transactions for interest posting transaction\n         *\/\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n        this.fixedDepositAccountHelper.calculatePrematureAmountForFixedDeposit(fixedDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.fixedDepositAccountHelper.prematureCloseForFixedDeposit(\n                fixedDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsPrematureClosed(fixedDepositAccountStatusHashMap);\n\n        \/***\n         * Verify journal entry transactions for preclosure transaction\n         *\/\n        HashMap accountDetails = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float maturityAmount = Float.valueOf(accountDetails.get(\"maturityAmount\").toString());\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.DEBIT));\n\n    } END"}
{"prompt":"test Fixed Deposit Account With Premature Closure Type Withdrawal WITH HOLD TAX\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithPrematureClosureTypeWithdrawal_WITH_HOLD_TAX() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        \/***\n         * Create GL Accounts for product account mapping\n         *\/\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n        final Account liabilityAccountForTax = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        final String CLOSED_ON_DATE = dateFormat.format(Calendar.getInstance().getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/***\n         * Create FD product with CashBased accounting enabled\n         *\/\n        final String accountingRule = CASH_BASED;\n        final Integer taxGroupId = createTaxGroup(\"10\", liabilityAccountForTax);\n        Integer fixedDepositProductId = createFixedDepositProductWithWithHoldTax(VALID_FROM, VALID_TO, String.valueOf(taxGroupId),\n                accountingRule, assetAccount, liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        \/***\n         * Apply for FD account with created product and verify status\n         *\/\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        \/***\n         * Approve the FD account and verify whether account is approved\n         *\/\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        \/***\n         * Activate the FD Account and verify whether account is activated\n         *\/\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n\n        Float depositAmount = (Float) accountSummary.get(\"totalDeposits\");\n\n        \/***\n         * Verify journal entries posted for initial deposit transaction which happened at activation time\n         *\/\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, ACTIVATION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, ACTIVATION_DATE, liablilityAccountInitialEntry);\n\n        \/***\n         * Update interest earned of FD account\n         *\/\n        fixedDepositAccountId = this.fixedDepositAccountHelper.calculateInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        \/***\n         * Post interest and verify the account summary\n         *\/\n        Integer transactionIdForPostInterest = this.fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n        Assertions.assertNull(accountSummary.get(\"totalWithholdTax\"));\n\n        \/***\n         * Verify journal entries transactions for interest posting transaction\n         *\/\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n        this.fixedDepositAccountHelper.calculatePrematureAmountForFixedDeposit(fixedDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.fixedDepositAccountHelper.prematureCloseForFixedDeposit(\n                fixedDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsPrematureClosed(fixedDepositAccountStatusHashMap);\n\n        \/***\n         * Verify journal entry transactions for preclosure transaction\n         *\/\n        HashMap accountDetails = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float maturityAmount = Float.valueOf(accountDetails.get(\"maturityAmount\").toString());\n\n        HashMap summary = (HashMap) accountDetails.get(\"summary\");\n        Assertions.assertNotNull(summary.get(\"totalWithholdTax\"));\n        Float withHoldTax = (Float) summary.get(\"totalWithholdTax\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccountForTax, CLOSED_ON_DATE,\n                new JournalEntry(withHoldTax, JournalEntry.TransactionType.CREDIT));\n\n    } END"}
{"prompt":"test Fixed Deposit Account Closure Type Withdrawal WITH HOLD TAX\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountClosureTypeWithdrawal_WITH_HOLD_TAX() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        \/***\n         * Create GL Accounts for product account mapping\n         *\/\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n        final Account liabilityAccountForTax = this.accountHelper.createLiabilityAccount();\n\n        DateTimeFormatter monthDayFormat = new DateTimeFormatterBuilder().appendPattern(\"dd MMM\").toFormatter();\n        DateTimeFormatter currentDateFormat = new DateTimeFormatterBuilder().appendPattern(\"dd\").toFormatter();\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(20);\n        final String VALID_FROM = Utils.dateFormatter.format(todaysDate);\n        todaysDate = todaysDate.plusYears(10);\n        final String VALID_TO = Utils.dateFormatter.format(todaysDate);\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(20);\n        final String SUBMITTED_ON_DATE = Utils.dateFormatter.format(todaysDate);\n        final String APPROVED_ON_DATE = Utils.dateFormatter.format(todaysDate);\n        final String ACTIVATION_DATE = Utils.dateFormatter.format(todaysDate);\n\n        LocalDate closedOn = todaysDate.plusMonths(14);\n        final String CLOSED_ON_DATE = Utils.dateFormatter.format(closedOn);\n\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/***\n         * Create FD product with CashBased accounting enabled\n         *\/\n        final Integer taxGroupId = createTaxGroup(\"10\", liabilityAccountForTax);\n        Integer fixedDepositProductId = createFixedDepositProductWithWithHoldTax(VALID_FROM, VALID_TO, String.valueOf(taxGroupId),\n                CASH_BASED, assetAccount, liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        \/***\n         * Apply for FD account with created product and verify status\n         *\/\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        \/***\n         * Approve the FD account and verify whether account is approved\n         *\/\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        \/***\n         * Activate the FD Account and verify whether account is activated\n         *\/\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n\n        Float depositAmount = (Float) accountSummary.get(\"totalDeposits\");\n\n        \/***\n         * Verify journal entries posted for initial deposit transaction which happened at activation time\n         *\/\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liabilityAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, ACTIVATION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, ACTIVATION_DATE, liabilityAccountInitialEntry);\n\n        \/***\n         * Update interest earned of FD account\n         *\/\n        fixedDepositAccountId = this.fixedDepositAccountHelper.calculateInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        \/***\n         * Post interest and verify the account summary\n         *\/\n        Integer transactionIdForPostInterest = this.fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n        accountSummary.get(\"totalInterestPosted\");\n        Assertions.assertNull(accountSummary.get(\"totalWithholdTax\"));\n\n        \/***\n         * FD account verify whether account is matured\n         *\/\n\n        SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n        String JobName = \"Update Deposit Accounts Maturity details\";\n        schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        HashMap accountDetails = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        HashMap summary = (HashMap) accountDetails.get(\"summary\");\n        Assertions.assertNotNull(summary.get(\"totalWithholdTax\"));\n        Float withHoldTax = (Float) summary.get(\"totalWithholdTax\");\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccountForTax, CLOSED_ON_DATE,\n                new JournalEntry(withHoldTax, JournalEntry.TransactionType.CREDIT));\n\n        fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsMatured(fixedDepositAccountStatusHashMap);\n    } END"}
{"prompt":"test Fixed Deposit Account With Period Interest Rate Chart\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithPeriodInterestRateChart() {\n        final String chartToUse = \"period\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 6.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Fixed Deposit Account With Period Interest Rate Chart AMOUNT VARIATION\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithPeriodInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"period\";\n        final String depositAmount = \"2000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 6.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Fixed Deposit Account With Period Interest Rate Chart PERIOD VARIATION\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithPeriodInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"period\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"18\";\n        final Float interestRate = (float) 7.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Fixed Deposit Account With Amount Interest Rate Chart\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithAmountInterestRateChart() {\n        final String chartToUse = \"amount\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 7.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Fixed Deposit Account With Amount Interest Rate Chart AMOUNT VARIATION\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithAmountInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"amount\";\n        final String depositAmount = \"5000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 5.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Fixed Deposit Account With Amount Interest Rate Chart PERIOD VARIATION\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithAmountInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"amount\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"26\";\n        final Float interestRate = (float) 7.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Fixed Deposit Account With Period And Amount Interest Rate Chart\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithPeriodAndAmountInterestRateChart() {\n        final String chartToUse = \"period_amount\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 7.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Fixed Deposit Account With Period And Amount Interest Rate Chart AMOUNT VARIATION\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithPeriodAndAmountInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"period_amount\";\n        final String depositAmount = \"5000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 6.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Fixed Deposit Account With Period And Amount Interest Rate Chart PERIOD VARIATION\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithPeriodAndAmountInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"period_amount\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"20\";\n        final Float interestRate = (float) 9.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Fixed Deposit Account With Amount And Period Interest Rate Chart\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithAmountAndPeriodInterestRateChart() {\n        final String chartToUse = \"amount_period\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 8.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Fixed Deposit Account With Amount And Period Interest Rate Chart AMOUNT VARIATION\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithAmountAndPeriodInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"amount_period\";\n        final String depositAmount = \"5000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 6.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Fixed Deposit Account With Amount And Period Interest Rate Chart PERIOD VARIATION\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithAmountAndPeriodInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"amount_period\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"6\";\n        final Float interestRate = (float) 7.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Fixed Deposit Account With Premature Closure Type Transfer To Savings\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithPrematureClosureTypeTransferToSavings() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        \/***\n         * Create GL Accounts for product account mapping\n         *\/\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        final String CLOSED_ON_DATE = dateFormat.format(Calendar.getInstance().getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/***\n         * Create Savings product with CashBased accounting enabled\n         *\/\n        final String accountingRule = CASH_BASED;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE, accountingRule,\n                assetAccount, liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientId, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        \/***\n         * Create FD product with CashBased accounting enabled\n         *\/\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount, liabilityAccount,\n                incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n\n        Float depositAmount = (Float) accountSummary.get(\"totalDeposits\");\n\n        \/***\n         * Verify journal entries posted for initial deposit transaction which happened at activation time\n         *\/\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, ACTIVATION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, ACTIVATION_DATE, liablilityAccountInitialEntry);\n\n        \/***\n         * Update interest earned of FD account\n         *\/\n        fixedDepositAccountId = this.fixedDepositAccountHelper.calculateInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        \/***\n         * Post interest and verify the account summary\n         *\/\n        Integer transactionIdForPostInterest = this.fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n\n        \/***\n         * Verify journal entries transactions for interest posting transaction\n         *\/\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n        HashMap savingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balanceBefore = (Float) savingsSummaryBefore.get(\"accountBalance\");\n\n        \/***\n         * Retrieve mapped financial account for liability transfer\n         *\/\n        Account financialAccount = getMappedLiabilityFinancialAccount();\n\n        this.fixedDepositAccountHelper.calculatePrematureAmountForFixedDeposit(fixedDepositAccountId, CLOSED_ON_DATE);\n\n        \/***\n         * Preclose the account and verify journal entries\n         *\/\n        Integer prematureClosureTransactionId = (Integer) this.fixedDepositAccountHelper.prematureCloseForFixedDeposit(\n                fixedDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_TRANSFER_TO_SAVINGS, savingsId, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsPrematureClosed(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float prematurityAmount = (Float) fixedDepositData.get(\"maturityAmount\");\n\n        \/***\n         * Verify journal entry transactions for preclosure transaction As this transaction is an account transfer you\n         * should get financial account mapping details and verify amounts\n         *\/\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, CLOSED_ON_DATE,\n                new JournalEntry(prematurityAmount, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(prematurityAmount, JournalEntry.TransactionType.DEBIT));\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(financialAccount, CLOSED_ON_DATE,\n                new JournalEntry(prematurityAmount, JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(prematurityAmount, JournalEntry.TransactionType.CREDIT));\n\n        HashMap savingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balanceAfter = (Float) savingsSummaryAfter.get(\"accountBalance\");\n        Float expectedSavingsBalance = balanceBefore + prematurityAmount;\n\n        Assertions.assertEquals(expectedSavingsBalance, balanceAfter, \"Verifying Savings Account Balance after Premature Closure\");\n\n    } END"}
{"prompt":"test Fixed Deposit Account With Premature Closure Type Reinvest\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithPrematureClosureTypeReinvest() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        FixedDepositAccountHelper fixedDepositAccountHelperValidationError = new FixedDepositAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        \/***\n         * Create GL Accounts for product account mapping\n         *\/\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        final String CLOSED_ON_DATE = dateFormat.format(Calendar.getInstance().getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/***\n         * Create FD product with CashBased accounting enabled\n         *\/\n        final String accountingRule = CASH_BASED;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount, liabilityAccount,\n                incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n\n        Float depositAmount = (Float) accountSummary.get(\"totalDeposits\");\n\n        \/***\n         * Verify journal entries posted for initial deposit transaction which happened at activation time\n         *\/\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, ACTIVATION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, ACTIVATION_DATE, liablilityAccountInitialEntry);\n\n        fixedDepositAccountId = this.fixedDepositAccountHelper.calculateInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        Integer transactionIdForPostInterest = this.fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n\n        \/***\n         * Verify journal entries transactions for interest posting transaction\n         *\/\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n        this.fixedDepositAccountHelper.calculatePrematureAmountForFixedDeposit(fixedDepositAccountId, CLOSED_ON_DATE);\n\n        ArrayList<HashMap> errorResponse = (ArrayList<HashMap>) fixedDepositAccountHelperValidationError.prematureCloseForFixedDeposit(\n                fixedDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_REINVEST, null, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"validation.msg.fixeddepositaccount.onAccountClosureId.reinvest.not.allowed\",\n                errorResponse.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    } END"}
{"prompt":"test Fixed Deposit Account Updation\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountUpdation() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        monthDayFormat.format(todaysDate.getTime());\n        String submittedOnDate = dateFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        FixedDepositProductHelper.retrieveAllFixedDepositProducts(this.requestSpec, this.responseSpec);\n        FixedDepositProductHelper.retrieveFixedDepositProductById(this.requestSpec, this.responseSpec, fixedDepositProductId.toString());\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                submittedOnDate, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        todaysDate.add(Calendar.DATE, -1);\n        submittedOnDate = dateFormat.format(todaysDate.getTime());\n        HashMap modificationsHashMap = this.fixedDepositAccountHelper.updateFixedDepositAccount(clientId.toString(),\n                fixedDepositProductId.toString(), fixedDepositAccountId.toString(), VALID_FROM, VALID_TO, WHOLE_TERM, submittedOnDate);\n        Assertions.assertTrue(modificationsHashMap.containsKey(\"submittedOnDate\"));\n\n    } END"}
{"prompt":"test Fixed Deposit Account Undo Approval\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountUndoApproval() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.undoApproval(fixedDepositAccountId);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n    } END"}
{"prompt":"test Fixed Deposit Account Rejected And Closed\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountRejectedAndClosed() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String REJECTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.rejectApplication(fixedDepositAccountId, REJECTED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsRejected(fixedDepositAccountStatusHashMap);\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsClosed(fixedDepositAccountStatusHashMap);\n    } END"}
{"prompt":"test Fixed Deposit Account Withdrawn By Client And Closed\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithdrawnByClientAndClosed() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String WITHDRAWN_ON_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.withdrawApplication(fixedDepositAccountId, WITHDRAWN_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsWithdrawn(fixedDepositAccountStatusHashMap);\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsClosed(fixedDepositAccountStatusHashMap);\n    } END"}
{"prompt":"test Fixed Deposit Account Is Deleted\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountIsDeleted() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountId = (Integer) this.fixedDepositAccountHelper.deleteFixedDepositApplication(fixedDepositAccountId, \"resourceId\");\n        Assertions.assertNotNull(fixedDepositAccountId);\n    } END"}
{"prompt":"test Maturity Amount For Monthly Compounding And Monthly Posting With 360 Days\n\n###\n\n","completion":"    @Test\n    public void testMaturityAmountForMonthlyCompoundingAndMonthlyPosting_With_360_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        todaysDate.add(Calendar.DATE, -(currentDate - 1));\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, MONTHLY, MONTHLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, depositAmount, depositPeriod,\n                interestPerDay, MONTHLY_INTERVAL, MONTHLY_INTERVAL);\n\n        LOG.info(\"{}\", principal.toString());\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Maturity amount for Recurring Deposit Account\");\n    } END"}
{"prompt":"test Premature Closure Amount With Penal Interest For Whole Term With 360\n\n###\n\n","completion":"    @Test\n    public void testPrematureClosureAmountWithPenalInterestForWholeTerm_With_360() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateTimeFormatter dateFormat = Utils.dateFormatter;\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(3);\n        final String VALID_FROM = dateFormat.format(todaysDate);\n        todaysDate = todaysDate.plusYears(10);\n        final String VALID_TO = dateFormat.format(todaysDate);\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n        todaysDate = todaysDate.minusDays(1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate);\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate);\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        final String CLOSED_ON_DATE = dateFormat.format(todaysDate);\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        this.fixedDepositAccountHelper.updateInterestCalculationConfigForFixedDeposit(clientId.toString(), fixedDepositProductId.toString(),\n                fixedDepositAccountId.toString(), SUBMITTED_ON_DATE, VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM,\n                INTEREST_CALCULATION_USING_DAILY_BALANCE, MONTHLY, MONTHLY);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float principal = (Float) fixedDepositAccountData.get(\"depositAmount\");\n        Integer depositPeriod = (Integer) fixedDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) fixedDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Float preClosurePenalInterestRate = (Float) fixedDepositAccountData.get(\"preClosurePenalInterest\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = FixedDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, fixedDepositProductId);\n\n        Float interestRate = FixedDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        interestRate -= preClosurePenalInterestRate;\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        log.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        todaysDate = todaysDate.minusMonths(1);\n        todaysDate = todaysDate.minusDays(1);\n\n        Float interestPerMonth = (float) (interestPerDay * principal * DAYS.between(todaysDate, Utils.getLocalDateOfTenant()));\n        principal += interestPerMonth;\n        log.info(\"{}\", Utils.dateFormatter.format(todaysDate));\n        log.info(\"IPM = {}\", interestPerMonth);\n        log.info(\"principal = {}\", principal);\n\n        Integer transactionIdForPostInterest = this.fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n\n        this.fixedDepositAccountHelper.calculatePrematureAmountForFixedDeposit(fixedDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.fixedDepositAccountHelper.prematureCloseForFixedDeposit(\n                fixedDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsPrematureClosed(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        Float maturityAmount = (float) fixedDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    } END"}
{"prompt":"test Maturity Amount For Monthly Compounding And Monthly Posting With 365 Days\n\n###\n\n","completion":"    @Test\n    public void testMaturityAmountForMonthlyCompoundingAndMonthlyPosting_With_365_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        todaysDate.add(Calendar.DATE, -(currentDate - 1));\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, depositAmount, depositPeriod,\n                interestPerDay, MONTHLY_INTERVAL, MONTHLY_INTERVAL);\n\n        LOG.info(\"{}\", principal.toString());\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Maturity amount for Recurring Deposit Account\");\n    } END"}
{"prompt":"test Premature Closure Amount With Penal Interest For Whole Term With 365\n\n###\n\n","completion":"    @Test\n    public void testPrematureClosureAmountWithPenalInterestForWholeTerm_With_365() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateTimeFormatter dateFormat = new DateTimeFormatterBuilder().appendPattern(\"dd MMMM yyyy\").toFormatter();\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(3);\n        final String VALID_FROM = dateFormat.format(todaysDate);\n        todaysDate = todaysDate.plusYears(10);\n        final String VALID_TO = dateFormat.format(todaysDate);\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n        todaysDate = todaysDate.minusDays(1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate);\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate);\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n        LocalDate activationDate = todaysDate;\n        todaysDate = todaysDate.plusMonths(1);\n        todaysDate = todaysDate.plusDays(1);\n        final String CLOSED_ON_DATE = dateFormat.format(todaysDate);\n        LocalDate closingDate = todaysDate;\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float principal = (Float) fixedDepositAccountData.get(\"depositAmount\");\n        Integer depositPeriod = (Integer) fixedDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) fixedDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Float preClosurePenalInterestRate = (Float) fixedDepositAccountData.get(\"preClosurePenalInterest\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = FixedDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, fixedDepositProductId);\n\n        Float interestRate = FixedDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        interestRate -= preClosurePenalInterestRate;\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        log.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        long daysBetween = DAYS.between(activationDate, closingDate);\n        Float totalInterest = (float) (interestPerDay * principal * daysBetween);\n        principal += totalInterest;\n        log.info(\"principal = {}\", principal);\n\n        this.fixedDepositAccountHelper.calculatePrematureAmountForFixedDeposit(fixedDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.fixedDepositAccountHelper.prematureCloseForFixedDeposit(\n                fixedDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsPrematureClosed(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        Float maturityAmount = (float) fixedDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    } END"}
{"prompt":"test Premature Closure Amount With Penal Interest Till Premature Withdrawal With 365 Days\n\n###\n\n","completion":"    @Test\n    public void testPrematureClosureAmountWithPenalInterestTillPrematureWithdrawal_With_365_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        todaysDate.add(Calendar.DAY_OF_MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.MONTH, 1);\n        todaysDate.add(Calendar.DAY_OF_MONTH, 1);\n        final String CLOSED_ON_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, TILL_PREMATURE_WITHDRAWAL, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Float preClosurePenalInterestRate = (Float) recurringDepositAccountData.get(\"preClosurePenalInterest\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Calendar activationDate = Calendar.getInstance();\n        activationDate.add(Calendar.MONTH, -1);\n        activationDate.add(Calendar.DAY_OF_MONTH, -1);\n        ZonedDateTime start = ZonedDateTime.ofInstant(activationDate.getTime().toInstant(), Utils.getZoneIdOfTenant());\n\n        Calendar prematureClosureDate = Calendar.getInstance();\n        ZonedDateTime end = ZonedDateTime.ofInstant(prematureClosureDate.getTime().toInstant(), Utils.getZoneIdOfTenant());\n\n        Integer depositedPeriod = Math.toIntExact(ChronoUnit.MONTHS.between(start.toLocalDate(), end.toLocalDate()));\n\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(depositTransactionId);\n\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"totalDeposits\");\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositedPeriod);\n        interestRate -= preClosurePenalInterestRate;\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.MONTH, -1);\n        calendar.add(Calendar.DAY_OF_MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(calendar.getTime()));\n        Integer daysInMonth = calendar.getActualMaximum(Calendar.DATE);\n        daysInMonth = daysInMonth - currentDate + 1;\n        Float interestPerMonth = (float) (interestPerDay * principal * daysInMonth);\n        principal += interestPerMonth + depositAmount;\n        calendar.add(Calendar.DATE, daysInMonth);\n        LOG.info(\"{}\", monthDayFormat.format(calendar.getTime()));\n\n        expectedFirstDepositOnDate = dateFormat.format(calendar.getTime());\n        Integer transactionIdForDeposit = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(transactionIdForDeposit);\n\n        currentDate = currentDate - 1;\n        interestPerMonth = (float) (interestPerDay * principal * currentDate);\n        LOG.info(\"IPM = {}\", interestPerMonth);\n        principal += interestPerMonth;\n        LOG.info(\"principal = {}\", principal);\n\n        HashMap recurringDepositPrematureData = this.recurringDepositAccountHelper\n                .calculatePrematureAmountForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.recurringDepositAccountHelper.prematureCloseForRecurringDeposit(\n                recurringDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsPrematureClosed(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    } END"}
{"prompt":"test Premature Closure Amount With Penal Interest Till Premature Withdrawal With 360 Days\n\n###\n\n","completion":"    @Test\n    public void testPrematureClosureAmountWithPenalInterestTillPrematureWithdrawal_With_360_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        todaysDate.add(Calendar.DAY_OF_MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.MONTH, 1);\n        todaysDate.add(Calendar.DAY_OF_MONTH, 1);\n        final String CLOSED_ON_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, TILL_PREMATURE_WITHDRAWAL, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_360, TILL_PREMATURE_WITHDRAWAL, INTEREST_CALCULATION_USING_DAILY_BALANCE, MONTHLY, MONTHLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Float preClosurePenalInterestRate = (Float) recurringDepositAccountData.get(\"preClosurePenalInterest\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Calendar activationDate = Calendar.getInstance();\n        activationDate.add(Calendar.MONTH, -1);\n        activationDate.add(Calendar.DAY_OF_MONTH, -1);\n        ZonedDateTime start = ZonedDateTime.ofInstant(activationDate.getTime().toInstant(), Utils.getZoneIdOfTenant());\n\n        Calendar prematureClosureDate = Calendar.getInstance();\n        ZonedDateTime end = ZonedDateTime.ofInstant(prematureClosureDate.getTime().toInstant(), Utils.getZoneIdOfTenant());\n\n        Integer depositedPeriod = Math.toIntExact(ChronoUnit.MONTHS.between(start.toLocalDate(), end.toLocalDate()));\n\n        Integer transactionIdForDeposit = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(transactionIdForDeposit);\n\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"totalDeposits\");\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositedPeriod);\n        interestRate -= preClosurePenalInterestRate;\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.MONTH, -1);\n        calendar.add(Calendar.DAY_OF_MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(calendar.getTime()));\n        Integer daysInMonth = calendar.getActualMaximum(Calendar.DATE);\n        daysInMonth = daysInMonth - currentDate + 1;\n        Float interestPerMonth = (float) (interestPerDay * principal * daysInMonth);\n        principal += interestPerMonth + depositAmount;\n        calendar.add(Calendar.DATE, daysInMonth);\n        LOG.info(\"{}\", monthDayFormat.format(calendar.getTime()));\n\n        expectedFirstDepositOnDate = dateFormat.format(calendar.getTime());\n        Integer newTransactionIdForDeposit = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(newTransactionIdForDeposit);\n\n        currentDate = currentDate - 1;\n        interestPerMonth = (float) (interestPerDay * principal * currentDate);\n        LOG.info(\"IPM = {}\", interestPerMonth);\n        principal += interestPerMonth;\n        LOG.info(\"principal = {}\", principal);\n\n        HashMap recurringDepositPrematureData = this.recurringDepositAccountHelper\n                .calculatePrematureAmountForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.recurringDepositAccountHelper.prematureCloseForRecurringDeposit(\n                recurringDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsPrematureClosed(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    } END"}
{"prompt":"test Maturity Amount For Daily Compounding And Monthly Posting With 365 Days\n\n###\n\n","completion":"    @Test\n    public void testMaturityAmountForDailyCompoundingAndMonthlyPosting_With_365_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        todaysDate.add(Calendar.DATE, -(currentDate - 1));\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_365, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, DAILY, MONTHLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, DAILY_COMPOUNDING_INTERVAL, MONTHLY_INTERVAL);\n\n        LOG.info(\"{}\", principal.toString());\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Maturity amount for Recurring Deposit Account\");\n\n    } END"}
{"prompt":"test Maturity Amount For Daily Compounding And Monthly Posting With 360 Days\n\n###\n\n","completion":"    @Test\n    public void testMaturityAmountForDailyCompoundingAndMonthlyPosting_With_360_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        todaysDate.add(Calendar.DATE, -(currentDate - 1));\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, DAILY, MONTHLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, DAILY_COMPOUNDING_INTERVAL, MONTHLY_INTERVAL);\n\n        LOG.info(\"{}\", principal.toString());\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Maturity amount for Recurring Deposit Account\");\n\n    } END"}
{"prompt":"test Maturity Amount For Daily Compounding And Annually Posting With 365 Days\n\n###\n\n","completion":"    @Test\n    public void testMaturityAmountForDailyCompoundingAndAnnuallyPosting_With_365_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        LOG.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_365, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, DAILY, ANNUALLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        LOG.info(\"per day = {} \", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, DAILY_COMPOUNDING_INTERVAL, ANNUL_INTERVAL);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Maturity amount\");\n\n    } END"}
{"prompt":"test Maturity Amount Daily Compounding And Annually Posting With 360 Days\n\n###\n\n","completion":"    @Test\n    public void testMaturityAmountDailyCompoundingAndAnnuallyPostingWith_360_Days() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        log.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        this.fixedDepositAccountHelper.updateInterestCalculationConfigForFixedDeposit(clientId.toString(), fixedDepositProductId.toString(),\n                fixedDepositAccountId.toString(), SUBMITTED_ON_DATE, VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM,\n                INTEREST_CALCULATION_USING_DAILY_BALANCE, DAILY, ANNUALLY);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float principal = (Float) fixedDepositAccountData.get(\"depositAmount\");\n        Integer depositPeriod = (Integer) fixedDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) fixedDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = FixedDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, fixedDepositProductId);\n\n        Float interestRate = FixedDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        log.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = FixedDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, depositPeriod, interestPerDay,\n                DAILY_COMPOUNDING_INTERVAL, ANNUL_INTERVAL);\n\n        fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) fixedDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Maturity amount\");\n\n    } END"}
{"prompt":"test Fixed Deposit With Bi Annual Compounding And Posting 365 Days\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositWithBi_AnnualCompoundingAndPosting_365_Days() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        log.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        this.fixedDepositAccountHelper.updateInterestCalculationConfigForFixedDeposit(clientId.toString(), fixedDepositProductId.toString(),\n                fixedDepositAccountId.toString(), SUBMITTED_ON_DATE, VALID_FROM, VALID_TO, DAYS_365, WHOLE_TERM,\n                INTEREST_CALCULATION_USING_DAILY_BALANCE, BI_ANNUALLY, BI_ANNUALLY);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float principal = (Float) fixedDepositAccountData.get(\"depositAmount\");\n        Integer depositPeriod = (Integer) fixedDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) fixedDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = FixedDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, fixedDepositProductId);\n\n        Float interestRate = FixedDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        log.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = FixedDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, depositPeriod, interestPerDay,\n                BIANNULLY_INTERVAL, BIANNULLY_INTERVAL);\n\n        fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) fixedDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    } END"}
{"prompt":"test Fixed Deposit With Bi Annual Compounding And Posting 360 Days\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositWithBi_AnnualCompoundingAndPosting_360_Days() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        log.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        this.fixedDepositAccountHelper.updateInterestCalculationConfigForFixedDeposit(clientId.toString(), fixedDepositProductId.toString(),\n                fixedDepositAccountId.toString(), SUBMITTED_ON_DATE, VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM,\n                INTEREST_CALCULATION_USING_DAILY_BALANCE, BI_ANNUALLY, BI_ANNUALLY);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float principal = (Float) fixedDepositAccountData.get(\"depositAmount\");\n        Integer depositPeriod = (Integer) fixedDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) fixedDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = FixedDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, fixedDepositProductId);\n\n        Float interestRate = FixedDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        log.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = FixedDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, depositPeriod, interestPerDay,\n                BIANNULLY_INTERVAL, BIANNULLY_INTERVAL);\n\n        fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) fixedDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    } END"}
{"prompt":"test Fixed Deposit With Quarterly Compounding And Quarterly Posting 365 Days\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositWithQuarterlyCompoundingAndQuarterlyPosting_365_Days() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        log.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        this.fixedDepositAccountHelper.updateInterestCalculationConfigForFixedDeposit(clientId.toString(), fixedDepositProductId.toString(),\n                fixedDepositAccountId.toString(), SUBMITTED_ON_DATE, VALID_FROM, VALID_TO, DAYS_365, WHOLE_TERM,\n                INTEREST_CALCULATION_USING_DAILY_BALANCE, QUARTERLY, QUARTERLY);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float principal = (Float) fixedDepositAccountData.get(\"depositAmount\");\n        Integer depositPeriod = (Integer) fixedDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) fixedDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = FixedDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, fixedDepositProductId);\n\n        Float interestRate = FixedDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        log.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = FixedDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, depositPeriod, interestPerDay,\n                QUARTERLY_INTERVAL, QUARTERLY_INTERVAL);\n\n        fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) fixedDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n    } END"}
{"prompt":"test Fixed Deposit With Quarterly Compounding And Quarterly Posting 360 Days\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositWithQuarterlyCompoundingAndQuarterlyPosting_360_Days() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        log.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        this.fixedDepositAccountHelper.updateInterestCalculationConfigForFixedDeposit(clientId.toString(), fixedDepositProductId.toString(),\n                fixedDepositAccountId.toString(), SUBMITTED_ON_DATE, VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM,\n                INTEREST_CALCULATION_USING_DAILY_BALANCE, QUARTERLY, QUARTERLY);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float principal = (Float) fixedDepositAccountData.get(\"depositAmount\");\n        Integer depositPeriod = (Integer) fixedDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) fixedDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = FixedDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, fixedDepositProductId);\n\n        Float interestRate = FixedDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        log.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = FixedDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, depositPeriod, interestPerDay,\n                QUARTERLY_INTERVAL, QUARTERLY_INTERVAL);\n\n        fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) fixedDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n    } END"}
{"prompt":"test Fixed Deposit Account With Rollover Maturity Amount\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithRolloverMaturityAmount() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        \/***\n         * Create GL Accounts for product account mapping\n         *\/\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/***\n         * Create FD product with CashBased accounting enabled\n         *\/\n        final String accountingRule = CASH_BASED;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount, liabilityAccount,\n                incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        \/***\n         * Set maturityInstructionId as re-invest principal+interest\n         *\/\n        final Integer maturityInstructionId = 300;\n\n        \/***\n         * Apply for FD account with created product and verify status\n         *\/\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM, maturityInstructionId);\n\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        \/***\n         * Approve the FD account and verify whether account is approved\n         *\/\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        \/***\n         * Activate the FD Account and verify whether account is activated\n         *\/\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n    } END"}
{"prompt":"test Fixed Deposit Account With Rollover Principal\n\n###\n\n","completion":"    @Test\n    public void testFixedDepositAccountWithRolloverPrincipal() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        \/***\n         * Create GL Accounts for product account mapping\n         *\/\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/***\n         * Create FD product with CashBased accounting enabled\n         *\/\n        final String accountingRule = CASH_BASED;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount, liabilityAccount,\n                incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        \/***\n         * Set maturityInstructionId as re-invest principal\n         *\/\n        final Integer maturityInstructionId = 400;\n\n        \/***\n         * Apply for FD account with created product and verify status\n         *\/\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM, maturityInstructionId);\n\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        \/***\n         * Approve the FD account and verify whether account is approved\n         *\/\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        \/***\n         * Activate the FD Account and verify whether account is activated\n         *\/\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n    } END"}
{"prompt":"test Savings Interest Posting At Period End\n\n###\n\n","completion":"    @Test\n    public void testSavingsInterestPostingAtPeriodEnd() {\n        \/\/ client activation, savings activation and 1st transaction date\n        final String startDate = \"01 December 2013\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        \/\/ Configuring global config flags\n        configureInterestPosting(true, 4);\n\n        final Integer savingsId = createSavingsAccount(clientID, startDate);\n\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"1000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        \/***\n         * Perform Post interest transaction and verify the posted transaction date\n         *\/\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        HashMap accountDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) accountDetails.get(\"transactions\");\n        HashMap<String, Object> interestPostingTransaction = transactions.get(transactions.size() - 2);\n        for (Map.Entry<String, Object> entry : interestPostingTransaction.entrySet()) {\n            LOG.info(\"{} - {}\", entry.getKey(), entry.getValue().toString());\n        }\n        \/\/ 1st Dec 13 to 31st March 14 - 365 days, daily compounding using daily\n        \/\/ balance\n        \/\/ 33.7016 obtained from formula in excel provided by Subramanya\n        assertEquals(\"33.7016\", interestPostingTransaction.get(\"amount\").toString(), \"Equality check for interest posted amount\");\n        assertEquals(\"[2014, 3, 31]\", interestPostingTransaction.get(\"date\").toString(), \"Date check for Interest Posting transaction\");\n\n    } END"}
{"prompt":"test Create Fund\n\n###\n\n","completion":"    @Test\n    public void testCreateFund() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n    } END"}
{"prompt":"test Create Fund With Empty Name\n\n###\n\n","completion":"    @Test\n    public void testCreateFundWithEmptyName() {\n        FundsHelper fh = FundsHelper.create(null).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final Long fundID = createFund(jsonData, this.requestSpec, responseSpec);\n        Assertions.assertNull(fundID);\n    } END"}
{"prompt":"test Create Fund With Empty External Id\n\n###\n\n","completion":"    @Test\n    public void testCreateFundWithEmptyExternalId() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(null).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n    } END"}
{"prompt":"test Create Fund With Duplicate Name\n\n###\n\n","completion":"    @Test\n    public void testCreateFundWithDuplicateName() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        FundsHelper fh2 = FundsHelper.create(fh.getName()).externalId(UUID.randomUUID().toString()).build();\n        jsonData = fh2.toJSON();\n\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final Long fundID2 = createFund(jsonData, this.requestSpec, responseSpec);\n        Assertions.assertNull(fundID2);\n    } END"}
{"prompt":"test Create Fund With Duplicate External Id\n\n###\n\n","completion":"    @Test\n    public void testCreateFundWithDuplicateExternalId() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        FundsHelper fh2 = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(fh.getExternalId()).build();\n        jsonData = fh2.toJSON();\n\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final Long fundID2 = createFund(jsonData, this.requestSpec, responseSpec);\n        Assertions.assertNull(fundID2);\n    } END"}
{"prompt":"test Create Fund With Invalid Name\n\n###\n\n","completion":"    @Test\n    public void testCreateFundWithInvalidName() {\n        FundsHelper fh = FundsHelper.create(Utils.randomStringGenerator(\"\", 120)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final Long fundID = createFund(jsonData, this.requestSpec, responseSpec);\n        Assertions.assertNull(fundID);\n    } END"}
{"prompt":"test Create Fund With Invalid External Id\n\n###\n\n","completion":"    @Test\n    public void testCreateFundWithInvalidExternalId() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(Utils.randomStringGenerator(\"fund-\", 120))\n                .build();\n        String jsonData = fh.toJSON();\n\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final Long fundID = createFund(jsonData, this.requestSpec, responseSpec);\n        Assertions.assertNull(fundID);\n    } END"}
{"prompt":"test Retrieve Fund\n\n###\n\n","completion":"    @Test\n    public void testRetrieveFund() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        jsonData = FundsResourceHandler.retrieveFund(fundID, this.requestSpec, this.statusOkResponseSpec);\n        FundsHelper fh2 = FundsHelper.fromJSON(jsonData);\n\n        assertEquals(fh.getName(), fh2.getName());\n    } END"}
{"prompt":"test Retrieve All Funds\n\n###\n\n","completion":"    @Test\n    public void testRetrieveAllFunds() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        List<FundsHelper> fhList = FundsResourceHandler.retrieveAllFunds(this.requestSpec, this.statusOkResponseSpec);\n\n        Assertions.assertNotNull(fhList);\n        assertThat(fhList.size(), greaterThanOrEqualTo(1));\n        assertThat(fhList, hasItem(fh));\n    } END"}
{"prompt":"test Retrieve Unknown Fund\n\n###\n\n","completion":"    @Test\n    public void testRetrieveUnknownFund() {\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(404).build();\n        String jsonData = FundsResourceHandler.retrieveFund(Long.MAX_VALUE, this.requestSpec, responseSpec);\n        HashMap<String, Object> map = new Gson().fromJson(jsonData, new TypeToken<HashMap<String, Object>>() {}.getType());\n        assertEquals(\"error.msg.resource.not.found\", map.get(\"userMessageGlobalisationCode\"));\n    } END"}
{"prompt":"test Update Fund\n\n###\n\n","completion":"    @Test\n    public void testUpdateFund() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        String newName = Utils.uniqueRandomStringGenerator(\"\", 10);\n        String newExternalId = UUID.randomUUID().toString();\n        FundsHelper fh2 = FundsResourceHandler.updateFund(fundID, newName, newExternalId, this.requestSpec, this.statusOkResponseSpec);\n\n        Assertions.assertEquals(newName, fh2.getName());\n        Assertions.assertEquals(newExternalId, fh2.getExternalId());\n    } END"}
{"prompt":"test Update Unknown Fund\n\n###\n\n","completion":"    @Test\n    public void testUpdateUnknownFund() {\n        String newName = Utils.uniqueRandomStringGenerator(\"\", 10);\n        String newExternalId = UUID.randomUUID().toString();\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(404).build();\n        FundsHelper fh = FundsResourceHandler.updateFund(Long.MAX_VALUE, newName, newExternalId, this.requestSpec, responseSpec);\n        Assertions.assertNull(fh);\n    } END"}
{"prompt":"test Update Fund With Invalid New Name\n\n###\n\n","completion":"    @Test\n    public void testUpdateFundWithInvalidNewName() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        String newName = Utils.randomStringGenerator(\"\", 120);\n        String newExternalId = UUID.randomUUID().toString();\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(400).build();\n        FundsHelper fh2 = FundsResourceHandler.updateFund(fundID, newName, newExternalId, this.requestSpec, responseSpec);\n\n        Assertions.assertNull(fh2);\n    } END"}
{"prompt":"test Update Fund With New External Id\n\n###\n\n","completion":"    @Test\n    public void testUpdateFundWithNewExternalId() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        String newExternalId = UUID.randomUUID().toString();\n        FundsHelper fh2 = FundsResourceHandler.updateFund(fundID, null, newExternalId, this.requestSpec, this.statusOkResponseSpec);\n\n        Assertions.assertEquals(newExternalId, fh2.getExternalId());\n    } END"}
{"prompt":"test Update Fund With Invalid New External Id\n\n###\n\n","completion":"    @Test\n    public void testUpdateFundWithInvalidNewExternalId() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        String newName = Utils.uniqueRandomStringGenerator(\"\", 10);\n        String newExternalId = Utils.randomStringGenerator(\"fund-\", 120);\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(400).build();\n        FundsHelper fh2 = FundsResourceHandler.updateFund(fundID, newName, newExternalId, this.requestSpec, responseSpec);\n\n        Assertions.assertNull(fh2);\n    } END"}
{"prompt":"test Update Fund With New Name\n\n###\n\n","completion":"    @Test\n    public void testUpdateFundWithNewName() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        String newName = Utils.uniqueRandomStringGenerator(\"\", 10);\n        FundsHelper fh2 = FundsResourceHandler.updateFund(fundID, newName, null, this.requestSpec, this.statusOkResponseSpec);\n\n        Assertions.assertEquals(newName, fh2.getName());\n    } END"}
{"prompt":"test Update Fund With Empty Params\n\n###\n\n","completion":"    @Test\n    public void testUpdateFundWithEmptyParams() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        FundsHelper fh2 = FundsResourceHandler.updateFund(fundID, null, null, this.requestSpec, this.statusOkResponseSpec);\n\n        Assertions.assertNull(fh2.getName());\n        Assertions.assertNull(fh2.getExternalId());\n\n        \/\/ assert that there was no change in\n        \/\/ the name and external ID of the fund\n        jsonData = FundsResourceHandler.retrieveFund(fundID, this.requestSpec, this.statusOkResponseSpec);\n        FundsHelper fh3 = new Gson().fromJson(jsonData, FundsHelper.class);\n\n        Assertions.assertEquals(fh.getName(), fh3.getName());\n        Assertions.assertEquals(fh.getExternalId(), fh3.getExternalId());\n    } END"}
{"prompt":"test Interest Charged From Date Same As Disbursal Date\n\n###\n\n","completion":"    @Test\n    public void testInterestChargedFromDateSameAsDisbursalDate() {\n        this.globalConfigurationHelper = new GlobalConfigurationHelper(this.requestSpec, this.responseSpec);\n\n        \/\/ Retrieving All Global Configuration details\n        final ArrayList<HashMap> globalConfig = GlobalConfigurationHelper.getAllGlobalConfigurations(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(globalConfig);\n\n        String configName = \"interest-charged-from-date-same-as-disbursal-date\";\n        boolean newBooleanValue = true;\n\n        for (Integer configIndex = 0; configIndex < globalConfig.size(); configIndex++) {\n            if (globalConfig.get(configIndex).get(\"name\").equals(configName)) {\n                String configId = globalConfig.get(configIndex).get(\"id\").toString();\n                Integer updateConfigId = GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec,\n                        this.responseSpec, configId.toString(), newBooleanValue);\n                Assertions.assertNotNull(updateConfigId);\n                break;\n            }\n        }\n\n    } END"}
{"prompt":"test Global Configurations\n\n###\n\n","completion":"    @Test\n    public void testGlobalConfigurations() {\n        this.globalConfigurationHelper = new GlobalConfigurationHelper(this.requestSpec, this.responseSpec);\n\n        \/\/ Retrieving All Global Configuration details\n        final ArrayList<HashMap> globalConfig = GlobalConfigurationHelper.getAllGlobalConfigurations(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(globalConfig);\n\n        String configName = \"penalty-wait-period\";\n        for (Integer configIndex = 0; configIndex < globalConfig.size() - 1; configIndex++) {\n            if (globalConfig.get(configIndex).get(\"name\").equals(configName)) {\n                Integer configId = (Integer) globalConfig.get(configIndex).get(\"id\");\n                Assertions.assertNotNull(configId);\n\n                HashMap configDataBefore = GlobalConfigurationHelper.getGlobalConfigurationById(this.requestSpec, this.responseSpec,\n                        configId.toString());\n                Assertions.assertNotNull(configDataBefore);\n\n                Integer value = (Integer) configDataBefore.get(\"value\") + 1;\n\n                \/\/ Updating Value for penalty-wait-period Global Configuration\n                configId = GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec,\n                        configId.toString(), value.toString());\n                Assertions.assertNotNull(configId);\n\n                HashMap configDataAfter = GlobalConfigurationHelper.getGlobalConfigurationById(this.requestSpec, this.responseSpec,\n                        configId.toString());\n\n                \/\/ Verifying Value for penalty-wait-period after Updation\n                Assertions.assertEquals(value, configDataAfter.get(\"value\"), \"Verifying Global Config Value after Updation\");\n\n                \/\/ Updating Enabled Flag for penalty-wait-period Global\n                \/\/ Configuration\n                Boolean enabled = (Boolean) globalConfig.get(configIndex).get(\"enabled\");\n\n                if (enabled == true) {\n                    enabled = false;\n                } else {\n                    enabled = true;\n                }\n\n                configId = GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec,\n                        configId.toString(), enabled);\n\n                configDataAfter = GlobalConfigurationHelper.getGlobalConfigurationById(this.requestSpec, this.responseSpec,\n                        configId.toString());\n\n                \/\/ Verifying Enabled Flag for penalty-wait-period after Updation\n                Assertions.assertEquals(enabled, configDataAfter.get(\"enabled\"), \"Verifying Enabled Flag Global Config after Updation\");\n                break;\n            }\n        }\n    } END"}
{"prompt":"test Global Configuration Is Cache Enabled\n\n###\n\n","completion":"    @Test\n    public void testGlobalConfigurationIsCacheEnabled() {\n        this.globalConfigurationHelper = new GlobalConfigurationHelper(this.requestSpec, this.responseSpec);\n\n        \/\/ Retrieving Is Cache Enabled Global Configuration details\n        ArrayList<HashMap> isCacheGlobalConfig = GlobalConfigurationHelper.getGlobalConfigurationIsCacheEnabled(this.requestSpec,\n                this.responseSpec);\n        Assertions.assertNotNull(isCacheGlobalConfig);\n\n        for (Integer cacheType = 0; cacheType <= isCacheGlobalConfig.size() - 1; cacheType++) {\n\n            \/\/ Retrieving Is Cache Enabled Global Configuration details\n            isCacheGlobalConfig = GlobalConfigurationHelper.getGlobalConfigurationIsCacheEnabled(this.requestSpec, this.responseSpec);\n            Assertions.assertNotNull(isCacheGlobalConfig);\n\n            HashMap cacheTypeAsHashMap = (HashMap) isCacheGlobalConfig.get(cacheType).get(\"cacheType\");\n            Integer cacheTypeId = (Integer) cacheTypeAsHashMap.get(\"id\");\n            String cacheTypeValue = (String) cacheTypeAsHashMap.get(\"value\");\n            Boolean enabled = (Boolean) isCacheGlobalConfig.get(cacheType).get(\"enabled\");\n\n            if (cacheTypeValue.compareTo(\"No cache\") == 0 && enabled == true) {\n                cacheTypeId += 1;\n            } else if (cacheTypeValue.compareTo(\"Single node\") == 0 && enabled == true) {\n                cacheTypeId -= 1;\n            }\n\n            HashMap changes = GlobalConfigurationHelper.updateIsCacheEnabledForGlobalConfiguration(this.requestSpec, this.responseSpec,\n                    cacheTypeId.toString());\n            Assertions.assertEquals(cacheTypeId, changes.get(\"cacheType\"), \"Verifying Is Cache Enabled Global Config after Updation\");\n        }\n    } END"}
{"prompt":"test Global Config Force Password Reset Days\n\n###\n\n","completion":"    @Test\n    public void testGlobalConfigForcePasswordResetDays() {\n\n        \/\/ Retrieving All Global Configuration details\n        final ArrayList<HashMap> globalConfig = GlobalConfigurationHelper.getAllGlobalConfigurations(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(globalConfig);\n\n        String configName = \"force-password-reset-days\";\n        String newValue = \"0\";\n        String newBooleanValue = \"true\";\n\n        for (Integer configIndex = 0; configIndex < globalConfig.size() - 1; configIndex++) {\n            if (globalConfig.get(configIndex).get(\"name\").equals(configName)) {\n                Integer configId = (Integer) globalConfig.get(configIndex).get(\"id\");\n                Assertions.assertNotNull(configId);\n\n                \/*\n                 * Update force-password-reset-days with value as 0 and Enable as true - failure case\n                 *\/\n                ArrayList error = (ArrayList) GlobalConfigurationHelper.updatePasswordResetDaysForGlobalConfiguration(this.requestSpec,\n                        this.httpStatusForidden, configId, newValue, newBooleanValue, CommonConstants.RESPONSE_ERROR);\n                HashMap hash = (HashMap) error.get(0);\n\n                Assertions.assertEquals(\"error.msg.password.reset.days.value.must.be.greater.than.zero\",\n                        hash.get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE),\n                        \"Force Password Reset days value must be greater than zero.\");\n\n                \/*\n                 * Update force-password-reset-days with value as 50 and Enable as true - success case\n                 *\/\n                final HashMap updateSuccess = (HashMap) GlobalConfigurationHelper.updatePasswordResetDaysForGlobalConfiguration(\n                        this.requestSpec, this.responseSpec, configId, \"50\", newBooleanValue, \"changes\");\n                Assertions.assertNotNull(updateSuccess);\n\n                \/* Update with value as 0 and Enable as false - success case *\/\n                final HashMap updateSuccess1 = (HashMap) GlobalConfigurationHelper.updatePasswordResetDaysForGlobalConfiguration(\n                        this.requestSpec, this.responseSpec, configId, newValue, \"false\", \"changes\");\n                Assertions.assertNotNull(updateSuccess1);\n\n                \/*\n                 * Update without sending value and Enable as true - failure case\n                 *\/\n                ArrayList failure = (ArrayList) GlobalConfigurationHelper.updatePasswordResetDaysForGlobalConfiguration(this.requestSpec,\n                        this.httpStatusForidden, configId, null, newBooleanValue, CommonConstants.RESPONSE_ERROR);\n                HashMap failureHash = (HashMap) failure.get(0);\n                Assertions.assertEquals(\"error.msg.password.reset.days.value.must.be.greater.than.zero\",\n                        failureHash.get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE),\n                        \"Force Password Reset days value must be greater than zero.\");\n\n                break;\n            }\n        }\n        \/* Update other global configuration property *\/\n        String otherConfigName = \"maker-checker\";\n        for (Integer configIndex = 0; configIndex < globalConfig.size() - 1; configIndex++) {\n            if (globalConfig.get(configIndex).get(\"name\").equals(otherConfigName)) {\n                String configId = globalConfig.get(configIndex).get(\"id\").toString();\n                Integer updateConfigId = GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec,\n                        configId, newValue);\n                Assertions.assertNotNull(updateConfigId);\n                break;\n            }\n        }\n    } END"}
{"prompt":"check Group Loan Create And Disburse Flow\n\n###\n\n","completion":"    @Test\n    public void checkGroupLoanCreateAndDisburseFlow() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n\n        final Integer loanProductID = createLoanProduct();\n        final Integer loanID = applyForLoanApplication(groupID, loanProductID);\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec,\n                loanID);\n        verifyLoanRepaymentSchedule(loanSchedule);\n    } END"}
{"prompt":"check Glim Account Commands\n\n###\n\n","completion":"    @Test\n    public void checkGlimAccountCommands() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        final Integer loanProductID = createLoanProduct();\n\n        HashMap<String, Integer> glim = applyForGlimApplication(clientID, groupID, loanProductID);\n        LOG.info(\"Glim Loan Application: {} \", glim);\n\n        final Integer glimId = glim.get(\"glimId\");\n        LOG.info(\"GlimId : {} \", glimId);\n\n        final Integer loanId = glim.get(\"loanId\");\n        LOG.info(\"LoanId : {} \", loanId);\n\n        List<Map<String, Object>> approvalFormData = new ArrayList<>();\n        approvalFormData.add(approvalFormData(loanId, \"22 September 2011\"));\n\n        HashMap loanStatusHashMap = this.loanTransactionHelper.approveGlimAccount(this.requestSpec, this.responseSpec, approvalFormData,\n                glimId);\n        LOG.info(\"glim approval loanSchedule: {} \", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.disburseGlimAccount(\"25 September 2011\", glimId);\n        LOG.info(\"glim disbursement loanSchedule: {} \", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.undoDisburseGlimAccount(glimId);\n        LOG.info(\"glim undodisbursement loanSchedule: {} \", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.undoApprovalGlimAccount(glimId);\n        LOG.info(\"glim undoApproval loanSchedule: {} \", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.rejectGlimAccount(\"22 September 2011\", glimId);\n        LOG.info(\"glim reject loanSchedule: {} \", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanAccountRejected(loanStatusHashMap);\n    } END"}
{"prompt":"get Glim Account By Group Id\n\n###\n\n","completion":"    @Test\n    public void getGlimAccountByGroupId() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final Integer loanProductID = createLoanProduct();\n        Assertions.assertNotNull(loanProductID);\n\n        HashMap<String, Integer> glim = applyForGlimApplication(clientID, groupID, loanProductID);\n        LOG.info(\"Glim Loan Application: {} \", glim);\n\n        final Integer glimId = glim.get(\"glimId\");\n        LOG.info(\"GlimId: {} \", glimId);\n\n        final Integer loanId = glim.get(\"loanId\");\n        LOG.info(\"LoanId: {} \", loanId);\n\n        final List<String> retrievedGlimId = GroupHelper.verifyRetrieveGlimAccountsByGroupId(this.requestSpec, this.responseSpec, groupID);\n        Assertions.assertNotNull(retrievedGlimId.toString());\n    } END"}
{"prompt":"get Glim Account By Glim Id\n\n###\n\n","completion":"    @Test\n    public void getGlimAccountByGlimId() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final Integer loanProductID = createLoanProduct();\n        Assertions.assertNotNull(loanProductID);\n\n        HashMap<String, Integer> glim = applyForGlimApplication(clientID, groupID, loanProductID);\n        LOG.info(\"Glim Loan Application: {} \", glim);\n\n        final Integer glimId = glim.get(\"glimId\");\n        LOG.info(\"GlimId: {} \", glimId);\n\n        final Integer loanId = glim.get(\"loanId\");\n        LOG.info(\"LoanId: {} \", loanId);\n\n        final List<String> retrievedGlimAccountId = GroupHelper.verifyRetrieveGlimAccountsByGlimId(this.requestSpec, this.responseSpec,\n                glimId);\n        Assertions.assertNotNull(retrievedGlimAccountId);\n    } END"}
{"prompt":"test Gsim Savings Account REJECT APPLICATION\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testGsimSavingsAccount_REJECT_APPLICATION() {\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        List<Map<String, Object>> clientArray = new ArrayList<>();\n        clientArray.add(clientArray(clientID, groupID, savingsProductID, \"08 January 2013\"));\n\n        final Integer gsimID = this.savingsAccountHelper.applyForGsimApplication(clientArray);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.approveGsimSavings(gsimID);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        List<HashMap> error1 = savingsAccountHelperValidationError.rejectGsimApplicationWithErrorCode(gsimID,\n                SavingsAccountHelper.CREATED_DATE_PLUS_ONE);\n        assertEquals(\"validation.msg.savingsaccount.reject.not.in.submittedandpendingapproval.state\",\n                error1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        savingsStatusHashMap = this.savingsAccountHelper.undoApprovalGsimSavings(gsimID);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        error1 = savingsAccountHelperValidationError.rejectGsimApplicationWithErrorCode(gsimID, SavingsAccountHelper.getFutureDate());\n        assertEquals(\"validation.msg.savingsaccount.reject.cannot.be.a.future.date\",\n                error1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error1 = savingsAccountHelperValidationError.rejectGsimApplicationWithErrorCode(gsimID,\n                SavingsAccountHelper.CREATED_DATE_MINUS_ONE);\n        assertEquals(\"validation.msg.savingsaccount.reject.cannot.be.before.submittal.date\",\n                error1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        savingsStatusHashMap = this.savingsAccountHelper.rejectGsimApplication(gsimID);\n        SavingsStatusChecker.verifySavingsIsRejected(savingsStatusHashMap);\n\n    } END"}
{"prompt":"test Gsim Savings Account DEPOSIT APPLICATION\n\n###\n\n","completion":"    @Test\n    public void testGsimSavingsAccount_DEPOSIT_APPLICATION() {\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        List<Map<String, Object>> clientArray = new ArrayList<>();\n        clientArray.add(clientArray(clientID, groupID, savingsProductID, \"08 January 2013\"));\n        LOG.info(\"client Array : {} \", clientArray);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        String name = PaymentTypeHelper.randomNameGenerator(\"P_T\", 5);\n        String description = PaymentTypeHelper.randomNameGenerator(\"PT_Desc\", 15);\n        Boolean isCashPayment = true;\n        Integer position = 1;\n\n        Integer paymentTypeId = PaymentTypeHelper.createPaymentType(requestSpec, responseSpec, name, description, isCashPayment, position);\n        Assertions.assertNotNull(paymentTypeId);\n\n        List<Map<String, Object>> savingsArray = new ArrayList<>();\n        final Integer transactionAmount = 2500;\n        savingsArray.add(savingsArray(paymentTypeId, savingsId, transactionAmount, \"10 March 2013\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final Integer depositId = this.savingsAccountHelper.depositGsimApplication(savingsId, savingsArray);\n        Assertions.assertNotNull(depositId);\n\n    } END"}
{"prompt":"test Gsim Savings Account CLOSE APPLICATION\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testGsimSavingsAccount_CLOSE_APPLICATION() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"1000.0\";\n        final String enforceMinRequiredBalance = \"true\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        List<Map<String, Object>> clientArray = new ArrayList<>();\n        clientArray.add(clientArray(clientID, groupID, savingsProductID, \"08 January 2013\"));\n\n        final Integer gsimID = this.savingsAccountHelper.applyForGsimApplication(clientArray);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.approveGsimSavings(gsimID);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateGsimSavings(gsimID);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        final String CLOSEDON_DATE = dateFormat.format(todaysDate.getTime());\n        String withdrawBalance = \"false\";\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper\n                .closeGsimSavingsAccountAndGetBackRequiredField(gsimID, withdrawBalance, CommonConstants.RESPONSE_ERROR, CLOSEDON_DATE);\n        assertEquals(\"validation.msg.savingsaccount.close.results.in.balance.not.zero\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        withdrawBalance = \"true\";\n        savingsStatusHashMap = this.savingsAccountHelper.closeGsimSavingsAccount(gsimID, withdrawBalance);\n        SavingsStatusChecker.verifySavingsAccountIsClosed(savingsStatusHashMap);\n\n    } END"}
{"prompt":"test Gsim Savings Account UPDATE APPLICATION\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testGsimSavingsAccount_UPDATE_APPLICATION() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"1000.0\";\n        final String enforceMinRequiredBalance = \"true\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        List<Map<String, Object>> clientArray = new ArrayList<>();\n        clientArray.add(clientArray(clientID, groupID, savingsProductID, \"08 January 2013\"));\n\n        final Integer gsimID = this.savingsAccountHelper.applyForGsimApplication(clientArray);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.updateGsimApplication(gsimID, clientID, groupID, savingsProductID);\n        LOG.info(\"savingsStatusHashMap: {} \", savingsStatusHashMap);\n        Assertions.assertTrue(savingsStatusHashMap.containsKey(\"savingsId\"));\n\n    } END"}
{"prompt":"get Gsim Account\n\n###\n\n","completion":"    @Test\n    public void getGsimAccount() {\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        \/\/ Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"1000.0\";\n        final String enforceMinRequiredBalance = \"true\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        List<Map<String, Object>> clientArray = new ArrayList<>();\n        clientArray.add(clientArray(clientID, groupID, savingsProductID, \"08 January 2013\"));\n        final Integer gsimID = this.savingsAccountHelper.applyForGsimApplication(clientArray);\n\n        final List<String> retrievedGsimId = GroupHelper.verifyRetrieveGsimAccounts(this.requestSpec, this.responseSpec, groupID);\n        Assertions.assertNotNull(retrievedGsimId.toString());\n    } END"}
{"prompt":"check Group Functions\n\n###\n\n","completion":"    @Test\n    public void checkGroupFunctions() {\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec);\n        GroupHelper.verifyGroupCreatedOnServer(this.requestSpec, this.responseSpec, groupID);\n\n        groupID = GroupHelper.activateGroup(this.requestSpec, this.responseSpec, groupID.toString());\n        GroupHelper.verifyGroupActivatedOnServer(this.requestSpec, this.responseSpec, groupID, true);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        GroupHelper.verifyGroupMembers(this.requestSpec, this.responseSpec, groupID, clientID);\n\n        groupID = GroupHelper.disAssociateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        GroupHelper.verifyEmptyGroupMembers(this.requestSpec, this.responseSpec, groupID);\n\n        final String updatedGroupName = GroupHelper.randomNameGenerator(\"Group-\", 5);\n        groupID = GroupHelper.updateGroup(this.requestSpec, this.responseSpec, updatedGroupName, groupID.toString());\n        GroupHelper.verifyGroupDetails(this.requestSpec, this.responseSpec, groupID, \"name\", updatedGroupName);\n\n        \/\/ NOTE: removed as consistently provides false positive result on\n        \/\/ cloudbees server.\n        \/\/ groupID = GroupHelper.createGroup(this.requestSpec,\n        \/\/ this.responseSpec);\n        \/\/ GroupHelper.deleteGroup(this.requestSpec, this.responseSpec,\n        \/\/ groupID.toString());\n        \/\/ GroupHelper.verifyGroupDeleted(this.requestSpec, this.responseSpec,\n        \/\/ groupID);\n    } END"}
{"prompt":"assign Staff To Group\n\n###\n\n","completion":"    @Test\n    public void assignStaffToGroup() {\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec);\n        GroupHelper.verifyGroupCreatedOnServer(this.requestSpec, this.responseSpec, groupID);\n\n        final String updateGroupName = Utils.uniqueRandomStringGenerator(\"Savings Group Help_\", 5);\n        groupID = GroupHelper.activateGroup(this.requestSpec, this.responseSpec, groupID.toString());\n        Integer updateGroupId = GroupHelper.updateGroup(this.requestSpec, this.responseSpec, updateGroupName, groupID.toString());\n\n        \/\/ create client and add client to group\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        GroupHelper.verifyGroupMembers(this.requestSpec, this.responseSpec, groupID, clientID);\n\n        \/\/ create staff\n        Integer createStaffId1 = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        LOG.info(\"--------------creating first staff with id------------- {}\", createStaffId1);\n        Assertions.assertNotNull(createStaffId1);\n\n        Integer createStaffId2 = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        LOG.info(\"--------------creating second staff with id------------- {}\", createStaffId2);\n        Assertions.assertNotNull(createStaffId2);\n\n        \/\/ assign staff \"createStaffId1\" to group\n        HashMap assignStaffGroupId = (HashMap) GroupHelper.assignStaff(this.requestSpec, this.responseSpec, groupID.toString(),\n                createStaffId1.longValue());\n        assertEquals(assignStaffGroupId.get(\"staffId\"), createStaffId1, \"Verify assigned staff id is the same as id sent\");\n\n        \/\/ assign staff \"createStaffId2\" to client\n        final HashMap assignStaffToClientChanges = (HashMap) ClientHelper.assignStaffToClient(this.requestSpec, this.responseSpec,\n                clientID.toString(), createStaffId2.toString());\n        assertEquals(assignStaffToClientChanges.get(\"staffId\"), createStaffId2, \"Verify assigned staff id is the same as id sent\");\n\n        final Integer loanProductId = this.createLoanProduct();\n\n        final Integer loanId = this.applyForLoanApplication(clientID, loanProductId, this.principal);\n\n        this.loanTransactionHelper.approveLoan(\"20 September 2014\", loanId);\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2014\", loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n\n        final HashMap assignStaffAndInheritStaffForClientAccounts = (HashMap) GroupHelper.assignStaffInheritStaffForClientAccounts(\n                this.requestSpec, this.responseSpec, groupID.toString(), createStaffId1.toString());\n        final Integer getClientStaffId = ClientHelper.getClientsStaffId(this.requestSpec, this.responseSpec, clientID.toString());\n\n        \/\/ assert if client staff officer has change Note client was assigned\n        \/\/ staff with createStaffId2\n        assertNotEquals(assignStaffAndInheritStaffForClientAccounts.get(\"staffId\"), createStaffId2, \"Verify if client stuff has changed\");\n        assertEquals(assignStaffAndInheritStaffForClientAccounts.get(\"staffId\"), getClientStaffId,\n                \"Verify if client inherited staff assigned above\");\n\n        \/\/ assert if clients loan officer has changed\n        final Integer loanOfficerId = this.loanTransactionHelper.getLoanOfficerId(loanId.toString());\n        assertEquals(assignStaffAndInheritStaffForClientAccounts.get(\"staffId\"), loanOfficerId, \"Verify if client loan inherited staff\");\n\n    } END"}
{"prompt":"should Send Office Creation Notification\n\n###\n\n","completion":"    @Test\n    public void shouldSendOfficeCreationNotification() {\n        \/\/ Subject to https:\/\/echo-webhook.herokuapp.com being up\n        \/\/ See http:\/\/www.jamesward.com\/2014\/06\/11\/testing-webhooks-was-a-pain-so-i-fixed-the-glitch\n        final String uniqueId = UUID.randomUUID().toString();\n        final String payloadURL = \"http:\/\/echo-webhook.herokuapp.com:80\/\" + uniqueId + \"\/\";\n        final Integer hookId = this.hookHelper.createHook(payloadURL);\n        Assertions.assertNotNull(hookId);\n        final Integer createdOfficeID = this.officeHelper.createOffice(\"01 January 2012\");\n        Assertions.assertNotNull(createdOfficeID);\n        try {\n            \/\/ sleep for a three seconds after each failure to increase the likelihood of the previous request for\n            \/\/ creating office completing\n            for (int i = 0; i < 6; i++) {\n                try {\n                    final String json = RestAssured.get(payloadURL.replace(\"?\", \"\")).asString();\n                    final Integer notificationOfficeId = JsonPath.with(json).get(\"officeId\");\n                    Assertions.assertEquals(createdOfficeID, notificationOfficeId,\n                            \"Equality check for created officeId and hook received payload officeId\");\n                    LOG.info(\"Notification Office Id - {}\", notificationOfficeId);\n                    i = 6;\n                } catch (Exception e) {\n                    TimeUnit.SECONDS.sleep(3);\n                    i++;\n                }\n            }\n\n        } catch (final Exception e) {\n            if (e instanceof HttpHostConnectException) {\n                fail(\"Failed to connect to https:\/\/echo-webhook.herokuapp.com platform\");\n            }\n            throw new RuntimeException(e);\n        } finally {\n            this.hookHelper.deleteHook(hookId.longValue());\n        }\n    } END"}
{"prompt":"create Update And Delete Hook\n\n###\n\n","completion":"    @Test\n    public void createUpdateAndDeleteHook() {\n        final String payloadURL = \"http:\/\/echo-webhook.herokuapp.com:80\/Z7RXoCBdLSFMDrpn\/\";\n        final String updateURL = \"http:\/\/localhost\";\n\n        Long hookId = this.hookHelper.createHook(payloadURL).longValue();\n        Assertions.assertNotNull(hookId);\n        this.hookHelper.verifyHookCreatedOnServer(hookId);\n        LOG.info(\"---------------------SUCCESSFULLY CREATED AND VERIFIED HOOK------------------------- {}\", hookId);\n        this.hookHelper.updateHook(updateURL, hookId);\n        this.hookHelper.verifyUpdateHook(updateURL, hookId);\n        LOG.info(\"---------------------SUCCESSFULLY UPDATED AND VERIFIED HOOK------------------------- {}\", hookId);\n        this.hookHelper.deleteHook(hookId);\n        this.hookHelper.verifyDeleteHook(hookId);\n        LOG.info(\"---------------------SUCCESSFULLY DELETED AND VERIFIED HOOK------------------------- {}\", hookId);\n    } END"}
{"prompt":"shoud The Second Request With Same Idempotency Key Will Failure Too\n\n###\n\n","completion":"    @Test\n    public void shoudTheSecondRequestWithSameIdempotencyKeyWillFailureToo() {\n        ResponseSpecification responseSpecForError = new ResponseSpecBuilder().expectStatusCode(400).build();\n        List<BusinessStep> requestBody = new ArrayList<>();\n        String idempotencyKey = UUID.randomUUID().toString();\n        \/\/ IdempotencyHelper.configuredApiParameterErrorFromJsonString(response.getBody().asString())\n\n        Response response1 = IdempotencyHelper.updateBusinessStepOrderWithError(requestSpec, responseSpecForError, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKey);\n        Assertions.assertNull(response1.getHeader(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        String originalBody = response1.getBody().asString();\n\n        Response response2 = IdempotencyHelper.updateBusinessStepOrderWithError(requestSpec, responseSpecForError, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKey);\n        Assertions.assertNotNull(response2.getHeader(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertEquals(originalBody, response2.getBody().asString());\n    } END"}
{"prompt":"test Get Head Office Works When Instance Mode Is Read Only\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = true, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = false)\n    @Test\n    public void testGetHeadOfficeWorks_WhenInstanceModeIsReadOnly() {\n        \/\/ given\n        \/\/ when\n        GetOfficesResponse result = OfficeHelper.getHeadOffice(requestSpec, responseSpec200);\n        \/\/ then\n        assertNotNull(result);\n    } END"}
{"prompt":"test Get Head Office Works When Instance Mode Is Write Only\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = false, writeEnabled = true, batchWorkerEnabled = false, batchManagerEnabled = false)\n    @Test\n    public void testGetHeadOfficeWorks_WhenInstanceModeIsWriteOnly() {\n        \/\/ given\n        \/\/ when\n        GetOfficesResponse result = OfficeHelper.getHeadOffice(requestSpec, responseSpec200);\n        \/\/ then\n        assertNotNull(result);\n    } END"}
{"prompt":"test Get Head Office Doesnt Work When Instance Mode Is Batch Only\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = true, batchManagerEnabled = true)\n    @Test\n    public void testGetHeadOfficeDoesntWork_WhenInstanceModeIsBatchOnly() {\n        \/\/ given\n        \/\/ when\n        OfficeHelper.getHeadOffice(requestSpec, responseSpec405);\n        \/\/ then no exception is thrown\n    } END"}
{"prompt":"test Create Client Doesnt Work When Read Only\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = true, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = false)\n    @Test\n    public void testCreateClientDoesntWork_WhenReadOnly() {\n        \/\/ given\n        PostClientsRequest request = ClientHelper.defaultClientCreationRequest();\n        \/\/ when\n        ClientHelper.createClient(requestSpec, responseSpec405, request);\n        \/\/ then no exception thrown\n    } END"}
{"prompt":"test Create Client Works When Write Only\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = false, writeEnabled = true, batchWorkerEnabled = false, batchManagerEnabled = false)\n    @Test\n    public void testCreateClientWorks_WhenWriteOnly() {\n        \/\/ given\n        PostClientsRequest request = ClientHelper.defaultClientCreationRequest();\n        \/\/ when\n        Integer result = ClientHelper.createClient(requestSpec, responseSpec200, request);\n        \/\/ then\n        assertNotNull(result);\n    } END"}
{"prompt":"test Create Client Doesnt Work When Batch Only\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = true, batchManagerEnabled = true)\n    @Test\n    public void testCreateClientDoesntWork_WhenBatchOnly() {\n        \/\/ given\n        PostClientsRequest request = ClientHelper.defaultClientCreationRequest();\n        \/\/ when\n        ClientHelper.createClient(requestSpec, responseSpec405, request);\n        \/\/ then no exception thrown\n    } END"}
{"prompt":"test Run Scheduler Job Doesnt Work When Read Only\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = true, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = false)\n    @Test\n    public void testRunSchedulerJobDoesntWork_WhenReadOnly() {\n        \/\/ given\n        \/\/ when\n        schedulerJobHelper.runSchedulerJob(jobId, responseSpec405);\n        \/\/ then no exception thrown\n    } END"}
{"prompt":"test Run Scheduler Job Doesnt Work When Write Only\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = false, writeEnabled = true, batchWorkerEnabled = false, batchManagerEnabled = false)\n    @Test\n    public void testRunSchedulerJobDoesntWork_WhenWriteOnly() {\n        \/\/ given\n        \/\/ when\n        schedulerJobHelper.runSchedulerJob(jobId, responseSpec405);\n        \/\/ then no exception thrown\n    } END"}
{"prompt":"test Run Scheduler Job Works When Batch Only\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = true, batchManagerEnabled = true)\n    @Test\n    public void testRunSchedulerJobWorks_WhenBatchOnly() {\n        \/\/ given\n        \/\/ when\n        schedulerJobHelper.runSchedulerJob(jobId);\n        \/\/ then no exception thrown\n    } END"}
{"prompt":"loan Arrears Ageing COBBusiness Step Test\n\n###\n\n","completion":"    @Test\n    public void loanArrearsAgeingCOBBusinessStepTest() {\n        \/\/ Set Business Date\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            LocalDate businessDate = Utils.getLocalDateOfTenant();\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n\n            LocalDate operationDate = businessDate.minusDays(40);\n            String loanOperationDate = Utils.dateFormatter.format(operationDate);\n\n            \/\/ create Client\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n\n            \/\/ create Loan Product\n\n            \/\/ Delinquency Bucket\n            final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketId);\n\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                    delinquencyBucketId);\n            assertNotNull(getLoanProductsProductResponse);\n\n            \/\/ Loan1 ExternalId\n            String loan1ExternalIdStr = UUID.randomUUID().toString();\n\n            \/\/ create Loan Account for Client with Loan Product type 1\n            Long loanProductId = getLoanProductsProductResponse.getId();\n            final Integer loanId_1 = createLoanAccount(loanOperationDate, clientId, loanProductId, loan1ExternalIdStr);\n\n            String loan2ExternalIdStr = UUID.randomUUID().toString();\n            final Integer loanId_2 = createLoanAccount(loanOperationDate, clientId, loanProductId, loan2ExternalIdStr);\n\n            \/\/ Run Loan cob with verfying business step for Update Arrears ageing details\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n\n            \/\/ COB Step Validation\n            final JobBusinessStepConfigData jobBusinessStepConfigData = BusinessStepConfigurationHelper\n                    .getConfiguredBusinessStepsByJobName(requestSpec, responseSpec, BusinessConfigurationApiTest.LOAN_JOB_NAME);\n            assertNotNull(jobBusinessStepConfigData);\n            assertEquals(BusinessConfigurationApiTest.LOAN_JOB_NAME, jobBusinessStepConfigData.getJobName());\n            assertTrue(jobBusinessStepConfigData.getBusinessSteps().size() > 0);\n            assertTrue(jobBusinessStepConfigData.getBusinessSteps().stream()\n                    .anyMatch(businessStep -> UPDATE_LOAN_ARREARS_AGING.equals(businessStep.getStepName())));\n\n            \/\/ Run the Loan COB Job\n            final String jobName = \"Loan COB\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            \/\/ verify Arrears details are updated for both the loans, by verifying loan summary fields for\n            \/\/ principalOverdue,totalOverdue,overdueSinceddate\n\n            \/\/ Retrieve Loan 1 with loanId\n            GetLoansLoanIdResponse loan1Details = loanTransactionHelper.getLoanDetails((long) loanId_1);\n            GetLoansLoanIdSummary loan1Summary = loan1Details.getSummary();\n            assertNotNull(loan1Summary);\n            assertNotNull(loan1Summary.getOverdueSinceDate());\n            assertEquals(loan1Summary.getPrincipalOverdue(), 1000.00);\n            assertEquals(loan1Summary.getTotalOverdue(), 1000.00);\n\n            \/\/ Retrieve Loan 2 with loanId\n            GetLoansLoanIdResponse loan2Details = loanTransactionHelper.getLoanDetails((long) loanId_2);\n            GetLoansLoanIdSummary loan2Summary = loan2Details.getSummary();\n            assertNotNull(loan2Summary);\n            assertNotNull(loan2Summary.getOverdueSinceDate());\n            assertEquals(loan2Summary.getPrincipalOverdue(), 1000.00);\n            assertEquals(loan2Summary.getTotalOverdue(), 1000.00);\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"loan Credit Refund Payout Get Created With Chargeback Test\n\n###\n\n","completion":"    @Test\n    public void loanCreditRefundPayoutGetCreatedWithChargebackTest() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        \/\/ Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        \/\/ make Repayment with full amount, Loan balance becomes zero, Loan closes\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 September 2022\").locale(\"en\")\n                        .transactionAmount(1000.0));\n\n        \/\/ Chargeback full repayment amount to add to principal balance\n        PostLoansLoanIdTransactionsResponse chargebackResponse = loanTransactionHelper.chargebackLoanTransaction(loanExternalIdStr,\n                repaymentTransaction_1.getResourceId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().locale(\"en\").transactionAmount(1000.0).paymentTypeId(1L));\n\n        GetLoansLoanIdTransactionsTransactionIdResponse chargebackTransactionResponse = loanTransactionHelper\n                .getLoanTransactionDetails(chargebackResponse.getLoanId(), chargebackResponse.getResourceId());\n        assertEquals(1L, chargebackTransactionResponse.getPaymentDetailData().getPaymentType().getId());\n\n        \/\/ Verify Goodwill Credit can be created with full amount\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"8 September 2022\").locale(\"en\")\n                        .transactionAmount(1000.0));\n        assertNotNull(goodwillCredit_1);\n        assertEquals(goodwillCredit_1.getLoanId(), (long) loanId);\n\n        \/\/ Verify Goodwill Credit can be created after balance is zero again\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_2 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"9 September 2022\").locale(\"en\")\n                        .transactionAmount(10.0));\n        assertNotNull(goodwillCredit_2);\n        assertEquals(goodwillCredit_2.getLoanId(), (long) loanId);\n\n        \/\/ Verify Payout refund can be created after balance is zero again\n        final PostLoansLoanIdTransactionsResponse payoutRefund_1 = loanTransactionHelper.makePayoutRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"9 September 2022\").locale(\"en\")\n                        .transactionAmount(10.0));\n        assertNotNull(payoutRefund_1);\n        assertEquals(payoutRefund_1.getLoanId(), (long) loanId);\n\n        \/\/ Verify Merchant refund can be created after balance is zero again\n        final PostLoansLoanIdTransactionsResponse merchantIssuedRefund_1 = loanTransactionHelper.makeMerchantIssuedRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"10 September 2022\").locale(\"en\")\n                        .transactionAmount(10.0));\n        assertNotNull(merchantIssuedRefund_1);\n        assertEquals(merchantIssuedRefund_1.getLoanId(), (long) loanId);\n\n    } END"}
{"prompt":"test Mark Loan As Fraud\n\n###\n\n","completion":"    @Test\n    public void testMarkLoanAsFraud() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, todaysDate);\n            final String command = \"markAsFraud\";\n            \/\/ Client and Loan account creation\n            final Integer loanId = createAccounts(15, 1);\n\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n\n            \/\/ Default values Not Null and False\n            assertNotNull(getLoansLoanIdResponse.getFraud());\n            assertEquals(Boolean.FALSE, getLoansLoanIdResponse.getFraud());\n\n            String payload = loanTransactionHelper.getLoanFraudPayloadAsJSON(\"fraud\", \"true\");\n            \/\/ Send the request, not expecting any errors (because only open loan restriction removed)\n            PutLoansLoanIdResponse putLoansLoanIdResponse = loanTransactionHelper.modifyLoanCommand(loanId, command, payload,\n                    this.responseSpecError);\n\n            String statusCode = getLoansLoanIdResponse.getStatus().getCode();\n            log.info(\"Loan with Id {} is with Status {}\", getLoansLoanIdResponse.getId(), statusCode);\n\n            \/\/ Approve the Loan active\n            loanTransactionHelper.approveLoan(operationDate, this.amountVal, loanId, null);\n            putLoansLoanIdResponse = loanTransactionHelper.modifyLoanCommand(loanId, command, payload, this.responseSpecError);\n\n            \/\/ Default values Not Null and False\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            assertNotNull(getLoansLoanIdResponse.getFraud());\n            assertEquals(Boolean.FALSE, getLoansLoanIdResponse.getFraud());\n            statusCode = getLoansLoanIdResponse.getStatus().getCode();\n            log.info(\"Loan with Id {} is with Status {}\", getLoansLoanIdResponse.getId(), statusCode);\n\n            loanTransactionHelper.disburseLoanWithNetDisbursalAmount(operationDate, loanId, this.amountVal);\n\n            \/\/ Mark On the Fraud\n            putLoansLoanIdResponse = loanTransactionHelper.modifyLoanCommand(loanId, command, payload, this.responseSpec);\n            assertNotNull(putLoansLoanIdResponse);\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            assertNotNull(getLoansLoanIdResponse.getFraud());\n            assertEquals(Boolean.TRUE, getLoansLoanIdResponse.getFraud());\n\n            \/\/ Mark Off the Fraud\n            payload = loanTransactionHelper.getLoanFraudPayloadAsJSON(\"fraud\", \"false\");\n            putLoansLoanIdResponse = loanTransactionHelper.modifyLoanCommand(loanId, command, payload, this.responseSpec);\n            assertNotNull(putLoansLoanIdResponse);\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            assertNotNull(getLoansLoanIdResponse.getFraud());\n            assertEquals(Boolean.FALSE, getLoansLoanIdResponse.getFraud());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"loan Overpaid Date Status Test\n\n###\n\n","completion":"    @Test\n    public void loanOverpaidDateStatusTest() {\n        \/\/ Set business date\n        try {\n            final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, todaysDate);\n\n            \/\/ Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            \/\/ Delinquency Bucket\n            final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketId);\n\n            \/\/ Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                    delinquencyBucketId);\n            assertNotNull(getLoanProductsProductResponse);\n\n            final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n            \/\/ make Repayments\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 September 2022\").locale(\"en\")\n                            .transactionAmount(200.0));\n\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_2 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"6 September 2022\").locale(\"en\")\n                            .transactionAmount(200.0));\n\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_3 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"7 September 2022\").locale(\"en\")\n                            .transactionAmount(500.0));\n\n            \/\/ make repayment to make loan overpaid\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_4 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"9 September 2022\").locale(\"en\")\n                            .transactionAmount(200.0));\n\n            \/\/ check loan overpaid date is not null and is set as Business date and loan status\n            GetLoansLoanIdResponse loanDetailsOverpaid = loanTransactionHelper.getLoanDetails((long) loanId);\n            assertTrue(loanDetailsOverpaid.getStatus().getOverpaid());\n            assertNotNull(loanDetailsOverpaid.getOverpaidOnDate());\n            assertEquals(loanDetailsOverpaid.getOverpaidOnDate(), LocalDate.of(2022, 9, 9));\n\n            \/\/ reverse repayment to make loan not overpaid and overpaid date is reset\n            loanTransactionHelper.reverseRepayment(loanId, repaymentTransaction_4.getResourceId().intValue(), \"10 September 2022\");\n            GetLoansLoanIdResponse loanDetailsNotOverpaidAfterReversal = loanTransactionHelper.getLoanDetails((long) loanId);\n            assertFalse(loanDetailsNotOverpaidAfterReversal.getStatus().getOverpaid());\n            assertNull(loanDetailsNotOverpaidAfterReversal.getOverpaidOnDate());\n\n            \/\/ make repayment to make loan overpaid again\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_5 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"11 September 2022\").locale(\"en\")\n                            .transactionAmount(200.0));\n\n            \/\/ check loan overpaid date is not null and is set as Business date and loan status\n            GetLoansLoanIdResponse loanDetailsOverpaid_1 = loanTransactionHelper.getLoanDetails((long) loanId);\n            assertTrue(loanDetailsOverpaid_1.getStatus().getOverpaid());\n            assertNotNull(loanDetailsOverpaid_1.getOverpaidOnDate());\n            assertEquals(loanDetailsOverpaid_1.getOverpaidOnDate(), LocalDate.of(2022, 9, 11));\n\n            \/\/ Credit balance refund to reset overpaid status\n            loanTransactionHelper.creditBalanceRefund(\"12 September 2022\", Float.valueOf(100), null, loanId, \"\");\n            GetLoansLoanIdResponse loanDetailsNotOverpaidAfterCBR = loanTransactionHelper.getLoanDetails((long) loanId);\n            assertFalse(loanDetailsNotOverpaidAfterCBR.getStatus().getOverpaid());\n            assertNull(loanDetailsNotOverpaidAfterCBR.getOverpaidOnDate());\n\n            \/\/ reverse repayment to make loan active again\n            loanTransactionHelper.reverseRepayment(loanId, repaymentTransaction_2.getResourceId().intValue(), \"13 September 2022\");\n            GetLoansLoanIdResponse loanDetailsNotOverpaidAfterReversal_1 = loanTransactionHelper.getLoanDetails((long) loanId);\n            assertFalse(loanDetailsNotOverpaidAfterReversal_1.getStatus().getOverpaid());\n            assertNull(loanDetailsNotOverpaidAfterReversal_1.getOverpaidOnDate());\n\n            \/\/ make repayment to make loan overpaid again\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_6 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"14 September 2022\").locale(\"en\")\n                            .transactionAmount(300.0));\n\n            \/\/ check loan overpaid date is not null and is set as Business date and loan status\n            GetLoansLoanIdResponse loanDetailsOverpaid_3 = loanTransactionHelper.getLoanDetails((long) loanId);\n            assertTrue(loanDetailsOverpaid_3.getStatus().getOverpaid());\n            assertNotNull(loanDetailsOverpaid_3.getOverpaidOnDate());\n            assertEquals(loanDetailsOverpaid_3.getOverpaidOnDate(), LocalDate.of(2022, 9, 14));\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n\n    } END"}
{"prompt":"loan Accrual Transaction On Charge Submitted Test Accrual Accounting Api\n\n###\n\n","completion":"    @Test\n    public void loanAccrualTransactionOnChargeSubmittedTest_Accrual_Accounting_Api() {\n        try {\n\n            \/\/ Accounts oof periodic accrual\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            \/\/ Set business date\n            LocalDate currentDate = LocalDate.of(2023, 03, 3);\n            final String accrualRunTillDate = dateFormatter.format(currentDate);\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"submitted-date\");\n            \/\/ Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            \/\/ Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper, assetAccount,\n                    incomeAccount, expenseAccount, overpaymentAccount);\n            assertNotNull(getLoanProductsProductResponse);\n\n            final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n            \/\/ Add Charge Penalty\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            LocalDate targetDate = LocalDate.of(2023, 3, 10);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n            assertNotNull(penalty1LoanChargeId);\n\n            \/\/ Add Charge Fee\n            Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 14);\n            final String feeChargeAddedDate = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeChargeAddedDate, \"10\"));\n\n            assertNotNull(feeLoanChargeId);\n\n            \/\/ Run accrual for charge created date\n            this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(accrualRunTillDate);\n\n            \/\/ verify accrual transaction created for charges create date\n            checkAccrualTransaction(currentDate, 0.0f, 10.0f, 10.0f, loanId);\n\n            \/\/ Set business date\n            LocalDate futureDate = LocalDate.of(2023, 03, 4);\n            final String nextAccrualRunDate = dateFormatter.format(futureDate);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, futureDate);\n\n            \/\/ make repayment\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"4 March 2023\").locale(\"en\")\n                            .transactionAmount(100.0));\n\n            \/\/ Add Charge\n            Integer feeCharge_1 = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 21);\n            final String feeChargeAddedDate_1 = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId_1 = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge_1), feeChargeAddedDate_1, \"10\"));\n\n            assertNotNull(feeLoanChargeId_1);\n\n            \/\/ Run accrual for charge created date\n            this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(nextAccrualRunDate);\n\n            \/\/ verify accrual transaction created for charges create date\n            checkAccrualTransaction(futureDate, 0.0f, 10.0f, 0.0f, loanId);\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"due-date\");\n        }\n\n    } END"}
{"prompt":"loan Accrual Transaction On Charge Submitted Test Add Periodic Accrual Transactions Job\n\n###\n\n","completion":"    @Test\n    public void loanAccrualTransactionOnChargeSubmittedTest_Add_Periodic_Accrual_Transactions_Job() {\n        try {\n\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n            \/\/ Accounts oof periodic accrual\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            \/\/ Set business date\n            LocalDate currentDate = LocalDate.of(2023, 03, 3);\n            final String accrualRunTillDate = dateFormatter.format(currentDate);\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"submitted-date\");\n            \/\/ Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            \/\/ Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper, assetAccount,\n                    incomeAccount, expenseAccount, overpaymentAccount);\n            assertNotNull(getLoanProductsProductResponse);\n\n            final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n            \/\/ Add Charge Penalty\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            LocalDate targetDate = LocalDate.of(2023, 3, 10);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n            assertNotNull(penalty1LoanChargeId);\n\n            \/\/ Add Charge Fee\n            Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 14);\n            final String feeChargeAddedDate = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeChargeAddedDate, \"10\"));\n\n            assertNotNull(feeLoanChargeId);\n\n            \/\/ Run periodic accrual job for business date\n            final String jobName = \"Add Periodic Accrual Transactions\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            \/\/ verify accrual transaction created for charges create date\n            checkAccrualTransaction(currentDate, 0.0f, 10.0f, 10.0f, loanId);\n\n            \/\/ Set business date\n            LocalDate futureDate = LocalDate.of(2023, 03, 4);\n            final String nextAccrualRunDate = dateFormatter.format(futureDate);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, futureDate);\n\n            \/\/ make repayment\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"4 March 2023\").locale(\"en\")\n                            .transactionAmount(100.0));\n\n            \/\/ Add Charge\n            Integer feeCharge_1 = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 21);\n            final String feeChargeAddedDate_1 = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId_1 = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge_1), feeChargeAddedDate_1, \"10\"));\n\n            assertNotNull(feeLoanChargeId_1);\n\n            \/\/ Run periodic accrual job for business date\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            \/\/ verify accrual transaction created for charges create date\n            checkAccrualTransaction(futureDate, 0.0f, 10.0f, 0.0f, loanId);\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"due-date\");\n        }\n    } END"}
{"prompt":"loan Accrual Transaction On Charge Submitted Test Loan COB Add Periodic Accrual Entries Business Step\n\n###\n\n","completion":"    @Test\n    public void loanAccrualTransactionOnChargeSubmittedTest_Loan_COB_AddPeriodicAccrualEntriesBusinessStep() {\n        try {\n\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n            \/\/ Accounts oof periodic accrual\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            \/\/ Set business date\n            LocalDate currentDate = LocalDate.of(2023, 03, 3);\n            final String accrualRunTillDate = dateFormatter.format(currentDate);\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"submitted-date\");\n            \/\/ Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            \/\/ Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper, assetAccount,\n                    incomeAccount, expenseAccount, overpaymentAccount);\n            assertNotNull(getLoanProductsProductResponse);\n\n            final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n            \/\/ Add Charge Penalty\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            LocalDate targetDate = LocalDate.of(2023, 3, 10);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n            assertNotNull(penalty1LoanChargeId);\n\n            \/\/ Add Charge Fee\n            Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 14);\n            final String feeChargeAddedDate = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeChargeAddedDate, \"10\"));\n\n            assertNotNull(feeLoanChargeId);\n\n            \/\/ Run cob job for business date + 1\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate.plusDays(1));\n\n            final String jobName = \"Loan COB\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            \/\/ verify accrual transaction created for charges create date\n            checkAccrualTransaction(currentDate, 0.0f, 10.0f, 10.0f, loanId);\n\n            \/\/ Set business date\n            LocalDate futureDate = LocalDate.of(2023, 03, 4);\n            final String nextAccrualRunDate = dateFormatter.format(futureDate);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, futureDate);\n\n            \/\/ make repayment\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"4 March 2023\").locale(\"en\")\n                            .transactionAmount(100.0));\n\n            \/\/ Add Charge\n            Integer feeCharge_1 = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 21);\n            final String feeChargeAddedDate_1 = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId_1 = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge_1), feeChargeAddedDate_1, \"10\"));\n\n            assertNotNull(feeLoanChargeId_1);\n\n            \/\/ Run cob job for business date + 1\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, futureDate.plusDays(1));\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            \/\/ verify accrual transaction created for charges create date\n            checkAccrualTransaction(futureDate, 0.0f, 10.0f, 0.0f, loanId);\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"due-date\");\n        }\n    } END"}
{"prompt":"loan Accrual Transaction On Charge Submitted Test Add Accrual Transactions Job\n\n###\n\n","completion":"    @Test\n    public void loanAccrualTransactionOnChargeSubmittedTest_Add_Accrual_Transactions_Job() {\n        try {\n\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n            \/\/ Accounts oof periodic accrual\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            \/\/ Set business date\n            LocalDate currentDate = LocalDate.of(2023, 03, 3);\n            final String accrualRunTillDate = dateFormatter.format(currentDate);\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"submitted-date\");\n            \/\/ Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            \/\/ Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper, assetAccount,\n                    incomeAccount, expenseAccount, overpaymentAccount);\n            assertNotNull(getLoanProductsProductResponse);\n\n            final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n            \/\/ Add Charge Penalty\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            LocalDate targetDate = LocalDate.of(2023, 3, 10);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n            assertNotNull(penalty1LoanChargeId);\n\n            \/\/ Add Charge Fee\n            Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 14);\n            final String feeChargeAddedDate = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeChargeAddedDate, \"10\"));\n\n            assertNotNull(feeLoanChargeId);\n\n            \/\/ Run accrual entries job for business date\n            final String jobName = \"Add Accrual Transactions\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            \/\/ verify accrual transaction created for charges create date\n            checkAccrualTransaction(currentDate, 0.0f, 10.0f, 10.0f, loanId);\n\n            \/\/ Set business date\n            LocalDate futureDate = LocalDate.of(2023, 03, 4);\n            final String nextAccrualRunDate = dateFormatter.format(futureDate);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, futureDate);\n\n            \/\/ make repayment\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"4 March 2023\").locale(\"en\")\n                            .transactionAmount(100.0));\n\n            \/\/ Add Charge\n            Integer feeCharge_1 = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 21);\n            final String feeChargeAddedDate_1 = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId_1 = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge_1), feeChargeAddedDate_1, \"10\"));\n\n            assertNotNull(feeLoanChargeId_1);\n\n            \/\/ Run accrual entries job for business date\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            \/\/ verify accrual transaction created for charges create date\n            checkAccrualTransaction(futureDate, 0.0f, 10.0f, 0.0f, loanId);\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"due-date\");\n        }\n    } END"}
{"prompt":"loan Accrual Transaction On Charge Submitted With Multiple Repayments Test Add Periodic Accrual Transactions Job\n\n###\n\n","completion":"    @Test\n    public void loanAccrualTransactionOnChargeSubmitted_With_Multiple_Repayments_Test_Add_Periodic_Accrual_Transactions_Job() {\n        try {\n\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n            \/\/ Accounts oof periodic accrual\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            \/\/ Set business date\n            LocalDate currentDate = LocalDate.of(2023, 03, 3);\n            final String accrualRunTillDate = dateFormatter.format(currentDate);\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"submitted-date\");\n            \/\/ Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            \/\/ Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductMultipleRepayments(\n                    loanTransactionHelper, assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            assertNotNull(getLoanProductsProductResponse);\n\n            final Integer loanId = createLoanAccountMultipleRepayments(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n            \/\/ Add Charge Penalty\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            \/\/ Due for future date in one of the schedule\n            LocalDate targetDate = LocalDate.of(2023, 3, 10);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n            assertNotNull(penalty1LoanChargeId);\n\n            \/\/ Add Charge Penalty\n            Integer penalty_1 = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            \/\/ Due for future date in different of the schedule\n            targetDate = LocalDate.of(2023, 3, 17);\n            final String penaltyChargeAddedDate = dateFormatter.format(targetDate);\n            Integer penaltyLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty_1), penaltyChargeAddedDate, \"10\"));\n\n            assertNotNull(penaltyLoanChargeId);\n\n            \/\/ Run periodic accrual job for business date\n            final String jobName = \"Add Periodic Accrual Transactions\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            \/\/ verify multiple accrual transactions are created on charge created date according to repayment schedule\n            \/\/ to which charge due date falls\n            checkAccrualTransactionsForMultipleRepaymentSchedulesChargeDueDate(currentDate, loanId);\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"due-date\");\n        }\n    } END"}
{"prompt":"loan Accrual Transaction On Charge Submitted multiple disbursement reversal test Loan COB\n\n###\n\n","completion":"    @Test\n    public void loanAccrualTransactionOnChargeSubmitted_multiple_disbursement_reversal_test_Loan_COB() {\n        try {\n\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n            \/\/ Accounts oof periodic accrual\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            \/\/ Set business date\n            LocalDate currentDate = LocalDate.of(2023, 03, 3);\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"submitted-date\");\n            \/\/ Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            \/\/ Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductMultipleDisbursements(\n                    loanTransactionHelper, assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            assertNotNull(getLoanProductsProductResponse);\n\n            final Integer loanId = createLoanAccountMultipleRepaymentsDisbursement(clientId, getLoanProductsProductResponse.getId(),\n                    loanExternalIdStr);\n\n            loanTransactionHelper.disburseLoanWithTransactionAmount(\"03 March 2023\", loanId, \"1000\");\n\n            \/\/ Add Charge Penalty\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            LocalDate targetDate = LocalDate.of(2023, 3, 9);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n            assertNotNull(penalty1LoanChargeId);\n\n            \/\/ Run cob job for business date + 1\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate.plusDays(1));\n\n            final String jobName = \"Loan COB\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            \/\/ verify accrual transaction created for charges create date\n            checkAccrualTransaction(currentDate, 0.0f, 0.0f, 10.0f, loanId);\n\n            \/\/ Set business date\n            LocalDate futureDate = LocalDate.of(2023, 03, 4);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, futureDate);\n\n            loanTransactionHelper.disburseLoanWithTransactionAmount(\"04 March 2023\", loanId, \"300\");\n\n            \/\/ verify accrual transaction exists with same date,amount and is not reversed by regeneration of repayment\n            \/\/ schedule\n            checkAccrualTransaction(currentDate, 0.0f, 0.0f, 10.0f, loanId);\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"due-date\");\n        }\n    } END"}
{"prompt":"test No Accrual Transaction Reversal For Multiple Disbursement With Charge For Loan Account With No Interest Bearing Schedule Periodic Accrual\n\n###\n\n","completion":"    @Test\n    public void testNoAccrualTransactionReversalForMultipleDisbursementWithChargeForLoanAccountWithNoInterestBearingSchedulePeriodicAccrual() {\n\n        \/\/ Accounts for periodic accrual\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        \/\/ Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithMultipleDisbursement(\n                loanTransactionHelper, delinquencyBucketId, assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n        \/\/ 1st disbursement\n        loanTransactionHelper.disburseLoanWithTransactionAmount(\"03 September 2022\", loanId, \"100\");\n        \/\/ 2nd disbursement\n        loanTransactionHelper.disburseLoanWithTransactionAmount(\"04 September 2022\", loanId, \"300\");\n\n        \/\/ Add Charge\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 4);\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        \/\/ Run accrual till charge date\n        this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(penaltyCharge1AddedDate);\n\n        \/\/ verify accrual transaction created\n        checkAccrualTransaction(targetDate, 0.0f, 0.0f, 10.0f, loanId);\n\n        \/\/ 3rd disbursement\n        loanTransactionHelper.disburseLoanWithTransactionAmount(\"05 September 2022\", loanId, \"600\");\n\n        \/\/ verify accrual transaction exists with same date,amount and is not reversed by regeneration of repayment\n        \/\/ schedule\n        checkAccrualTransaction(targetDate, 0.0f, 0.0f, 10.0f, loanId);\n\n    } END"}
{"prompt":"test Last Accrual Transaction Reversal Recalculation For Loan Account With Interest Bearing Schedule With Declining Balance\n\n###\n\n","completion":"    @Test\n    public void testLastAccrualTransactionReversalRecalculationForLoanAccountWithInterestBearingScheduleWithDecliningBalance() {\n\n        try {\n            \/\/ Set business date\n            LocalDate currentDate = LocalDate.of(2022, 05, 8);\n            final String accrualRunTillDate = dateFormatter.format(currentDate);\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate);\n\n            \/\/ Accounts oof periodic accrual\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            \/\/ Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            \/\/ Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n\n            \/\/ create loan product\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithInterestRecalculation(assetAccount,\n                    incomeAccount, expenseAccount, overpaymentAccount);\n            assertNotNull(getLoanProductsProductResponse);\n            \/\/ create loan account\n            final Integer loanId = createLoanAccountWithInterestRecalculation(clientId, getLoanProductsProductResponse.getId(),\n                    loanExternalIdStr);\n            \/\/ run accruals till business date\n            this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(accrualRunTillDate);\n            \/\/ check amount for last accrual on business date\n            checkAccrualTransaction(currentDate, 0.82f, 0.0f, 0.0f, loanId);\n            \/\/ make repayment on due date\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 February 2022\").locale(\"en\")\n                            .transactionAmount(106.57));\n            \/\/ check previous accrual is reversed and new accrual created for same date and different amount.\n            checkAccrualTransaction(currentDate, 0.71f, 0.0f, 0.0f, loanId);\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n\n    } END"}
{"prompt":"loan Application Approved Amount Less Than Proposed Amount\n\n###\n\n","completion":"    @Test\n    public void loanApplicationApprovedAmountLessThanProposedAmount() {\n\n        final String proposedAmount = \"8000\";\n        final String approvalAmount = \"5000\";\n        final String approveDate = \"20 September 2012\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, proposedAmount);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        final String expectedDisbursementDate = null;\n        List<HashMap> approveTranches = null;\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(approveDate, expectedDisbursementDate, approvalAmount,\n                loanID, approveTranches);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n    } END"}
{"prompt":"loan Application Approved Amount Greater Than Proposed Amount\n\n###\n\n","completion":"    @Test\n    public void loanApplicationApprovedAmountGreaterThanProposedAmount() {\n\n        final String proposedAmount = \"5000\";\n        final String approvalAmount = \"9000\";\n        final String approveDate = \"20 September 2011\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, proposedAmount);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpecForStatusCode403);\n\n        @SuppressWarnings(\"unchecked\")\n        List<HashMap> error = (List<HashMap>) this.loanTransactionHelper.approveLoan(approveDate, approvalAmount, loanID,\n                CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.loan.approval.amount.can't.be.greater.than.loan.amount.demanded\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    } END"}
{"prompt":"loan Application Approval And Validation For Multi Disburse Loans\n\n###\n\n","completion":"    @Test\n    public void loanApplicationApprovalAndValidationForMultiDisburseLoans() {\n\n        List<HashMap> createTranches = new ArrayList<>();\n        createTranches.add(createTrancheDetail(\"01 March 2014\", \"1000\"));\n        createTranches.add(createTrancheDetail(\"23 March 2014\", \"4000\"));\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        LOG.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientID);\n\n        final Integer loanProductID = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withInterestTypeAsDecliningBalance().withTranches(true)\n                        .withInterestCalculationPeriodTypeAsRepaymentPeriod(true).build(null));\n        LOG.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductID);\n\n        this.trancheLoansApprovedAmountLesserThanProposedAmount(clientID, loanProductID, createTranches);\n        this.trancheLoansApprovalValidation(clientID, loanProductID, createTranches);\n\n    } END"}
{"prompt":"loan Application Rejection For Periodic Accrual Accounting Loan Product Test\n\n###\n\n","completion":"    @Test\n    public void loanApplicationRejectionForPeriodicAccrualAccountingLoanProductTest() {\n\n        Account assetAccount = this.accountHelper.createAssetAccount();\n        Account incomeAccount = this.accountHelper.createIncomeAccount();\n        Account expenseAccount = this.accountHelper.createExpenseAccount();\n        Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        \/\/ Create Loan Product with Periodic Accrual accounting\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccounting(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Client and Loan account creation\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n\n        final Integer loanId = createLoanAccount(clientId, loanProductID, loanExternalIdStr);\n\n        \/\/ verify Loan status as submitted and pending approval\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getPendingApproval());\n\n        \/\/ Reject Loan application\n        PostLoansLoanIdResponse result = this.loanTransactionHelper.rejectLoan(loanExternalIdStr,\n                new PostLoansLoanIdRequest().rejectedOnDate(\"3 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n\n        \/\/ Verify Loan application status is Rejected\n        assertTrue(result.getChanges().getStatus().getValue().equals(\"Rejected\"));\n\n    } END"}
{"prompt":"validate Seed Date31\n\n###\n\n","completion":"    @Test\n    public void validateSeedDate31() {\n        final Integer clientId = createClient(CLIENT_ACTIVATION_DATE);\n\n        String firstRepaymentDate = \"31 January 2023\";\n        Integer loanProductId = createLoanProductEntity();\n\n        Integer loanId = applyForLoanApplication(clientId, loanProductId, firstRepaymentDate);\n\n        final ArrayList<HashMap> repaymentPeriods = (ArrayList<HashMap>) this.loanTransactionHelper\n                .getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanId);\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 1, 31)), repaymentPeriods.get(1).get(DUE_DATE),\n                \"Checking for Due Date for 1st Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 2, 28)), repaymentPeriods.get(2).get(DUE_DATE),\n                \"Checking for Due Date for 2nd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 3, 31)), repaymentPeriods.get(3).get(DUE_DATE),\n                \"Checking for Due Date for 3rd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 4, 30)), repaymentPeriods.get(4).get(DUE_DATE),\n                \"Checking for Due Date for 4th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 5, 31)), repaymentPeriods.get(5).get(DUE_DATE),\n                \"Checking for Due Date for 5th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 6, 30)), repaymentPeriods.get(6).get(DUE_DATE),\n                \"Checking for Due Date for 6th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 7, 31)), repaymentPeriods.get(7).get(DUE_DATE),\n                \"Checking for Due Date for 7th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 8, 31)), repaymentPeriods.get(8).get(DUE_DATE),\n                \"Checking for Due Date for 8th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 9, 30)), repaymentPeriods.get(9).get(DUE_DATE),\n                \"Checking for Due Date for 9th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 10, 31)), repaymentPeriods.get(10).get(DUE_DATE),\n                \"Checking for Due Date for 10th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 11, 30)), repaymentPeriods.get(11).get(DUE_DATE),\n                \"Checking for Due Date for 11th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 12, 31)), repaymentPeriods.get(12).get(DUE_DATE),\n                \"Checking for Due Date for 12th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 1, 31)), repaymentPeriods.get(13).get(DUE_DATE),\n                \"Checking for Due Date for 13th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 2, 29)), repaymentPeriods.get(14).get(DUE_DATE),\n                \"Checking for Due Date for 14th Month\");\n    } END"}
{"prompt":"validate Seed Date30\n\n###\n\n","completion":"    @Test\n    public void validateSeedDate30() {\n        final Integer clientId = createClient(CLIENT_ACTIVATION_DATE);\n\n        String firstRepaymentDate = \"30 January 2023\";\n        Integer loanProductId = createLoanProductEntity();\n\n        Integer loanId = applyForLoanApplication(clientId, loanProductId, firstRepaymentDate);\n\n        final ArrayList<HashMap> repaymentPeriods = (ArrayList<HashMap>) this.loanTransactionHelper\n                .getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanId);\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 1, 30)), repaymentPeriods.get(1).get(DUE_DATE),\n                \"Checking for Due Date for 1st Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 2, 28)), repaymentPeriods.get(2).get(DUE_DATE),\n                \"Checking for Due Date for 2nd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 3, 30)), repaymentPeriods.get(3).get(DUE_DATE),\n                \"Checking for Due Date for 3rd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 4, 30)), repaymentPeriods.get(4).get(DUE_DATE),\n                \"Checking for Due Date for 4th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 5, 30)), repaymentPeriods.get(5).get(DUE_DATE),\n                \"Checking for Due Date for 5th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 6, 30)), repaymentPeriods.get(6).get(DUE_DATE),\n                \"Checking for Due Date for 6th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 7, 30)), repaymentPeriods.get(7).get(DUE_DATE),\n                \"Checking for Due Date for 7th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 8, 30)), repaymentPeriods.get(8).get(DUE_DATE),\n                \"Checking for Due Date for 8th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 9, 30)), repaymentPeriods.get(9).get(DUE_DATE),\n                \"Checking for Due Date for 9th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 10, 30)), repaymentPeriods.get(10).get(DUE_DATE),\n                \"Checking for Due Date for 10th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 11, 30)), repaymentPeriods.get(11).get(DUE_DATE),\n                \"Checking for Due Date for 11th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 12, 30)), repaymentPeriods.get(12).get(DUE_DATE),\n                \"Checking for Due Date for 12th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 1, 30)), repaymentPeriods.get(13).get(DUE_DATE),\n                \"Checking for Due Date for 13th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 2, 29)), repaymentPeriods.get(14).get(DUE_DATE),\n                \"Checking for Due Date for 14th Month\");\n    }\n\n    @SuppressWarnings({ \"unchecked\" } END"}
{"prompt":"validate Seed Date28\n\n###\n\n","completion":"    @Test\n    public void validateSeedDate28() {\n        final Integer clientId = createClient(CLIENT_ACTIVATION_DATE);\n\n        String firstRepaymentDate = \"28 January 2023\";\n        Integer loanProductId = createLoanProductEntity();\n\n        Integer loanId = applyForLoanApplication(clientId, loanProductId, firstRepaymentDate);\n\n        final ArrayList<HashMap> repaymentPeriods = (ArrayList<HashMap>) this.loanTransactionHelper\n                .getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanId);\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 1, 28)), repaymentPeriods.get(1).get(DUE_DATE),\n                \"Checking for Due Date for 1st Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 2, 28)), repaymentPeriods.get(2).get(DUE_DATE),\n                \"Checking for Due Date for 2nd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 3, 28)), repaymentPeriods.get(3).get(DUE_DATE),\n                \"Checking for Due Date for 3rd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 4, 28)), repaymentPeriods.get(4).get(DUE_DATE),\n                \"Checking for Due Date for 4th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 5, 28)), repaymentPeriods.get(5).get(DUE_DATE),\n                \"Checking for Due Date for 5th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 6, 28)), repaymentPeriods.get(6).get(DUE_DATE),\n                \"Checking for Due Date for 6th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 7, 28)), repaymentPeriods.get(7).get(DUE_DATE),\n                \"Checking for Due Date for 7th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 8, 28)), repaymentPeriods.get(8).get(DUE_DATE),\n                \"Checking for Due Date for 8th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 9, 28)), repaymentPeriods.get(9).get(DUE_DATE),\n                \"Checking for Due Date for 9th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 10, 28)), repaymentPeriods.get(10).get(DUE_DATE),\n                \"Checking for Due Date for 10th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 11, 28)), repaymentPeriods.get(11).get(DUE_DATE),\n                \"Checking for Due Date for 11th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 12, 28)), repaymentPeriods.get(12).get(DUE_DATE),\n                \"Checking for Due Date for 12th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 1, 28)), repaymentPeriods.get(13).get(DUE_DATE),\n                \"Checking for Due Date for 13th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 2, 28)), repaymentPeriods.get(14).get(DUE_DATE),\n                \"Checking for Due Date for 14th Month\");\n    }\n\n    @SuppressWarnings({ \"unchecked\" } END"}
{"prompt":"validate Seed Date25\n\n###\n\n","completion":"    @Test\n    public void validateSeedDate25() {\n        final Integer clientId = createClient(CLIENT_ACTIVATION_DATE);\n\n        String firstRepaymentDate = \"25 January 2023\";\n        Integer loanProductId = createLoanProductEntity();\n\n        Integer loanId = applyForLoanApplication(clientId, loanProductId, firstRepaymentDate);\n\n        final ArrayList<HashMap> repaymentPeriods = (ArrayList<HashMap>) this.loanTransactionHelper\n                .getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanId);\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 1, 25)), repaymentPeriods.get(1).get(DUE_DATE),\n                \"Checking for Due Date for 1st Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 2, 25)), repaymentPeriods.get(2).get(DUE_DATE),\n                \"Checking for Due Date for 2nd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 3, 25)), repaymentPeriods.get(3).get(DUE_DATE),\n                \"Checking for Due Date for 3rd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 4, 25)), repaymentPeriods.get(4).get(DUE_DATE),\n                \"Checking for Due Date for 4th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 5, 25)), repaymentPeriods.get(5).get(DUE_DATE),\n                \"Checking for Due Date for 5th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 6, 25)), repaymentPeriods.get(6).get(DUE_DATE),\n                \"Checking for Due Date for 6th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 7, 25)), repaymentPeriods.get(7).get(DUE_DATE),\n                \"Checking for Due Date for 7th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 8, 25)), repaymentPeriods.get(8).get(DUE_DATE),\n                \"Checking for Due Date for 8th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 9, 25)), repaymentPeriods.get(9).get(DUE_DATE),\n                \"Checking for Due Date for 9th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 10, 25)), repaymentPeriods.get(10).get(DUE_DATE),\n                \"Checking for Due Date for 10th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 11, 25)), repaymentPeriods.get(11).get(DUE_DATE),\n                \"Checking for Due Date for 11th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 12, 25)), repaymentPeriods.get(12).get(DUE_DATE),\n                \"Checking for Due Date for 12th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 1, 25)), repaymentPeriods.get(13).get(DUE_DATE),\n                \"Checking for Due Date for 13th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 2, 25)), repaymentPeriods.get(14).get(DUE_DATE),\n                \"Checking for Due Date for 14th Month\");\n    } END"}
{"prompt":"loan Application Undo Last Tranche\n\n###\n\n","completion":"    @Test\n    public void loanApplicationUndoLastTranche() {\n\n        final String proposedAmount = \"5000\";\n        final String approvalAmount = \"2000\";\n        final String approveDate = \"01 March 2014\";\n        final String expectedDisbursementDate = \"01 March 2014\";\n        final String disbursalDate = \"01 March 2014\";\n\n        \/\/ CREATE CLIENT\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        LOG.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientID);\n\n        \/\/ CREATE LOAN MULTIDISBURSAL PRODUCT\n        final Integer loanProductID = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withInterestTypeAsDecliningBalance().withTranches(true)\n                        .withInterestCalculationPeriodTypeAsRepaymentPeriod(true).build(null));\n        LOG.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductID);\n\n        \/\/ CREATE TRANCHES\n        List<HashMap> createTranches = new ArrayList<>();\n        createTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"01 March 2014\", \"1000\"));\n        createTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"23 June 2014\", \"4000\"));\n\n        \/\/ APPROVE TRANCHES\n        List<HashMap> approveTranches = new ArrayList<>();\n        approveTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"01 March 2014\", \"1000\"));\n        approveTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"23 June 2014\", \"1000\"));\n\n        \/\/ APPLY FOR LOAN WITH TRANCHES\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, proposedAmount, \"2\", createTranches);\n        LOG.info(\"-----------------------------------LOAN CREATED WITH LOANID------------------------------------------------- {}\", loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n\n        \/\/ VALIDATE THE LOAN STATUS\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(approveDate, expectedDisbursementDate, approvalAmount,\n                loanID, approveTranches);\n\n        \/\/ VALIDATE THE LOAN IS APPROVED\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        \/\/ DISBURSE A LOAN\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(disbursalDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n\n        \/\/ VALIDATE THE LOAN IS ACTIVE STATUS\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        LOG.info(\"-------------Make repayment 1-----------\");\n        this.loanTransactionHelper.makeRepayment(\"01 April 2014\", Float.valueOf(\"420\"), loanID);\n        LOG.info(\"-------------Make repayment 2-----------\");\n        this.loanTransactionHelper.makeRepayment(\"01 May 2014\", Float.valueOf(\"412\"), loanID);\n        LOG.info(\"-------------Make repayment 3-----------\");\n        this.loanTransactionHelper.makeRepayment(\"01 June 2014\", Float.valueOf(\"204\"), loanID);\n        \/\/ DISBURSE A SECOND TRANCHE\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"23 June 2014\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        \/\/ UNDO LAST TRANCHE\n        Float disbursedAmount = this.loanTransactionHelper.undoLastDisbursal(loanID);\n        validateDisbursedAmount(disbursedAmount);\n    } END"}
{"prompt":"loan Application Undo Last Tranche To Close\n\n###\n\n","completion":"    @Test\n    public void loanApplicationUndoLastTrancheToClose() {\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        LocalDate transactionDate = LocalDate.of(todaysDate.getYear(), 1, 1);\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n        LOG.info(\"Operation date {}\", transactionDate);\n\n        final String proposedAmount = \"1000\";\n\n        \/\/ CREATE CLIENT\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        LOG.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientID);\n\n        \/\/ CREATE LOAN MULTIDISBURSAL PRODUCT\n        final Integer loanProductID = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withInterestTypeAsDecliningBalance().withTranches(true)\n                        .withDisallowExpectedDisbursements(true).withInterestCalculationPeriodTypeAsRepaymentPeriod(true).build(null));\n        LOG.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductID);\n\n        \/\/ APPLY FOR LOAN WITH TRANCHES\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, proposedAmount, \"0\", new ArrayList<>());\n\n        LOG.info(\"-----------------------------------LOAN CREATED WITH LOANID------------------------------------------------- {}\", loanID);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        this.loanTransactionHelper.approveLoan(operationDate, proposedAmount, loanID, null);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.approved\");\n\n        \/\/ DISBURSE A LOAN\n        loanTransactionHelper.disburseLoanWithTransactionAmount(operationDate, loanID, \"500\");\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        \/\/ VALIDATE THE LOAN IS ACTIVE STATUS\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n        loanTransactionHelper.evaluateLoanDisbursementDetails(getLoansLoanIdResponse, 1, Double.valueOf(\"500.00\"));\n\n        \/\/ DISBURSE A LOAN (second)\n        transactionDate = transactionDate.plusDays(2);\n        operationDate = Utils.dateFormatter.format(transactionDate);\n        LOG.info(\"Operation date {}\", transactionDate);\n        loanTransactionHelper.disburseLoanWithTransactionAmount(operationDate, loanID, \"500\");\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        \/\/ VALIDATE THE LOAN IS ACTIVE STATUS\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n        loanTransactionHelper.evaluateLoanDisbursementDetails(getLoansLoanIdResponse, 2, Double.valueOf(\"1000.00\"));\n\n        \/\/ BACKDATE REPAYMENT\n        transactionDate = transactionDate.minusDays(1);\n        operationDate = Utils.dateFormatter.format(transactionDate);\n        LOG.info(\"Operation date {}\", transactionDate);\n        Float amount = Float.valueOf(\"500.00\");\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanID);\n        assertNotNull(loanIdTransactionsResponse);\n        LOG.info(\"Loan Transaction Id: {} {}\", loanID, loanIdTransactionsResponse.getResourceId());\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        \/\/ VALIDATE THE LOAN IS ACTIVE STATUS\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n        loanTransactionHelper.evaluateLoanDisbursementDetails(getLoansLoanIdResponse, 2, Double.valueOf(\"1000.00\"));\n        loanTransactionHelper.validateLoanTotalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"500.00\"));\n\n        \/\/ UNDO LAST TRANCHE\n        this.loanTransactionHelper.undoLastDisbursal(loanID);\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        \/\/ VALIDATE THE LOAN IS ACTIVE STATUS\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n        loanTransactionHelper.validateLoanTotalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"0.00\"));\n    } END"}
{"prompt":"loan Application Undo Last Tranche With Same Date\n\n###\n\n","completion":"    @Test\n    public void loanApplicationUndoLastTrancheWithSameDate() {\n\n        final String proposedAmount = \"5000\";\n        final String approveDate = \"01 March 2014\";\n        final String disbursalDate = \"01 March 2014\";\n\n        \/\/ CREATE CLIENT\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        LOG.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientID);\n\n        \/\/ CREATE LOAN MULTIDISBURSAL PRODUCT\n        final Integer loanProductID = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withInterestTypeAsDecliningBalance().withTranches(true)\n                        .withDisallowExpectedDisbursements(true).withInterestCalculationPeriodTypeAsRepaymentPeriod(true).build(null));\n        LOG.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductID);\n\n        \/\/ APPLY FOR LOAN WITH TRANCHES\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, proposedAmount, \"0\", new ArrayList<>());\n\n        LOG.info(\"-----------------------------------LOAN CREATED WITH LOANID------------------------------------------------- {}\", loanID);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        this.loanTransactionHelper.approveLoan(approveDate, proposedAmount, loanID, null);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.approved\");\n\n        \/\/ DISBURSE A LOAN\n        loanTransactionHelper.disburseLoanWithTransactionAmount(disbursalDate, loanID, \"1000\");\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        \/\/ VALIDATE THE LOAN IS ACTIVE STATUS\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n        loanTransactionHelper.evaluateLoanDisbursementDetails(getLoansLoanIdResponse, 1, Double.valueOf(\"1000.00\"));\n\n        \/\/ DISBURSE A LOAN (second)\n        loanTransactionHelper.disburseLoanWithTransactionAmount(disbursalDate, loanID, \"2000\");\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        \/\/ VALIDATE THE LOAN IS ACTIVE STATUS\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n        loanTransactionHelper.evaluateLoanDisbursementDetails(getLoansLoanIdResponse, 2, Double.valueOf(\"3000.00\"));\n\n        \/\/ UNDO LAST TRANCHE\n        this.loanTransactionHelper.undoLastDisbursal(loanID);\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        \/\/ VALIDATE THE LOAN IS ACTIVE STATUS\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n        loanTransactionHelper.evaluateLoanDisbursementDetails(getLoansLoanIdResponse, 1, Double.valueOf(\"1000.00\"));\n        loanTransactionHelper.validateLoanTotalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"1000.00\"));\n    } END"}
{"prompt":"test Catch Up In Locked Instance\n\n###\n\n","completion":"    @Test\n    public void testCatchUpInLockedInstance() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"0\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n            loanAccountLockHelper = new LoanAccountLockHelper(requestSpec, new ResponseSpecBuilder().expectStatusCode(202).build());\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            loanAccountLockHelper.placeSoftLockOnLoanAccount(loanID, \"LOAN_INLINE_COB_PROCESSING\", \"Sample error\");\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 5));\n\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n            loanCOBCatchUpHelper.executeLoanCOBCatchUp();\n\n            Utils.conditionalSleepWithMaxWait(30, 5, () -> loanCOBCatchUpHelper.isLoanCOBCatchUpRunning());\n\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 4), loan.getLastClosedBusinessDate());\n\n            requestSpec = UserHelper.getSimpleUserWithoutBypassPermission(requestSpec, responseSpec);\n\n            final BatchRequest br1 = BatchHelper.repayLoanRequestWithGivenLoanId(4730L, loanID, \"10\", LocalDate.of(2020, 3, 5));\n\n            final List<BatchRequest> batchRequests = new ArrayList<>();\n\n            batchRequests.add(br1);\n\n            final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n            final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec,\n                    this.responseSpec, jsonifiedRequest);\n            Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(0).getStatusCode(), \"Verify Status Code 200 for Repayment\");\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 4), loan.getLastClosedBusinessDate());\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"2\");\n        }\n    } END"}
{"prompt":"loan Transaction Chargeback For Payment Type Repayment Transaction Test\n\n###\n\n","completion":"    @Test\n    public void loanTransactionChargebackForPaymentTypeRepaymentTransactionTest() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        \/\/ Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        \/\/ make Repayment\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 September 2022\").locale(\"en\")\n                        .transactionAmount(500.0));\n\n        \/\/ verify transaction relation and outstanding balance\n        reviewLoanTransactionRelations(loanId, repaymentTransaction_1.getResourceId(), 0, Double.valueOf(\"500.00\"));\n\n        GetLoansLoanIdResponse loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 500.0);\n\n        \/\/ chargeback on Repayment\n        PostLoansLoanIdTransactionsResponse chargebackTransactionResponse = loanTransactionHelper.chargebackLoanTransaction(\n                loanExternalIdStr, repaymentTransaction_1.getResourceId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().locale(\"en\").transactionAmount(500.0).paymentTypeId(1L));\n\n        \/\/ verify transaction relation and outstanding balance\n        assertNotNull(chargebackTransactionResponse);\n        reviewLoanTransactionRelations(loanId, repaymentTransaction_1.getResourceId(), 1, Double.valueOf(\"500.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionResponse.getResourceId(), 0, Double.valueOf(\"1000.00\"));\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 1000.0);\n\n        \/\/ Goodwill Credit\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"6 September 2022\").locale(\"en\")\n                        .transactionAmount(200.0));\n\n        \/\/ verify transaction relation and outstanding balance\n        reviewLoanTransactionRelations(loanId, goodwillCredit_1.getResourceId(), 0, Double.valueOf(\"300.00\"));\n\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 800.0);\n\n        \/\/ chargeback on Goodwill Credit Transaction\n        chargebackTransactionResponse = loanTransactionHelper.chargebackLoanTransaction(loanExternalIdStr, goodwillCredit_1.getResourceId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().locale(\"en\").transactionAmount(200.0).paymentTypeId(1L));\n\n        \/\/ verify transaction relation and outstanding balance\n        assertNotNull(chargebackTransactionResponse);\n        reviewLoanTransactionRelations(loanId, goodwillCredit_1.getResourceId(), 1, Double.valueOf(\"300.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionResponse.getResourceId(), 0, Double.valueOf(\"1000.00\"));\n\n        \/\/ Payout Refund\n\n        final PostLoansLoanIdTransactionsResponse payoutRefund_1 = loanTransactionHelper.makePayoutRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"7 September 2022\").locale(\"en\")\n                        .transactionAmount(300.0));\n\n        \/\/ verify transaction relation and outstanding balance\n        reviewLoanTransactionRelations(loanId, payoutRefund_1.getResourceId(), 0, Double.valueOf(\"0.00\"));\n\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 700.0);\n\n        \/\/ chargeback on Payout Refund Transaction\n        chargebackTransactionResponse = loanTransactionHelper.chargebackLoanTransaction(loanExternalIdStr, payoutRefund_1.getResourceId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().locale(\"en\").transactionAmount(300.0).paymentTypeId(1L));\n\n        \/\/ verify transaction relation and outstanding balance\n        assertNotNull(chargebackTransactionResponse);\n        reviewLoanTransactionRelations(loanId, payoutRefund_1.getResourceId(), 1, Double.valueOf(\"0.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionResponse.getResourceId(), 0, Double.valueOf(\"1000.00\"));\n\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 1000.0);\n\n        \/\/ Merchant Issued Refund\n\n        final PostLoansLoanIdTransactionsResponse merchantIssuedRefund_1 = loanTransactionHelper.makeMerchantIssuedRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"8 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        \/\/ verify transaction relation and outstanding balance\n        reviewLoanTransactionRelations(loanId, merchantIssuedRefund_1.getResourceId(), 0, Double.valueOf(\"0.00\"));\n\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 900.0);\n\n        \/\/ chargeback on Merchant Issued Refund Transaction\n        chargebackTransactionResponse = loanTransactionHelper.chargebackLoanTransaction(loanExternalIdStr,\n                merchantIssuedRefund_1.getResourceId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().locale(\"en\").transactionAmount(100.0).paymentTypeId(1L));\n\n        \/\/ verify transaction relation and outstanding balance\n        assertNotNull(chargebackTransactionResponse);\n        reviewLoanTransactionRelations(loanId, merchantIssuedRefund_1.getResourceId(), 1, Double.valueOf(\"0.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionResponse.getResourceId(), 0, Double.valueOf(\"1000.00\"));\n\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 1000.0);\n\n    } END"}
{"prompt":"loan Chargeback Not Allowed For Reversed Payment Type Repayment Test\n\n###\n\n","completion":"    @Test\n    public void loanChargebackNotAllowedForReversedPaymentTypeRepaymentTest() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        \/\/ Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        \/\/ Merchant Refund\n        final PostLoansLoanIdTransactionsResponse merchantIssuedRefund_2 = loanTransactionHelper.makeMerchantIssuedRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"8 September 2022\").locale(\"en\")\n                        .transactionAmount(50.0));\n\n        \/\/ reverse Merchant Refund\n        loanTransactionHelper.reverseRepayment(loanId, merchantIssuedRefund_2.getResourceId().intValue(), \"8 September 2022\");\n\n        \/\/ apply Chargeback should give 503 error\n        final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId,\n                merchantIssuedRefund_2.getResourceId(), \"50.00\", 1, responseSpecErr503);\n\n    } END"}
{"prompt":"loan Accounting Treatment Test For Goodwill Credit Periodic Accrual Accounting No Charge Off\n\n###\n\n","completion":"    @Test\n    public void loanAccountingTreatmentTestForGoodwillCreditPeriodicAccrualAccounting_NoChargeOff() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Product to GL account mapping for test\n        \/\/ ASSET\n        \/\/ -fundSourceAccountId,loanPortfolioAccountId,transfersInSuspenseAccountId,receivableFeeAccountId,receivablePenaltyAccountId,receivableInterestAccountId\n        \/\/ INCOME-interestOnLoanAccountId,incomeFromFeeAccountId,incomeFromPenaltyAccountId,incomeFromRecoveryAccountId,incomeFromChargeOffInterestAccountId,incomeFromChargeOffFeesAccountId,incomeFromChargeOffPenaltyAccountId,incomeFromGoodwillCreditInterestAccountId,incomeFromGoodwillCreditFeesAccountId,incomeFromGoodwillCreditPenaltyAccountId\n        \/\/ EXPENSE-writeOffAccountId,goodwillCreditAccountId,chargeOffExpenseAccountId,chargeOffFraudExpenseAccountId\n        \/\/ LIABILITY-overpaymentLiabilityAccountId\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccounting(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final Integer loanId = createLoanAccount(clientId, loanProductID, loanExternalIdStr);\n\n        \/\/ apply charges\n        Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 5);\n        final String feeCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeCharge1AddedDate, \"10\"));\n\n        \/\/ apply penalty\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"110\", true));\n\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n\n        \/\/ Goodwill Credit\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"06 September 2022\").locale(\"en\")\n                        .transactionAmount(800.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n\n        \/\/ verify Journal Entries for Goodwill Credit\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"6 September 2022\",\n                new JournalEntry(800, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"6 September 2022\",\n                new JournalEntry(780, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.DEBIT));\n\n    } END"}
{"prompt":"loan Accounting Treatment Test For Goodwill Credit Periodic Accrual Accounting Charge Off\n\n###\n\n","completion":"    @Test\n    public void loanAccountingTreatmentTestForGoodwillCreditPeriodicAccrualAccounting_ChargeOff() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Product to GL account mapping for test\n        \/\/ ASSET\n        \/\/ -fundSourceAccountId,loanPortfolioAccountId,transfersInSuspenseAccountId,receivableFeeAccountId,receivablePenaltyAccountId,receivableInterestAccountId\n        \/\/ INCOME-interestOnLoanAccountId,incomeFromFeeAccountId,incomeFromPenaltyAccountId,incomeFromRecoveryAccountId,incomeFromChargeOffInterestAccountId,incomeFromChargeOffFeesAccountId,incomeFromChargeOffPenaltyAccountId,incomeFromGoodwillCreditInterestAccountId,incomeFromGoodwillCreditFeesAccountId,incomeFromGoodwillCreditPenaltyAccountId\n        \/\/ EXPENSE-writeOffAccountId,goodwillCreditAccountId,chargeOffExpenseAccountId,chargeOffFraudExpenseAccountId\n        \/\/ LIABILITY-overpaymentLiabilityAccountId\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccounting(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final Integer loanId = createLoanAccount(clientId, loanProductID, loanExternalIdStr);\n\n        \/\/ apply charges\n        Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 5);\n        final String feeCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeCharge1AddedDate, \"10\"));\n\n        \/\/ apply penalty\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        \/\/ set loan as chargeoff\n        String randomText = Utils.randomStringGenerator(\"en\", 5) + Utils.randomNumberGenerator(6) + Utils.randomStringGenerator(\"is\", 5);\n        Integer chargeOffReasonId = CodeHelper.createChargeOffCodeValue(requestSpec, responseSpec, randomText, 1);\n        String transactionExternalId = UUID.randomUUID().toString();\n        this.loanTransactionHelper.chargeOffLoan((long) loanId, new PostLoansLoanIdTransactionsRequest().transactionDate(\"6 September 2022\")\n                .locale(\"en\").dateFormat(\"dd MMMM yyyy\").externalId(transactionExternalId).chargeOffReasonId((long) chargeOffReasonId));\n\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getChargedOff());\n\n        \/\/ verify Journal Entries For ChargeOff Transaction\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"6 September 2022\",\n                new JournalEntry(1020, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"6 September 2022\",\n                new JournalEntry(1000, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.DEBIT));\n\n        \/\/ Goodwill Credit\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"08 September 2022\").locale(\"en\")\n                        .transactionAmount(800.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getChargedOff());\n\n        \/\/ verify Journal Entries for Goodwill Credit\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"8 September 2022\",\n                new JournalEntry(800, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"8 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"8 September 2022\",\n                new JournalEntry(780, JournalEntry.TransactionType.DEBIT));\n\n    } END"}
{"prompt":"loan Accounting Treatment Test For Cash Based Accounting No Charge Off\n\n###\n\n","completion":"    @Test\n    public void loanAccountingTreatmentTestForCashBasedAccounting_NoChargeOff() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Product to GL account mapping for test\n        \/\/ ASSET\n        \/\/ -fundSourceAccountId,loanPortfolioAccountId,transfersInSuspenseAccountId\n        \/\/ INCOME-interestOnLoanAccountId,incomeFromFeeAccountId,incomeFromPenaltyAccountId,incomeFromRecoveryAccountId,incomeFromChargeOffInterestAccountId,incomeFromChargeOffFeesAccountId,incomeFromChargeOffPenaltyAccountId,incomeFromGoodwillCreditInterestAccountId,incomeFromGoodwillCreditFeesAccountId,incomeFromGoodwillCreditPenaltyAccountId\n        \/\/ EXPENSE-writeOffAccountId,goodwillCreditAccountId,chargeOffExpenseAccountId,chargeOffFraudExpenseAccountId\n        \/\/ LIABILITY-overpaymentLiabilityAccountId\n\n        final Integer loanProductID = createLoanProductWithCashBasedAccounting(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final Integer loanId = createLoanAccount(clientId, loanProductID, loanExternalIdStr);\n\n        \/\/ apply charges\n        Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 5);\n        final String feeCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeCharge1AddedDate, \"10\"));\n\n        \/\/ apply penalty\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n\n        \/\/ Goodwill Credit\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"06 September 2022\").locale(\"en\")\n                        .transactionAmount(800.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n\n        \/\/ verify Journal Entries for Goodwill Credit\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"6 September 2022\",\n                new JournalEntry(780, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(10, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(10, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"6 September 2022\",\n                new JournalEntry(780, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.DEBIT));\n\n    } END"}
{"prompt":"loan Accounting Treatment Test For Cash Based Accounting Charge Off\n\n###\n\n","completion":"    @Test\n    public void loanAccountingTreatmentTestForCashBasedAccounting_ChargeOff() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Product to GL account mapping for test\n        \/\/ ASSET\n        \/\/ -fundSourceAccountId,loanPortfolioAccountId,transfersInSuspenseAccountId\n        \/\/ INCOME-interestOnLoanAccountId,incomeFromFeeAccountId,incomeFromPenaltyAccountId,incomeFromRecoveryAccountId,incomeFromChargeOffInterestAccountId,incomeFromChargeOffFeesAccountId,incomeFromChargeOffPenaltyAccountId,incomeFromGoodwillCreditInterestAccountId,incomeFromGoodwillCreditFeesAccountId,incomeFromGoodwillCreditPenaltyAccountId\n        \/\/ EXPENSE-writeOffAccountId,goodwillCreditAccountId,chargeOffExpenseAccountId,chargeOffFraudExpenseAccountId\n        \/\/ LIABILITY-overpaymentLiabilityAccountId\n\n        final Integer loanProductID = createLoanProductWithCashBasedAccounting(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final Integer loanId = createLoanAccount(clientId, loanProductID, loanExternalIdStr);\n\n        \/\/ apply charges\n        Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 5);\n        final String feeCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeCharge1AddedDate, \"10\"));\n\n        \/\/ apply penalty\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n\n        \/\/ set loan as chargeoff\n        String randomText = Utils.randomStringGenerator(\"en\", 5) + Utils.randomNumberGenerator(6) + Utils.randomStringGenerator(\"is\", 5);\n        Integer chargeOffReasonId = CodeHelper.createChargeOffCodeValue(requestSpec, responseSpec, randomText, 1);\n        String transactionExternalId = UUID.randomUUID().toString();\n        this.loanTransactionHelper.chargeOffLoan((long) loanId, new PostLoansLoanIdTransactionsRequest().transactionDate(\"6 September 2022\")\n                .locale(\"en\").dateFormat(\"dd MMMM yyyy\").externalId(transactionExternalId).chargeOffReasonId((long) chargeOffReasonId));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getChargedOff());\n\n        \/\/ verify Journal Entries For ChargeOff Transaction\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"6 September 2022\",\n                new JournalEntry(1000, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"6 September 2022\",\n                new JournalEntry(1000, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.DEBIT));\n\n        \/\/ Goodwill Credit\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"10 September 2022\").locale(\"en\")\n                        .transactionAmount(800.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getChargedOff());\n\n        \/\/ verify Journal Entries for Goodwill Credit\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"6 September 2022\",\n                new JournalEntry(1000, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"6 September 2022\",\n                new JournalEntry(1000, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.DEBIT));\n    } END"}
{"prompt":"test Apply Loan Specific Due Date Fee With Disbursement Date\n\n###\n\n","completion":"    @Test\n    public void testApplyLoanSpecificDueDateFeeWithDisbursementDate() {\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n\n        \/\/ Client and Loan account creation\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithPeriodicAccrual(loanTransactionHelper,\n                null);\n        assertNotNull(getLoanProductsProductResponse);\n\n        \/\/ Older date to have more than one overdue installment\n        LocalDate transactionDate = todaysDate;\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n        log.info(\"Operation date {}\", transactionDate);\n\n        \/\/ Create Loan Account\n        final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                getLoanProductsProductResponse.getId().toString(), operationDate, \"12\", \"0\");\n\n        \/\/ Get loan details\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), false);\n\n        \/\/ Apply Loan Charge with specific due date\n\n        final String feeAmount = \"10.00\";\n        String payloadJSON = ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, feeAmount, false);\n        final PostChargesResponse postChargesResponse = ChargesHelper.createLoanCharge(requestSpec, responseSpec, payloadJSON);\n        assertNotNull(postChargesResponse);\n        final Long loanChargeId = postChargesResponse.getResourceId();\n\n        payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(loanChargeId.toString(), operationDate, feeAmount);\n        PostLoansLoanIdChargesResponse postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON,\n                responseSpec);\n        assertNotNull(postLoansLoanIdChargesResponse);\n\n        \/\/ Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"10.00\"), false);\n\n        \/\/ Run Accruals\n        log.info(\"Running Periodic Accrual for date {}\", transactionDate);\n        periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n\n        final Long transactionId = loanTransactionHelper.evaluateLastLoanTransactionData(getLoansLoanIdResponse,\n                \"loanTransactionType.accrual\", operationDate, Double.valueOf(\"10.00\"));\n        assertNotNull(transactionId);\n        log.info(\"transactionId {}\", transactionId);\n\n        final GetJournalEntriesTransactionIdResponse journalEntriesResponse = journalEntryHelper.getJournalEntries(\"L\" + transactionId);\n        assertNotNull(journalEntriesResponse);\n        final List<JournalEntryTransactionItem> journalEntries = journalEntriesResponse.getPageItems();\n        assertEquals(2, journalEntries.size());\n        assertEquals(10, journalEntries.get(0).getAmount());\n        assertEquals(10, journalEntries.get(1).getAmount());\n        assertEquals(transactionDate, journalEntries.get(0).getTransactionDate());\n        assertEquals(transactionDate, journalEntries.get(1).getTransactionDate());\n\n        \/\/ Make a full repayment to close the Loan\n        Float amount = Float.valueOf(\"1010.00\");\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        log.info(\"Loan Transaction Id: {} {}\", loanId, loanIdTransactionsResponse.getResourceId());\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(\"0.00\"), Double.valueOf(\"0.00\"), false);\n\n    } END"}
{"prompt":"test Apply Loan Specific Due Date Penalty With Disbursement Date\n\n###\n\n","completion":"    @Test\n    public void testApplyLoanSpecificDueDatePenaltyWithDisbursementDate() {\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n\n        \/\/ Client and Loan account creation\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithPeriodicAccrual(loanTransactionHelper,\n                null);\n        assertNotNull(getLoanProductsProductResponse);\n\n        \/\/ Older date to have more than one overdue installment\n        LocalDate transactionDate = todaysDate;\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n        log.info(\"Operation date {}\", transactionDate);\n\n        \/\/ Create Loan Account\n        final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                getLoanProductsProductResponse.getId().toString(), operationDate, \"12\", \"0\");\n\n        \/\/ Get loan details\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), true);\n\n        \/\/ Apply Loan Charge with specific due date\n\n        final String feeAmount = \"10.00\";\n        String payloadJSON = ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, feeAmount, true);\n        final PostChargesResponse postChargesResponse = ChargesHelper.createLoanCharge(requestSpec, responseSpec, payloadJSON);\n        assertNotNull(postChargesResponse);\n        final Long loanChargeId = postChargesResponse.getResourceId();\n        assertNotNull(loanChargeId);\n\n        payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(loanChargeId.toString(), operationDate, feeAmount);\n        PostLoansLoanIdChargesResponse postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON,\n                responseSpec);\n        assertNotNull(postLoansLoanIdChargesResponse);\n\n        \/\/ Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"10.00\"), true);\n\n        \/\/ Run Accruals\n        log.info(\"Running Periodic Accrual for date {}\", transactionDate);\n        periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n\n        final Long transactionId = loanTransactionHelper.evaluateLastLoanTransactionData(getLoansLoanIdResponse,\n                \"loanTransactionType.accrual\", operationDate, Double.valueOf(\"10.00\"));\n        assertNotNull(transactionId);\n        log.info(\"transactionId {}\", transactionId);\n\n        final GetJournalEntriesTransactionIdResponse journalEntriesResponse = journalEntryHelper.getJournalEntries(\"L\" + transactionId);\n        assertNotNull(journalEntriesResponse);\n        final List<JournalEntryTransactionItem> journalEntries = journalEntriesResponse.getPageItems();\n        assertEquals(2, journalEntries.size());\n        assertEquals(10, journalEntries.get(0).getAmount());\n        assertEquals(10, journalEntries.get(1).getAmount());\n        assertEquals(transactionDate, journalEntries.get(0).getTransactionDate());\n        assertEquals(transactionDate, journalEntries.get(1).getTransactionDate());\n\n        \/\/ Make a full repayment to close the Loan\n        Float amount = Float.valueOf(\"1010.00\");\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        log.info(\"Loan Transaction Id: {} {}\", loanId, loanIdTransactionsResponse.getResourceId());\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(\"0.00\"), Double.valueOf(\"0.00\"), true);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n\n    } END"}
{"prompt":"test Apply And Waive Loan Specific Due Date Penalty With Disbursement Date\n\n###\n\n","completion":"    @Test\n    public void testApplyAndWaiveLoanSpecificDueDatePenaltyWithDisbursementDate() {\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n\n        \/\/ Client and Loan account creation\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper, null);\n        assertNotNull(getLoanProductsProductResponse);\n\n        \/\/ Older date to have more than one overdue installment\n        LocalDate transactionDate = todaysDate;\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n        log.info(\"Operation date {}\", transactionDate);\n\n        \/\/ Create Loan Account\n        final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                getLoanProductsProductResponse.getId().toString(), operationDate, \"12\", \"0\");\n\n        \/\/ Get loan details\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), true);\n\n        \/\/ Apply Loan Charge with specific due date\n        final String feeAmount = \"10.00\";\n        String payloadJSON = ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, feeAmount, true);\n        final PostChargesResponse postChargesResponse = ChargesHelper.createLoanCharge(requestSpec, responseSpec, payloadJSON);\n        assertNotNull(postChargesResponse);\n        final Long chargeId = postChargesResponse.getResourceId();\n        assertNotNull(chargeId);\n\n        payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(chargeId.toString(), operationDate, feeAmount);\n        PostLoansLoanIdChargesResponse postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON,\n                responseSpec);\n        assertNotNull(postLoansLoanIdChargesResponse);\n        final Long loanChargeId = postLoansLoanIdChargesResponse.getResourceId();\n        assertNotNull(loanChargeId);\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"10.00\"), true);\n\n        \/\/ Waive the Loan Charge\n        final PostLoansLoanIdChargesChargeIdResponse postWaiveLoanChargesResponse = loanTransactionHelper.applyLoanChargeCommand(loanId,\n                loanChargeId, \"waive\", Utils.emptyJson());\n        assertNotNull(postWaiveLoanChargesResponse);\n\n        \/\/ evaluate the outstanding\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), true);\n\n        \/\/ Make a full repayment to close the Loan\n        Float amount = Float.valueOf(\"1000.00\");\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        log.info(\"Loan Transaction Id: {} {}\", loanId, loanIdTransactionsResponse.getResourceId());\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n\n    } END"}
{"prompt":"test Apply Fee Accrual On Closed Date\n\n###\n\n","completion":"    @Test\n    public void testApplyFeeAccrualOnClosedDate() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, todaysDate);\n\n            \/\/ Client and Loan account creation\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithPeriodicAccrual(\n                    loanTransactionHelper, null);\n            assertNotNull(getLoanProductsProductResponse);\n\n            LocalDate transactionDate = LocalDate.of(Utils.getLocalDateOfTenant().getYear(), 1, 1);\n            String operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Disbursement date {}\", transactionDate);\n\n            \/\/ Create Loan Account\n            final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                    getLoanProductsProductResponse.getId().toString(), operationDate, \"1\", \"0\");\n\n            \/\/ Get loan details\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), true);\n\n            \/\/ Apply Loan Charge with specific due date\n            String feeAmount = \"10.00\";\n            String payloadJSON = ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, feeAmount, true);\n            final PostChargesResponse postChargesResponse = ChargesHelper.createLoanCharge(requestSpec, responseSpec, payloadJSON);\n            assertNotNull(postChargesResponse);\n            final Long chargeId = postChargesResponse.getResourceId();\n            assertNotNull(chargeId);\n\n            \/\/ First Loan Charge\n            transactionDate = transactionDate.plusDays(1);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, transactionDate);\n            operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Operation date {}\", transactionDate);\n            payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(chargeId.toString(), operationDate, feeAmount);\n            PostLoansLoanIdChargesResponse postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON,\n                    responseSpec);\n            assertNotNull(postLoansLoanIdChargesResponse);\n            final Long loanChargeId01 = postLoansLoanIdChargesResponse.getResourceId();\n            assertNotNull(loanChargeId01);\n\n            \/\/ Run Accruals\n            log.info(\"Running Periodic Accrual for date {}\", transactionDate);\n            periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.evaluateLoanTransactionData(getLoansLoanIdResponse, \"loanTransactionType.accrual\",\n                    Double.valueOf(\"10.00\"));\n\n            \/\/ Repay the first charge fully, 10\n            Float amount = Float.valueOf(\"10.00\");\n            transactionDate = transactionDate.plusDays(40);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, transactionDate);\n            operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Operation date {}\", transactionDate);\n            PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                    loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            log.info(\"Loan Transaction Id: {} {}\", loanId, loanIdTransactionsResponse.getResourceId());\n\n            \/\/ Second Loan Charge\n            feeAmount = \"15.00\";\n            transactionDate = transactionDate.plusDays(1);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, transactionDate);\n            operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Operation date {}\", transactionDate);\n            payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(chargeId.toString(), operationDate, feeAmount);\n            postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON, responseSpec);\n            assertNotNull(postLoansLoanIdChargesResponse);\n            final Long loanChargeId02 = postLoansLoanIdChargesResponse.getResourceId();\n            assertNotNull(loanChargeId02);\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"15.00\"), true);\n\n            \/\/ Run Accruals\n            log.info(\"Running Periodic Accrual for date {}\", transactionDate);\n            periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.evaluateLoanTransactionData(getLoansLoanIdResponse, \"loanTransactionType.accrual\",\n                    Double.valueOf(\"25.00\"));\n\n            \/\/ Third Loan Charge\n            feeAmount = \"25.00\";\n            transactionDate = transactionDate.plusDays(1);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, transactionDate);\n            operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Operation date {}\", transactionDate);\n            payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(chargeId.toString(), operationDate, feeAmount);\n            postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON, responseSpec);\n            assertNotNull(postLoansLoanIdChargesResponse);\n            final Long loanChargeId03 = postLoansLoanIdChargesResponse.getResourceId();\n            assertNotNull(loanChargeId03);\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"40.00\"), true);\n            loanTransactionHelper.evaluateLoanTransactionData(getLoansLoanIdResponse, \"loanTransactionType.accrual\",\n                    Double.valueOf(\"25.00\"));\n\n            amount = Float.valueOf(\"1040.00\");\n            loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount, loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            log.info(\"Loan Transaction Id: {} {}\", loanId, loanIdTransactionsResponse.getResourceId());\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n            loanTransactionHelper.evaluateLoanTransactionData(getLoansLoanIdResponse, \"loanTransactionType.accrual\",\n                    Double.valueOf(\"50.00\"));\n\n            final Long transactionId = loanTransactionHelper.evaluateLastLoanTransactionData(getLoansLoanIdResponse,\n                    \"loanTransactionType.accrual\", operationDate, Double.valueOf(\"25.00\"));\n            assertNotNull(transactionId);\n            log.info(\"transactionId {}\", transactionId);\n\n            final GetJournalEntriesTransactionIdResponse journalEntriesResponse = journalEntryHelper\n                    .getJournalEntries(\"L\" + transactionId.toString());\n            assertNotNull(journalEntriesResponse);\n            final List<JournalEntryTransactionItem> journalEntries = journalEntriesResponse.getPageItems();\n            assertEquals(2, journalEntries.size());\n            assertEquals(25, journalEntries.get(0).getAmount());\n            assertEquals(25, journalEntries.get(1).getAmount());\n            assertEquals(transactionDate, journalEntries.get(0).getTransactionDate());\n            assertEquals(transactionDate, journalEntries.get(1).getTransactionDate());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Apply Fee Accrual When Loan Overpaid\n\n###\n\n","completion":"    @Test\n    public void testApplyFeeAccrualWhenLoanOverpaid() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, todaysDate);\n\n            \/\/ Client and Loan account creation\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithPeriodicAccrual(\n                    loanTransactionHelper, null);\n            assertNotNull(getLoanProductsProductResponse);\n\n            LocalDate transactionDate = LocalDate.of(Utils.getLocalDateOfTenant().getYear(), 1, 1);\n            String operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Disbursement date {}\", transactionDate);\n\n            \/\/ Create Loan Account\n            final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                    getLoanProductsProductResponse.getId().toString(), operationDate, \"1\", \"0\");\n\n            \/\/ Get loan details\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), true);\n\n            \/\/ Apply Loan Charge with specific due date\n            String feeAmount = \"10.00\";\n            String payloadJSON = ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, feeAmount, true);\n            final PostChargesResponse postChargesResponse = ChargesHelper.createLoanCharge(requestSpec, responseSpec, payloadJSON);\n            assertNotNull(postChargesResponse);\n            final Long chargeId = postChargesResponse.getResourceId();\n            assertNotNull(chargeId);\n\n            \/\/ First Loan Charge\n            transactionDate = transactionDate.plusDays(1);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, transactionDate);\n            operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Operation date {}\", transactionDate);\n            payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(chargeId.toString(), operationDate, feeAmount);\n            PostLoansLoanIdChargesResponse postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON,\n                    responseSpec);\n            assertNotNull(postLoansLoanIdChargesResponse);\n            final Long loanChargeId01 = postLoansLoanIdChargesResponse.getResourceId();\n            assertNotNull(loanChargeId01);\n\n            Float amount = Float.valueOf(\"1020.00\");\n            transactionDate = transactionDate.plusDays(2);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, transactionDate);\n            operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Operation date {}\", transactionDate);\n            PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                    loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            log.info(\"Loan Transaction Id: {} {}\", loanId, loanIdTransactionsResponse.getResourceId());\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.overpaid\");\n\n            final Long transactionId = loanTransactionHelper.evaluateLastLoanTransactionData(getLoansLoanIdResponse,\n                    \"loanTransactionType.accrual\", operationDate, Double.valueOf(\"10.00\"));\n            assertNotNull(transactionId);\n            log.info(\"transactionId {}\", transactionId);\n\n            final GetJournalEntriesTransactionIdResponse journalEntriesResponse = journalEntryHelper.getJournalEntries(\"L\" + transactionId);\n            assertNotNull(journalEntriesResponse);\n            final List<JournalEntryTransactionItem> journalEntries = journalEntriesResponse.getPageItems();\n            assertEquals(2, journalEntries.size());\n            assertEquals(10, journalEntries.get(0).getAmount());\n            assertEquals(10, journalEntries.get(1).getAmount());\n            assertEquals(transactionDate, journalEntries.get(0).getTransactionDate());\n            assertEquals(transactionDate, journalEntries.get(1).getTransactionDate());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Apply Loan Specific Due Date Penalty With Disbursement Date With Multiple Disbursement\n\n###\n\n","completion":"    @Test\n    public void testApplyLoanSpecificDueDatePenaltyWithDisbursementDateWithMultipleDisbursement() {\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n\n        \/\/ Client and Loan account creation\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithPeriodicAccrual(loanTransactionHelper,\n                null);\n        assertNotNull(getLoanProductsProductResponse);\n\n        \/\/ Older date to have more than one overdue installment\n        LocalDate transactionDate = todaysDate;\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n        log.info(\"Operation date {}\", transactionDate);\n\n        \/\/ Create Loan Account\n        final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                getLoanProductsProductResponse.getId().toString(), operationDate, \"12\", \"0\");\n\n        \/\/ Get loan details\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), true);\n\n        \/\/ Apply Loan Charge with specific due date\n\n        final String feeAmount = \"10.00\";\n        String payloadJSON = ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, feeAmount, true);\n        final PostChargesResponse postChargesResponse = ChargesHelper.createLoanCharge(requestSpec, responseSpec, payloadJSON);\n        assertNotNull(postChargesResponse);\n        final Long loanChargeId = postChargesResponse.getResourceId();\n        assertNotNull(loanChargeId);\n\n        payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(loanChargeId.toString(), operationDate, feeAmount);\n        PostLoansLoanIdChargesResponse postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON,\n                responseSpec);\n        assertNotNull(postLoansLoanIdChargesResponse);\n\n        periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n\n        \/\/ Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"10.00\"), true);\n\n        loanTransactionHelper.disburseLoan((long) loanId, new PostLoansLoanIdRequest().actualDisbursementDate(operationDate)\n                .transactionAmount(new BigDecimal(\"1000\")).locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n\n        \/\/ Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.parseDouble(principalAmount) * 2, Double.valueOf(\"10.00\"), true);\n\n        operationDate = Utils.dateFormatter.format(transactionDate.plusMonths(1));\n        payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(loanChargeId.toString(), operationDate, feeAmount);\n        postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON, responseSpec);\n\n        \/\/ Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.parseDouble(principalAmount) * 2, Double.valueOf(\"20.00\"), true);\n    } END"}
{"prompt":"test Apply Loan Specific Due Date Penalty Accrual With Disbursement Date With Multiple Disbursement\n\n###\n\n","completion":"    @Test\n    public void testApplyLoanSpecificDueDatePenaltyAccrualWithDisbursementDateWithMultipleDisbursement() {\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n\n        \/\/ Client and Loan account creation\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithPeriodicAccrual(loanTransactionHelper,\n                null);\n        assertNotNull(getLoanProductsProductResponse);\n\n        \/\/ Older date to have more than one overdue installment\n        LocalDate transactionDate = todaysDate.minusDays(2);\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n        log.info(\"Operation date {}\", transactionDate);\n\n        \/\/ Create Loan Account\n        final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                getLoanProductsProductResponse.getId().toString(), operationDate, \"12\", \"0\");\n\n        \/\/ Get loan details\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), true);\n\n        \/\/ Apply Loan Charge with specific due date\n\n        final String feeAmount = \"10.00\";\n        String payloadJSON = ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, feeAmount, true);\n        final PostChargesResponse postChargesResponse = ChargesHelper.createLoanCharge(requestSpec, responseSpec, payloadJSON);\n        assertNotNull(postChargesResponse);\n        final Long loanChargeId = postChargesResponse.getResourceId();\n        assertNotNull(loanChargeId);\n\n        payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(loanChargeId.toString(), operationDate, feeAmount);\n        PostLoansLoanIdChargesResponse postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON,\n                responseSpec);\n        assertNotNull(postLoansLoanIdChargesResponse);\n\n        periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n\n        \/\/ Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"10.00\"), true);\n\n        transactionDate = transactionDate.plusDays(1);\n        operationDate = Utils.dateFormatter.format(transactionDate);\n\n        loanTransactionHelper.disburseLoan((long) loanId, new PostLoansLoanIdRequest().actualDisbursementDate(operationDate)\n                .transactionAmount(new BigDecimal(\"1000\")).locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n\n        \/\/ Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.parseDouble(principalAmount) * 2, Double.valueOf(\"10.00\"), true);\n\n        periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n\n        operationDate = Utils.dateFormatter.format(transactionDate.plusMonths(1));\n        payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(loanChargeId.toString(), operationDate, feeAmount);\n        postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON, responseSpec);\n\n        transactionDate = transactionDate.plusDays(1);\n        operationDate = Utils.dateFormatter.format(transactionDate);\n        periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n        \/\/ Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.parseDouble(principalAmount) * 2, Double.valueOf(\"20.00\"), true);\n    } END"}
{"prompt":"test Loan COBCatch Up Works When In Batch Manager Mode\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = true)\n    @Test\n    public void testLoanCOBCatchUpWorksWhenInBatchManagerMode() {\n        loanCOBCatchUpHelper.executeLoanCOBCatchUp();\n    } END"}
{"prompt":"test Loan COBCatch Up Does Not Works When Not In Batch Manager Mode\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = true, batchManagerEnabled = false)\n    @Test\n    public void testLoanCOBCatchUpDoesNotWorksWhenNotInBatchManagerMode() {\n        CallFailedRuntimeException exception = assertThrows(CallFailedRuntimeException.class,\n                () -> loanCOBCatchUpHelper.executeLoanCOBCatchUp());\n        assertEquals(405, exception.getResponse().code());\n    } END"}
{"prompt":"test Loan COBCatch Up Get Status Works When In Batch Manager Mode\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = true)\n    @Test\n    public void testLoanCOBCatchUpGetStatusWorksWhenInBatchManagerMode() {\n        loanCOBCatchUpHelper.executeGetLoanCatchUpStatus();\n    } END"}
{"prompt":"test Loan COBCatch Up Get Status Does Not Works When Not In Batch Manager Mode\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = true, batchManagerEnabled = false)\n    @Test\n    public void testLoanCOBCatchUpGetStatusDoesNotWorksWhenNotInBatchManagerMode() {\n        CallFailedRuntimeException exception = assertThrows(CallFailedRuntimeException.class,\n                () -> loanCOBCatchUpHelper.executeGetLoanCatchUpStatus());\n        assertEquals(405, exception.getResponse().code());\n    } END"}
{"prompt":"test Loan COBCatch Up Other Get Apis Works When In Batch Manager And Read Mode\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = true, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = true)\n    @Test\n    public void testLoanCOBCatchUpOtherGetApisWorksWhenInBatchManagerAndReadMode() {\n        loanCOBCatchUpHelper.executeRetrieveOldestCOBProcessedLoan();\n    } END"}
{"prompt":"test Loan COBCatch Up Other Get Apis Works When In Read Only Mode\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = true, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = false)\n    @Test\n    public void testLoanCOBCatchUpOtherGetApisWorksWhenInReadOnlyMode() {\n        loanCOBCatchUpHelper.executeRetrieveOldestCOBProcessedLoan();\n    } END"}
{"prompt":"test Scheduler Works When In Batch Manager Mode\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = true)\n    @Test\n    public void testSchedulerWorksWhenInBatchManagerMode() {\n        schedulerJobHelper.updateSchedulerStatus(false);\n    } END"}
{"prompt":"test Scheduler Does Not Works When Not In Batch Manager Mode\n\n###\n\n","completion":"    @ConfigureInstanceMode(readEnabled = true, writeEnabled = true, batchWorkerEnabled = true, batchManagerEnabled = false)\n    @Test\n    public void testSchedulerDoesNotWorksWhenNotInBatchManagerMode() {\n        CallFailedRuntimeException exception = assertThrows(CallFailedRuntimeException.class,\n                () -> schedulerJobHelper.updateSchedulerStatus(false));\n        assertEquals(405, exception.getResponse().code());\n    } END"}
{"prompt":"loan Application Validate Disbursal Date\n\n###\n\n","completion":"    @Test\n    public void loanApplicationValidateDisbursalDate() {\n\n        final String proposedAmount = \"5000\";\n        final String approveDate = \"01 March 2014\";\n        final String disbursalDate = \"02 March 2014\";\n\n        \/\/ CREATE CLIENT\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        LOG.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientID);\n\n        \/\/ CREATE LOAN PRODUCT\n        final Integer loanProductID = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withSyncExpectedWithDisbursementDate(true).build(null));\n        LOG.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductID);\n\n        \/\/ APPLY FOR LOAN\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, proposedAmount);\n        LOG.info(\"-----------------------------------LOAN CREATED WITH LOANID------------------------------------------------- {}\", loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n\n        \/\/ VALIDATE THE LOAN STATUS\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(approveDate, loanID);\n\n        \/\/ VALIDATE THE LOAN IS APPROVED\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        \/\/ DISBURSE A LOAN\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        @SuppressWarnings(\"unchecked\")\n        List<HashMap> disbursalError = (List<HashMap>) this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(disbursalDate, loanID,\n                this.responseForbiddenError, JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n\n        Assertions.assertEquals(disbursalError.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE),\n                \"error.msg.actual.disbursement.date.does.not.match.with.expected.disbursal.date\");\n\n    } END"}
{"prompt":"create And Validate Multi Disburse Loans Based On Emi\n\n###\n\n","completion":"    @Test\n    public void createAndValidateMultiDisburseLoansBasedOnEmi() {\n        List<HashMap> createTranches = new ArrayList<>();\n        String id = null;\n        String installmentAmount = \"800\";\n        String withoutInstallmentAmount = \"\";\n        String proposedAmount = \"10000\";\n        createTranches.add(this.loanTransactionHelper.createTrancheDetail(id, \"01 June 2015\", \"5000\"));\n        createTranches.add(this.loanTransactionHelper.createTrancheDetail(id, \"01 September 2015\", \"5000\"));\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        log.info(\"---------------------------------CLIENT CREATED WITH ID---------------------------------------------------{}\", clientID);\n\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder()\n                .withInterestTypeAsDecliningBalance().withMoratorium(\"\", \"\").withAmortizationTypeAsEqualInstallments().withTranches(true)\n                .withInterestCalculationPeriodTypeAsRepaymentPeriod(true).build(null));\n        log.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductID);\n\n        final Integer loanIDWithEmi = applyForLoanApplicationWithEmiAmount(clientID, loanProductID, proposedAmount, createTranches,\n                installmentAmount);\n\n        log.info(\"-----------------------------------LOAN CREATED WITH EMI LOANID------------------------------------------------- {}\",\n                loanIDWithEmi);\n\n        HashMap repaymentScheduleWithEmi = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec,\n                loanIDWithEmi, \"repaymentSchedule\");\n\n        ArrayList<HashMap> periods = (ArrayList<HashMap>) repaymentScheduleWithEmi.get(\"periods\");\n        assertEquals(15, periods.size());\n\n        this.validateRepaymentScheduleWithEMI(periods);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanIDWithEmi);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        log.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(\"01 June 2015\", \"01 June 2015\", \"10000\", loanIDWithEmi,\n                createTranches);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        log.info(\n                \"-----------------------------------MULTI DISBURSAL LOAN WITH EMI APPROVED SUCCESSFULLY---------------------------------------\");\n\n        final Integer loanIDWithoutEmi = applyForLoanApplicationWithEmiAmount(clientID, loanProductID, proposedAmount, createTranches,\n                withoutInstallmentAmount);\n\n        this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanIDWithoutEmi, \"repaymentSchedule\");\n\n        ArrayList<HashMap> periods1 = (ArrayList<HashMap>) repaymentScheduleWithEmi.get(\"periods\");\n        assertEquals(15, periods1.size());\n\n        log.info(\"-----------------------------------LOAN CREATED WITHOUT EMI LOANID------------------------------------------------- {}\",\n                loanIDWithoutEmi);\n\n        \/* To be uncommented once issue MIFOSX-2006 is closed. *\/\n        \/\/ this.validateRepaymentScheduleWithoutEMI(periods1);\n\n        HashMap loanStatusMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanIDWithoutEmi);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusMap);\n\n        log.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(\"01 June 2015\", \"01 June 2015\", \"10000\",\n                loanIDWithoutEmi, createTranches);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        log.info(\n                \"-----------------------------------MULTI DISBURSAL LOAN WITHOUT EMI APPROVED SUCCESSFULLY---------------------------------------\");\n\n    } END"}
{"prompt":"validate Equal Installments For Multi Tranche Loan\n\n###\n\n","completion":"    @Test\n    public void validateEqualInstallmentsForMultiTrancheLoan() {\n        final String operationDate = \"01 January 2014\";\n        final String principal = \"1000\";\n        final String disbursedPrincipal = \"900\";\n\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, operationDate);\n        log.info(\"-----------------CLIENT CREATED WITH ID------------------- {}\", clientId);\n\n        final String loanProductJSON = new LoanProductTestBuilder().withAmortizationTypeAsEqualInstallments() \/\/\n                .withInterestTypeAsDecliningBalance().withMoratorium(\"\", \"\").withInterestCalculationPeriodTypeAsRepaymentPeriod(true)\n                .withInterestTypeAsDecliningBalance() \/\/\n                .withMultiDisburse() \/\/\n                .withDisallowExpectedDisbursements(true) \/\/\n                .build(null);\n        log.info(\"Product {}\", loanProductJSON);\n        final Integer loanProductId = this.loanTransactionHelper.getLoanProductId(loanProductJSON);\n        log.info(\"------------------LOAN PRODUCT CREATED WITH ID----------- {}\", loanProductId);\n\n        final Integer loanId = applyForMultiTrancheLoanApplication(clientId.toString(), loanProductId.toString(), principal, operationDate);\n\n        log.info(\"-------------------LOAN CREATED WITH loanId----------------- {}\", loanId);\n\n        this.loanTransactionHelper.approveLoanWithApproveAmount(operationDate, expectedDisbursementDate, principal, loanId, null);\n        log.info(\"-------------------MULTI DISBURSAL LOAN APPROVED SUCCESSFULLY-------\");\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        this.loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        loanTransactionHelper.disburseLoanWithTransactionAmount(operationDate, loanId, disbursedPrincipal);\n        log.info(\"-------------------MULTI DISBURSAL LOAN DISBURSED SUCCESSFULLY-------\");\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        this.loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n        final Double limit = 2.0;\n        evaluateEqualInstallmentsForRepaymentSchedule(getLoansLoanIdResponse.getRepaymentSchedule(), limit);\n        log.info(\"-----------MULTI DISBURSAL LOAN EQUAL INSTALLMENTS SUCCESSFULLY-------\");\n    } END"}
{"prompt":"create Approve And Validate Multi Disburse Loan\n\n###\n\n","completion":"    @Test\n    public void createApproveAndValidateMultiDisburseLoan() throws ParseException {\n\n        List<HashMap> createTranches = new ArrayList<>();\n        String id = null;\n        createTranches.add(this.loanTransactionHelper.createTrancheDetail(id, \"01 March 2014\", \"1000\"));\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        log.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientID);\n\n        final Integer loanProductID = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withInterestTypeAsDecliningBalance().withTranches(true)\n                        .withInterestCalculationPeriodTypeAsRepaymentPeriod(true).build(null));\n        log.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductID);\n\n        this.loanId = applyForLoanApplicationWithTranches(clientID, loanProductID, proposedAmount, createTranches);\n        log.info(\"-----------------------------------LOAN CREATED WITH LOANID------------------------------------------------- {}\",\n                this.loanId);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        log.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(approveDate, expectedDisbursementDate, approvalAmount,\n                this.loanId, createTranches);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        log.info(\"-----------------------------------MULTI DISBURSAL LOAN APPROVED SUCCESSFULLY---------------------------------------\");\n        ArrayList<HashMap> disbursementDetails = (ArrayList<HashMap>) this.loanTransactionHelper.getLoanDetail(this.requestSpec,\n                this.responseSpec, this.loanId, \"disbursementDetails\");\n        this.disbursementId = (Integer) disbursementDetails.get(0).get(\"id\");\n        this.editLoanDisbursementDetails();\n    } END"}
{"prompt":"allow Modify Loan Application After Undo Disbursal With Tranches\n\n###\n\n","completion":"    @Test\n    public void allowModifyLoanApplicationAfterUndoDisbursalWithTranches() throws ParseException {\n        final String operationDate = this.approveDate;\n        List<HashMap> tranches = new ArrayList<>();\n        String principal = \"1000\";\n        final List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, operationDate);\n        log.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientId);\n\n        final Integer loanProductId = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withInterestTypeAsDecliningBalance().withTranches(true)\n                        .withDisallowExpectedDisbursements(true).withInterestCalculationPeriodTypeAsRepaymentPeriod(true).build(null));\n        log.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductId);\n        GetLoanProductsProductIdResponse getLoanProductsProductIdResponse = this.loanTransactionHelper.getLoanProduct(loanProductId);\n        assertNotNull(getLoanProductsProductIdResponse);\n        log.info(\"Loan Product Id {} with DisallowExpectectedDisbursements in {}\", loanProductId,\n                getLoanProductsProductIdResponse.getDisallowExpectedDisbursements());\n        assertEquals(true, getLoanProductsProductIdResponse.getDisallowExpectedDisbursements());\n\n        final Integer loanId = applyForLoanApplicationWithTranches(clientId, loanProductId, proposedAmount, tranches);\n        log.info(\"-----------------------------------LOAN CREATED WITH LOANID------------------------------------------------- {}\", loanId);\n\n        loanTransactionHelper.approveLoanWithApproveAmount(operationDate, operationDate, approvalAmount, loanId, tranches);\n        GetLoansLoanIdResponse getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size());\n        log.info(\"-------------------MULTI DISBURSAL LOAN APPROVED SUCCESSFULLY-------\");\n        assertEquals(0, getLoansLoanIdResponse.getDisbursementDetails().size(), \"Disbursement details items\");\n\n        loanTransactionHelper.disburseLoanWithTransactionAmount(operationDate, loanId, principal);\n\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size());\n        log.info(\"-------------------MULTI DISBURSAL LOAN DISBURSED SUCCESSFULLY-------\");\n        assertEquals(1, getLoansLoanIdResponse.getDisbursementDetails().size(), \"Disbursement details items\");\n\n        PostLoansLoanIdResponse postLoansLoanIdResponse = this.loanTransactionHelper.applyLoanCommand(loanId, \"undoDisbursal\");\n        assertNotNull(postLoansLoanIdResponse);\n        log.info(\"-------------------UNDO DISBURSAL LOAN SUCCESSFULLY-------\");\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size());\n        assertEquals(0, getLoansLoanIdResponse.getDisbursementDetails().size(), \"Disbursement details items\");\n\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size());\n        assertEquals(0, getLoansLoanIdResponse.getDisbursementDetails().size(), \"Disbursement details items\");\n\n        postLoansLoanIdResponse = this.loanTransactionHelper.applyLoanCommand(loanId, \"undoApproval\");\n        assertNotNull(postLoansLoanIdResponse);\n        log.info(\"-------------------UNDO APPROVAL LOAN SUCCESSFULLY-------\");\n\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size());\n\n        principal = \"10000\";\n        final String loanApplicationJSON = buildLoanApplicationJSON(clientId, loanProductId, principal, tranches, operationDate,\n                collaterals);\n        log.info(\"Modify Loan Application: {}\", loanApplicationJSON);\n        PutLoansLoanIdResponse putLoansLoanIdResponse = this.loanTransactionHelper.modifyLoanApplication(loanId, loanApplicationJSON);\n        assertNotNull(putLoansLoanIdResponse);\n\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {} and Principal {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size(),\n                getLoansLoanIdResponse.getPrincipal());\n\n        \/\/ ReDo the Approval and Disbursement\n        loanTransactionHelper.approveLoanWithApproveAmount(operationDate, operationDate, approvalAmount, loanId, null);\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size());\n\n        loanTransactionHelper.disburseLoanWithTransactionAmount(operationDate, loanId, principal);\n\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size());\n        log.info(\"-------------------MULTI DISBURSAL LOAN DISBURSED SUCCESSFULLY-------\");\n        assertEquals(1, getLoansLoanIdResponse.getDisbursementDetails().size(), \"Disbursement details items\");\n    } END"}
{"prompt":"check Loan Create And Disburse Flow With Fixed Principal Percentage\n\n###\n\n","completion":"    @Test\n    public void checkLoanCreateAndDisburseFlowWithFixedPrincipalPercentage() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(ACCOUNTING_NONE);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, null, null, \"100000.00\");\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec,\n                loanID);\n        verifyLoanRepaymentScheduleForEqualPrincipal(loanSchedule);\n    } END"}
{"prompt":"check Loan Create And Disburse Flow With Fixed Principal Percentage With Principal Grace\n\n###\n\n","completion":"    @Test\n    public void checkLoanCreateAndDisburseFlowWithFixedPrincipalPercentageWithPrincipalGrace() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(ACCOUNTING_NONE);\n        final Integer loanID = applyForLoanApplicationWithPrincipalGrace(clientID, loanProductID, null, null, \"100000.00\");\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec,\n                loanID);\n        verifyLoanRepaymentScheduleForEqualPrincipalWithPrincipalGrace(loanSchedule);\n    } END"}
{"prompt":"check Loan Create And Disburse Flow With Fixed Principal Percentage And Flat Interest\n\n###\n\n","completion":"    @Test\n    public void checkLoanCreateAndDisburseFlowWithFixedPrincipalPercentageAndFlatInterest() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithFlatInterest(ACCOUNTING_NONE);\n        final Integer loanID = applyForLoanApplicationWithFlatInterest(clientID, loanProductID, null, null, \"100000.00\");\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec,\n                loanID);\n        verifyLoanRepaymentScheduleForEqualPrincipalAndFlatInterest(loanSchedule);\n    } END"}
{"prompt":"loan Last Repayment Details Test Closed Loan\n\n###\n\n","completion":"    @Test\n    public void loanLastRepaymentDetailsTestClosedLoan() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        \/\/ Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        \/\/ make Repayments\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 September 2022\").locale(\"en\")\n                        .transactionAmount(500.0));\n\n        GetLoansLoanIdResponse loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n\n        \/\/ verify loan is active and last repayment details\n        LocalDate lastRepaymentDate_1 = LocalDate.of(2022, 9, 5);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getDelinquent());\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentAmount());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentAmount(), 500);\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentDate());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentDate(), lastRepaymentDate_1);\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_2 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"6 September 2022\").locale(\"en\")\n                        .transactionAmount(500.0));\n\n        \/\/ verify loan is closed and last repayment details\n\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n\n        LocalDate lastRepaymentDate_2 = LocalDate.of(2022, 9, 6);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getClosedObligationsMet());\n        assertNotNull(loanDetails.getDelinquent());\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentAmount());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentAmount(), 500);\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentDate());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentDate(), lastRepaymentDate_2);\n\n    } END"}
{"prompt":"loan Last Repayment Details Test Overpaid Loan\n\n###\n\n","completion":"    @Test\n    public void loanLastRepaymentDetailsTestOverpaidLoan() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        \/\/ Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        \/\/ make Repayments\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 September 2022\").locale(\"en\")\n                        .transactionAmount(500.0));\n\n        GetLoansLoanIdResponse loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n\n        \/\/ verify loan is active and last repayment details\n        LocalDate lastRepaymentDate_1 = LocalDate.of(2022, 9, 5);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getDelinquent());\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentAmount());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentAmount(), 500);\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentDate());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentDate(), lastRepaymentDate_1);\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_2 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"6 September 2022\").locale(\"en\")\n                        .transactionAmount(600.0));\n\n        \/\/ verify loan is overpaid and last repayment details\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n\n        LocalDate lastRepaymentDate_2 = LocalDate.of(2022, 9, 6);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getOverpaid());\n        assertNotNull(loanDetails.getDelinquent());\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentAmount());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentAmount(), 600);\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentDate());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentDate(), lastRepaymentDate_2);\n\n    } END"}
{"prompt":"loan Add Charge For Paid Off Loan With Refund Test\n\n###\n\n","completion":"    @Test\n    public void loanAddChargeForPaidOffLoanWithRefundTest() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        \/\/ Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        \/\/ make Repayments\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"4 September 2022\").locale(\"en\")\n                        .transactionAmount(1000.0));\n\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        final Integer loanRepaymentScheduleSize = loanDetails.getRepaymentSchedule().getPeriods().size();\n        assertTrue(loanDetails.getStatus().getClosedObligationsMet());\n\n        \/\/ make payout refund\n        final PostLoansLoanIdTransactionsResponse payoutRefund_1 = loanTransactionHelper.makePayoutRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"4 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getOverpaid());\n\n        \/\/ apply charges on date before maturity date\n        Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 4);\n        final String feeChargeAddedDate = dateFormatter.format(targetDate);\n        Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeChargeAddedDate, \"10\"));\n\n        assertNotNull(feeLoanChargeId);\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertEquals(loanDetails.getRepaymentSchedule().getPeriods().size(), loanRepaymentScheduleSize);\n\n        \/\/ apply charges on date after maturity date\n        Integer feeCharge_1 = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n        LocalDate targetDate_1 = LocalDate.of(2022, 10, 4);\n        final String feeCharge1AddedDate = dateFormatter.format(targetDate_1);\n        Integer feeLoanChargeId_1 = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge_1), feeCharge1AddedDate, \"10\"));\n\n        assertNotNull(feeLoanChargeId_1);\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertEquals(loanDetails.getRepaymentSchedule().getPeriods().size(), loanRepaymentScheduleSize + 1);\n\n    } END"}
{"prompt":"loan Product Creation With Due Days Configuration For Repayment Event Test\n\n###\n\n","completion":"    @Test\n    public void loanProductCreationWithDueDaysConfigurationForRepaymentEventTest() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        \/\/ event days configuration\n        Integer dueDaysForRepaymentEvent = 1;\n        Integer overDueDaysForRepaymentEvent = 2;\n\n        \/\/ Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        Integer loanProductId = createLoanProductWithDueDaysForRepaymentEvent(loanTransactionHelper, delinquencyBucketId,\n                dueDaysForRepaymentEvent, overDueDaysForRepaymentEvent);\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = loanTransactionHelper.getLoanProduct(loanProductId);\n        assertNotNull(getLoanProductsProductResponse);\n        assertNotNull(getLoanProductsProductResponse.getDueDaysForRepaymentEvent());\n        assertNotNull(getLoanProductsProductResponse.getOverDueDaysForRepaymentEvent());\n        assertEquals(getLoanProductsProductResponse.getDueDaysForRepaymentEvent(), dueDaysForRepaymentEvent);\n        assertEquals(getLoanProductsProductResponse.getOverDueDaysForRepaymentEvent(), overDueDaysForRepaymentEvent);\n    } END"}
{"prompt":"loan Product Update With Due Days Configuration For Repayment Event Test\n\n###\n\n","completion":"    @Test\n    public void loanProductUpdateWithDueDaysConfigurationForRepaymentEventTest() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        \/\/ Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        \/\/ Modify Loan Product\n        PutLoanProductsProductIdResponse loanProductModifyResponse = updateLoanProduct(loanTransactionHelper,\n                getLoanProductsProductResponse.getId());\n        assertNotNull(loanProductModifyResponse);\n\n    } END"}
{"prompt":"test Loan Repayment Reschedule At Disbursement\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testLoanRepaymentRescheduleAtDisbursement() {\n\n        final String approvalAmount = \"10000\";\n        final String approveDate = \"01 March 2015\";\n        final String expectedDisbursementDate = \"01 March 2015\";\n        final String disbursementDate = \"01 March 2015\";\n        final String adjustRepaymentDate = \"16 March 2015\";\n\n        \/\/ CREATE CLIENT\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        LOG.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientID);\n\n        \/\/ CREATE LOAN MULTIDISBURSAL PRODUCT WITH INTEREST RECALCULATION\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.RBI_INDIA_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"0\",\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null);\n\n        \/\/ CREATE TRANCHES\n        List<HashMap> createTranches = new ArrayList<>();\n        createTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"01 March 2015\", \"5000\"));\n        createTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"01 May 2015\", \"5000\"));\n\n        \/\/ APPROVE TRANCHES\n        List<HashMap> approveTranches = new ArrayList<>();\n        approveTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"01 March 2015\", \"5000\"));\n        approveTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"01 May 2015\", \"5000\"));\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        \/\/ APPLY FOR TRANCHE LOAN WITH INTEREST RECALCULATION\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, disbursementDate,\n                LoanApplicationTestBuilder.RBI_INDIA_STRATEGY, new ArrayList<HashMap>(0), createTranches, collaterals);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n\n        \/\/ VALIDATE THE LOAN STATUS\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(approveDate, expectedDisbursementDate, approvalAmount,\n                loanID, approveTranches);\n\n        \/\/ VALIDATE THE LOAN IS APPROVED\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        \/\/ DISBURSE A FIRST TRANCHE\n        this.loanTransactionHelper.disburseLoanWithRepaymentReschedule(disbursementDate, loanID, adjustRepaymentDate);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n\n        ArrayList<HashMap> loanRepaymnetSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, generalResponseSpec,\n                loanID);\n        HashMap firstInstallement = loanRepaymnetSchedule.get(1);\n        Map<String, Object> expectedvalues = new HashMap<>(3);\n        Calendar date = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        date.set(2015, Calendar.MARCH, 16);\n        expectedvalues.put(\"dueDate\", getDateAsArray(date, 0));\n        expectedvalues.put(\"principalDue\", \"834.71\");\n        expectedvalues.put(\"interestDue\", \"49.32\");\n        expectedvalues.put(\"feeChargesDue\", \"0\");\n        expectedvalues.put(\"penaltyChargesDue\", \"0\");\n        expectedvalues.put(\"totalDueForPeriod\", \"884.03\");\n\n        \/\/ VALIDATE REPAYMENT SCHEDULE\n        verifyLoanRepaymentSchedule(firstInstallement, expectedvalues);\n\n    } END"}
{"prompt":"test Create Loan Reschedule Request With Interest Appropriation\n\n###\n\n","completion":"    @Test\n    public void testCreateLoanRescheduleRequestWithInterestAppropriation() {\n        \/\/ create all required entities\n        this.createRequiredEntities();\n        this.createAndApproveLoanRescheduleRequestForRecoverInterestInterestFirst();\n\n    } END"}
{"prompt":"test Create Loan Reschedule Request Fail If Loan Is Charged Off\n\n###\n\n","completion":"    @Test\n    public void testCreateLoanRescheduleRequestFailIfLoanIsChargedOff() {\n        \/\/ create all required entities\n        this.createRequiredEntitiesNoInterest();\n        this.createLoanRescheduleRequestWhichFailsAsLoanIdChargedOff();\n\n    } END"}
{"prompt":"test Create Loan Reschedule Request With Recalculation Enabled\n\n###\n\n","completion":"    @Test\n    public void testCreateLoanRescheduleRequestWithRecalculationEnabled() {\n        \/\/ create all required entities\n        this.createRequiredEntitiesWithRecalculationEnabled();\n        this.createAndApproveLoanRescheduleRequestWithRecalculationEnabled();\n    } END"}
{"prompt":"test Create Loan Reschedule Request For Interest Appropriation And Fixed EMI\n\n###\n\n","completion":"    @Test\n    public void testCreateLoanRescheduleRequestForInterestAppropriationAndFixedEMI() {\n        \/\/ create all required entities\n        this.createRequiredEntities();\n        this.createAndApproveLoanRescheduleRequestForRecoverInterestFirstAndFixedEMI();\n    } END"}
{"prompt":"test Create Loan Reschedule Request With Multple Interest Appropriation\n\n###\n\n","completion":"    @Test\n    public void testCreateLoanRescheduleRequestWithMultpleInterestAppropriation() {\n        \/\/ create all required entities\n        this.createRequiredEntities();\n        this.createAndApproveLoanRescheduleRequestForRecoverInterestInterestFirst();\n\n        this.createAndApproveLoanRescheduleRequestForSecondInterestAppropriation();\n\n    } END"}
{"prompt":"test Create Loan Interest Greater Than EMIFrom Gap With Recalculation Enabled And Principal Compounding Off\n\n###\n\n","completion":"    @Test\n    public void testCreateLoanInterestGreaterThanEMIFromGapWithRecalculationEnabledAndPrincipalCompoundingOff() {\n        this.enableConfig();\n        this.enablePrincipalCompoundingConfig();\n        \/\/ create all required entities\n        this.createRequiredEntitiesWithRecalculationEnabledWithPrincipalCompoundingOff();\n        this.createApproveLoanRescheduleRequestWithRecalculationEnabledWithPrincipalCompoundingOff();\n        this.disablePrincipalCompoundingConfig();\n        this.disableConfig();\n    } END"}
{"prompt":"test Create Loan Reschedule Request\n\n###\n\n","completion":"    @Test\n    public void testCreateLoanRescheduleRequest() {\n        this.createLoanRescheduleRequest();\n    } END"}
{"prompt":"test Reject Loan Reschedule Request\n\n###\n\n","completion":"    @Test\n    public void testRejectLoanRescheduleRequest() {\n        this.createLoanRescheduleRequest();\n\n        LOG.info(\"-----------------------------REJECTING LOAN RESCHEDULE REQUEST--------------------------\");\n\n        final String requestJSON = new LoanRescheduleRequestTestBuilder().getRejectLoanRescheduleRequestJSON();\n        this.loanRescheduleRequestHelper.rejectLoanRescheduleRequest(this.loanRescheduleRequestId, requestJSON);\n\n        final HashMap response = (HashMap) this.loanRescheduleRequestHelper.getLoanRescheduleRequest(loanRescheduleRequestId, \"statusEnum\");\n        assertTrue((Boolean) response.get(\"rejected\"));\n\n        LOG.info(\"Successfully rejected loan reschedule request (ID: {} )\", this.loanRescheduleRequestId);\n    } END"}
{"prompt":"test Approve Loan Reschedule Request\n\n###\n\n","completion":"    @Test\n    public void testApproveLoanRescheduleRequest() {\n        this.createLoanRescheduleRequest();\n\n        LOG.info(\"-----------------------------APPROVING LOAN RESCHEDULE REQUEST--------------------------\");\n\n        final String requestJSON = new LoanRescheduleRequestTestBuilder().getApproveLoanRescheduleRequestJSON();\n        this.loanRescheduleRequestHelper.approveLoanRescheduleRequest(this.loanRescheduleRequestId, requestJSON);\n\n        final HashMap response = (HashMap) this.loanRescheduleRequestHelper.getLoanRescheduleRequest(loanRescheduleRequestId, \"statusEnum\");\n        assertTrue((Boolean) response.get(\"approved\"));\n\n        final Integer numberOfRepayments = (Integer) this.loanTransactionHelper.getLoanDetail(requestSpec, generalResponseSpec, loanId,\n                \"numberOfRepayments\");\n        final HashMap loanSummary = this.loanTransactionHelper.getLoanSummary(requestSpec, generalResponseSpec, loanId);\n        final Float totalExpectedRepayment = (Float) loanSummary.get(\"totalExpectedRepayment\");\n\n        assertEquals(12, numberOfRepayments, \"NUMBER OF REPAYMENTS is NOK\");\n        assertEquals(118000, totalExpectedRepayment, \"TOTAL EXPECTED REPAYMENT is NOK\");\n\n        LOG.info(\"Successfully approved loan reschedule request (ID: {})\", this.loanRescheduleRequestId);\n    } END"}
{"prompt":"test Create Loan Reschedule Change EMIRequest\n\n###\n\n","completion":"    @Test\n    public void testCreateLoanRescheduleChangeEMIRequest() {\n        this.createLoanRescheduleChangeEMIRequest();\n    } END"}
{"prompt":"test Reschedule After Late Payment\n\n###\n\n","completion":"    @Test\n    public void testRescheduleAfterLatePayment() {\n        this.enableConfig();\n        this.enablePrincipalCompoundingConfig();\n        WorkingDaysHelper.updateWorkingDaysWeekDays(this.requestSpec, this.responseSpec);\n        \/\/ create all required entities\n        this.createRequiredEntitiesWithLatePayment();\n        this.createApproveLoanRescheduleRequestAfterLatePayment();\n        WorkingDaysHelper.updateWorkingDays(this.requestSpec, this.responseSpec);\n        this.disablePrincipalCompoundingConfig();\n        this.disableConfig();\n    } END"}
{"prompt":"test Multiple Advance Payment With Reschedule\n\n###\n\n","completion":"    @Test\n    public void testMultipleAdvancePaymentWithReschedule() {\n        this.enableConfig();\n        this.enablePrincipalCompoundingConfig();\n        WorkingDaysHelper.updateWorkingDaysWeekDays(this.requestSpec, this.responseSpec);\n        \/\/ create all required entities\n        this.createRequiredEntitiesForTestMultipleAdvancePaymentWithReschedule();\n        this.doMultipleAdvancePaymentsAndVerifySchedule();\n        WorkingDaysHelper.updateWorkingDays(this.requestSpec, this.responseSpec);\n        this.disablePrincipalCompoundingConfig();\n        this.disableConfig();\n    } END"}
{"prompt":"test Center Rescheduling Loans With Interest Recalculation Enabled\n\n###\n\n","completion":"    @SuppressWarnings(\"rawtypes\")\n    @Test\n    public void testCenterReschedulingLoansWithInterestRecalculationEnabled() {\n\n        Integer officeId = new OfficeHelper(requestSpec, responseSpec).createOffice(\"01 July 2007\");\n        String name = \"TestFullCreation\" + new Timestamp(new java.util.Date().getTime());\n        String externalId = UUID.randomUUID().toString();\n        int staffId = StaffHelper.createStaff(requestSpec, responseSpec);\n        int[] groupMembers = generateGroupMembers(1, officeId);\n        final String centerActivationDate = \"01 July 2007\";\n        Integer centerId = CenterHelper.createCenter(name, officeId, externalId, staffId, groupMembers, centerActivationDate, requestSpec,\n                responseSpec);\n        CenterDomain center = CenterHelper.retrieveByID(centerId, requestSpec, responseSpec);\n        Integer groupId = groupMembers[0];\n        Assertions.assertNotNull(center);\n        Assertions.assertTrue(center.getStaffId() == staffId);\n        Assertions.assertTrue(center.isActive() == true);\n\n        Integer calendarId = createCalendarMeeting(centerId);\n\n        Integer clientId = createClient(officeId);\n\n        associateClientsToGroup(groupId, clientId);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n        Calendar today = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        today.add(Calendar.DAY_OF_MONTH, -14);\n        \/\/ CREATE A LOAN PRODUCT\n        final String disbursalDate = dateFormat.format(today.getTime());\n        final String recalculationRestFrequencyDate = \"01 January 2012\";\n        final boolean isMultiTrancheLoan = false;\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientId), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        \/\/ CREATE LOAN MULTIDISBURSAL PRODUCT WITH INTEREST RECALCULATION\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.RBI_INDIA_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"0\", recalculationRestFrequencyDate,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, isMultiTrancheLoan, null, null);\n\n        \/\/ APPLY FOR TRANCHE LOAN WITH INTEREST RECALCULATION\n        final Integer loanId = applyForLoanApplicationForInterestRecalculation(clientId, groupId, calendarId, loanProductID, disbursalDate,\n                recalculationRestFrequencyDate, LoanApplicationTestBuilder.RBI_INDIA_STRATEGY, new ArrayList<HashMap>(0), null,\n                collaterals);\n\n        \/\/ Test for loan account is created\n        Assertions.assertNotNull(loanId);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanId);\n\n        \/\/ Test for loan account is created, can be approved\n        this.loanTransactionHelper.approveLoan(disbursalDate, loanId);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanId);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        \/\/ Test for loan account approved can be disbursed\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(disbursalDate, loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanId);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        LOG.info(\"---------------------------------CHANGING GROUP MEETING DATE ------------------------------------------\");\n        Calendar todaysdate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysdate.add(Calendar.DAY_OF_MONTH, 14);\n        String oldMeetingDate = dateFormat.format(todaysdate.getTime());\n        todaysdate.add(Calendar.DAY_OF_MONTH, 1);\n        final String centerMeetingNewStartDate = dateFormat.format(todaysdate.getTime());\n        CalendarHelper.updateMeetingCalendarForCenter(this.requestSpec, this.responseSpec, centerId, calendarId.toString(), oldMeetingDate,\n                centerMeetingNewStartDate);\n\n        ArrayList loanRepaymnetSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, generalResponseSpec, loanId);\n        \/\/ VERIFY RESCHEDULED DATE\n        ArrayList dueDateLoanSchedule = (ArrayList) ((HashMap) loanRepaymnetSchedule.get(2)).get(\"dueDate\");\n        assertEquals(getDateAsArray(todaysdate, 0), dueDateLoanSchedule);\n\n        \/\/ VERIFY THE INTEREST\n        Float interestDue = (Float) ((HashMap) loanRepaymnetSchedule.get(2)).get(\"interestDue\");\n        assertEquals(\"90.82\", String.valueOf(interestDue));\n    } END"}
{"prompt":"test Center Rescheduling Multi Tranche Loans With Interest Recalculation Enabled\n\n###\n\n","completion":"    @SuppressWarnings(\"rawtypes\")\n    @Test\n    public void testCenterReschedulingMultiTrancheLoansWithInterestRecalculationEnabled() {\n\n        Integer officeId = new OfficeHelper(requestSpec, responseSpec).createOffice(\"01 July 2007\");\n        String name = \"TestFullCreation\" + new Timestamp(new java.util.Date().getTime());\n        String externalId = UUID.randomUUID().toString();\n        int staffId = StaffHelper.createStaff(requestSpec, responseSpec);\n        int[] groupMembers = generateGroupMembers(1, officeId);\n        final String centerActivationDate = \"01 July 2007\";\n        Integer centerId = CenterHelper.createCenter(name, officeId, externalId, staffId, groupMembers, centerActivationDate, requestSpec,\n                responseSpec);\n        CenterDomain center = CenterHelper.retrieveByID(centerId, requestSpec, responseSpec);\n        Integer groupId = groupMembers[0];\n        Assertions.assertNotNull(center);\n        Assertions.assertTrue(center.getStaffId() == staffId);\n        Assertions.assertTrue(center.isActive() == true);\n\n        Integer calendarId = createCalendarMeeting(centerId);\n\n        Integer clientId = createClient(officeId);\n\n        associateClientsToGroup(groupId, clientId);\n\n        \/\/ CREATE A LOAN PRODUCT\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n        Calendar today = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        today.add(Calendar.DAY_OF_MONTH, -14);\n        \/\/ CREATE A LOAN PRODUCT\n        final String approveDate = dateFormat.format(today.getTime());\n        final String expectedDisbursementDate = dateFormat.format(today.getTime());\n        final String disbursementDate = dateFormat.format(today.getTime());\n        final String approvalAmount = \"10000\";\n        final String recalculationRestFrequencyDate = \"01 January 2012\";\n        final boolean isMultiTrancheLoan = true;\n\n        \/\/ CREATE LOAN MULTIDISBURSAL PRODUCT WITH INTEREST RECALCULATION\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.RBI_INDIA_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"0\", recalculationRestFrequencyDate,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, isMultiTrancheLoan, null, null);\n\n        Calendar secondTrancheDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        secondTrancheDate.add(Calendar.DAY_OF_MONTH, -7);\n        String secondDisbursement = dateFormat.format(secondTrancheDate.getTime());\n\n        \/\/ CREATE TRANCHES\n        List<HashMap> createTranches = new ArrayList<>();\n        createTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(disbursementDate, \"5000\"));\n        createTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(secondDisbursement, \"5000\"));\n\n        \/\/ APPROVE TRANCHES\n        List<HashMap> approveTranches = new ArrayList<>();\n        approveTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(disbursementDate, \"5000\"));\n        approveTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(secondDisbursement, \"5000\"));\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientId), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        \/\/ APPLY FOR TRANCHE LOAN WITH INTEREST RECALCULATION\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientId, groupId, calendarId, loanProductID,\n                disbursementDate, recalculationRestFrequencyDate, LoanApplicationTestBuilder.RBI_INDIA_STRATEGY, new ArrayList<HashMap>(0),\n                createTranches, collaterals);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n\n        \/\/ VALIDATE THE LOAN STATUS\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(approveDate, expectedDisbursementDate, approvalAmount,\n                loanID, approveTranches);\n\n        \/\/ VALIDATE THE LOAN IS APPROVED\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        \/\/ DISBURSE THE FIRST TRANCHE\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(disbursementDate, loanID, \"5000\");\n\n        LOG.info(\"---------------------------------CHANGING GROUP MEETING DATE ------------------------------------------\");\n        Calendar todaysdate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysdate.add(Calendar.DAY_OF_MONTH, 14);\n        String oldMeetingDate = dateFormat.format(todaysdate.getTime());\n        todaysdate.add(Calendar.DAY_OF_MONTH, 1);\n        final String centerMeetingNewStartDate = dateFormat.format(todaysdate.getTime());\n        CalendarHelper.updateMeetingCalendarForCenter(this.requestSpec, this.responseSpec, centerId, calendarId.toString(), oldMeetingDate,\n                centerMeetingNewStartDate);\n\n        ArrayList loanRepaymnetSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, generalResponseSpec, loanID);\n        \/\/ VERIFY RESCHEDULED DATE\n        ArrayList dueDateLoanSchedule = (ArrayList) ((HashMap) loanRepaymnetSchedule.get(2)).get(\"dueDate\");\n        assertEquals(getDateAsArray(todaysdate, 0), dueDateLoanSchedule);\n\n        \/\/ VERIFY THE INTEREST\n        Float interestDue = (Float) ((HashMap) loanRepaymnetSchedule.get(2)).get(\"interestDue\");\n        assertEquals(\"41.05\", String.valueOf(interestDue));\n\n        \/\/ DISBURSE THE SECOND TRANCHE (for let the loan test lifecycle callback to close the loan\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(secondDisbursement, loanID, \"5000\");\n    } END"}
{"prompt":"apply Loan Transaction Chargeback\n\n###\n\n","completion":"    @Test\n    public void applyLoanTransactionChargeback() {\n        \/\/ Client and Loan account creation\n        final Integer loanId = createAccounts(15, 1, true);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        Float amount = Float.valueOf(amountVal);\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        final Long transactionId = loanIdTransactionsResponse.getResourceId();\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n\n        reviewLoanTransactionRelations(loanId, transactionId, 0, Double.valueOf(\"0.00\"));\n\n        final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"1000.00\", 0,\n                responseSpec);\n\n        reviewLoanTransactionRelations(loanId, transactionId, 1, Double.valueOf(\"0.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionId, 0, Double.valueOf(\"1000.00\"));\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n\n        loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, amount.doubleValue());\n\n        GetJournalEntriesTransactionIdResponse journalEntries = journalEntryHelper\n                .getJournalEntries(\"L\" + chargebackTransactionId.toString());\n        assertEquals(2L, journalEntries.getTotalFilteredRecords());\n        assertEquals(1000.0, journalEntries.getPageItems().get(0).getAmount());\n        assertEquals(\"CREDIT\", journalEntries.getPageItems().get(0).getEntryType().getValue());\n\n        assertEquals(1000.0, journalEntries.getPageItems().get(1).getAmount());\n        assertEquals(\"DEBIT\", journalEntries.getPageItems().get(1).getEntryType().getValue());\n\n        \/\/ Try to reverse a Loan Transaction charge back\n        PostLoansLoanIdTransactionsResponse reverseTransactionResponse = loanTransactionHelper.reverseLoanTransaction(loanId,\n                chargebackTransactionId, operationDate, responseSpecErr403);\n\n        \/\/ Try to reverse a Loan Transaction repayment with linked transactions\n        reverseTransactionResponse = loanTransactionHelper.reverseLoanTransaction(loanId, transactionId, operationDate, responseSpecErr503);\n    } END"}
{"prompt":"apply And Adjust Loan Transaction Chargeback\n\n###\n\n","completion":"    @Test\n    public void applyAndAdjustLoanTransactionChargeback() {\n        \/\/ Client and Loan account creation\n        final Integer loanId = createAccounts(15, 1, false);\n\n        Float amount = Float.valueOf(amountVal);\n        PostLoansLoanIdTransactionsResponse loanTransactionResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanTransactionResponse);\n        final Long transactionId = loanTransactionResponse.getResourceId();\n\n        final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"1000.00\", 0,\n                responseSpec);\n\n        \/\/ Then\n        loanTransactionHelper.adjustLoanTransaction(loanId, chargebackTransactionId, operationDate, responseSpecErr403);\n    } END"}
{"prompt":"apply Loan Transaction Chargeback With Amount Zero\n\n###\n\n","completion":"    @Test\n    public void applyLoanTransactionChargebackWithAmountZero() {\n        \/\/ Client and Loan account creation\n        final Integer loanId = createAccounts(15, 1, false);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        Float amount = Float.valueOf(amountVal);\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        final Long transactionId = loanIdTransactionsResponse.getResourceId();\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n\n        loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"0.00\", 0, responseSpecErr400);\n    } END"}
{"prompt":"apply Loan Transaction Chargeback In Long Term Loan\n\n###\n\n","completion":"    @Disabled(\"Failing test.Need rework\")\n    @Test\n    public void applyLoanTransactionChargebackInLongTermLoan() {\n        \/\/ Client and Loan account creation\n        final Integer daysToSubtract = 1;\n        final Integer numberOfRepayments = 3;\n        final Integer loanId = createAccounts(daysToSubtract, numberOfRepayments, false);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        final String baseAmount = \"333.33\";\n        Float amount = Float.valueOf(baseAmount);\n        final LocalDate transactionDate = this.todaysDate.minusMonths(numberOfRepayments - 1).plusDays(3);\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        final Long transactionId = loanIdTransactionsResponse.getResourceId();\n        reviewLoanTransactionRelations(loanId, transactionId, 0, Double.valueOf(\"666.67\"));\n\n        final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, amount.toString(), 0,\n                responseSpec);\n        reviewLoanTransactionRelations(loanId, transactionId, 1, Double.valueOf(\"666.67\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionId, 0, Double.valueOf(\"1000.00\"));\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(amountVal));\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n        GetLoansLoanIdRepaymentSchedule getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n        for (GetLoansLoanIdRepaymentPeriod period : getLoanRepaymentSchedule.getPeriods()) {\n            if (period.getPeriod() != null && period.getPeriod() == 3) {\n                log.info(\"Period number {} for due date {} and totalDueForPeriod {}\", period.getPeriod(), period.getDueDate(),\n                        period.getTotalDueForPeriod());\n                assertEquals(Double.valueOf(\"666.67\"), period.getTotalDueForPeriod());\n            }\n        }\n\n        loanTransactionHelper.evaluateLoanSummaryAdjustments(getLoansLoanIdResponse, Double.valueOf(baseAmount));\n        DelinquencyBucketsHelper.evaluateLoanCollectionData(getLoansLoanIdResponse, 0, Double.valueOf(\"0.00\"));\n    } END"}
{"prompt":"apply Loan Transaction Chargeback Over No Repayment Type\n\n###\n\n","completion":"    @Test\n    public void applyLoanTransactionChargebackOverNoRepaymentType() {\n        \/\/ Client and Loan account creation\n        final Integer loanId = createAccounts(15, 1, false);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        List<GetLoansLoanIdTransactions> loanTransactions = getLoansLoanIdResponse.getTransactions();\n        assertNotNull(loanTransactions);\n        log.info(\"Loan Id {} with {} transactions\", loanId, loanTransactions.size());\n        assertEquals(2, loanTransactions.size());\n        GetLoansLoanIdTransactions loanTransaction = loanTransactions.iterator().next();\n        log.info(\"Try to apply the Charge back over transaction Id {} with type {}\", loanTransaction.getId(),\n                loanTransaction.getType().getCode());\n\n        loanTransactionHelper.applyChargebackTransaction(loanId, loanTransaction.getId(), amountVal, 0, responseSpecErr503);\n    } END"}
{"prompt":"apply Loan Transaction Chargeback After Mature\n\n###\n\n","completion":"    @Test\n    public void applyLoanTransactionChargebackAfterMature() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, todaysDate);\n            log.info(\"Current Business date {}\", todaysDate);\n\n            \/\/ Client and Loan account creation\n            final Integer loanId = createAccounts(45, 1, false);\n\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            GetDelinquencyRangesResponse delinquencyRange = getLoansLoanIdResponse.getDelinquencyRange();\n            assertNotNull(delinquencyRange);\n            log.info(\"Loan Delinquency Range is {}\", delinquencyRange.getClassification());\n\n            GetLoansLoanIdRepaymentSchedule getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n            log.info(\"Loan with {} periods\", getLoanRepaymentSchedule.getPeriods().size());\n            assertEquals(2, getLoanRepaymentSchedule.getPeriods().size());\n\n            Float amount = Float.valueOf(amountVal);\n            PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                    loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            final Long transactionId = loanIdTransactionsResponse.getResourceId();\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n\n            reviewLoanTransactionRelations(loanId, transactionId, 0, Double.valueOf(\"0.00\"));\n\n            Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"500.00\", 0,\n                    responseSpec);\n\n            reviewLoanTransactionRelations(loanId, transactionId, 1, Double.valueOf(\"0.00\"));\n            reviewLoanTransactionRelations(loanId, chargebackTransactionId, 0, Double.valueOf(\"500.00\"));\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n\n            loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"500.00\"));\n\n            \/\/ N+1 Scenario\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n            getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n            log.info(\"Loan with {} periods\", getLoanRepaymentSchedule.getPeriods().size());\n            assertEquals(3, getLoanRepaymentSchedule.getPeriods().size());\n            getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n            for (GetLoansLoanIdRepaymentPeriod period : getLoanRepaymentSchedule.getPeriods()) {\n                if (period.getPeriod() != null && period.getPeriod() == 2) {\n                    log.info(\"Period number {} for due date {} and totalDueForPeriod {}\", period.getPeriod(), period.getDueDate(),\n                            period.getTotalDueForPeriod());\n                    assertEquals(Double.valueOf(\"500.00\"), period.getPrincipalDue());\n                }\n            }\n\n            chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"300.00\", 0, responseSpec);\n\n            reviewLoanTransactionRelations(loanId, transactionId, 2, Double.valueOf(\"0.00\"));\n            reviewLoanTransactionRelations(loanId, chargebackTransactionId, 0, Double.valueOf(\"800.00\"));\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n\n            delinquencyRange = getLoansLoanIdResponse.getDelinquencyRange();\n            assertNull(delinquencyRange);\n            log.info(\"Loan Delinquency Range is null {}\", (delinquencyRange == null));\n\n            loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"800.00\"));\n\n            \/\/ N+1 Scenario -- Remains the same periods number\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n            getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n            log.info(\"Loan with {} periods\", getLoanRepaymentSchedule.getPeriods().size());\n            assertEquals(3, getLoanRepaymentSchedule.getPeriods().size());\n            getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n            for (GetLoansLoanIdRepaymentPeriod period : getLoanRepaymentSchedule.getPeriods()) {\n                if (period.getPeriod() != null && period.getPeriod() == 2) {\n                    log.info(\"Period number {} for due date {} and totalDueForPeriod {}\", period.getPeriod(), period.getDueDate(),\n                            period.getTotalDueForPeriod());\n                    assertEquals(Double.valueOf(\"800.00\"), period.getPrincipalDue());\n                }\n            }\n\n            \/\/ Move the Business date few days to get Collection data\n            LocalDate businessDate = todaysDate.plusDays(4);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n            log.info(\"Current Business date {}\", businessDate);\n\n            \/\/ Get loan details expecting to have a delinquency classification\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            DelinquencyBucketsHelper.evaluateLoanCollectionData(getLoansLoanIdResponse, 4, Double.valueOf(\"800.00\"));\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"apply Loan Transaction Chargeback With Loan Overpaid To Loan Active\n\n###\n\n","completion":"    @Test\n    public void applyLoanTransactionChargebackWithLoanOverpaidToLoanActive() {\n        \/\/ Client and Loan account creation\n        final Integer loanId = createAccounts(15, 1, true);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        Float amount = Float.valueOf(\"1100.00\");\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        final Long transactionId = loanIdTransactionsResponse.getResourceId();\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.overpaid\");\n\n        reviewLoanTransactionRelations(loanId, transactionId, 0, Double.valueOf(\"0.00\"));\n\n        final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"200.00\", 0,\n                responseSpec);\n\n        reviewLoanTransactionRelations(loanId, transactionId, 1, Double.valueOf(\"0.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionId, 0, Double.valueOf(\"100.00\"));\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n\n        loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"100.00\"));\n        GetJournalEntriesTransactionIdResponse journalEntries = journalEntryHelper\n                .getJournalEntries(\"L\" + chargebackTransactionId.toString());\n        assertEquals(3L, journalEntries.getTotalFilteredRecords());\n        assertEquals(100.0, journalEntries.getPageItems().get(0).getAmount());\n        assertEquals(\"DEBIT\", journalEntries.getPageItems().get(0).getEntryType().getValue());\n\n        assertEquals(200.0, journalEntries.getPageItems().get(1).getAmount());\n        assertEquals(\"CREDIT\", journalEntries.getPageItems().get(1).getEntryType().getValue());\n\n        assertEquals(100.0, journalEntries.getPageItems().get(2).getAmount());\n        assertEquals(\"DEBIT\", journalEntries.getPageItems().get(2).getEntryType().getValue());\n\n        final GetDelinquencyRangesResponse delinquencyRange = getLoansLoanIdResponse.getDelinquencyRange();\n        assertNull(delinquencyRange);\n        log.info(\"Loan Delinquency Range is null {}\", (delinquencyRange == null));\n    } END"}
{"prompt":"apply Loan Transaction Chargeback With Loan Overpaid To Loan Close\n\n###\n\n","completion":"    @Test\n    public void applyLoanTransactionChargebackWithLoanOverpaidToLoanClose() {\n        \/\/ Client and Loan account creation\n        final Integer loanId = createAccounts(15, 1, false);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        Float amount = Float.valueOf(\"1100.00\");\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        final Long transactionId = loanIdTransactionsResponse.getResourceId();\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.overpaid\");\n\n        reviewLoanTransactionRelations(loanId, transactionId, 0, Double.valueOf(\"0.00\"));\n\n        final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"100.00\", 0,\n                responseSpec);\n\n        reviewLoanTransactionRelations(loanId, transactionId, 1, Double.valueOf(\"0.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionId, 0, Double.valueOf(\"0.00\"));\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n\n        loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"0.00\"));\n    } END"}
{"prompt":"apply Loan Transaction Chargeback With Loan Overpaid To Keep As Loan Overpaid\n\n###\n\n","completion":"    @Test\n    public void applyLoanTransactionChargebackWithLoanOverpaidToKeepAsLoanOverpaid() {\n        \/\/ Client and Loan account creation\n        final Integer loanId = createAccounts(15, 1, true);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        Float amount = Float.valueOf(\"1100.00\");\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        final Long transactionId = loanIdTransactionsResponse.getResourceId();\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.overpaid\");\n\n        reviewLoanTransactionRelations(loanId, transactionId, 0, Double.valueOf(\"0.00\"));\n\n        GetDelinquencyRangesResponse delinquencyRange = getLoansLoanIdResponse.getDelinquencyRange();\n        assertNull(delinquencyRange);\n        log.info(\"Loan Delinquency Range is null {}\", (delinquencyRange == null));\n        final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"50.00\", 0,\n                responseSpec);\n        reviewLoanTransactionRelations(loanId, transactionId, 1, Double.valueOf(\"0.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionId, 0, Double.valueOf(\"0.00\"));\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.overpaid\");\n\n        delinquencyRange = getLoansLoanIdResponse.getDelinquencyRange();\n        assertNull(delinquencyRange);\n        log.info(\"Loan Delinquency Range is null {}\", (delinquencyRange == null));\n\n        loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"0.00\"));\n\n        GetJournalEntriesTransactionIdResponse journalEntries = journalEntryHelper\n                .getJournalEntries(\"L\" + chargebackTransactionId.toString());\n        assertEquals(2L, journalEntries.getTotalFilteredRecords());\n        assertEquals(50.0, journalEntries.getPageItems().get(0).getAmount());\n        assertEquals(\"CREDIT\", journalEntries.getPageItems().get(0).getEntryType().getValue());\n\n        assertEquals(50.0, journalEntries.getPageItems().get(1).getAmount());\n        assertEquals(\"DEBIT\", journalEntries.getPageItems().get(1).getEntryType().getValue());\n    } END"}
{"prompt":"apply Multiple Loan Transaction Chargeback\n\n###\n\n","completion":"    @Test\n    public void applyMultipleLoanTransactionChargeback() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, todaysDate);\n            log.info(\"Current Business date {}\", todaysDate);\n\n            \/\/ Client and Loan account creation\n            final Integer loanId = createAccounts(15, 1, false);\n\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            Float amount = Float.valueOf(amountVal);\n            PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                    loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            final Long transactionId = loanIdTransactionsResponse.getResourceId();\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n\n            \/\/ First round, empty array\n            reviewLoanTransactionRelations(loanId, transactionId, 0, Double.valueOf(\"0.00\"));\n\n            loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"200.00\", 0, responseSpec);\n\n            Double expectedAmount = Double.valueOf(\"200.00\");\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, expectedAmount);\n\n            loanTransactionHelper.evaluateLoanSummaryAdjustments(getLoansLoanIdResponse, expectedAmount);\n            loanTransactionHelper.printDelinquencyData(getLoansLoanIdResponse);\n            DelinquencyBucketsHelper.evaluateLoanCollectionData(getLoansLoanIdResponse, 0, Double.valueOf(\"0.00\"));\n\n            \/\/ Second round, array size equal to 1\n            reviewLoanTransactionRelations(loanId, transactionId, 1, Double.valueOf(\"0.00\"));\n\n            loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"300.00\", 1, responseSpec);\n\n            expectedAmount = Double.valueOf(\"500.00\");\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, expectedAmount);\n\n            loanTransactionHelper.evaluateLoanSummaryAdjustments(getLoansLoanIdResponse, expectedAmount);\n            DelinquencyBucketsHelper.evaluateLoanCollectionData(getLoansLoanIdResponse, 0, Double.valueOf(\"0.00\"));\n\n            \/\/ Third round, array size equal to 2\n            reviewLoanTransactionRelations(loanId, transactionId, 2, Double.valueOf(\"0.00\"));\n\n            loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"500.00\", 0, responseSpec);\n\n            expectedAmount = Double.valueOf(\"1000.00\");\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, expectedAmount);\n\n            loanTransactionHelper.evaluateLoanSummaryAdjustments(getLoansLoanIdResponse, expectedAmount);\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            DelinquencyBucketsHelper.evaluateLoanCollectionData(getLoansLoanIdResponse, 0, Double.valueOf(\"0.00\"));\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"loan Transaction Chargeback Of Full Amount For Overpaid Loan Test\n\n###\n\n","completion":"    @Test\n    public void loanTransactionChargebackOfFullAmountForOverpaidLoanTest() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        \/\/ Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        \/\/ make Repayments\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 September 2022\").locale(\"en\")\n                        .transactionAmount(450.0));\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_2 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"6 September 2022\").locale(\"en\")\n                        .transactionAmount(450.0));\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_3 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"7 September 2022\").locale(\"en\")\n                        .transactionAmount(300.0));\n\n        GetLoansLoanIdResponse loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n\n        \/\/ verify loan is overpaid\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getOverpaid());\n        assertEquals(loanDetails.getTotalOverpaid(), 200.0);\n\n        \/\/ verify loan outstanding\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 0.0);\n\n        \/\/ verify last transaction amount distribution\n        GetLoansLoanIdTransactionsTransactionIdResponse loanTransaction = loanTransactionHelper.getLoanTransaction(loanId,\n                repaymentTransaction_3.getResourceId().intValue());\n\n        assertNotNull(loanTransaction);\n        assertEquals(loanTransaction.getAmount(), 300.0);\n        assertEquals(loanTransaction.getPrincipalPortion(), 100.0);\n\n        \/\/ chargeback for full amount on last repayment for which the amount is 300 and principal is 100 due to\n        \/\/ overpayment adjustment\n        \/\/ This verifies that validation for chargeback amount is with total amount of transaction and not principal\n        \/\/ portion.\n        PostLoansLoanIdTransactionsResponse chargebackTransactionResponse = loanTransactionHelper.chargebackLoanTransaction(\n                loanExternalIdStr, repaymentTransaction_3.getResourceId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().locale(\"en\").transactionAmount(300.0).paymentTypeId(1L));\n\n        assertNotNull(chargebackTransactionResponse);\n        GetLoansLoanIdResponse loanDetailsAfterChargeback = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetailsAfterChargeback);\n        assertTrue(loanDetailsAfterChargeback.getStatus().getActive());\n\n        \/\/ verify loan outstanding\n        assertNotNull(loanDetailsAfterChargeback.getSummary());\n        assertEquals(loanDetailsAfterChargeback.getSummary().getTotalOutstanding(), 100.0);\n\n        \/\/ verify chargeback transaction amount distribution\n        GetLoansLoanIdTransactionsTransactionIdResponse chargebackTransaction = loanTransactionHelper.getLoanTransaction(loanId,\n                chargebackTransactionResponse.getResourceId().intValue());\n\n        assertNotNull(chargebackTransaction);\n        assertEquals(chargebackTransaction.getAmount(), 300.0);\n        assertEquals(chargebackTransaction.getPrincipalPortion(), 100.0);\n\n    } END"}
{"prompt":"loan Transaction Reverse Replay Relation Test\n\n###\n\n","completion":"    @Test\n    public void loanTransactionReverseReplayRelationTest() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        \/\/ Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        \/\/ Add Charge\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 7);\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        \/\/ make repayment\n\n        \/\/ Set Loan transaction externalId for transaction getting reversed and replayed\n        String loanTransactionExternalIdStr = UUID.randomUUID().toString();\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"15 September 2022\").locale(\"en\")\n                        .transactionAmount(11.0).externalId(loanTransactionExternalIdStr));\n\n        \/\/ make backdated repayment for reverse replay\n        final PostLoansLoanIdTransactionsResponse backDatedRepaymentTransaction = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"10 September 2022\").locale(\"en\")\n                        .transactionAmount(5.0));\n\n        \/\/ get transaction relationship for new transaction using externalId of reversed loan transaction\n\n        Long reversedAndReplayedTransactionId = repaymentTransaction.getResourceId();\n        Long backDatedRepaymentTransactionId = backDatedRepaymentTransaction.getResourceId();\n\n        GetLoansLoanIdTransactionsTransactionIdResponse getLoansTransactionResponse = loanTransactionHelper\n                .getLoanTransactionDetails((long) loanId, loanTransactionExternalIdStr);\n        assertNotNull(getLoansTransactionResponse);\n        assertNotNull(getLoansTransactionResponse.getTransactionRelations());\n\n        \/\/ test replayed relationship\n        GetLoanTransactionRelation transactionRelation = getLoansTransactionResponse.getTransactionRelations().iterator().next();\n        assertEquals(reversedAndReplayedTransactionId, transactionRelation.getToLoanTransaction());\n        assertEquals(\"REPLAYED\", transactionRelation.getRelationType());\n    } END"}
{"prompt":"loan Transaction Summary Test\n\n###\n\n","completion":"    @Test\n    public void loanTransactionSummaryTest() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        \/\/ Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        \/\/ make Repayments\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_2 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"6 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_3 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"7 September 2022\").locale(\"en\")\n                        .transactionAmount(50.0));\n\n        \/\/ reverse Repayment\n        loanTransactionHelper.reverseRepayment(loanId, repaymentTransaction_3.getResourceId().intValue(), \"7 September 2022\");\n\n        \/\/ Merchant Refund\n        final PostLoansLoanIdTransactionsResponse merchantIssuedRefund_1 = loanTransactionHelper.makeMerchantIssuedRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"8 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        final PostLoansLoanIdTransactionsResponse merchantIssuedRefund_2 = loanTransactionHelper.makeMerchantIssuedRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"8 September 2022\").locale(\"en\")\n                        .transactionAmount(50.0));\n\n        \/\/ reverse Merchant Refund\n        loanTransactionHelper.reverseRepayment(loanId, merchantIssuedRefund_2.getResourceId().intValue(), \"8 September 2022\");\n\n        \/\/ Payout Refund\n        final PostLoansLoanIdTransactionsResponse payoutRefund_1 = loanTransactionHelper.makePayoutRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"9 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        final PostLoansLoanIdTransactionsResponse payoutRefund_2 = loanTransactionHelper.makePayoutRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"9 September 2022\").locale(\"en\")\n                        .transactionAmount(50.0));\n\n        \/\/ reverse Payout Refund\n        loanTransactionHelper.reverseRepayment(loanId, payoutRefund_2.getResourceId().intValue(), \"9 September 2022\");\n\n        \/\/ Goodwill Credit\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"10 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_2 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"10 September 2022\").locale(\"en\")\n                        .transactionAmount(50.0));\n\n        \/\/ reverse Goodwill Credit\n        loanTransactionHelper.reverseRepayment(loanId, goodwillCredit_2.getResourceId().intValue(), \"10 September 2022\");\n\n        \/\/ Chargeback\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_4 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"11 September 2022\").locale(\"en\")\n                        .transactionAmount(150.0));\n\n        loanTransactionHelper.chargebackLoanTransaction(loanExternalIdStr, repaymentTransaction_4.getResourceId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().locale(\"en\").transactionAmount(50.0).paymentTypeId(1L));\n\n        \/\/ Charge Adjustment\n\n        \/\/ Add Charge\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 10);\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        PostLoansLoanIdChargesChargeIdResponse chargeAdjustmentResult = loanTransactionHelper.chargeAdjustment((long) loanId,\n                (long) penalty1LoanChargeId, new PostLoansLoanIdChargesChargeIdRequest().amount(10.0).locale(\"en\"));\n\n        \/\/ Retrieve Loan with loanId\n\n        GetLoansLoanIdResponse loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n\n        \/\/ verify transaction summary fields\n\n        GetLoansLoanIdSummary loanSummary = loanDetails.getSummary();\n\n        assertNotNull(loanSummary);\n\n        \/\/ repayment\n        assertEquals(loanSummary.getTotalRepaymentTransaction(), 350.00);\n        \/\/ repayment reversed\n        assertEquals(loanSummary.getTotalRepaymentTransactionReversed(), 50.00);\n        \/\/ merchant refund\n        assertEquals(loanSummary.getTotalMerchantRefund(), 100.00);\n        \/\/ merchant refund reversed\n        assertEquals(loanSummary.getTotalMerchantRefundReversed(), 50.00);\n        \/\/ payout refund\n        assertEquals(loanSummary.getTotalPayoutRefund(), 100.00);\n        \/\/ payout refund reversed\n        assertEquals(loanSummary.getTotalPayoutRefundReversed(), 50.00);\n        \/\/ goodwill credit\n        assertEquals(loanSummary.getTotalGoodwillCredit(), 100.00);\n        \/\/ goodwill credit reversed\n        assertEquals(loanSummary.getTotalGoodwillCreditReversed(), 50.00);\n        \/\/ charge adjustment\n        assertEquals(loanSummary.getTotalChargeAdjustment(), 10.00);\n        \/\/ charge\n        assertEquals(loanSummary.getTotalChargeback(), 50.00);\n    } END"}
{"prompt":"last Repayment Amount Test\n\n###\n\n","completion":"    @Test\n    public void lastRepaymentAmountTest() {\n        \/\/ Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        \/\/ Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        \/\/ Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        \/\/ Merchant Refund\n        final PostLoansLoanIdTransactionsResponse merchantIssuedRefund = loanTransactionHelper.makeMerchantIssuedRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"8 September 2022\").locale(\"en\")\n                        .transactionAmount(20.0));\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"7 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_2 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"6 September 2022\").locale(\"en\")\n                        .transactionAmount(50.0));\n\n        \/\/ Retrieve Loan with loanId\n        GetLoansLoanIdResponse loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n\n        assertEquals(20.0, loanDetails.getDelinquent().getLastPaymentAmount());\n        assertEquals(LocalDate.of(2022, 9, 8), loanDetails.getDelinquent().getLastPaymentDate());\n\n        assertEquals(100.0, loanDetails.getDelinquent().getLastRepaymentAmount());\n        assertEquals(LocalDate.of(2022, 9, 7), loanDetails.getDelinquent().getLastRepaymentDate());\n    } END"}
{"prompt":"loan Withdrawn By Applicant\n\n###\n\n","completion":"    @Test\n    public void loanWithdrawnByApplicant() {\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        this.loanTransactionHelper.withdrawLoanApplicationByClient(\"03 April 2012\", loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsNotActive(loanStatusHashMap);\n\n    } END"}
{"prompt":"check Client Loan WRITTEN OFF\n\n###\n\n","completion":"    @Test\n    public void checkClientLoan_WRITTEN_OFF() {\n        \/\/ CREATE CLIENT\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, DATE_OF_JOINING);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        \/\/ CREATE LOAN PRODUCT\n        final Integer loanProductID = createLoanProduct();\n        \/\/ APPLY FOR LOAN\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"28 September 2010\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        \/\/ DISBURSE\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        \/\/ MAKE REPAYMENTS\n        final float repayment_with_interest = 680.0f;\n\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(1, 4000.0F, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 January 2011\", repayment_with_interest, loanID);\n\n        HashMap toLoanSummaryAfter = this.loanTransactionHelper.getLoanSummary(requestSpec, responseSpec, loanID);\n        Assertions.assertTrue(Float.valueOf(\"500.0\").compareTo(Float.valueOf(String.valueOf(toLoanSummaryAfter.get(\"principalPaid\")))) == 0,\n                \"Checking for Principal paid \");\n        Assertions.assertTrue(Float.valueOf(\"180.0\").compareTo(Float.valueOf(String.valueOf(toLoanSummaryAfter.get(\"interestPaid\")))) == 0,\n                \"Checking for interestPaid paid \");\n        Assertions.assertTrue(\n                Float.valueOf(\"680.0\").compareTo(Float.valueOf(String.valueOf(toLoanSummaryAfter.get(\"totalRepayment\")))) == 0,\n                \"Checking for total paid \");\n\n        \/\/ WRITE OFF LOAN AND CHECK ACCOUNT IS CLOSED\n        LoanStatusChecker.verifyLoanAccountIsClosed(this.loanTransactionHelper.writeOffLoan(\"01 January 2011\", loanID));\n        toLoanSummaryAfter = this.loanTransactionHelper.getLoanSummary(requestSpec, responseSpec, loanID);\n        Assertions.assertTrue(\n                Float.valueOf(\"4000.0\").compareTo(Float.valueOf(String.valueOf(toLoanSummaryAfter.get(\"principalWrittenOff\")))) == 0,\n                \"Checking for Principal written off \");\n        Assertions.assertTrue(\n                Float.valueOf(\"1440.0\").compareTo(Float.valueOf(String.valueOf(toLoanSummaryAfter.get(\"interestWrittenOff\")))) == 0,\n                \"Checking for interestPaid written off \");\n        Assertions.assertTrue(\n                Float.valueOf(\"5440.0\").compareTo(Float.valueOf(String.valueOf(toLoanSummaryAfter.get(\"totalWrittenOff\")))) == 0,\n                \"Checking for total written off \");\n\n    } END"}
{"prompt":"test Makercheker Inbox List\n\n###\n\n","completion":"    @Test\n    public void testMakerchekerInboxList() {\n        \/\/ given\n        \/\/ when\n        final ArrayList<GetMakerCheckerResponse> makerCheckerList = this.makercheckersHelper.getMakerCheckerList();\n\n        assertNotNull(makerCheckerList);\n    } END"}
{"prompt":"create Loan Entity WITH DAY BETWEEN DISB DATE AND REPAY START DATE GREATER THAN MIN DAY CRITERIA\n\n###\n\n","completion":"    @Test\n    public void createLoanEntity_WITH_DAY_BETWEEN_DISB_DATE_AND_REPAY_START_DATE_GREATER_THAN_MIN_DAY_CRITERIA() {\n\n        this.requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n        this.requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n        this.responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        \/\/ create all required entities\n        this.createRequiredEntities();\n\n        final String disbursalDate = \"04 September 2014\";\n        final String firstRepaymentDate = \"11 September 2014\";\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                this.clientId.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final String loanApplicationJSON = new LoanApplicationTestBuilder().withPrincipal(loanPrincipalAmount)\n                .withLoanTermFrequency(numberOfRepayments).withLoanTermFrequencyAsWeeks().withNumberOfRepayments(numberOfRepayments)\n                .withRepaymentEveryAfter(\"1\").withRepaymentFrequencyTypeAsMonths().withAmortizationTypeAsEqualInstallments()\n                .withInterestCalculationPeriodTypeAsDays().withInterestRatePerPeriod(interestRatePerPeriod)\n                .withRepaymentFrequencyTypeAsWeeks().withSubmittedOnDate(disbursalDate).withExpectedDisbursementDate(disbursalDate)\n                .withPrincipalGrace(\"2\").withInterestGrace(\"2\").withFirstRepaymentDate(firstRepaymentDate).withCollaterals(collaterals)\n                .build(this.clientId.toString(), this.loanProductId.toString(), null);\n\n        this.loanId = this.loanTransactionHelper.getLoanId(loanApplicationJSON);\n\n        \/\/ Test for loan account is created\n        Assertions.assertNotNull(this.loanId);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        \/\/ Test for loan account is created, can be approved\n        this.loanTransactionHelper.approveLoan(disbursalDate, this.loanId);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        \/\/ Test for loan account approved can be disbursed\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, this.loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(disbursalDate, this.loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n    } END"}
{"prompt":"create Loan Entity WITH DAY BETWEEN DISB DATE AND REPAY START DATE LESS THAN MIN DAY CRITERIA\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void createLoanEntity_WITH_DAY_BETWEEN_DISB_DATE_AND_REPAY_START_DATE_LESS_THAN_MIN_DAY_CRITERIA() {\n\n        this.requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n        this.requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n        this.responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n        this.responseSpecForStatusCode403 = new ResponseSpecBuilder().expectStatusCode(403).build();\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        \/\/ create all required entities\n        this.createRequiredEntities();\n\n        \/\/ loanTransactionHelper is reassigned to accept 403 status code from\n        \/\/ server\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpecForStatusCode403);\n\n        final String disbursalDate = \"04 September 2014\";\n        final String firstRepaymentDate = \"05 September 2014\";\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                this.clientId.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final String loanApplicationJSON = new LoanApplicationTestBuilder().withPrincipal(loanPrincipalAmount)\n                .withLoanTermFrequency(numberOfRepayments).withLoanTermFrequencyAsWeeks().withNumberOfRepayments(numberOfRepayments)\n                .withRepaymentEveryAfter(\"1\").withRepaymentFrequencyTypeAsMonths().withAmortizationTypeAsEqualInstallments()\n                .withInterestCalculationPeriodTypeAsDays().withInterestRatePerPeriod(interestRatePerPeriod)\n                .withRepaymentFrequencyTypeAsWeeks().withSubmittedOnDate(disbursalDate).withExpectedDisbursementDate(disbursalDate)\n                .withPrincipalGrace(\"2\").withInterestGrace(\"2\").withFirstRepaymentDate(firstRepaymentDate).withCollaterals(collaterals)\n                .build(this.clientId.toString(), this.loanProductId.toString(), null);\n\n        List<HashMap> error = (List<HashMap>) this.loanTransactionHelper.createLoanAccount(loanApplicationJSON,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.loan.days.between.first.repayment.and.disbursal.are.less.than.minimum.allowed\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    } END"}
{"prompt":"test Create Client Note\n\n###\n\n","completion":"    @Test\n    public void testCreateClientNote() {\n        String noteText = \"this is a test note\";\n\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createClientNote(requestSpec, responseSpec, clientId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getClientNote(requestSpec, responseSpec, clientId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n    } END"}
{"prompt":"test Update Client Note\n\n###\n\n","completion":"    @Test\n    public void testUpdateClientNote() {\n        String noteText = \"this is a test note\";\n\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createClientNote(requestSpec, responseSpec, clientId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getClientNote(requestSpec, responseSpec, clientId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        String updatedNoteText = \"this is an updated test note\";\n\n        String updateRequest = \"{\\\"note\\\": \\\"\" + updatedNoteText + \"\\\"}\";\n        NotesHelper.updateClientNote(requestSpec, responseSpec, clientId, noteId, updateRequest);\n\n        receivedNoteText = NotesHelper.getClientNote(requestSpec, responseSpec, clientId, noteId);\n        Assertions.assertEquals(updatedNoteText, receivedNoteText);\n    } END"}
{"prompt":"test Delete Client Note\n\n###\n\n","completion":"    @Test\n    public void testDeleteClientNote() {\n        String noteText = \"this is a test note\";\n\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createClientNote(requestSpec, responseSpec, clientId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getClientNote(requestSpec, responseSpec, clientId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        NotesHelper.deleteClientNote(requestSpec, responseSpec, clientId, noteId);\n\n        NotesHelper.getClientNote(requestSpec, responseSpec404, clientId, noteId);\n    } END"}
{"prompt":"test Create Group Note\n\n###\n\n","completion":"    @Test\n    public void testCreateGroupNote() {\n        String noteText = \"this is a test group note\";\n\n        Integer groupId = GroupHelper.createGroup(requestSpec, responseSpec);\n        Assertions.assertNotNull(groupId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createGroupNote(requestSpec, responseSpec, groupId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getGroupNote(requestSpec, responseSpec, groupId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n    } END"}
{"prompt":"test Update Group Note\n\n###\n\n","completion":"    @Test\n    public void testUpdateGroupNote() {\n        String noteText = \"this is a test group note\";\n\n        Integer groupId = GroupHelper.createGroup(requestSpec, responseSpec);\n        Assertions.assertNotNull(groupId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createGroupNote(requestSpec, responseSpec, groupId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getGroupNote(requestSpec, responseSpec, groupId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        String updatedNoteText = \"this is an updated test group note\";\n\n        String updateRequest = \"{\\\"note\\\": \\\"\" + updatedNoteText + \"\\\"}\";\n        NotesHelper.updateGroupNote(requestSpec, responseSpec, groupId, noteId, updateRequest);\n\n        receivedNoteText = NotesHelper.getGroupNote(requestSpec, responseSpec, groupId, noteId);\n        Assertions.assertEquals(updatedNoteText, receivedNoteText);\n    } END"}
{"prompt":"test Delete Group Note\n\n###\n\n","completion":"    @Test\n    public void testDeleteGroupNote() {\n        String noteText = \"this is a test group note\";\n\n        Integer groupId = GroupHelper.createGroup(requestSpec, responseSpec);\n        Assertions.assertNotNull(groupId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createGroupNote(requestSpec, responseSpec, groupId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getGroupNote(requestSpec, responseSpec, groupId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        NotesHelper.deleteGroupNote(requestSpec, responseSpec, groupId, noteId);\n\n        NotesHelper.getGroupNote(requestSpec, responseSpec404, groupId, noteId);\n    } END"}
{"prompt":"test Create Loan Note\n\n###\n\n","completion":"    @Test\n    public void testCreateLoanNote() {\n        String noteText = \"this is a test loan note\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanId = applyForLoanApplication(clientID, loanProductID);\n        Assertions.assertNotNull(loanId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createLoanNote(requestSpec, responseSpec, loanId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getLoanNote(requestSpec, responseSpec, loanId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n    } END"}
{"prompt":"test Create Savings Note\n\n###\n\n","completion":"    @Test\n    public void testCreateSavingsNote() {\n        final String noteText = \"this is a test Savings note\";\n        final String testDate = \"01 January 2012\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, testDate);\n        \/\/ Savings Account\n        final String savingsProductJSON = this.savingsProductHelper.withInterestCompoundingPeriodTypeAsDaily()\n                .withInterestPostingPeriodTypeAsDaily().withInterestCalculationPeriodTypeAsDailyBalance().build();\n        final Integer savingsProductId = SavingsProductHelper.createSavingsProduct(savingsProductJSON, requestSpec, responseSpec);\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplicationOnDate(clientID, savingsProductId, \"INDIVIDUAL\",\n                testDate);\n        Assertions.assertNotNull(savingsId);\n\n        \/\/ Notes\n        final String payload = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        final PostResourceTypeResourceIdNotesResponse postNoteResponse = NotesHelper.createSavingsNote(requestSpec, responseSpec, savingsId,\n                payload);\n        Assertions.assertNotNull(postNoteResponse);\n        Assertions.assertNotNull(postNoteResponse.getResourceId());\n\n        final GetResourceTypeResourceIdNotesNoteIdResponse getNoteResponse = NotesHelper.getSavingsNote(requestSpec, responseSpec,\n                savingsId, postNoteResponse.getResourceId());\n        Assertions.assertNotNull(getNoteResponse);\n        Assertions.assertEquals(noteText, getNoteResponse.getNote());\n    } END"}
{"prompt":"test Update Loan Note\n\n###\n\n","completion":"    @Test\n    public void testUpdateLoanNote() {\n        String noteText = \"this is a test loan note\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanId = applyForLoanApplication(clientID, loanProductID);\n        Assertions.assertNotNull(loanId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createLoanNote(requestSpec, responseSpec, loanId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getLoanNote(requestSpec, responseSpec, loanId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        String updatedNoteText = \"this is an updated test loan note\";\n\n        String updateRequest = \"{\\\"note\\\": \\\"\" + updatedNoteText + \"\\\"}\";\n        NotesHelper.updateLoanNote(requestSpec, responseSpec, loanId, noteId, updateRequest);\n\n        receivedNoteText = NotesHelper.getLoanNote(requestSpec, responseSpec, loanId, noteId);\n        Assertions.assertEquals(updatedNoteText, receivedNoteText);\n    } END"}
{"prompt":"test Delete Loan Note\n\n###\n\n","completion":"    @Test\n    public void testDeleteLoanNote() {\n        String noteText = \"this is a test loan note\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanId = applyForLoanApplication(clientID, loanProductID);\n        Assertions.assertNotNull(loanId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createLoanNote(requestSpec, responseSpec, loanId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getLoanNote(requestSpec, responseSpec, loanId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        NotesHelper.deleteLoanNote(requestSpec, responseSpec, loanId, noteId);\n\n        NotesHelper.getLoanNote(requestSpec, responseSpec404, loanId, noteId);\n    } END"}
{"prompt":"test Create Loan Transaction Note\n\n###\n\n","completion":"    @Test\n    public void testCreateLoanTransactionNote() {\n        String noteText = \"this is a test loan transaction note\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanId = applyForLoanApplication(clientID, loanProductID);\n        Assertions.assertNotNull(loanId);\n\n        this.loanTransactionHelper.approveLoan(\"02 April 2012\", loanId);\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 April 2012\", loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        HashMap repayment = this.loanTransactionHelper.makeRepayment(\"02 April 2012\", 100.0f, loanId);\n        Integer loanTransactionId = (Integer) repayment.get(\"resourceId\");\n        Assertions.assertNotNull(loanTransactionId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n    } END"}
{"prompt":"test Update Loan Transaction Note\n\n###\n\n","completion":"    @Test\n    public void testUpdateLoanTransactionNote() {\n        String noteText = \"this is a test loan transaction note\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanId = applyForLoanApplication(clientID, loanProductID);\n        Assertions.assertNotNull(loanId);\n\n        this.loanTransactionHelper.approveLoan(\"02 April 2012\", loanId);\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 April 2012\", loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        HashMap repayment = this.loanTransactionHelper.makeRepayment(\"02 April 2012\", 100.0f, loanId);\n        Integer loanTransactionId = (Integer) repayment.get(\"resourceId\");\n        Assertions.assertNotNull(loanTransactionId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        String updatedNoteText = \"this is an updated test loan transaction note\";\n\n        String updateRequest = \"{\\\"note\\\": \\\"\" + updatedNoteText + \"\\\"}\";\n        NotesHelper.updateLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, noteId, updateRequest);\n\n        receivedNoteText = NotesHelper.getLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, noteId);\n        Assertions.assertEquals(updatedNoteText, receivedNoteText);\n\n    } END"}
{"prompt":"test Delete Loan Transaction Note\n\n###\n\n","completion":"    @Test\n    public void testDeleteLoanTransactionNote() {\n        String noteText = \"this is a test loan transaction note\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanId = applyForLoanApplication(clientID, loanProductID);\n        Assertions.assertNotNull(loanId);\n\n        this.loanTransactionHelper.approveLoan(\"02 April 2012\", loanId);\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 April 2012\", loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        HashMap repayment = this.loanTransactionHelper.makeRepayment(\"02 April 2012\", 100.0f, loanId);\n        Integer loanTransactionId = (Integer) repayment.get(\"resourceId\");\n        Assertions.assertNotNull(loanTransactionId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        NotesHelper.deleteLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, noteId);\n\n        NotesHelper.getLoanTransactionNote(requestSpec, responseSpec404, loanTransactionId, noteId);\n    } END"}
{"prompt":"test Notification Retrieval Works When No Notifications Are Available\n\n###\n\n","completion":"    @Test\n    public void testNotificationRetrievalWorksWhenNoNotificationsAreAvailable() {\n        \/\/ given\n        \/\/ when\n        GetNotificationsResponse response = NotificationHelper.getNotifications(requestSpec, responseSpec);\n        \/\/ then\n        Assertions.assertNotNull(response);\n    } END"}
{"prompt":"test Notification Retrieval Works When One Notification Is Available\n\n###\n\n","completion":"    @Test\n    public void testNotificationRetrievalWorksWhenOneNotificationIsAvailable() {\n        \/\/ given\n        PostClientsRequest clientRequest = ClientHelper.defaultClientCreationRequest();\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec, clientRequest);\n        Assertions.assertNotNull(clientId);\n\n        \/\/ when\n        NotificationHelper.waitUntilNotificationsAreAvailable(newUserRequestSpec, newUserResponseSpec);\n        GetNotificationsResponse response = NotificationHelper.getNotifications(newUserRequestSpec, newUserResponseSpec);\n        \/\/ then\n        Assertions.assertNotNull(response);\n        List<GetNotification> pageItems = response.getPageItems();\n        Assertions.assertEquals(1, pageItems.size());\n        GetNotification firstNotification = pageItems.get(0);\n        Assertions.assertEquals(SUPER_USER_ID, firstNotification.getActorId());\n        Assertions.assertEquals(false, firstNotification.getIsRead());\n        Assertions.assertEquals(CREATED_ACTION_TYPE, firstNotification.getAction());\n        Assertions.assertEquals(clientId.longValue(), firstNotification.getObjectId());\n        Assertions.assertEquals(CLIENT_OBJECT_TYPE, firstNotification.getObjectType());\n    } END"}
{"prompt":"test Office Modification\n\n###\n\n","completion":"    @Test\n    public void testOfficeModification() {\n        OfficeHelper oh = new OfficeHelper(requestSpec, responseSpec);\n        int officeId = oh.createOffice(\"01 July 2007\");\n        String name = Utils.uniqueRandomStringGenerator(\"New_Office_\", 4);\n        String date = \"02 July 2007\";\n        String[] dateArr = { \"2007\", \"7\", \"2\" };\n\n        oh.updateOffice(officeId, name, date);\n        OfficeDomain newOffice = oh.retrieveOfficeByID(officeId);\n\n        Assertions.assertTrue(name.equals(newOffice.getName()));\n        Assertions.assertArrayEquals(dateArr, newOffice.getOpeningDate());\n    } END"}
{"prompt":"update Password Preferences\n\n###\n\n","completion":"    @Test\n    public void updatePasswordPreferences() {\n        String validationPolicyId = \"2\";\n        PasswordPreferencesHelper.updatePasswordPreferences(requestSpec, responseSpec, validationPolicyId);\n        this.validateIfThePasswordIsUpdated(validationPolicyId);\n    } END"}
{"prompt":"update With Invalid Policy Id\n\n###\n\n","completion":"    @Test\n    public void updateWithInvalidPolicyId() {\n        String invalidValidationPolicyId = \"2000\";\n        final List<HashMap> error = (List) PasswordPreferencesHelper.updateWithInvalidValidationPolicyId(requestSpec, generalResponseSpec,\n                invalidValidationPolicyId, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.password.validation.policy.id.invalid\", error.get(0).get(\"userMessageGlobalisationCode\"),\n                \"Password Validation Policy with identifier 2000 does not exist\");\n    } END"}
{"prompt":"test Payment Type\n\n###\n\n","completion":"    @Test\n    public void testPaymentType() {\n        String name = PaymentTypeHelper.randomNameGenerator(\"P_T\", 5);\n        String description = PaymentTypeHelper.randomNameGenerator(\"PT_Desc\", 15);\n        Boolean isCashPayment = true;\n        Integer position = 1;\n\n        Integer paymentTypeId = PaymentTypeHelper.createPaymentType(requestSpec, responseSpec, name, description, isCashPayment, position);\n        Assertions.assertNotNull(paymentTypeId);\n        PaymentTypeHelper.verifyPaymentTypeCreatedOnServer(requestSpec, responseSpec, paymentTypeId);\n        PaymentTypeDomain paymentTypeResponse = PaymentTypeHelper.retrieveById(requestSpec, responseSpec, paymentTypeId);\n        Assertions.assertEquals(name, paymentTypeResponse.getName());\n        Assertions.assertEquals(description, paymentTypeResponse.getDescription());\n        Assertions.assertEquals(isCashPayment, paymentTypeResponse.getIsCashPayment());\n        Assertions.assertEquals(position, paymentTypeResponse.getPosition());\n\n        \/\/ Update Payment Type\n        String newName = PaymentTypeHelper.randomNameGenerator(\"P_TU\", 5);\n        String newDescription = PaymentTypeHelper.randomNameGenerator(\"PTU_Desc\", 15);\n        Boolean isCashPaymentUpdatedValue = false;\n        Integer newPosition = 2;\n\n        HashMap request = new HashMap();\n        request.put(\"name\", newName);\n        request.put(\"description\", newDescription);\n        request.put(\"isCashPayment\", isCashPaymentUpdatedValue);\n        request.put(\"position\", newPosition);\n        PaymentTypeHelper.updatePaymentType(paymentTypeId, request, requestSpec, responseSpec);\n        PaymentTypeDomain paymentTypeUpdatedResponse = PaymentTypeHelper.retrieveById(requestSpec, responseSpec, paymentTypeId);\n        Assertions.assertEquals(newName, paymentTypeUpdatedResponse.getName());\n        Assertions.assertEquals(newDescription, paymentTypeUpdatedResponse.getDescription());\n        Assertions.assertEquals(isCashPaymentUpdatedValue, paymentTypeUpdatedResponse.getIsCashPayment());\n        Assertions.assertEquals(newPosition, paymentTypeUpdatedResponse.getPosition());\n\n        \/\/ Delete\n        Integer deletedPaymentTypeId = PaymentTypeHelper.deletePaymentType(paymentTypeId, requestSpec, responseSpec);\n        Assertions.assertEquals(paymentTypeId, deletedPaymentTypeId);\n        ResponseSpecification responseSpecification = new ResponseSpecBuilder().expectStatusCode(404).build();\n        PaymentTypeHelper.retrieveById(requestSpec, responseSpecification, paymentTypeId);\n\n    } END"}
{"prompt":"get Product Mix List\n\n###\n\n","completion":"    @Test\n    public void getProductMixList() {\n        final ArrayList productMixList = this.productMixHelper.getProductsMixList();\n        Assertions.assertNotNull(productMixList);\n\n        final HashMap productMixTemplate = (HashMap) this.productMixHelper.getProductMixTemplate();\n        Assertions.assertNotNull(productMixTemplate);\n    } END"}
{"prompt":"test Rates For Loans\n\n###\n\n","completion":"    @Test\n    public void testRatesForLoans() {\n\n        \/\/ Retrieving all Rates\n        ArrayList<HashMap> allRatesData = RatesHelper.getRates(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(allRatesData);\n\n        \/\/ Testing Creation and Update of Loan Rate\n        final Integer loanRateId = RatesHelper.createRates(this.requestSpec, this.responseSpec, RatesHelper.getLoanRateJSON());\n        Assertions.assertNotNull(loanRateId);\n\n        \/\/ Update Rate percentage\n        HashMap changes = RatesHelper.updateRates(this.requestSpec, this.responseSpec, loanRateId, RatesHelper.getModifyRateJSON());\n\n        HashMap rateDataAfterChanges = RatesHelper.getRateById(this.requestSpec, this.responseSpec, loanRateId);\n        Assertions.assertEquals(rateDataAfterChanges.get(\"percentage\"), changes.get(\"percentage\"), \"Verifying Rate after modification\");\n\n    } END"}
{"prompt":"test Recurring Deposit Account With Premature Closure Type Withdrawal\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountWithPrematureClosureTypeWithdrawal() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        \/***\n         * Create GL Accounts for product account mapping\n         *\/\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        final String CLOSED_ON_DATE = dateFormat.format(Calendar.getInstance().getTime());\n\n        \/***\n         * Create client for applying Deposit account\n         *\/\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/***\n         * Create RD product with CashBased accounting enabled\n         *\/\n        final String accountingRule = CASH_BASED;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount,\n                liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        \/***\n         * Apply for RD account with created product and verify status\n         *\/\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        \/***\n         * Approve the RD account and verify whether account is approved\n         *\/\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        \/***\n         * Activate the RD Account and verify whether account is activated\n         *\/\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n\n        \/***\n         * Perform Deposit transaction and verify journal entries are posted for the transaction\n         *\/\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                depositAmount, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(depositTransactionId);\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, expectedFirstDepositOnDate,\n                new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, expectedFirstDepositOnDate,\n                new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT));\n\n        \/***\n         * Update interest earned field for RD account\n         *\/\n        recurringDepositAccountId = this.recurringDepositAccountHelper.calculateInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        \/***\n         * Post interest and verify journal entries\n         *\/\n        Integer transactionIdForPostInterest = this.recurringDepositAccountHelper\n                .postInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        HashMap accountSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n        \/***\n         * Calculate expected premature closure amount\n         *\/\n        HashMap recurringDepositPrematureData = this.recurringDepositAccountHelper\n                .calculatePrematureAmountForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE);\n\n        \/***\n         * Preclose the RD account verify whether account is preClosed\n         *\/\n        Integer prematureClosureTransactionId = (Integer) this.recurringDepositAccountHelper.prematureCloseForRecurringDeposit(\n                recurringDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsPrematureClosed(recurringDepositAccountStatusHashMap);\n\n        \/***\n         * Verify journal entry transactions for preclosure transaction\n         *\/\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n        Float maturityAmount = Float.valueOf(recurringDepositAccountData.get(\"maturityAmount\").toString());\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.DEBIT));\n\n    } END"}
{"prompt":"test Recurring Deposit Account With Closure Type Transfer To Savings WITH HOLD TAX\n\n###\n\n","completion":"    @Test\n    @Disabled \/\/ TODO FINERACT-1248\n    public void testRecurringDepositAccountWithClosureTypeTransferToSavings_WITH_HOLD_TAX() throws InterruptedException {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        \/***\n         * Create GL Accounts for product account mapping\n         *\/\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n        final Account liabilityAccountForTax = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -20);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -20);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        Calendar closedOn = Calendar.getInstance();\n        closedOn.add(Calendar.MONTH, -6);\n        final String CLOSED_ON_DATE = dateFormat.format(closedOn.getTime());\n\n        \/***\n         * Create client for applying Deposit and Savings accounts\n         *\/\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/***\n         * Create Savings product with CashBased accounting enabled\n         *\/\n        final String accountingRule = CASH_BASED;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE, accountingRule,\n                assetAccount, liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(savingsProductID);\n\n        \/***\n         * Create Savings account and verify status is pending\n         *\/\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientId, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        \/***\n         * Approve the savings account and verify account is approved\n         *\/\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        \/***\n         * Activate the savings account and verify account is activated\n         *\/\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        \/***\n         * Create RD product with CashBased accounting enabled\n         *\/\n        final Integer taxGroupId = createTaxGroup(\"10\", liabilityAccountForTax);\n        Integer recurringDepositProductId = createRecurringDepositProductWithWithHoldTax(VALID_FROM, VALID_TO, String.valueOf(taxGroupId),\n                accountingRule, assetAccount, liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        \/***\n         * Apply for RD account with created product and verify status\n         *\/\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        \/***\n         * Approve the RD account and verify whether account is approved\n         *\/\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        \/***\n         * Activate the RD Account and verify whether account is activated\n         *\/\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n\n        \/***\n         * Perform Deposit transaction and verify journal entries are posted for the transaction\n         *\/\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -20);\n\n        for (int i = 0; i < 14; i++) {\n            Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                    depositAmount, dateFormat.format(todaysDate.getTime()));\n            Assertions.assertNotNull(depositTransactionId);\n\n            this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, dateFormat.format(todaysDate.getTime()),\n                    new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT));\n            this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, dateFormat.format(todaysDate.getTime()),\n                    new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT));\n            todaysDate.add(Calendar.MONTH, 1);\n        }\n\n        \/***\n         * FD account verify whether account is matured\n         *\/\n\n        SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n        String JobName = \"Update Deposit Accounts Maturity details\";\n        schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        HashMap accountDetails = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        HashMap summary = (HashMap) accountDetails.get(\"summary\");\n        Assertions.assertNotNull(summary.get(\"totalWithholdTax\"));\n        Float withHoldTax = (Float) summary.get(\"totalWithholdTax\");\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccountForTax, CLOSED_ON_DATE,\n                new JournalEntry(withHoldTax, JournalEntry.TransactionType.CREDIT));\n\n        recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsMatured(recurringDepositAccountStatusHashMap);\n\n    } END"}
{"prompt":"test Recurring Deposit Account With Premature Closure Type Reinvest\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountWithPrematureClosureTypeReinvest() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        RecurringDepositAccountHelper recurringDepositAccountHelperValidationError = new RecurringDepositAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        \/***\n         * Create GL Accounts for product account mapping\n         *\/\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        final String CLOSED_ON_DATE = dateFormat.format(Calendar.getInstance().getTime());\n\n        \/***\n         * Create client for applying Deposit account\n         *\/\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/***\n         * Create RD product with CashBased accounting enabled\n         *\/\n        final String accountingRule = CASH_BASED;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount,\n                liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        ArrayList<HashMap> allRecurringDepositProductsData = RecurringDepositProductHelper\n                .retrieveAllRecurringDepositProducts(this.requestSpec, this.responseSpec);\n        HashMap recurringDepositProductData = RecurringDepositProductHelper.retrieveRecurringDepositProductById(this.requestSpec,\n                this.responseSpec, recurringDepositProductId.toString());\n\n        \/***\n         * Apply for RD account with created product and verify status\n         *\/\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        \/***\n         * Approve the RD account and verify whether account is approved\n         *\/\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        \/***\n         * Activate the RD Account and verify whether account is activated\n         *\/\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n\n        \/***\n         * Perform Deposit transaction and verify journal entries are posted for the transaction\n         *\/\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(depositTransactionId);\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, expectedFirstDepositOnDate,\n                new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, expectedFirstDepositOnDate,\n                new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT));\n\n        \/***\n         * Update interest earned field for RD account\n         *\/\n        recurringDepositAccountId = this.recurringDepositAccountHelper.calculateInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        \/***\n         * Post interest and verify journal entries\n         *\/\n        Integer transactionIdForPostInterest = this.recurringDepositAccountHelper\n                .postInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        HashMap accountSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n        \/***\n         * Calculate expected premature closure amount\n         *\/\n        HashMap recurringDepositPrematureData = this.recurringDepositAccountHelper\n                .calculatePrematureAmountForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE);\n\n        \/***\n         * Expected to get an error response from api because re-invest option is not supported for account preClosure\n         *\/\n        ArrayList<HashMap> errorResponse = (ArrayList<HashMap>) recurringDepositAccountHelperValidationError\n                .prematureCloseForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_REINVEST, null,\n                        CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"validation.msg.recurringdepositaccount.onAccountClosureId.reinvest.not.allowed\",\n                errorResponse.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    } END"}
{"prompt":"test Recurring Deposit Account Updation\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountUpdation() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        todaysDate.add(Calendar.DATE, -1);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateRecurringDepositAccount(clientId.toString(),\n                recurringDepositProductId.toString(), recurringDepositAccountId.toString(), VALID_FROM, VALID_TO, WHOLE_TERM,\n                SUBMITTED_ON_DATE);\n        Assertions.assertTrue(modificationsHashMap.containsKey(\"submittedOnDate\"));\n\n    } END"}
{"prompt":"test Recurring Deposit Account Undo Approval\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountUndoApproval() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.undoApproval(recurringDepositAccountId);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n    } END"}
{"prompt":"test Recurring Deposit Account Rejected And Closed\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountRejectedAndClosed() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String REJECTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.rejectApplication(recurringDepositAccountId,\n                REJECTED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsRejected(recurringDepositAccountStatusHashMap);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsClosed(recurringDepositAccountStatusHashMap);\n    } END"}
{"prompt":"test Recurring Deposit Account Withdrawn By Client And Closed\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountWithdrawnByClientAndClosed() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String WITHDRAWN_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.withdrawApplication(recurringDepositAccountId,\n                WITHDRAWN_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsWithdrawn(recurringDepositAccountStatusHashMap);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsClosed(recurringDepositAccountStatusHashMap);\n    } END"}
{"prompt":"test Recurring Deposit Account Is Deleted\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountIsDeleted() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountId = (Integer) this.recurringDepositAccountHelper\n                .deleteRecurringDepositApplication(recurringDepositAccountId, \"resourceId\");\n        Assertions.assertNotNull(recurringDepositAccountId);\n    } END"}
{"prompt":"test Update And Undo Transaction For Recurring Deposit Account\n\n###\n\n","completion":"    @Test\n    public void testUpdateAndUndoTransactionForRecurringDepositAccount() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        \/***\n         * Create GL Accounts for product account mapping\n         *\/\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.MONTH, 1);\n        final String DEPOSIT_DATE = dateFormat.format(todaysDate.getTime());\n\n        \/***\n         * Create client for applying Deposit account\n         *\/\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        \/***\n         * Create RD product with CashBased accounting enabled\n         *\/\n        final String accountingRule = CASH_BASED;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount,\n                liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        \/***\n         * Apply for RD account with created product and verify status\n         *\/\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        \/***\n         * Approve the RD account and verify whether account is approved\n         *\/\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        \/***\n         * Activate the RD Account and verify whether account is activated\n         *\/\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositSummaryBefore = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float balanceBefore = (Float) recurringDepositSummaryBefore.get(\"accountBalance\");\n\n        \/***\n         * Perform Deposit transaction and verify journal entries are posted for the transaction\n         *\/\n        Integer transactionIdForDeposit = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, DEPOSIT_DATE);\n        Assertions.assertNotNull(transactionIdForDeposit);\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, DEPOSIT_DATE,\n                new JournalEntry(DEPOSIT_AMOUNT, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, DEPOSIT_DATE,\n                new JournalEntry(DEPOSIT_AMOUNT, JournalEntry.TransactionType.CREDIT));\n\n        \/***\n         * verify account balances after transactions\n         *\/\n        Float expectedBalanceAfter = balanceBefore + DEPOSIT_AMOUNT;\n        HashMap recurringDepositSummaryAfter = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float balanceAfter = (Float) recurringDepositSummaryAfter.get(\"accountBalance\");\n\n        Assertions.assertEquals(expectedBalanceAfter, balanceAfter, \"Verifying account balance after deposit\");\n\n        \/***\n         * Update transaction and verify account balance after transaction\n         *\/\n        Float updatedTransactionAmount = DEPOSIT_AMOUNT - 1000.0f;\n        Integer updateTransactionId = this.recurringDepositAccountHelper.updateTransactionForRecurringDeposit(recurringDepositAccountId,\n                transactionIdForDeposit, DEPOSIT_DATE, updatedTransactionAmount);\n        Assertions.assertNotNull(updateTransactionId);\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, DEPOSIT_DATE,\n                new JournalEntry(updatedTransactionAmount, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, DEPOSIT_DATE,\n                new JournalEntry(updatedTransactionAmount, JournalEntry.TransactionType.CREDIT));\n\n        expectedBalanceAfter = DEPOSIT_AMOUNT - updatedTransactionAmount;\n        recurringDepositSummaryAfter = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        balanceAfter = (Float) recurringDepositSummaryAfter.get(\"accountBalance\");\n\n        Assertions.assertEquals(expectedBalanceAfter, balanceAfter, \"Verifying account balance after updating Transaction\");\n\n        Integer undoTransactionId = this.recurringDepositAccountHelper.undoTransactionForRecurringDeposit(recurringDepositAccountId,\n                updateTransactionId, DEPOSIT_DATE, 0.0f);\n        Assertions.assertNotNull(undoTransactionId);\n\n        expectedBalanceAfter = expectedBalanceAfter - updatedTransactionAmount;\n        recurringDepositSummaryAfter = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        balanceAfter = (Float) recurringDepositSummaryAfter.get(\"accountBalance\");\n\n        Assertions.assertEquals(expectedBalanceAfter, balanceAfter, \"Verifying account balance after Undo Transaction\");\n\n    } END"}
{"prompt":"test Post Interest For Recurring Deposit\n\n###\n\n","completion":"    @Test\n    public void testPostInterestForRecurringDeposit() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(depositTransactionId);\n\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"totalDeposits\");\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        daysInMonth = daysInMonth - currentDate + 1;\n        Float interestToBePosted = (float) (interestPerDay * principal * daysInMonth);\n        principal += interestToBePosted;\n\n        Float expectedBalanceAfter = principal;\n        LOG.info(\"{}\", expectedBalanceAfter.toString());\n\n        Integer transactionIdForPostInterest = this.recurringDepositAccountHelper\n                .postInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        HashMap recurringDepositAccountSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float interestAmountPosted = (Float) recurringDepositAccountSummary.get(\"totalInterestPosted\");\n        Float principalAfter = (Float) recurringDepositAccountSummary.get(\"accountBalance\");\n\n        Assertions.assertTrue(Math.abs(interestToBePosted - interestAmountPosted) < THRESHOLD,\n                \"Verifying Amount of Interest Posted to Recurring Deposit Account\");\n        Assertions.assertTrue(Math.abs(expectedBalanceAfter - principalAfter) < THRESHOLD,\n                \"Verifying Principal Amount after Interest Posting\");\n\n    } END"}
{"prompt":"test Premature Closure Amount With Penal Interest For Whole Term With 365 Days\n\n###\n\n","completion":"    @Test\n    public void testPrematureClosureAmountWithPenalInterestForWholeTerm_With_365_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.MONTH, 1);\n        final String CLOSED_ON_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Float preClosurePenalInterestRate = (Float) recurringDepositAccountData.get(\"preClosurePenalInterest\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(depositTransactionId);\n\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"totalDeposits\");\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        interestRate -= preClosurePenalInterestRate;\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(calendar.getTime()));\n        Integer daysInMonth = calendar.getActualMaximum(Calendar.DATE);\n        daysInMonth = daysInMonth - currentDate + 1;\n        Float interestPerMonth = (float) (interestPerDay * principal * daysInMonth);\n        principal += interestPerMonth + depositAmount;\n        calendar.add(Calendar.DATE, daysInMonth);\n        LOG.info(\"{}\", monthDayFormat.format(calendar.getTime()));\n\n        expectedFirstDepositOnDate = dateFormat.format(calendar.getTime());\n        Integer transactionIdForDeposit = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(transactionIdForDeposit);\n\n        currentDate = currentDate - 1;\n        interestPerMonth = (float) (interestPerDay * principal * currentDate);\n        LOG.info(\"IPM = {}\", interestPerMonth);\n        principal += interestPerMonth;\n        LOG.info(\"principal = {}\", principal);\n\n        HashMap recurringDepositPrematureData = this.recurringDepositAccountHelper\n                .calculatePrematureAmountForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.recurringDepositAccountHelper.prematureCloseForRecurringDeposit(\n                recurringDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsPrematureClosed(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    } END"}
{"prompt":"test Premature Closure Amount With Penal Interest For Whole Term With 360 Days\n\n###\n\n","completion":"    @Test\n    public void testPrematureClosureAmountWithPenalInterestForWholeTerm_With_360_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.MONTH, 1);\n        final String CLOSED_ON_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, MONTHLY, MONTHLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Float preClosurePenalInterestRate = (Float) recurringDepositAccountData.get(\"preClosurePenalInterest\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(depositTransactionId);\n\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"totalDeposits\");\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        interestRate -= preClosurePenalInterestRate;\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(calendar.getTime()));\n        Integer daysInMonth = calendar.getActualMaximum(Calendar.DATE);\n        daysInMonth = daysInMonth - currentDate + 1;\n        Float interestPerMonth = (float) (interestPerDay * principal * daysInMonth);\n        principal += interestPerMonth + depositAmount;\n        calendar.add(Calendar.DATE, daysInMonth);\n        LOG.info(\"{}\", monthDayFormat.format(calendar.getTime()));\n\n        expectedFirstDepositOnDate = dateFormat.format(calendar.getTime());\n        Integer transactionIdForDeposit = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(transactionIdForDeposit);\n\n        currentDate = currentDate - 1;\n        interestPerMonth = (float) (interestPerDay * principal * currentDate);\n        LOG.info(\"IPM = {}\", interestPerMonth);\n        principal += interestPerMonth;\n        LOG.info(\"principal = {}\", principal);\n\n        HashMap recurringDepositPrematureData = this.recurringDepositAccountHelper\n                .calculatePrematureAmountForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.recurringDepositAccountHelper.prematureCloseForRecurringDeposit(\n                recurringDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsPrematureClosed(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    } END"}
{"prompt":"test Recurring Deposit With Bi Annual Compounding And Posting 365 Days\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositWithBi_AnnualCompoundingAndPosting_365_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        LOG.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_365, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, BI_ANNUALLY, BI_ANNUALLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, BIANNULLY_INTERVAL, BIANNULLY_INTERVAL);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    } END"}
{"prompt":"test Recurring Deposit With Bi Annual Compounding And Posting 360 Days\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositWithBi_AnnualCompoundingAndPosting_360_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        LOG.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, BI_ANNUALLY, BI_ANNUALLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        LOG.info(\"per day = {} \", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, BIANNULLY_INTERVAL, BIANNULLY_INTERVAL);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    } END"}
{"prompt":"test Maturity Amount For Daily Compounding And Annually Posting With 360 Days\n\n###\n\n","completion":"    @Test\n    public void testMaturityAmountForDailyCompoundingAndAnnuallyPosting_With_360_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        LOG.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, DAILY, ANNUALLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        LOG.info(\"per day = {} \", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, DAILY_COMPOUNDING_INTERVAL, ANNUL_INTERVAL);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Maturity amount\");\n\n    } END"}
{"prompt":"test Recurring Deposit Quarterly Compounding And Quarterly Posting 365 Days\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositQuarterlyCompoundingAndQuarterlyPosting_365_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        LOG.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_365, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, QUARTERLY, QUARTERLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        LOG.info(\"per day = {} \", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, QUARTERLY_INTERVAL, QUARTERLY_INTERVAL);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    } END"}
{"prompt":"test Recurring Deposit Quarterly Compounding And Quarterly Posting 360 Days\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositQuarterlyCompoundingAndQuarterlyPosting_360_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        LOG.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, QUARTERLY, QUARTERLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate \/ 100;\n        double perDay = (double) 1 \/ daysInYear;\n        LOG.info(\"per day = {} \", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, QUARTERLY_INTERVAL, QUARTERLY_INTERVAL);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    } END"}
{"prompt":"test Recurring Deposit Account With Period Interest Rate Chart\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountWithPeriodInterestRateChart() {\n        final String chartToUse = \"period\";\n        final String depositAmount = \"1000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 6.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Recurring Deposit Account With Period Interest Rate Chart AMOUNT VARIATION\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountWithPeriodInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"period\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 6.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Recurring Deposit Account With Period Interest Rate Chart PERIOD VARIATION\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountWithPeriodInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"period\";\n        final String depositAmount = \"1000\";\n        final String depositPeriod = \"18\";\n        final Float interestRate = Float.valueOf((float) 7.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Recurring Deposit Account With Amount Interest Rate Chart\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountWithAmountInterestRateChart() {\n        final String chartToUse = \"amount\";\n        final String depositAmount = \"1000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 8.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Recurring Deposit Account With Amount Interest Rate Chart AMOUNT VARIATION\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountWithAmountInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"amount\";\n        final String depositAmount = \"500\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 7.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Recurring Deposit Account With Amount Interest Rate Chart PERIOD VARIATION\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountWithAmountInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"amount\";\n        final String depositAmount = \"500\";\n        final String depositPeriod = \"10\";\n        final Float interestRate = Float.valueOf((float) 5.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Recurring Deposit Account With Period And Amount Interest Rate Chart\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountWithPeriodAndAmountInterestRateChart() {\n        final String chartToUse = \"period_amount\";\n        final String depositAmount = \"1000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 7.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Recurring Deposit Account With Period And Amount Interest Rate Chart AMOUNT VARIATION\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountWithPeriodAndAmountInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"period_amount\";\n        final String depositAmount = \"400\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 6.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Recurring Deposit Account With Period And Amount Interest Rate Chart PERIOD VARIATION\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountWithPeriodAndAmountInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"period_amount\";\n        final String depositAmount = \"1000\";\n        final String depositPeriod = \"14\";\n        final Float interestRate = Float.valueOf((float) 8.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Recurring Deposit Account With Amount And Period Interest Rate Chart\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountWithAmountAndPeriodInterestRateChart() {\n        final String chartToUse = \"amount_period\";\n        final String depositAmount = \"1000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 8.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Recurring Deposit Account With Amount And Period Interest Rate Chart AMOUNT VARIATION\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountWithAmountAndPeriodInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"amount_period\";\n        final String depositAmount = \"100\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 6.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Recurring Deposit Account With Amount And Period Interest Rate Chart PERIOD VARIATION\n\n###\n\n","completion":"    @Test\n    public void testRecurringDepositAccountWithAmountAndPeriodInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"amount_period\";\n        final String depositAmount = \"1000\";\n        final String depositPeriod = \"6\";\n        final Float interestRate = Float.valueOf((float) 7.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    } END"}
{"prompt":"test Repayment With Post Dated Checks\n\n###\n\n","completion":"    @Test\n    public void testRepaymentWithPostDatedChecks() {\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        Calendar meetingCalendar = Calendar.getInstance();\n        meetingCalendar.set(2012, 3, 4);\n\n        final String disbursalDate = this.dateFormatterStandard.format(meetingCalendar.getTime());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientID);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        Assertions.assertNotNull(loanProductID, \"Could not create Loan Product\");\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"8000\");\n        Assertions.assertNotNull(loanID, \"Could not create Loan Account\");\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        \/\/ Test for loan account is created, can be approved\n        this.loanTransactionHelper.approveLoan(disbursalDate, loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        \/\/ Get repayments Template for Repayment\n        ArrayList<HashMap> installmentData = this.loanTransactionHelper.getRepayments(loanID);\n        Assertions.assertNotNull(installmentData, \"Empty Installment Data Template\");\n\n        \/\/ Get repayments for Disburse\n        installmentData = this.loanTransactionHelper.getRepayments(loanID);\n        Assertions.assertNotNull(installmentData, \"Empty Installment Data\");\n        List<HashMap> postDatedChecks = new ArrayList<>();\n        Gson gson = new Gson();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        \/\/ Get the first installment date\n        ArrayList installmentDate = (ArrayList) installmentData.get(0).get(\"date\");\n        Assertions.assertNotNull(installmentDate);\n        Assertions.assertEquals(3, installmentDate.size());\n        Calendar calendar = Calendar.getInstance();\n        calendar.set((Integer) installmentDate.get(0), (Integer) installmentDate.get(1) - 1, (Integer) installmentDate.get(2));\n        final String LOAN_REPAYMENT_DATE = dateFormat.format(calendar.getTime());\n        Float firstInstallmentAmount = (Float) installmentData.get(0).get(\"amount\");\n\n        for (int i = 0; i < installmentData.size(); i++) {\n            String result = gson.toJson(installmentData.get(i));\n            JsonObject reportObject = JsonParser.parseString(result).getAsJsonObject();\n            final Integer installmentId = reportObject.get(\"installmentId\").getAsInt();\n            final BigDecimal amount = reportObject.get(\"amount\").getAsBigDecimal();\n            postDatedChecks.add(postDatedCheck(installmentId, amount));\n        }\n\n        Assertions.assertNotNull(postDatedChecks);\n\n        \/\/ Test for loan account approved can be disbursed\n        this.loanTransactionHelper.disburseLoanWithPostDatedChecks(disbursalDate, loanID, BigDecimal.valueOf(8000), postDatedChecks);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        \/\/ Create payment type PDC - Post Dated Checks\n        String name = \"PDC\";\n        String description = PaymentTypeHelper.randomNameGenerator(\"PDC\", 15);\n        Boolean isCashPayment = false;\n        Integer position = 1;\n\n        Integer paymentTypeId = PaymentTypeHelper.createPaymentType(requestSpec, responseSpec, name, description, isCashPayment, position);\n        Assertions.assertNotNull(paymentTypeId);\n        PaymentTypeHelper.verifyPaymentTypeCreatedOnServer(requestSpec, responseSpec, paymentTypeId);\n        PaymentTypeDomain paymentTypeResponse = PaymentTypeHelper.retrieveById(requestSpec, responseSpec, paymentTypeId);\n        Assertions.assertEquals(name, paymentTypeResponse.getName());\n\n        \/\/ Repay for the installment 1 using post dated check\n        HashMap postDatedCheck = this.loanTransactionHelper.getPostDatedCheck(loanID, Integer.valueOf(1));\n        Assertions.assertNotNull(postDatedCheck);\n        Assertions.assertNotNull(Float.valueOf(String.valueOf(postDatedCheck.get(\"amount\"))));\n\n        this.loanTransactionHelper.makeRepaymentWithPDC(LOAN_REPAYMENT_DATE, firstInstallmentAmount, loanID, paymentTypeId);\n    } END"}
{"prompt":"test Create Roles Status\n\n###\n\n","completion":"    @SuppressWarnings(\"cast\")\n    @Test\n    public void testCreateRolesStatus() {\n\n        LOG.info(\"---------------------------------CREATING A ROLE---------------------------------------------\");\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        LOG.info(\"--------------------------------- Getting ROLE -------------------------------\");\n        HashMap<String, Object> role = RolesHelper.getRoleDetails(requestSpec, responseSpec, roleId);\n        assertEquals((Integer) role.get(\"id\"), roleId);\n\n    } END"}
{"prompt":"test Disable Roles Status\n\n###\n\n","completion":"    @SuppressWarnings(\"cast\")\n    @Test\n    public void testDisableRolesStatus() {\n\n        LOG.info(\"---------------------------------CREATING A ROLE---------------------------------------------\");\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        LOG.info(\"--------------------------------- Getting ROLE -------------------------------\");\n        HashMap<String, Object> role = RolesHelper.getRoleDetails(requestSpec, responseSpec, roleId);\n        assertEquals((Integer) role.get(\"id\"), roleId);\n\n        LOG.info(\"--------------------------------- DISABLING ROLE -------------------------------\");\n        final Integer disableRoleId = RolesHelper.disableRole(this.requestSpec, this.responseSpec, roleId);\n        assertEquals(disableRoleId, roleId);\n        role = RolesHelper.getRoleDetails(requestSpec, responseSpec, roleId);\n        assertEquals((Integer) role.get(\"id\"), roleId);\n        assertEquals(true, (Boolean) role.get(\"disabled\"));\n\n    } END"}
{"prompt":"test Enable Roles Status\n\n###\n\n","completion":"    @SuppressWarnings(\"cast\")\n    @Test\n    public void testEnableRolesStatus() {\n\n        LOG.info(\"---------------------------------CREATING A ROLE---------------------------------------------\");\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        LOG.info(\"--------------------------------- Getting ROLE -------------------------------\");\n        HashMap<String, Object> role = RolesHelper.getRoleDetails(requestSpec, responseSpec, roleId);\n        assertEquals((Integer) role.get(\"id\"), roleId);\n\n        LOG.info(\"--------------------------------- DISABLING ROLE -------------------------------\");\n        final Integer disableRoleId = RolesHelper.disableRole(this.requestSpec, this.responseSpec, roleId);\n        assertEquals(disableRoleId, roleId);\n        role = RolesHelper.getRoleDetails(requestSpec, responseSpec, roleId);\n        assertEquals((Integer) role.get(\"id\"), roleId);\n        assertEquals(true, (Boolean) role.get(\"disabled\"));\n\n        LOG.info(\"--------------------------------- ENABLING ROLE -------------------------------\");\n        final Integer enableRoleId = RolesHelper.enableRole(this.requestSpec, this.responseSpec, roleId);\n        assertEquals(enableRoleId, roleId);\n        role = RolesHelper.getRoleDetails(requestSpec, responseSpec, roleId);\n        assertEquals((Integer) role.get(\"id\"), roleId);\n        assertEquals(false, (Boolean) role.get(\"disabled\"));\n\n    } END"}
{"prompt":"test Delete Role Status\n\n###\n\n","completion":"    @SuppressWarnings(\"cast\")\n    @Test\n    public void testDeleteRoleStatus() {\n\n        LOG.info(\"-------------------------------- CREATING A ROLE---------------------------------------------\");\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        LOG.info(\"--------------------------------- Getting ROLE -------------------------------\");\n        HashMap<String, Object> role = RolesHelper.getRoleDetails(requestSpec, responseSpec, roleId);\n        assertEquals((Integer) role.get(\"id\"), roleId);\n\n        LOG.info(\"--------------------------------- DELETE ROLE -------------------------------\");\n        final Integer deleteRoleId = RolesHelper.deleteRole(this.requestSpec, this.responseSpec, roleId);\n        assertEquals(deleteRoleId, roleId);\n    } END"}
{"prompt":"test Role Should Get Deleted If No Active User Exists\n\n###\n\n","completion":"    @Test\n    public void testRoleShouldGetDeletedIfNoActiveUserExists() {\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(staffId);\n\n        final Integer userId = UserHelper.createUser(this.requestSpec, this.responseSpec, roleId, staffId);\n        Assertions.assertNotNull(userId);\n\n        final Integer deletedUserId = UserHelper.deleteUser(this.requestSpec, this.responseSpec, userId);\n        Assertions.assertEquals(deletedUserId, userId);\n\n        final Integer deletedRoleId = RolesHelper.deleteRole(this.requestSpec, this.responseSpec, roleId);\n        assertEquals(deletedRoleId, roleId);\n    } END"}
{"prompt":"test Role Should Not Get Deleted If Active User Exists\n\n###\n\n","completion":"    @Test\n    public void testRoleShouldNotGetDeletedIfActiveUserExists() {\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(staffId);\n\n        final Integer userId = UserHelper.createUser(this.requestSpec, this.responseSpec, roleId, staffId);\n        Assertions.assertNotNull(userId);\n\n        this.responseSpec = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final Integer deletedRoleId = RolesHelper.deleteRole(this.requestSpec, this.responseSpec, roleId);\n        assertNotEquals(deletedRoleId, roleId);\n    } END"}
{"prompt":"test Savings Balance After Withdrawal\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsBalanceAfterWithdrawal() {\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, START_DATE);\n        Assertions.assertNotNull(clientID);\n        final Integer savingsId = createSavingsAccountDailyPosting(clientID);\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"10000\", START_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        this.savingsAccountHelper.reverseSavingsAccountTransaction(savingsId, depositTransactionId);\n        HashMap reversedDepositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        Assertions.assertTrue((Boolean) reversedDepositTransaction.get(\"reversed\"));\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(\"0.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance is 0\");\n        List<HashMap> error = (List<HashMap>) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"100\", START_DATE,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n    } END"}
{"prompt":"test Savings Balance With Over Draft After Withdrawal\n\n###\n\n","completion":"    @Test\n    public void testSavingsBalanceWithOverDraftAfterWithdrawal() {\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, START_DATE);\n        Assertions.assertNotNull(clientID);\n        final Integer savingsId = createSavingsAccountDailyPostingWithOverDraft(clientID);\n        Integer withdrawalTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"1000\", START_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        this.savingsAccountHelper.reverseSavingsAccountTransaction(savingsId, withdrawalTransactionId);\n        HashMap reversedWithdrawalTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawalTransactionId);\n        Assertions.assertTrue((Boolean) reversedWithdrawalTransaction.get(\"reversed\"));\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(\"0.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance is 0\");\n        Integer withdrawalAfterReversalTransactionId = (Integer) savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"500\",\n                START_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(\"-500.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance is -500\");\n    } END"}
{"prompt":"approve Savings Account\n\n###\n\n","completion":"    @Test\n    @Order(2)\n    void approveSavingsAccount() {\n        LOG.info(\"------------------------------ APPROVING SAVINGS ACCOUNT ---------------------------------------\");\n        PostSavingsAccountsAccountIdRequest request = new PostSavingsAccountsAccountIdRequest();\n        request.dateFormat(dateFormat);\n        request.setLocale(locale);\n        request.setApprovedOnDate(formattedDate);\n        Response<PostSavingsAccountsAccountIdResponse> response = okR(\n                fineract().savingsAccounts.handleCommands6((long) savingId, request, \"approve\"));\n\n        assertThat(response.isSuccessful()).isTrue();\n        assertThat(response.body()).isNotNull();\n    } END"}
{"prompt":"activate Savings Account\n\n###\n\n","completion":"    @Test\n    @Order(3)\n    void activateSavingsAccount() {\n        LOG.info(\"------------------------------ ACTIVATING SAVINGS ACCOUNT ---------------------------------------\");\n        PostSavingsAccountsAccountIdRequest request = new PostSavingsAccountsAccountIdRequest();\n        request.dateFormat(dateFormat);\n        request.setLocale(locale);\n        request.setActivatedOnDate(formattedDate);\n        Response<PostSavingsAccountsAccountIdResponse> response = okR(\n                fineract().savingsAccounts.handleCommands6((long) savingId, request, \"activate\"));\n\n        assertThat(response.isSuccessful()).isTrue();\n        assertThat(response.body()).isNotNull();\n    } END"}
{"prompt":"test Savings Daily Interest Posting\n\n###\n\n","completion":"    @Test\n    public void testSavingsDailyInterestPosting() {\n        \/\/ client activation, savings activation and 1st transaction date\n        final String startDate = \"01 November 2021\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPosting(clientID, startDate);\n\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"1000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        \/***\n         * Perform Post interest transaction and verify the posted transaction date\n         *\/\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        HashMap accountDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) accountDetails.get(\"transactions\");\n        HashMap<String, Object> interestPostingTransaction = transactions.get(transactions.size() - 2);\n        for (Map.Entry<String, Object> entry : interestPostingTransaction.entrySet()) {\n            LOG.info(\"{} - {}\", entry.getKey(), entry.getValue().toString());\n        }\n        assertEquals(\"0.274\", interestPostingTransaction.get(\"amount\").toString(), \"Equality check for interest posted amount\");\n        assertEquals(\"[2021, 11, 2]\", interestPostingTransaction.get(\"date\").toString(), \"Date check for Interest Posting transaction\");\n\n    } END"}
{"prompt":"test Savings Balance Check After Daily Interest Posting Job\n\n###\n\n","completion":"    @Test\n    public void testSavingsBalanceCheckAfterDailyInterestPostingJob() {\n        \/\/ client activation, savings activation and 1st transaction date\n        final String startDate = \"10 April 2022\";\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPosting(clientID, startDate);\n\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"10000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        \/***\n         * Runs Post interest posting job and verify the new account created with accounting configuration set as none\n         * is picked up by job\n         *\/\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        Object transactionObj = this.savingsAccountHelper.getSavingsDetails(savingsId, \"transactions\");\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) transactionObj;\n        HashMap<String, Object> interestPostingTransaction = transactions.get(transactions.size() - 48);\n        for (Map.Entry<String, Object> entry : interestPostingTransaction.entrySet()) {\n            LOG.info(\"{} - {}\", entry.getKey(), entry.getValue().toString());\n        }\n        assertEquals(\"10129.582\", interestPostingTransaction.get(\"runningBalance\").toString(), \"Equality check for Balance\");\n    } END"}
{"prompt":"test Savings Daily Interest Posting Job With Accounting None\n\n###\n\n","completion":"    @Test\n    public void testSavingsDailyInterestPostingJobWithAccountingNone() {\n        final String startDate = \"10 April 2022\";\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n        this.accountHelper = new AccountHelper(requestSpec, responseSpec);\n        this.journalEntryHelper = new JournalEntryHelper(requestSpec, responseSpec);\n\n        final Integer savingsId = createSavingsAccountDailyPostingWithAccounting(clientID, startDate);\n\n        Integer transactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"1000\", startDate,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        ArrayList<HashMap> journalEntries = this.journalEntryHelper.getJournalEntriesByTransactionId(String.valueOf(transactionId));\n        assertEquals(0, journalEntries.size());\n    } END"}
{"prompt":"test Duplicate Overdraft Interest Posting Job\n\n###\n\n","completion":"    @Test\n    public void testDuplicateOverdraftInterestPostingJob() {\n        \/\/ client activation, savings activation and 1st transaction date\n        final String startDate = \"01 July 2022\";\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"1000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"1000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        Object transactionObj = this.savingsAccountHelper.getSavingsDetails(savingsId, \"transactions\");\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) transactionObj;\n        Integer dateCount = 0;\n        for (HashMap<String, Object> transaction : transactions) {\n            if (transaction.get(\"date\").toString().equals(\"[2022, 7, 10]\") && transaction.get(\"reversed\").toString().equals(\"false\")) {\n                dateCount++;\n            }\n        }\n        assertEquals(1, dateCount, \"No Duplicate Overdraft Interest Posting\");\n    } END"}
{"prompt":"test Savings Daily Interest Posting Job\n\n###\n\n","completion":"    @Test\n    public void testSavingsDailyInterestPostingJob() {\n        \/\/ client activation, savings activation and 1st transaction date\n        final String startDate = \"10 April 2022\";\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPosting(clientID, startDate);\n\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"10000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        \/***\n         * Runs Post interest posting job and verify the new account created with accounting configuration set as none\n         * is picked up by job\n         *\/\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        Object transactionObj = this.savingsAccountHelper.getSavingsDetails(savingsId, \"transactions\");\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) transactionObj;\n        HashMap<String, Object> interestPostingTransaction = transactions.get(transactions.size() - 3);\n        for (Map.Entry<String, Object> entry : interestPostingTransaction.entrySet()) {\n            LOG.info(\"{} - {}\", entry.getKey(), entry.getValue().toString());\n        }\n        assertEquals(\"2.7405\", interestPostingTransaction.get(\"amount\").toString(), \"Equality check for interest posted amount\");\n        assertEquals(\"[2022, 4, 12]\", interestPostingTransaction.get(\"date\").toString(), \"Date check for Interest Posting transaction\");\n    } END"}
{"prompt":"test Savings Daily Overdraft Interest Posting Job\n\n###\n\n","completion":"    @Test\n    public void testSavingsDailyOverdraftInterestPostingJob() {\n        \/\/ client activation, savings activation and 1st transaction date\n        final String startDate = \"10 April 2022\";\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"10000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        \/***\n         * Runs Post interest posting job and verify the new account created with Overdraft is posting negative interest\n         *\/\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        Object transactionObj = this.savingsAccountHelper.getSavingsDetails(savingsId, \"transactions\");\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) transactionObj;\n        HashMap<String, Object> interestPostingTransaction = transactions.get(transactions.size() - 2);\n        for (Map.Entry<String, Object> entry : interestPostingTransaction.entrySet()) {\n            LOG.info(\"{} - {}\", entry.getKey(), entry.getValue().toString());\n        }\n        assertEquals(\"2.7397\", interestPostingTransaction.get(\"amount\").toString(), \"Equality check for overdatft interest posted amount\");\n        assertEquals(\"[2022, 4, 11]\", interestPostingTransaction.get(\"date\").toString(),\n                \"Date check for overdraft Interest Posting transaction\");\n\n    } END"}
{"prompt":"test Account Balance With Withdrawal Fee After Interest Posting Job\n\n###\n\n","completion":"    @Test\n    public void testAccountBalanceWithWithdrawalFeeAfterInterestPostingJob() {\n        final String startDate = \"21 June 2022\";\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingWithCharge(clientID, startDate);\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"1000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(\"800.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account balance is 800\");\n\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        Object transactionObj = this.savingsAccountHelper.getSavingsDetails(savingsId, \"transactions\");\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) transactionObj;\n        HashMap<String, Object> interestPostingTransaction = transactions.get(transactions.size() - 5);\n        for (Map.Entry<String, Object> entry : interestPostingTransaction.entrySet()) {\n            LOG.info(\"{} - {}\", entry.getKey(), entry.getValue().toString());\n        }\n        assertEquals(\"800.4384\", interestPostingTransaction.get(\"runningBalance\").toString(), \"Equality check for Balance\");\n    } END"}
{"prompt":"test Date Format\n\n###\n\n","completion":"    @Test \/\/ FINERACT-926\n    public void testDateFormat() {\n        \/\/ must start scheduler and make job active to have nextRunTime (which\n        \/\/ is a\n        \/\/ java.util.Date)\n        schedulerJobHelper.updateSchedulerStatus(true);\n        int minJobId = schedulerJobHelper.getAllSchedulerJobIds().stream().mapToInt(number -> number).min().orElse(Integer.MAX_VALUE);\n        schedulerJobHelper.updateSchedulerJob(minJobId, true);\n        String nextRunTimeText = await().until(() -> (String) schedulerJobHelper.getSchedulerJobById(minJobId).get(\"nextRunTime\"),\n                Objects::nonNull);\n        DateTimeFormatter.ISO_INSTANT.parse(nextRunTimeText);\n    } END"}
{"prompt":"test Flipping Scheduler Status\n\n###\n\n","completion":"    @Test\n    @Disabled \/\/ TODO FINERACT-1167\n    public void testFlippingSchedulerStatus() throws InterruptedException {\n        \/\/ Retrieving Status of Scheduler\n        Boolean schedulerStatus = schedulerJobHelper.getSchedulerStatus();\n        if (schedulerStatus == true) {\n            schedulerJobHelper.updateSchedulerStatus(false);\n            schedulerStatus = schedulerJobHelper.getSchedulerStatus();\n            \/\/ Verifying Status of the Scheduler after stopping\n            assertEquals(false, schedulerStatus, \"Verifying Scheduler Job Status\");\n        } else {\n            schedulerJobHelper.updateSchedulerStatus(true);\n            schedulerStatus = schedulerJobHelper.getSchedulerStatus();\n            \/\/ Verifying Status of the Scheduler after starting\n            assertEquals(true, schedulerStatus, \"Verifying Scheduler Job Status\");\n        }\n    } END"}
{"prompt":"test Number Of Jobs\n\n###\n\n","completion":"    @Test\n    public void testNumberOfJobs() {\n        List<Integer> jobIds = schedulerJobHelper.getAllSchedulerJobIds();\n        assertEquals(JobName.values().length, jobIds.size(), \"Number of jobs in database and code do not match: \" + jobIds);\n    } END"}
{"prompt":"test Flipping Jobs Active Status\n\n###\n\n","completion":"    @Test\n    public void testFlippingJobsActiveStatus() throws InterruptedException {\n        \/\/ Stop the Scheduler while we test flapping jobs' active on\/off, to\n        \/\/ avoid side\n        \/\/ effects\n        schedulerJobHelper.updateSchedulerStatus(false);\n\n        \/\/ For each retrieved scheduled job (by ID)...\n        for (Integer jobId : schedulerJobHelper.getAllSchedulerJobIds()) {\n            \/\/ Retrieving Scheduler Job by ID\n            Map<String, Object> schedulerJob = schedulerJobHelper.getSchedulerJobById(jobId);\n\n            Boolean active = (Boolean) schedulerJob.get(\"active\");\n            active = !active;\n\n            \/\/ Updating Scheduler Job\n            Map<String, Object> changes = schedulerJobHelper.updateSchedulerJob(jobId, active);\n\n            \/\/ Verifying Scheduler Job updates\n            assertEquals(active, changes.get(\"active\"), \"Verifying Scheduler Job Updates\");\n\n            schedulerJob = schedulerJobHelper.getSchedulerJobById(jobId);\n            assertEquals(active, schedulerJob.get(\"active\"), \"Verifying Get Scheduler Job\");\n        }\n    } END"}
{"prompt":"test Triggering Manual Execution Of All Scheduler Jobs\n\n###\n\n","completion":"    @Test\n    public void testTriggeringManualExecutionOfAllSchedulerJobs() {\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            for (String jobName : schedulerJobHelper.getAllSchedulerJobNames()) {\n                schedulerJobHelper.executeAndAwaitJob(jobName);\n            }\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Apply Annual Fee For Savings Job Outcome\n\n###\n\n","completion":"    @Test\n    public void testApplyAnnualFeeForSavingsJobOutcome() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsProductID = createSavingsProduct(requestSpec, responseSpec,\n                ClientSavingsIntegrationTest.MINIMUM_OPENING_BALANCE);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID,\n                ClientSavingsIntegrationTest.ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        final Integer annualFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper.getSavingsAnnualFeeJSON());\n        Assertions.assertNotNull(annualFeeChargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, annualFeeChargeId, true);\n        ArrayList<HashMap> chargesPendingState = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertEquals(1, chargesPendingState.size());\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        String JobName = \"Apply Annual Fee For Savings\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        final HashMap savingsDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        final HashMap annualFeeDetails = (HashMap) savingsDetails.get(\"annualFee\");\n        ArrayList<Integer> annualFeeDueDateAsArrayList = (ArrayList<Integer>) annualFeeDetails.get(\"dueDate\");\n        LocalDate nextDueDateForAnnualFee = LocalDate.of(annualFeeDueDateAsArrayList.get(0), annualFeeDueDateAsArrayList.get(1),\n                annualFeeDueDateAsArrayList.get(2));\n        LocalDate todaysDate = LocalDate.now(ZoneId.of(\"Asia\/Kolkata\"));\n\n        Truth.assertWithMessage(\"Verifying that all due Annual Fees have been paid\").that(nextDueDateForAnnualFee)\n                .isGreaterThan(todaysDate);\n    } END"}
{"prompt":"test Interest Posting For Savings Job Outcome\n\n###\n\n","completion":"    @Test\n    public void testInterestPostingForSavingsJobOutcome() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsProductID = createSavingsProduct(requestSpec, responseSpec,\n                ClientSavingsIntegrationTest.MINIMUM_OPENING_BALANCE);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID,\n                ClientSavingsIntegrationTest.ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        String JobName = \"Post Interest For Savings\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n        final HashMap summaryAfter = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Assertions.assertNotSame(summaryBefore.get(\"accountBalance\"), summaryAfter.get(\"accountBalance\"),\n                \"Verifying the Balance after running Post Interest for Savings Job\");\n    } END"}
{"prompt":"test Transfer Fee For Loans From Savings Job Outcome\n\n###\n\n","completion":"    @Test\n    public void testTransferFeeForLoansFromSavingsJobOutcome() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsProductID = createSavingsProduct(requestSpec, responseSpec,\n                ClientSavingsIntegrationTest.MINIMUM_OPENING_BALANCE);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID,\n                ClientSavingsIntegrationTest.ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final Integer loanProductID = createLoanProduct(null);\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), savingsId.toString(),\n                \"10 January 2013\");\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(AccountTransferTest.LOAN_APPROVAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        Integer specifiedDueDateChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateWithAccountTransferJSON());\n        Assertions.assertNotNull(specifiedDueDateChargeId);\n\n        this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(specifiedDueDateChargeId.toString(), \"12 March 2013\", \"100\"));\n        ArrayList<HashMap> chargesPendingState = this.loanTransactionHelper.getLoanCharges(loanID);\n        Assertions.assertEquals(1, chargesPendingState.size());\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(AccountTransferTest.LOAN_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        String JobName = \"Transfer Fee For Loans From Savings\";\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n        final HashMap summaryAfter = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        final HashMap chargeData = ChargesHelper.getChargeById(requestSpec, responseSpec, specifiedDueDateChargeId);\n\n        Float chargeAmount = (Float) chargeData.get(\"amount\");\n\n        final Float balance = (Float) summaryBefore.get(\"accountBalance\") - chargeAmount;\n\n        Assertions.assertEquals(balance, (Float) summaryAfter.get(\"accountBalance\"),\n                \"Verifying the Balance after running Transfer Fee for Loans from Savings\");\n    } END"}
{"prompt":"test Apply Holidays To Loans Job Outcome\n\n###\n\n","completion":"    @Test\n    public void testApplyHolidaysToLoansJobOutcome() throws InterruptedException {\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer holidayId = HolidayHelper.createHolidays(requestSpec, responseSpec);\n        Assertions.assertNotNull(holidayId);\n\n        final Integer loanProductID = createLoanProduct(null);\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2013\");\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(AccountTransferTest.LOAN_APPROVAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(AccountTransferTest.LOAN_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        \/\/ Retrieving All Global Configuration details\n        final ArrayList<HashMap> globalConfig = GlobalConfigurationHelper.getAllGlobalConfigurations(requestSpec, responseSpec);\n        Assertions.assertNotNull(globalConfig);\n\n        \/\/ Updating Value for reschedule-repayments-on-holidays Global\n        \/\/ Configuration\n        Integer configId = (Integer) globalConfig.get(3).get(\"id\");\n        Assertions.assertNotNull(configId);\n\n        HashMap configData = GlobalConfigurationHelper.getGlobalConfigurationById(requestSpec, responseSpec, configId.toString());\n        Assertions.assertNotNull(configData);\n\n        Boolean enabled = (Boolean) globalConfig.get(3).get(\"enabled\");\n\n        if (!enabled) {\n            enabled = true;\n            configId = GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(requestSpec, responseSpec, configId, enabled);\n        }\n\n        holidayId = HolidayHelper.activateHolidays(requestSpec, responseSpec, holidayId.toString());\n        Assertions.assertNotNull(holidayId);\n\n        String JobName = \"Apply Holidays To Loans\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        HashMap holidayData = HolidayHelper.getHolidayById(requestSpec, responseSpec, holidayId.toString());\n        ArrayList<Integer> repaymentsRescheduledDate = (ArrayList<Integer>) holidayData.get(\"repaymentsRescheduledTo\");\n\n        Assertions.assertEquals(repaymentsRescheduledDate, repaymentsRescheduledDate,\n                \"Verifying Repayment Rescheduled Date after Running Apply Holidays to Loans Scheduler Job\");\n    } END"}
{"prompt":"test Apply Due Fee Charges For Savings Job Outcome\n\n###\n\n","completion":"    @Test\n    public void testApplyDueFeeChargesForSavingsJobOutcome() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsProductID = createSavingsProduct(requestSpec, responseSpec,\n                ClientSavingsIntegrationTest.MINIMUM_OPENING_BALANCE);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID,\n                ClientSavingsIntegrationTest.ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        final Integer specifiedDueDateChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getSavingsSpecifiedDueDateJSON());\n        Assertions.assertNotNull(specifiedDueDateChargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, specifiedDueDateChargeId, true);\n        ArrayList<HashMap> chargesPendingState = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertEquals(1, chargesPendingState.size());\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        String JobName = \"Pay Due Savings Charges\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n        HashMap summaryAfter = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        final HashMap chargeData = ChargesHelper.getChargeById(requestSpec, responseSpec, specifiedDueDateChargeId);\n\n        Float chargeAmount = (Float) chargeData.get(\"amount\");\n\n        final Float balance = (Float) summaryBefore.get(\"accountBalance\") - chargeAmount;\n\n        Assertions.assertEquals(balance, (Float) summaryAfter.get(\"accountBalance\"),\n                \"Verifying the Balance after running Pay due Savings Charges\");\n    } END"}
{"prompt":"test Update Accounting Running Balances Job Outcome\n\n###\n\n","completion":"    @Test\n    public void testUpdateAccountingRunningBalancesJobOutcome() {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer accountID = assetAccount.getAccountID();\n\n        final Integer savingsProductID = createSavingsProduct(MINIMUM_OPENING_BALANCE, assetAccount, incomeAccount, expenseAccount,\n                liabilityAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n        final Integer savingsID = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, savingsID);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsID);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsID);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        \/\/ Checking initial Account entries.\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(SP_BALANCE, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liabilityAccountInitialEntry = { new JournalEntry(SP_BALANCE, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, TRANSACTION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, TRANSACTION_DATE, liabilityAccountInitialEntry);\n\n        String JobName = \"Update Accounting Running Balances\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n        final HashMap runningBalanceAfter = this.accountHelper.getAccountingWithRunningBalanceById(accountID.toString());\n\n        final Integer INT_BALANCE = Integer.valueOf(MINIMUM_OPENING_BALANCE);\n\n        Assertions.assertEquals(INT_BALANCE, runningBalanceAfter.get(\"organizationRunningBalance\"),\n                \"Verifying Account Running Balance after running Update Accounting Running Balances Scheduler Job\");\n    } END"}
{"prompt":"test Update Loan Arrears Aging Job Outcome\n\n###\n\n","completion":"    @Test\n    public void testUpdateLoanArrearsAgingJobOutcome() {\n        loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        final Integer loanProductID = createLoanProduct(null);\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2013\");\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = loanTransactionHelper.approveLoan(AccountTransferTest.LOAN_APPROVAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(AccountTransferTest.LOAN_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        String JobName = \"Update Loan Arrears Ageing\";\n\n        schedulerJobHelper.executeAndAwaitJob(JobName);\n        HashMap loanSummaryData = loanTransactionHelper.getLoanSummary(requestSpec, responseSpec, loanID);\n\n        Float totalLoanArrearsAging = (Float) loanSummaryData.get(\"principalOverdue\") + (Float) loanSummaryData.get(\"interestOverdue\");\n\n        Assertions.assertEquals(totalLoanArrearsAging, loanSummaryData.get(\"totalOverdue\"),\n                \"Verifying Arrears Aging after Running Update Loan Arrears Aging Scheduler Job\");\n    } END"}
{"prompt":"test Execute Standing Instructions Job Outcome\n\n###\n\n","completion":"    @Test\n    public void testExecuteStandingInstructionsJobOutcome() throws InterruptedException {\n        savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        StandingInstructionsHelper standingInstructionsHelper = new StandingInstructionsHelper(requestSpec, responseSpec);\n\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n        final DateTimeFormatter monthDayFormat = DateTimeFormatter.ofPattern(\"dd MMMM\", Locale.US);\n\n        \/\/ Create the LocalDate with the Zone used by default\n        final LocalDate localDate = LocalDate.now(this.systemTimeZone.toZoneId());\n        ZonedDateTime currentDate = ZonedDateTime.of(localDate, LocalTime.MIDNIGHT, this.systemTimeZone.toZoneId());\n        \/\/ When the Stanging Instruction will be applied\n        final String MONTH_DAY = monthDayFormat.format(currentDate.toLocalDate());\n        \/\/ Standing Instruction valid from (One week before today)\n        currentDate = currentDate.minus(Duration.ofDays(7));\n        final String VALID_FROM = dateFormat.format(currentDate);\n        \/\/ Standing Instruction valid to (One year after)\n        currentDate = currentDate.plus(1, ChronoUnit.YEARS);\n        final String VALID_TO = dateFormat.format(currentDate);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsProductID = createSavingsProduct(requestSpec, responseSpec,\n                ClientSavingsIntegrationTest.MINIMUM_OPENING_BALANCE);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer fromSavingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID,\n                ClientSavingsIntegrationTest.ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap fromSavingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, fromSavingsId);\n        SavingsStatusChecker.verifySavingsIsPending(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.approveSavings(fromSavingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.activateSavings(fromSavingsId);\n        SavingsStatusChecker.verifySavingsIsActive(fromSavingsStatusHashMap);\n\n        final Integer toSavingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID,\n                ClientSavingsIntegrationTest.ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap toSavingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, toSavingsId);\n        SavingsStatusChecker.verifySavingsIsPending(toSavingsStatusHashMap);\n\n        toSavingsStatusHashMap = this.savingsAccountHelper.approveSavings(toSavingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(toSavingsStatusHashMap);\n\n        toSavingsStatusHashMap = this.savingsAccountHelper.activateSavings(toSavingsId);\n        SavingsStatusChecker.verifySavingsIsActive(toSavingsStatusHashMap);\n\n        HashMap fromSavingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(fromSavingsId);\n        Float fromSavingsBalanceBefore = (Float) fromSavingsSummaryBefore.get(\"accountBalance\");\n\n        HashMap toSavingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(toSavingsId);\n        Float toSavingsBalanceBefore = (Float) toSavingsSummaryBefore.get(\"accountBalance\");\n\n        Integer standingInstructionId = standingInstructionsHelper.createStandingInstruction(clientID.toString(), fromSavingsId.toString(),\n                toSavingsId.toString(), FROM_ACCOUNT_TYPE_SAVINGS, TO_ACCOUNT_TYPE_SAVINGS, VALID_FROM, VALID_TO, MONTH_DAY);\n        Assertions.assertNotNull(standingInstructionId);\n\n        String JobName = \"Execute Standing Instruction\";\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n        HashMap fromSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(fromSavingsId);\n        Float fromSavingsBalanceAfter = (Float) fromSavingsSummaryAfter.get(\"accountBalance\");\n\n        HashMap toSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(toSavingsId);\n        Float toSavingsBalanceAfter = (Float) toSavingsSummaryAfter.get(\"accountBalance\");\n\n        final HashMap standingInstructionData = standingInstructionsHelper.getStandingInstructionById(standingInstructionId.toString());\n        Float expectedFromSavingsBalance = fromSavingsBalanceBefore - (Float) standingInstructionData.get(\"amount\");\n        Float expectedToSavingsBalance = toSavingsBalanceBefore + (Float) standingInstructionData.get(\"amount\");\n\n        Assertions.assertEquals(expectedFromSavingsBalance, fromSavingsBalanceAfter,\n                \"Verifying From Savings Balance after Successful completion of Scheduler Job\");\n        Assertions.assertEquals(expectedToSavingsBalance, toSavingsBalanceAfter,\n                \"Verifying To Savings Balance after Successful completion of Scheduler Job\");\n        Integer fromAccountType = PortfolioAccountType.SAVINGS.getValue();\n        Integer transferType = AccountTransferType.ACCOUNT_TRANSFER.getValue();\n        List<HashMap> standingInstructionHistoryData = standingInstructionsHelper.getStandingInstructionHistory(fromSavingsId,\n                fromAccountType, clientID, transferType);\n        Assertions.assertEquals(1, standingInstructionHistoryData.size(),\n                \"Verifying the no of standing instruction transactions logged for the client\");\n        HashMap loggedTransaction = standingInstructionHistoryData.get(0);\n\n        Assertions.assertEquals((Float) standingInstructionData.get(\"amount\"), (Float) loggedTransaction.get(\"amount\"),\n                \"Verifying transferred amount and logged transaction amounts\");\n    } END"}
{"prompt":"test Apply Penalty For Overdue Loans Job Outcome\n\n###\n\n","completion":"    @Test\n    public void testApplyPenaltyForOverdueLoansJobOutcome() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper.getLoanOverdueFeeJSON());\n        Assertions.assertNotNull(overdueFeeChargeId);\n\n        final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        String JobName = \"Apply penalty to overdue loans\";\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        final HashMap chargeData = ChargesHelper.getChargeById(requestSpec, responseSpec, overdueFeeChargeId);\n\n        Float chargeAmount = (Float) chargeData.get(\"amount\");\n\n        ArrayList<HashMap> repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec,\n                loanID);\n\n        Assertions.assertEquals(chargeAmount, (Float) repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                \"Verifying From Penalty Charges due fot first Repayment after Successful completion of Scheduler Job\");\n\n        loanStatusHashMap = this.loanTransactionHelper.undoDisbursal(loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n    } END"}
{"prompt":"test Apply Penalty For Overdue Loans Job Outcome If Loan Charged Off\n\n###\n\n","completion":"    @Test\n    public void testApplyPenaltyForOverdueLoansJobOutcomeIfLoanChargedOff() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper.getLoanOverdueFeeJSON());\n        Assertions.assertNotNull(overdueFeeChargeId);\n\n        final Integer loanProductID = createLoanProductNoInterest(overdueFeeChargeId.toString());\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplicationNoInterest(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        this.loanTransactionHelper.chargeOffLoan((long) loanID,\n                new PostLoansLoanIdTransactionsRequest().transactionDate(\"03 March 2020\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n\n        String JobName = \"Apply penalty to overdue loans\";\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        ArrayList<HashMap> repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec,\n                loanID);\n\n        Assertions.assertEquals(0, (Integer) repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                \"Verifying From Penalty Charges due fot first Repayment after Successful completion of Scheduler Job\");\n\n    } END"}
{"prompt":"test Loan COBJob Outcome\n\n###\n\n","completion":"    @Test\n    public void testLoanCOBJobOutcome() {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n        Assertions.assertNotNull(overdueFeeChargeId);\n\n        Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n        Assertions.assertNotNull(fee);\n\n        final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n        Assertions.assertNotNull(loanProductID);\n        List<Integer> loanIDs = new ArrayList<>();\n        HashMap loanStatusHashMap;\n        for (int i = 0; i < 3; i++) {\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n            loanIDs.add(loanID);\n\n            this.loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), \"02 March 2020\", \"10\", null));\n        }\n\n        String jobName = \"Loan COB\";\n        this.schedulerJobHelper.executeAndAwaitJob(jobName);\n        for (Integer loanId : loanIDs) {\n            List<HashMap> repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec,\n                    loanId);\n\n            Assertions.assertEquals(10.00f, (Float) repaymentScheduleDataAfter.get(1).get(\"feeChargesDue\"),\n                    \"Verifying From Fee Charges due for first Repayment after Successful completion of Scheduler Job\");\n            Assertions.assertEquals(39.39f, (Float) repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due for first Repayment after Successful completion of Scheduler Job\");\n            Assertions.assertEquals(39.39f, (Float) repaymentScheduleDataAfter.get(2).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due for first Repayment after Successful completion of Scheduler Job\");\n            Assertions.assertEquals(39.39f, (Float) repaymentScheduleDataAfter.get(3).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due for first Repayment after Successful completion of Scheduler Job\");\n            Assertions.assertEquals(39.39f, (Float) repaymentScheduleDataAfter.get(4).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due for first Repayment after Successful completion of Scheduler Job\");\n\n        }\n    } END"}
{"prompt":"test Loan COBJob Outcome While Adding Fee On Disbursement Date\n\n###\n\n","completion":"    @Test\n    public void testLoanCOBJobOutcomeWhileAddingFeeOnDisbursementDate() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n            this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n            Assertions.assertNotNull(fee);\n\n            final Integer loanProductID = createLoanProductWithPeriodicAccrual(null);\n            Assertions.assertNotNull(loanProductID);\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            this.loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), \"02 March 2020\", \"10\", null));\n\n            String jobName = \"Loan COB\";\n            this.schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            List<HashMap> repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec,\n                    loanID);\n\n            Assertions.assertEquals(10.00f, (Float) repaymentScheduleDataAfter.get(1).get(\"feeChargesDue\"),\n                    \"Verifying From Fee Charges due for first Repayment after Successful completion of Scheduler Job\");\n\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            \/\/ First accrual transaction\n            assertTrue(getLoansLoanIdResponse.getTransactions().get(1).getType().getAccrual());\n            assertEquals(10.0f, getLoansLoanIdResponse.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(LocalDate.of(2020, 3, 2), getLoansLoanIdResponse.getTransactions().get(1).getDate());\n            Long transactionId = getLoansLoanIdResponse.getTransactions().get(1).getId();\n\n            final GetJournalEntriesTransactionIdResponse journalEntriesResponse = journalEntryHelper.getJournalEntries(\"L\" + transactionId);\n            assertNotNull(journalEntriesResponse);\n            final List<JournalEntryTransactionItem> journalEntries = journalEntriesResponse.getPageItems();\n            assertEquals(2, journalEntries.size());\n            assertEquals(10, journalEntries.get(0).getAmount());\n            assertEquals(10, journalEntries.get(1).getAmount());\n            assertEquals(LocalDate.of(2020, 3, 2), journalEntries.get(1).getTransactionDate());\n            assertEquals(LocalDate.of(2020, 3, 2), journalEntries.get(0).getTransactionDate());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Loan COBRuns Only On Loans One Day Behind\n\n###\n\n","completion":"    @Test\n    public void testLoanCOBRunsOnlyOnLoansOneDayBehind() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            String jobName = \"Loan COB\";\n\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 2), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 3));\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 3), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 5));\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 3), loan.getLastClosedBusinessDate());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Loan COBApply Penalty On Due\n\n###\n\n","completion":"    @Test\n    public void testLoanCOBApplyPenaltyOnDue() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            \/\/ set penalty wait period to 0\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"0\");\n            this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 4, 1));\n            String jobName = \"Loan COB\";\n\n            this.schedulerJobHelper.executeAndAwaitJob(jobName);\n            List<HashMap> repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec,\n                    loanID);\n            Assertions.assertEquals(0, (Integer) repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due fot first Repayment after Successful completion of Scheduler Job\");\n\n            LocalDate lastBusinessDateBeforeFastForward = LocalDate.of(2020, 4, 2);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, lastBusinessDateBeforeFastForward);\n            this.schedulerJobHelper.executeAndAwaitJob(jobName);\n            repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(39.39f, (Float) repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due fot first Repayment after Successful completion of Scheduler Job\");\n\n            List<Map> transactions = this.loanTransactionHelper.getLoanTransactions(this.requestSpec, this.responseSpec, loanID);\n            Assertions.assertEquals(39.39f, (Float) transactions.get(2).get(\"amount\"));\n            Assertions.assertEquals(2020, ((List) transactions.get(2).get(\"date\")).get(0));\n            Assertions.assertEquals(4, ((List) transactions.get(2).get(\"date\")).get(1));\n            Assertions.assertEquals(2, ((List) transactions.get(2).get(\"date\")).get(2));\n\n            \/\/ Test penalty where there is 1 day grace period\n            final Integer loanID2 = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID2);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID2);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 April 2020\", loanID2);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails2 = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID2);\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 April 2020\", loanID2,\n                    JsonPath.from(loanDetails2).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"1\");\n            LocalDate dateToFastForward = LocalDate.of(2020, 5, 2);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, dateToFastForward);\n            this.schedulerJobHelper.executeAndAwaitJob(jobName);\n            repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID2);\n            Assertions.assertEquals(0, (Integer) repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due fot first Repayment after Successful completion of Scheduler Job\");\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 5, 3));\n            this.schedulerJobHelper.executeAndAwaitJob(jobName);\n            repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID2);\n            Assertions.assertEquals(39.39f, (Float) repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due fot first Repayment after Successful completion of Scheduler Job\");\n\n            transactions = this.loanTransactionHelper.getLoanTransactions(this.requestSpec, this.responseSpec, loanID2);\n            Assertions.assertEquals(39.39f, (Float) transactions.get(2).get(\"amount\"));\n            Assertions.assertEquals(2020, ((List) transactions.get(2).get(\"date\")).get(0));\n            Assertions.assertEquals(5, ((List) transactions.get(2).get(\"date\")).get(1));\n            Assertions.assertEquals(2, ((List) transactions.get(2).get(\"date\")).get(2));\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"2\");\n        }\n    } END"}
{"prompt":"test Avoid Unncessary Penalty When Amount Zero For Overdue Loans Job Outcome\n\n###\n\n","completion":"    @Test\n    public void testAvoidUnncessaryPenaltyWhenAmountZeroForOverdueLoansJobOutcome() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"0.000001\"));\n        Assertions.assertNotNull(overdueFeeChargeId);\n\n        final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2013\");\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(AccountTransferTest.LOAN_APPROVAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(AccountTransferTest.LOAN_APPROVAL_DATE_PLUS_ONE,\n                loanID, JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        String JobName = \"Apply penalty to overdue loans\";\n        int jobId = 12;\n\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        Map<String, Object> schedulerJob = this.schedulerJobHelper.getSchedulerJobById(jobId);\n\n        Assertions.assertNotNull(schedulerJob);\n        while ((Boolean) schedulerJob.get(\"currentlyRunning\")) {\n            Thread.sleep(15000);\n            schedulerJob = this.schedulerJobHelper.getSchedulerJobById(jobId);\n            Assertions.assertNotNull(schedulerJob);\n        }\n\n        ArrayList<HashMap> repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec,\n                loanID);\n\n        Assertions.assertEquals(0, repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                \"Verifying From Penalty Charges due fot first Repayment after Successful completion of Scheduler Job\");\n\n        final List<?> loanCharges = this.loanTransactionHelper.getLoanCharges(requestSpec, responseSpec, loanID);\n        Assertions.assertNull(loanCharges, \"Verifying that charge isn't created when the amount is 0\");\n\n        loanStatusHashMap = this.loanTransactionHelper.undoDisbursal(loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n    } END"}
{"prompt":"test Update Overdue Days For NPA\n\n###\n\n","completion":"    @Test\n    public void testUpdateOverdueDaysForNPA() throws InterruptedException {\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        final Integer loanProductID = createLoanProduct(null);\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2013\");\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(AccountTransferTest.LOAN_APPROVAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(AccountTransferTest.LOAN_APPROVAL_DATE_PLUS_ONE,\n                loanID, JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final Boolean isNPABefore = (Boolean) this.loanTransactionHelper.getLoanDetail(requestSpec, responseSpec, loanID, \"isNPA\");\n        Assertions.assertFalse(isNPABefore);\n        String JobName = \"Update Non Performing Assets\";\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n        final Boolean isNPAAfter = (Boolean) this.loanTransactionHelper.getLoanDetail(requestSpec, responseSpec, loanID, \"isNPA\");\n        assertTrue(isNPAAfter);\n    } END"}
{"prompt":"test Interest Transfer For Savings\n\n###\n\n","completion":"    @Test\n    public void testInterestTransferForSavings() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        FixedDepositAccountHelper fixedDepositAccountHelper = new FixedDepositAccountHelper(requestSpec, responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -2);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.MONTH, 1);\n        final String WHOLE_TERM = \"1\";\n\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientId);\n        Float balance = Float.parseFloat(MINIMUM_OPENING_BALANCE) + Float.parseFloat(FixedDepositAccountHelper.DEPOSIT_AMOUNT);\n        final Integer savingsProductID = createSavingsProduct(requestSpec, responseSpec, String.valueOf(balance));\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientId, savingsProductID,\n                ClientSavingsIntegrationTest.ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        HashMap summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM, savingsId.toString());\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(requestSpec,\n                responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n        summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(MINIMUM_OPENING_BALANCE);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance\");\n\n        fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n\n        HashMap fixedDepositSummary = savingsAccountHelper.getSavingsSummary(fixedDepositAccountId);\n        float interestPosted = (Float) fixedDepositSummary.get(\"accountBalance\")\n                - Float.parseFloat(FixedDepositAccountHelper.DEPOSIT_AMOUNT);\n\n        String JobName = \"Transfer Interest To Savings\";\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n        fixedDepositSummary = savingsAccountHelper.getSavingsSummary(fixedDepositAccountId);\n        assertEquals(Float.parseFloat(FixedDepositAccountHelper.DEPOSIT_AMOUNT), fixedDepositSummary.get(\"accountBalance\"),\n                \"Verifying opening Balance\");\n\n        summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(MINIMUM_OPENING_BALANCE) + interestPosted;\n        validateNumberForEqualExcludePrecision(String.valueOf(balance), String.valueOf(summary.get(\"accountBalance\")));\n    } END"}
{"prompt":"business Date Is Correct For Cron Job\n\n###\n\n","completion":"    @Test\n    public void businessDateIsCorrectForCronJob() throws InterruptedException {\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2022.09.04\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account assetFeeAndPenaltyAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            final String loanProductJSON = new LoanProductTestBuilder().withPrincipal(\"1000\").withRepaymentTypeAsMonth()\n                    .withRepaymentAfterEvery(\"1\").withNumberOfRepayments(\"1\").withRepaymentTypeAsMonth().withinterestRatePerPeriod(\"0\")\n                    .withInterestRateFrequencyTypeAsMonths().withAmortizationTypeAsEqualPrincipalPayment().withInterestTypeAsFlat()\n                    .withAccountingRulePeriodicAccrual(new Account[] { assetAccount, incomeAccount, expenseAccount, overpaymentAccount })\n                    .withDaysInMonth(\"30\").withDaysInYear(\"365\").withMoratorium(\"0\", \"0\")\n                    .withFeeAndPenaltyAssetAccount(assetFeeAndPenaltyAccount).build(null);\n            final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJSON);\n\n            final PostClientsResponse client = clientHelper.createClient(ClientHelper.defaultClientCreationRequest());\n\n            Integer loanId = applyForLoanApplication(client.getClientId().toString(), loanProductID.toString(), null, \"02 September 2022\");\n\n            this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanId);\n            this.loanTransactionHelper.disburseLoan(\"03 September 2022\", loanId, \"1000\", null);\n\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2022.09.05\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            LocalDate targetDate = LocalDate.of(2022, 9, 5);\n            String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            this.loanTransactionHelper.addChargesForLoan(loanId, LoanTransactionHelper\n                    .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\", null));\n            this.schedulerJobHelper.updateSchedulerJob(16L, new PutJobsJobIDRequest().cronExpression(\"0\/5 * * * * ?\"));\n\n            Thread.sleep(11000);\n            GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(1).getDate());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n\n        try {\n            this.schedulerJobHelper.updateSchedulerJob(16L, new PutJobsJobIDRequest().cronExpression(\"0 2 0 1\/1 * ? *\"));\n        } catch (CallFailedRuntimeException e) {\n            \/\/ Try again (maybe it was executed by scheduler at the same time when it was called... :\/\n            Thread.sleep(2000);\n            this.schedulerJobHelper.updateSchedulerJob(16L, new PutJobsJobIDRequest().cronExpression(\"0 2 0 1\/1 * ? *\"));\n        }\n    } END"}
{"prompt":"test Datatable Creation For Share Product\n\n###\n\n","completion":"    @Test\n    public void testDatatableCreationForShareProduct() {\n        \/\/ create dataTable\n        String datatableName = Utils.uniqueRandomStringGenerator(\"dt_\" + SHARES_APP_TABLE_NAME + \"_\", 5).toLowerCase().toLowerCase();\n        String column1Name = \"aNumber\";\n        String column2Name = \"aString\";\n\n        PostDataTablesRequest request = new PostDataTablesRequest();\n        request.setDatatableName(datatableName);\n        request.setApptableName(SHARES_APP_TABLE_NAME);\n        request.setMultiRow(false);\n\n        PostColumnHeaderData column1HeaderRequestData = new PostColumnHeaderData();\n        column1HeaderRequestData.setName(column1Name);\n        column1HeaderRequestData.setType(\"Number\");\n        column1HeaderRequestData.setMandatory(false);\n        column1HeaderRequestData.setLength(10L);\n        column1HeaderRequestData.setCode(\"\");\n        column1HeaderRequestData.setUnique(false);\n        column1HeaderRequestData.setIndexed(false);\n\n        request.addColumnsItem(column1HeaderRequestData);\n\n        PostColumnHeaderData column2HeaderRequestData = new PostColumnHeaderData();\n        column2HeaderRequestData.setName(column2Name);\n        column2HeaderRequestData.setType(\"String\");\n        column2HeaderRequestData.setMandatory(false);\n        column2HeaderRequestData.setLength(10L);\n        column2HeaderRequestData.setCode(\"\");\n        column2HeaderRequestData.setUnique(false);\n        column2HeaderRequestData.setIndexed(false);\n\n        request.addColumnsItem(column2HeaderRequestData);\n\n        PostDataTablesResponse response = datatableHelper.createDatatable(request);\n\n        assertNotNull(response.getResourceIdentifier());\n\n        \/\/ verify Datatable got created\n        GetDataTablesResponse dataTable = datatableHelper.getDataTableDetails(datatableName);\n\n        \/\/ verfify columns\n        List<ResultsetColumnHeaderData> columnHeaderData = dataTable.getColumnHeaderData();\n        assertNotNull(columnHeaderData);\n\n        \/\/ two columns with 1 primary key and 2 audit columns created\n        assertEquals(columnHeaderData.size(), 5);\n    } END"}
{"prompt":"test Datatable Entry For Share Product\n\n###\n\n","completion":"    @Test\n    public void testDatatableEntryForShareProduct() {\n        \/\/ create Shares Product\n        shareProductHelper = new ShareProductHelper();\n        final Integer shareProductId = createShareProduct();\n\n        assertNotNull(shareProductId);\n\n        \/\/ create dataTable\n        String datatableName = Utils.uniqueRandomStringGenerator(\"dt_\" + SHARES_APP_TABLE_NAME + \"_\", 5).toLowerCase().toLowerCase();\n        String column1Name = \"aNumber\";\n\n        PostDataTablesRequest request = new PostDataTablesRequest();\n        request.setDatatableName(datatableName);\n        request.setApptableName(SHARES_APP_TABLE_NAME);\n        request.setMultiRow(true);\n\n        PostColumnHeaderData column1HeaderRequestData = new PostColumnHeaderData();\n        column1HeaderRequestData.setName(column1Name);\n        column1HeaderRequestData.setType(\"Number\");\n        column1HeaderRequestData.setMandatory(false);\n        column1HeaderRequestData.setLength(10L);\n        column1HeaderRequestData.setCode(\"\");\n        column1HeaderRequestData.setUnique(false);\n        column1HeaderRequestData.setIndexed(false);\n\n        request.addColumnsItem(column1HeaderRequestData);\n\n        PostDataTablesResponse response = datatableHelper.createDatatable(request);\n\n        assertNotNull(response);\n\n        String datatableId = response.getResourceIdentifier();\n\n        \/\/ add entries\n        final HashMap<String, Object> datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(column1Name, Utils.randomNumberGenerator(5));\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(\"dateFormat\", \"yyyy-MM-dd\");\n\n        String datatabelEntryRequestJsonString = new Gson().toJson(datatableEntryMap);\n\n        final boolean genericResultSet = true;\n\n        HashMap<String, Object> datatableEntryResponseFirst = this.datatableHelper.createDatatableEntry(datatableId, shareProductId,\n                genericResultSet, datatabelEntryRequestJsonString);\n        HashMap<String, Object> datatableEntryResponseSecond = this.datatableHelper.createDatatableEntry(datatableId, shareProductId,\n                genericResultSet, datatabelEntryRequestJsonString);\n\n        assertNotNull(datatableEntryResponseFirst.get(\"resourceId\"));\n        assertNotNull(datatableEntryResponseSecond.get(\"resourceId\"));\n\n        \/\/ Read the Datatable entry generated with genericResultSet\n        HashMap<String, Object> items = this.datatableHelper.readDatatableEntry(datatableId, shareProductId, genericResultSet, null, \"\");\n        assertNotNull(items);\n        assertEquals(2, ((List) items.get(\"data\")).size());\n    } END"}
{"prompt":"test Skipping Repayment On First Day Of Month\n\n###\n\n","completion":"    @Test\n    public void testSkippingRepaymentOnFirstDayOfMonth() {\n        this.globalConfigurationHelper = new GlobalConfigurationHelper(this.requestSpec, this.responseSpec);\n\n        \/\/ Retrieving All Global Configuration details\n        final ArrayList<HashMap> globalConfig = GlobalConfigurationHelper.getAllGlobalConfigurations(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(globalConfig);\n\n        String configName = \"skip-repayment-on-first-day-of-month\";\n        boolean newBooleanValue = true;\n\n        for (Integer configIndex = 0; configIndex < globalConfig.size(); configIndex++) {\n            if (globalConfig.get(configIndex).get(\"name\").equals(configName)) {\n                String configId = globalConfig.get(configIndex).get(\"id\").toString();\n                Integer updateConfigId = GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec,\n                        this.responseSpec, configId.toString(), newBooleanValue);\n                Assertions.assertNotNull(updateConfigId);\n                break;\n            }\n        }\n\n    } END"}
{"prompt":"check Repayment Skip On First Day Of Month\n\n###\n\n","completion":"    @Test\n    public void checkRepaymentSkipOnFirstDayOfMonth() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        final String startDate = \"15 September 2011\";\n        final String frequency = \"3\"; \/\/ Monthly\n        final String interval = \"1\"; \/\/ Every One Moth\n        Integer calendarID = CalendarHelper.createMeetingForGroup(requestSpec, responseSpec, groupID, startDate, frequency, interval, null);\n        LOG.info(\"caladerId -------------------- {}\", calendarID);\n        final Integer loanProductID = createLoanProduct();\n        final Integer loanID = applyForLoanApplication(groupID, loanProductID, calendarID, clientID);\n        LOG.info(\"loanID---- {}\", loanID);\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec,\n                loanID);\n        verifyLoanRepaymentSchedule(loanSchedule);\n\n    } END"}
{"prompt":"test Staff Create\n\n###\n\n","completion":"    @Test\n    public void testStaffCreate() {\n        Map<String, Object> response = StaffHelper.createStaffMap(requestSpec, responseSpec);\n\n        Assertions.assertNotNull(response);\n        Assertions.assertEquals(1, response.get(\"officeId\"));\n        Assertions.assertNotNull(response.get(\"resourceId\"));\n    } END"}
{"prompt":"test Staff Create Validation Error\n\n###\n\n","completion":"    @Test\n    public void testStaffCreateValidationError() {\n        final String noOfficeJson = StaffHelper.createStaffWithJSONFields(\"firstname\", \"lastname\");\n        final String noFirstnameJson = StaffHelper.createStaffWithJSONFields(\"officeId\", \"lastname\");\n        final String noLastnameJson = StaffHelper.createStaffWithJSONFields(\"officeId\", \"firstname\");\n\n        StaffHelper.createStaffWithJson(requestSpec, responseSpecForValidationError, noOfficeJson);\n        StaffHelper.createStaffWithJson(requestSpec, responseSpecForValidationError, noFirstnameJson);\n        StaffHelper.createStaffWithJson(requestSpec, responseSpecForValidationError, noLastnameJson);\n\n        final Map<String, Object> map = StaffHelper.getMapWithJoiningDate();\n\n        map.put(\"officeId\", 1);\n        map.put(\"firstname\", Utils.uniqueRandomStringGenerator(\"michael_\", 5));\n        map.put(\"lastname\", Utils.uniqueRandomStringGenerator(\"Doe_\", 4));\n\n        \/** Long firstname test *\/\n        map.put(\"firstname\", Utils.uniqueRandomStringGenerator(\"michael_\", 43));\n        StaffHelper.createStaffWithJson(requestSpec, responseSpecForValidationError, new Gson().toJson(map));\n        map.put(\"firstname\", Utils.uniqueRandomStringGenerator(\"michael_\", 5));\n\n        \/** Long lastname test *\/\n        map.put(\"lastname\", Utils.uniqueRandomStringGenerator(\"Doe_\", 47));\n        StaffHelper.createStaffWithJson(requestSpec, responseSpecForValidationError, new Gson().toJson(map));\n        map.put(\"lastname\", Utils.uniqueRandomStringGenerator(\"Doe_\", 4));\n\n        \/** Long mobileNo test *\/\n        map.put(\"mobileNo\", Utils.uniqueRandomStringGenerator(\"num_\", 47));\n        StaffHelper.createStaffWithJson(requestSpec, responseSpecForValidationError, new Gson().toJson(map));\n    } END"}
{"prompt":"test Staff Create Max Name Length\n\n###\n\n","completion":"    @Test\n    public void testStaffCreateMaxNameLength() {\n\n        final Map<String, Object> map = StaffHelper.getMapWithJoiningDate();\n\n        map.put(\"officeId\", 1);\n        map.put(\"firstname\", Utils.uniqueRandomStringGenerator(\"michael_\", 42));\n        map.put(\"lastname\", Utils.uniqueRandomStringGenerator(\"Doe_\", 46));\n\n        StaffHelper.createStaffWithJson(requestSpec, responseSpec, new Gson().toJson(map));\n    } END"}
{"prompt":"test Staff Create External Id Validation Error\n\n###\n\n","completion":"    @Test\n    public void testStaffCreateExternalIdValidationError() {\n        final Map<String, Object> map = StaffHelper.getMapWithJoiningDate();\n\n        map.put(\"officeId\", 1);\n        map.put(\"firstname\", Utils.uniqueRandomStringGenerator(\"michael_\", 5));\n        map.put(\"lastname\", Utils.uniqueRandomStringGenerator(\"Doe_\", 4));\n\n        map.put(\"externalId\", Utils.randomStringGenerator(\"EXT\", 98));\n        StaffHelper.createStaffWithJson(requestSpec, responseSpecForValidationError, new Gson().toJson(map));\n    } END"}
{"prompt":"test Staff Fetch\n\n###\n\n","completion":"    @Test\n    public void testStaffFetch() {\n        Map<String, Object> response = StaffHelper.getStaff(requestSpec, responseSpec, 1);\n        Assertions.assertNotNull(response);\n        Assertions.assertNotNull(response.get(\"id\"));\n        Assertions.assertEquals(1, response.get(\"id\"));\n    } END"}
{"prompt":"test Staff List Fetch\n\n###\n\n","completion":"    @Test\n    public void testStaffListFetch() {\n        StaffHelper.getStaffList(requestSpec, responseSpec);\n    } END"}
{"prompt":"test Staff List Status All\n\n###\n\n","completion":"    @Test\n    public void testStaffListStatusAll() {\n        StaffHelper.getStaffListWithState(requestSpec, responseSpec, \"all\");\n    } END"}
{"prompt":"test Staff List Status Active\n\n###\n\n","completion":"    @Test\n    public void testStaffListStatusActive() {\n        List<Map<String, Object>> responseActive = StaffHelper.getStaffListWithState(requestSpec, responseSpec, \"active\");\n        for (final Map<String, Object> staff : responseActive) {\n            Assertions.assertNotNull(staff.get(\"id\"));\n            Assertions.assertEquals(true, staff.get(\"isActive\"));\n        }\n    } END"}
{"prompt":"test Staff List Status Inactive\n\n###\n\n","completion":"    @Test\n    public void testStaffListStatusInactive() {\n        List<Map<String, Object>> responseInactive = StaffHelper.getStaffListWithState(requestSpec, responseSpec, \"inactive\");\n        for (final Map<String, Object> staff : responseInactive) {\n            Assertions.assertNotNull(staff.get(\"id\"));\n            Assertions.assertEquals(false, staff.get(\"isActive\"));\n        }\n    } END"}
{"prompt":"test Staff List Fetch Wrong State\n\n###\n\n","completion":"    @Test \/\/ because \"xyz\" will return an error, not a List\n    public void testStaffListFetchWrongState() throws ClassCastException {\n        Assertions.assertThrows(ClassCastException.class, () -> {\n            StaffHelper.getStaffListWithState(requestSpec, responseSpecForValidationError, \"xyz\");\n        });\n    } END"}
{"prompt":"test Staff Fetch Not Found\n\n###\n\n","completion":"    @Test\n    public void testStaffFetchNotFound() {\n        StaffHelper.getStaff(requestSpec, responseSpecForNotFoundError, Integer.MAX_VALUE);\n    } END"}
{"prompt":"test Staff Update\n\n###\n\n","completion":"    @Test\n    public void testStaffUpdate() {\n        final Map<String, Object> map = new HashMap<>();\n        final String firstname = Utils.uniqueRandomStringGenerator(\"michael_\", 10);\n        final String lastname = Utils.uniqueRandomStringGenerator(\"Doe_\", 10);\n        final String externalId = UUID.randomUUID().toString();\n        final String mobileNo = Utils.uniqueRandomStringGenerator(\"num_\", 10);\n\n        map.put(\"firstname\", firstname);\n        map.put(\"lastname\", lastname);\n        map.put(\"externalId\", externalId);\n        map.put(\"mobileNo\", mobileNo);\n\n        Map<String, Object> response = StaffHelper.updateStaff(requestSpec, responseSpec, 1, map);\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> changes = (Map<String, Object>) response.get(\"changes\");\n\n        Assertions.assertEquals(1, response.get(\"resourceId\"));\n        Assertions.assertEquals(firstname, changes.get(\"firstname\"));\n        Assertions.assertEquals(lastname, changes.get(\"lastname\"));\n        Assertions.assertEquals(externalId, changes.get(\"externalId\"));\n        Assertions.assertEquals(mobileNo, changes.get(\"mobileNo\"));\n    } END"}
{"prompt":"test Staff Update Long External Id Error\n\n###\n\n","completion":"    @Test\n    public void testStaffUpdateLongExternalIdError() {\n        final HashMap<String, Object> map = new HashMap<>();\n        map.put(\"externalId\", Utils.randomStringGenerator(\"EXT\", 98));\n\n        StaffHelper.updateStaff(requestSpec, responseSpecForValidationError, 1, map);\n    } END"}
{"prompt":"test Staff Update Wrong Active State\n\n###\n\n","completion":"    @Test\n    public void testStaffUpdateWrongActiveState() {\n        final HashMap<String, Object> map = new HashMap<>();\n        map.put(\"isActive\", \"xyz\");\n\n        StaffHelper.updateStaff(requestSpec, responseSpecForValidationError, 1, map);\n    } END"}
{"prompt":"test Staff Update Not Found Error\n\n###\n\n","completion":"    @Test\n    public void testStaffUpdateNotFoundError() {\n        final HashMap<String, Object> map = new HashMap<>();\n        map.put(\"firstname\", Utils.uniqueRandomStringGenerator(\"michael_\", 5));\n\n        StaffHelper.updateStaff(requestSpec, responseSpecForNotFoundError, Integer.MAX_VALUE, map);\n    } END"}
{"prompt":"test Staff Update Validation Error\n\n###\n\n","completion":"    @Test\n    public void testStaffUpdateValidationError() {\n        final HashMap<String, Object> map = new HashMap<>();\n        final String firstname = Utils.uniqueRandomStringGenerator(\"michael_\", 5);\n        final String lastname = Utils.uniqueRandomStringGenerator(\"Doe_\", 4);\n        final String firstnameLong = Utils.uniqueRandomStringGenerator(\"michael_\", 43);\n        final String lastnameLong = Utils.uniqueRandomStringGenerator(\"Doe_\", 47);\n\n        map.put(\"firstname\", firstname);\n        map.put(\"lastname\", lastname);\n\n        \/** Test long firstname *\/\n        map.put(\"firstname\", firstnameLong);\n        StaffHelper.updateStaff(requestSpec, responseSpecForValidationError, 1, map);\n        map.put(\"firstname\", firstname);\n\n        \/** Test long lastname *\/\n        map.put(\"lastname\", lastnameLong);\n        StaffHelper.updateStaff(requestSpec, responseSpecForValidationError, 1, map);\n        map.put(\"lastname\", lastname);\n\n        \/** Long mobileNo test *\/\n        map.put(\"mobileNo\", Utils.uniqueRandomStringGenerator(\"num_\", 47));\n        StaffHelper.updateStaff(requestSpec, responseSpecForValidationError, 1, map);\n        map.remove(\"mobileNo\");\n\n        \/** Test unsupported parameter *\/\n        map.put(\"xyz\", \"xyz\");\n        StaffHelper.updateStaff(requestSpec, responseSpecForValidationError, 1, map);\n    } END"}
{"prompt":"test Staff Loan Officer\n\n###\n\n","completion":"    @Test\n    public void testStaffLoanOfficer() {\n        final Map<String, Object> map = StaffHelper.getMapWithJoiningDate();\n\n        map.put(\"officeId\", 1);\n        map.put(\"firstname\", Utils.uniqueRandomStringGenerator(\"michael_\", 5));\n        map.put(\"lastname\", Utils.uniqueRandomStringGenerator(\"Doe_\", 5));\n        map.put(\"isLoanOfficer\", true);\n\n        StaffHelper.createStaffWithJson(requestSpec, responseSpec, new Gson().toJson(map));\n\n        List<Map<String, Object>> responseActive = StaffHelper.getStaffListWithLoanOfficerStatus(requestSpec, responseSpec, \"true\");\n        for (final Map<String, Object> staff : responseActive) {\n            Assertions.assertNotNull(staff.get(\"id\"));\n            Assertions.assertEquals(true, staff.get(\"isLoanOfficer\"));\n        }\n    } END"}
{"prompt":"test Swaggerui Access\n\n###\n\n","completion":"    @Test\n    public void testSwaggeruiAccess() {\n        Utils.performServerGet(requestSpec, responseSpec, \"\/fineract-provider\/swagger-ui\/index.html\", null);\n        Utils.performServerGet(requestSpec, responseSpec, \"\/fineract-provider\/fineract.json\", null);\n    } END"}
{"prompt":"test Create Code\n\n###\n\n","completion":"    @Test\n    \/\/ scenario 57, 58, 59, 60\n    public void testCreateCode() {\n        final String codeName = \"Client Marital Status\";\n\n        final Integer createResponseId = (Integer) CodeHelper.createCode(this.requestSpec, this.responseSpec, codeName,\n                CodeHelper.RESPONSE_ID_ATTRIBUTE_NAME);\n\n        \/\/ verify code created\n\n        final HashMap newCodeAttributes = (HashMap) CodeHelper.getCodeById(this.requestSpec, this.responseSpec, createResponseId, \"\");\n\n        Assertions.assertNotNull(newCodeAttributes);\n        assertEquals(createResponseId, newCodeAttributes.get(CodeHelper.CODE_ID_ATTRIBUTE_NAME), \"Verify value of codeId\");\n\n        assertEquals(codeName, newCodeAttributes.get(CodeHelper.CODE_NAME_ATTRIBUTE_NAME), \"Verify code name\");\n        assertEquals(false, newCodeAttributes.get(CodeHelper.CODE_SYSTEM_DEFINED_ATTRIBUTE_NAME), \"Verify system defined is false\");\n\n        \/\/ update code\n        final HashMap updateChangeResponse = (HashMap) CodeHelper.updateCode(this.requestSpec, this.responseSpec, createResponseId,\n                codeName + \"(CHANGE)\", \"changes\");\n\n        assertEquals(codeName + \"(CHANGE)\", updateChangeResponse.get(CodeHelper.CODE_NAME_ATTRIBUTE_NAME), \"Verify code name updated\");\n\n        \/\/ delete code\n        final Integer deleteResponseId = (Integer) CodeHelper.deleteCodeById(this.requestSpec, this.responseSpec, createResponseId,\n                CodeHelper.RESPONSE_ID_ATTRIBUTE_NAME);\n        assertEquals(createResponseId, deleteResponseId, \"Verify code deleted\");\n\n        \/\/ verify code deleted\n        final HashMap deletedCodeValues = (HashMap) CodeHelper.getCodeById(this.requestSpec, this.generalResponseSpec, deleteResponseId,\n                \"\");\n\n        Assertions.assertNotNull(deletedCodeValues);\n        assertNull(deletedCodeValues.get(CodeHelper.CODE_ID_ATTRIBUTE_NAME), \"Verify value of codeId\");\n\n        assertNull(deletedCodeValues.get(CodeHelper.CODE_NAME_ATTRIBUTE_NAME), \"Verify code name\");\n        assertNull(deletedCodeValues.get(CodeHelper.CODE_SYSTEM_DEFINED_ATTRIBUTE_NAME), \"Verify system defined is false\");\n    } END"}
{"prompt":"test Prevent Create Duplicate Code\n\n###\n\n","completion":"    @Test\n    \/\/ scenario 57, 60\n    public void testPreventCreateDuplicateCode() {\n        final String codeName = \"Client Marital Status\";\n\n        \/\/ create code\n        final Integer createResponseId = (Integer) CodeHelper.createCode(this.requestSpec, this.responseSpec, codeName,\n                CodeHelper.RESPONSE_ID_ATTRIBUTE_NAME);\n\n        \/\/ verify code created\n        final HashMap newCodeAttributes = (HashMap) CodeHelper.getCodeById(this.requestSpec, this.responseSpec, createResponseId, \"\");\n\n        Assertions.assertNotNull(newCodeAttributes);\n        assertEquals(createResponseId, newCodeAttributes.get(CodeHelper.CODE_ID_ATTRIBUTE_NAME), \"Verify value of codeId\");\n\n        assertEquals(codeName, newCodeAttributes.get(CodeHelper.CODE_NAME_ATTRIBUTE_NAME), \"Verify code name\");\n        assertEquals(false, newCodeAttributes.get(CodeHelper.CODE_SYSTEM_DEFINED_ATTRIBUTE_NAME), \"Verify system defined is false\");\n\n        \/\/ try to create duplicate-- should fail\n        final List<HashMap> error = (List) CodeHelper.createCode(this.requestSpec, this.generalResponseSpec, codeName,\n                CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.code.duplicate.name\", error.get(0).get(\"userMessageGlobalisationCode\"), \"Verify duplication error\");\n\n        \/\/ delete code that was just created\n\n        final Integer deleteResponseId = (Integer) CodeHelper.deleteCodeById(this.requestSpec, this.responseSpec, createResponseId,\n                CodeHelper.RESPONSE_ID_ATTRIBUTE_NAME);\n        assertEquals(createResponseId, deleteResponseId, \"Verify code deleted\");\n\n        \/\/ verify code deleted\n        final HashMap deletedCodeAttributes = (HashMap) CodeHelper.getCodeById(this.requestSpec, this.generalResponseSpec, deleteResponseId,\n                \"\");\n\n        Assertions.assertNotNull(deletedCodeAttributes);\n        assertNull(deletedCodeAttributes.get(CodeHelper.CODE_ID_ATTRIBUTE_NAME), \"Verify value of codeId\");\n\n        assertNull(deletedCodeAttributes.get(CodeHelper.CODE_NAME_ATTRIBUTE_NAME), \"Verify code name\");\n        assertNull(deletedCodeAttributes.get(CodeHelper.CODE_SYSTEM_DEFINED_ATTRIBUTE_NAME), \"Verify system defined is false\");\n\n    } END"}
{"prompt":"test Update Delete System Defined Code\n\n###\n\n","completion":"    \/\/ @Ignore\n    @Test\n    public void testUpdateDeleteSystemDefinedCode() {\n\n        \/\/ get any systemDefined code\n        final HashMap systemDefinedCode = (HashMap) CodeHelper.getSystemDefinedCodes(this.requestSpec, this.responseSpec);\n\n        \/\/ delete system-defined code should fail\n        final List<HashMap> error = (List) CodeHelper.deleteCodeById(this.requestSpec, this.generalResponseSpec,\n                (Integer) systemDefinedCode.get(CodeHelper.CODE_ID_ATTRIBUTE_NAME), CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.code.systemdefined\", error.get(0).get(\"userMessageGlobalisationCode\"), \"Cannot delete system-defined code\");\n\n        \/\/ update system-defined code should fail\n\n        final List<HashMap> updateError = (List) CodeHelper.updateCode(this.requestSpec, this.generalResponseSpec,\n                (Integer) systemDefinedCode.get(CodeHelper.CODE_ID_ATTRIBUTE_NAME),\n                systemDefinedCode.get(CodeHelper.CODE_NAME_ATTRIBUTE_NAME) + \"CHANGE\", CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.code.systemdefined\", updateError.get(0).get(\"userMessageGlobalisationCode\"),\n                \"Cannot update system-defined code\");\n\n    } END"}
{"prompt":"test Code Values Not Assigned To Table\n\n###\n\n","completion":"    \/\/ @Ignore\n    @Test\n    public void testCodeValuesNotAssignedToTable() {\n\n        final String codeName = Utils.uniqueRandomStringGenerator(\"Marital Status1\", 10);\n\n        final String codeValue1 = \"Married1\";\n        final String codeValue2 = \"Unmarried1\";\n\n        final int codeValue1Position = 1;\n        final int codeValue2Position = 1;\n\n        final String codeDescription1 = \"Description11\";\n        final String codeDescription2 = \"Description22\";\n\n        \/\/ create code\n        final Integer createCodeResponseId = (Integer) CodeHelper.createCode(this.requestSpec, this.responseSpec, codeName,\n                CodeHelper.RESPONSE_ID_ATTRIBUTE_NAME);\n\n        \/\/ create first code value\n        final Integer createCodeValueResponseId1 = (Integer) CodeHelper.createCodeValue(this.requestSpec, this.responseSpec,\n                createCodeResponseId, codeValue1, codeDescription1, codeValue1Position, CodeHelper.SUBRESPONSE_ID_ATTRIBUTE_NAME);\n\n        \/\/ create second code value\n        final Integer createCodeValueResponseId2 = (Integer) CodeHelper.createCodeValue(this.requestSpec, this.responseSpec,\n                createCodeResponseId, codeValue2, codeDescription2, codeValue1Position, CodeHelper.SUBRESPONSE_ID_ATTRIBUTE_NAME);\n\n        \/\/ verify two code values created\n\n        final List<HashMap> codeValuesList = (List) CodeHelper.getCodeValuesForCode(this.requestSpec, this.responseSpec,\n                createCodeResponseId, \"\");\n\n        assertEquals(2, codeValuesList.size(), \"Number of code values returned matches number created\");\n\n        \/\/ verify values of first code value\n        final HashMap codeValuesAttributes1 = (HashMap) CodeHelper.getCodeValueById(this.requestSpec, this.responseSpec,\n                createCodeResponseId, createCodeValueResponseId1, \"\");\n\n        Assertions.assertNotNull(codeValuesAttributes1);\n        assertEquals(createCodeValueResponseId1, codeValuesAttributes1.get(CodeHelper.CODE_VALUE_ID_ATTRIBUTE_NAME),\n                \"Verify value of codeValueId\");\n\n        assertEquals(codeValue1, codeValuesAttributes1.get(CodeHelper.CODE_VALUE_NAME_ATTRIBUTE_NAME), \"Verify value of code name\");\n\n        assertEquals(codeDescription1, codeValuesAttributes1.get(CodeHelper.CODE_VALUE_DESCRIPTION_ATTRIBUTE_NAME),\n                \"Verify value of code description\");\n\n        assertEquals(codeValue1Position, codeValuesAttributes1.get(CodeHelper.CODE_VALUE_POSITION_ATTRIBUTE_NAME),\n                \"Verify position of code value\");\n\n        \/\/ verify values of second code value\n        final HashMap codeValuesAttributes2 = (HashMap) CodeHelper.getCodeValueById(this.requestSpec, this.responseSpec,\n                createCodeResponseId, createCodeValueResponseId2, \"\");\n\n        Assertions.assertNotNull(codeValuesAttributes2);\n        assertEquals(createCodeValueResponseId2, codeValuesAttributes2.get(CodeHelper.CODE_VALUE_ID_ATTRIBUTE_NAME),\n                \"Verify value of codeValueId\");\n\n        assertEquals(codeValue2, codeValuesAttributes2.get(CodeHelper.CODE_VALUE_NAME_ATTRIBUTE_NAME), \"Verify value of code name\");\n\n        assertEquals(codeDescription2, codeValuesAttributes2.get(CodeHelper.CODE_VALUE_DESCRIPTION_ATTRIBUTE_NAME),\n                \"Verify value of code description\");\n\n        assertEquals(codeValue2Position, codeValuesAttributes2.get(CodeHelper.CODE_VALUE_POSITION_ATTRIBUTE_NAME),\n                \"Verify position of code value\");\n\n        \/\/ update code value 1\n        final HashMap codeValueChanges = (HashMap) CodeHelper.updateCodeValue(this.requestSpec, this.responseSpec, createCodeResponseId,\n                createCodeValueResponseId1, codeValue1 + \"CHANGE\", codeDescription1 + \"CHANGE\", 4, \"changes\");\n\n        assertEquals(codeValue1 + \"CHANGE\", codeValueChanges.get(\"name\"), \"Verify changed code value name\");\n\n        assertEquals(codeDescription1 + \"CHANGE\", codeValueChanges.get(\"description\"), \"Verify changed code value description\");\n\n        \/\/ delete code value\n        Integer deletedCodeValueResponseId1 = (Integer) CodeHelper.deleteCodeValueById(this.requestSpec, this.generalResponseSpec,\n                createCodeResponseId, createCodeValueResponseId1, CodeHelper.SUBRESPONSE_ID_ATTRIBUTE_NAME);\n\n        \/\/ Verify code value deleted\n\n        final ArrayList<HashMap> deletedCodeValueAttributes1 = (ArrayList<HashMap>) CodeHelper.getCodeValueById(this.requestSpec,\n                this.generalResponseSpec, createCodeResponseId, deletedCodeValueResponseId1, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.codevalue.id.invalid\", deletedCodeValueAttributes1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        final List<HashMap> deletedCodeValuesList = (List) CodeHelper.getCodeValuesForCode(this.requestSpec, this.responseSpec,\n                createCodeResponseId, \"\");\n\n        assertEquals(1, deletedCodeValuesList.size(), \"Number of code values is 1\");\n\n        final Integer deletedCodeValueResponseId2 = (Integer) CodeHelper.deleteCodeValueById(this.requestSpec, this.generalResponseSpec,\n                createCodeResponseId, createCodeValueResponseId2, CodeHelper.SUBRESPONSE_ID_ATTRIBUTE_NAME);\n\n        final ArrayList<HashMap> deletedCodeValueAttributes2 = (ArrayList<HashMap>) CodeHelper.getCodeValueById(this.requestSpec,\n                this.generalResponseSpec, createCodeResponseId, deletedCodeValueResponseId2, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(deletedCodeValueAttributes2.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE), \"error.msg.codevalue.id.invalid\");\n\n        final List<HashMap> deletedCodeValuesList1 = (List) CodeHelper.getCodeValuesForCode(this.requestSpec, this.responseSpec,\n                createCodeResponseId, \"\");\n\n        assertEquals(0, deletedCodeValuesList1.size(), \"Number of code values is 0\");\n\n    } END"}
{"prompt":"test Code Values Assigned To Table\n\n###\n\n","completion":"    @Disabled\n    @Test\n    public void testCodeValuesAssignedToTable() {\n\n    } END"}
{"prompt":"test Create New User Blocks Duplicate Username\n\n###\n\n","completion":"    @Test\n    public void testCreateNewUserBlocksDuplicateUsername() {\n\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(staffId);\n\n        final Integer userId = (Integer) UserHelper.createUser(this.requestSpec, this.responseSpec, roleId, staffId, \"alphabet\",\n                \"resourceId\");\n        Assertions.assertNotNull(userId);\n        this.transientUsers.add(userId);\n\n        final List errors = (List) UserHelper.createUser(this.requestSpec, expectStatusCode(403), roleId, staffId, \"alphabet\", \"errors\");\n        Map reason = (Map) errors.get(0);\n        LOG.info(\"Reason: {}\", reason.get(\"defaultUserMessage\"));\n        LOG.info(\"Code: {}\", reason.get(\"userMessageGlobalisationCode\"));\n        Assertions.assertEquals(\"User with username alphabet already exists.\", reason.get(\"defaultUserMessage\"));\n        Assertions.assertEquals(\"error.msg.user.duplicate.username\", reason.get(\"userMessageGlobalisationCode\"));\n    } END"}
{"prompt":"test Update User Accepts New Or Same Username\n\n###\n\n","completion":"    @Test\n    public void testUpdateUserAcceptsNewOrSameUsername() {\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(staffId);\n\n        final Integer userId = (Integer) UserHelper.createUser(this.requestSpec, this.responseSpec, roleId, staffId, \"alphabet\",\n                \"resourceId\");\n        Assertions.assertNotNull(userId);\n        this.transientUsers.add(userId);\n\n        final Integer userId2 = (Integer) UserHelper.updateUser(this.requestSpec, this.responseSpec, userId, \"renegade\", \"resourceId\");\n        Assertions.assertNotNull(userId2);\n\n        final Integer userId3 = (Integer) UserHelper.updateUser(this.requestSpec, this.responseSpec, userId, \"renegade\", \"resourceId\");\n        Assertions.assertNotNull(userId3);\n    } END"}
{"prompt":"test Update User Block Duplicate Username\n\n###\n\n","completion":"    @Test\n    public void testUpdateUserBlockDuplicateUsername() {\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(staffId);\n\n        final Integer userId = (Integer) UserHelper.createUser(this.requestSpec, this.responseSpec, roleId, staffId, \"alphabet\",\n                \"resourceId\");\n        Assertions.assertNotNull(userId);\n        this.transientUsers.add(userId);\n\n        final Integer userId2 = (Integer) UserHelper.createUser(this.requestSpec, this.responseSpec, roleId, staffId, \"bilingual\",\n                \"resourceId\");\n        Assertions.assertNotNull(userId2);\n        this.transientUsers.add(userId2);\n\n        final List errors = (List) UserHelper.updateUser(this.requestSpec, expectStatusCode(403), userId2, \"alphabet\", \"errors\");\n        Map reason = (Map) errors.get(0);\n        Assertions.assertEquals(\"User with username alphabet already exists.\", reason.get(\"defaultUserMessage\"));\n        Assertions.assertEquals(\"error.msg.user.duplicate.username\", reason.get(\"userMessageGlobalisationCode\"));\n    } END"}
{"prompt":"test Create New User Blocks Duplicate Client Id\n\n###\n\n","completion":"    @Test\n    public void testCreateNewUserBlocksDuplicateClientId() {\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(staffId);\n\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final Integer userId = (Integer) UserHelper.createUserForSelfService(this.requestSpec, this.responseSpec, roleId, staffId, clientId,\n                \"resourceId\");\n        Assertions.assertNotNull(userId);\n        this.transientUsers.add(userId);\n\n        final List errors = (List) UserHelper.createUserForSelfService(this.requestSpec, expectStatusCode(403), roleId, staffId, clientId,\n                \"errors\");\n        Map reason = (Map) errors.get(0);\n        Assertions.assertEquals(\"Self Service User Id is already created. Go to Admin->Users to edit or delete the self-service user.\",\n                reason.get(\"defaultUserMessage\"));\n    } END"}
{"prompt":"test Delete System User\n\n###\n\n","completion":"    @Test\n    public void testDeleteSystemUser() {\n        final Integer userId = UserHelper.getUserId(requestSpec, responseSpec, AppUserConstants.SYSTEM_USER_NAME);\n        Assertions.assertNotNull(userId);\n\n        UserHelper.deleteUser(requestSpec, expectStatusCode(403), userId.intValue());\n    } END"}
{"prompt":"test Modify System User\n\n###\n\n","completion":"    @Test\n    public void testModifySystemUser() {\n        final Integer userId = UserHelper.getUserId(requestSpec, responseSpec, AppUserConstants.SYSTEM_USER_NAME);\n        Assertions.assertNotNull(userId);\n\n        final List errors = (List) UserHelper.updateUser(this.requestSpec, expectStatusCode(403), userId, \"systemtest\", \"errors\");\n    } END"}
{"prompt":"update Working Days\n\n###\n\n","completion":"    @Test\n    public void updateWorkingDays() {\n        HashMap response = (HashMap) WorkingDaysHelper.updateWorkingDays(requestSpec, responseSpec);\n        Assertions.assertNotNull(response.get(\"resourceId\"));\n    } END"}
{"prompt":"update Working Days With Wrong Recurrence Pattern\n\n###\n\n","completion":"    @Test\n    public void updateWorkingDaysWithWrongRecurrencePattern() {\n        final List<HashMap> error = (List) WorkingDaysHelper.updateWorkingDaysWithWrongRecurrence(requestSpec, generalResponseSpec,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.recurring.rule.parsing.error\", error.get(0).get(\"userMessageGlobalisationCode\"),\n                \"Verify wrong recurrence pattern error\");\n    } END"}
{"prompt":"should Retrieve Taxonomy List\n\n###\n\n","completion":"    @Test\n    public void shouldRetrieveTaxonomyList() {\n        this.xbrlHelper = new XBRLIntegrationTestHelper(this.requestSpec, this.responseSpec);\n\n        final ArrayList<HashMap> taxonomyList = this.xbrlHelper.getTaxonomyList();\n        verifyTaxonomyList(taxonomyList);\n    } END"}
{"prompt":"test Accounting Rule Creation\n\n###\n\n","completion":"    @Test\n    public void testAccountingRuleCreation() {\n        \/\/ given\n        final Account accountToCredit = accountHelper.createIncomeAccount();\n        final Account accountToDebit = accountHelper.createExpenseAccount();\n        final GetOfficesResponse headOffice = OfficeHelper.getHeadOffice(requestSpec, responseSpec);\n\n        \/\/ when\n        final PostAccountingRulesResponse accountingRule = accountRuleHelper.createAccountRule(headOffice.getId(), accountToCredit,\n                accountToDebit);\n        final ArrayList<GetAccountRulesResponse> accountingRules = accountRuleHelper.getAccountingRules();\n\n        \/\/ then\n        assertNotNull(accountingRule);\n        assertNotNull(accountingRule.getResourceId());\n        assertNotNull(accountingRules);\n        assertTrue(accountingRules.size() > 0);\n    } END"}
{"prompt":"test Client Import\n\n###\n\n","completion":"    @Test\n    public void testClientImport() throws InterruptedException, IOException, ParseException {\n\n        \/\/ in order to populate helper sheets\n        requestSpec.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON);\n        Integer outcome_staff_creation = StaffHelper.createStaff(requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_staff_creation, \"Could not create staff\");\n\n        \/\/ in order to populate helper sheets\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        Integer outcome_office_creation = officeHelper.createOffice(\"02 May 2000\");\n        Assertions.assertNotNull(outcome_office_creation, \"Could not create office\");\n\n        \/\/ in order to populate helper columns in client entity sheet\n        \/\/ create constitution\n        CodeHelper.retrieveOrCreateCodeValue(24, requestSpec, responseSpec);\n        \/\/ create client classification\n        CodeHelper.retrieveOrCreateCodeValue(17, requestSpec, responseSpec);\n        \/\/ create client types\n        CodeHelper.retrieveOrCreateCodeValue(16, requestSpec, responseSpec);\n        \/\/ create Address types\n        CodeHelper.retrieveOrCreateCodeValue(29, requestSpec, responseSpec);\n        \/\/ create State\n        CodeHelper.retrieveOrCreateCodeValue(27, requestSpec, responseSpec);\n        \/\/ create Country\n        CodeHelper.retrieveOrCreateCodeValue(28, requestSpec, responseSpec);\n        \/\/ create Main business line\n        CodeHelper.retrieveOrCreateCodeValue(25, requestSpec, responseSpec);\n\n        ClientHelper clientHelper = new ClientHelper(requestSpec, responseSpec);\n        Workbook workbook = clientHelper.getClientEntityWorkbook(GlobalEntityType.CLIENTS_ENTITY, \"dd MMMM yyyy\");\n\n        \/\/ insert dummy data into client entity sheet\n        Sheet clientEntitySheet = workbook.getSheet(TemplatePopulateImportConstants.CLIENT_ENTITY_SHEET_NAME);\n        Row firstClientRow = clientEntitySheet.getRow(1);\n        firstClientRow.createCell(ClientEntityConstants.NAME_COL).setCellValue(Utils.randomStringGenerator(\"C_E_\", 6));\n        Sheet staffSheet = workbook.getSheet(TemplatePopulateImportConstants.STAFF_SHEET_NAME);\n        firstClientRow.createCell(ClientEntityConstants.OFFICE_NAME_COL).setCellValue(staffSheet.getRow(1).getCell(0).getStringCellValue());\n        firstClientRow.createCell(ClientEntityConstants.STAFF_NAME_COL).setCellValue(staffSheet.getRow(1).getCell(1).getStringCellValue());\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Date incoporationDate = simpleDateFormat.parse(\"14 May 2001\");\n        firstClientRow.createCell(ClientEntityConstants.INCOPORATION_DATE_COL).setCellValue(incoporationDate);\n        Date validTill = simpleDateFormat.parse(\"14 May 2019\");\n        firstClientRow.createCell(ClientEntityConstants.INCOPORATION_VALID_TILL_COL).setCellValue(validTill);\n        firstClientRow.createCell(ClientEntityConstants.MOBILE_NO_COL).setCellValue(Utils.uniqueRandomNumberGenerator(7));\n        firstClientRow.createCell(ClientEntityConstants.CLIENT_TYPE_COL)\n                .setCellValue(clientEntitySheet.getRow(1).getCell(ClientEntityConstants.LOOKUP_CLIENT_TYPES).getStringCellValue());\n        firstClientRow.createCell(ClientEntityConstants.CLIENT_CLASSIFICATION_COL)\n                .setCellValue(clientEntitySheet.getRow(1).getCell(ClientEntityConstants.LOOKUP_CLIENT_CLASSIFICATION).getStringCellValue());\n        firstClientRow.createCell(ClientEntityConstants.INCOPORATION_NUMBER_COL).setCellValue(Utils.randomNumberGenerator(6));\n        firstClientRow.createCell(ClientEntityConstants.MAIN_BUSINESS_LINE)\n                .setCellValue(clientEntitySheet.getRow(1).getCell(ClientEntityConstants.LOOKUP_MAIN_BUSINESS_LINE).getStringCellValue());\n        firstClientRow.createCell(ClientEntityConstants.CONSTITUTION_COL)\n                .setCellValue(clientEntitySheet.getRow(1).getCell(ClientEntityConstants.LOOKUP_CONSTITUTION_COL).getStringCellValue());\n        firstClientRow.createCell(ClientEntityConstants.ACTIVE_COL).setCellValue(\"False\");\n        Date submittedDate = simpleDateFormat.parse(\"28 September 2017\");\n        firstClientRow.createCell(ClientEntityConstants.SUBMITTED_ON_COL).setCellValue(submittedDate);\n        firstClientRow.createCell(ClientEntityConstants.ADDRESS_ENABLED).setCellValue(\"False\");\n\n        File directory = new File(System.getProperty(\"user.home\") + File.separator + \"Fineract\" + File.separator + \"bulkimport\"\n                + File.separator + \"integration_tests\" + File.separator + \"importhandler\" + File.separator + \"client\");\n        if (!directory.exists()) {\n            directory.mkdirs();\n        }\n        File file = new File(directory + File.separator + \"ClientEntity.xls\");\n        OutputStream outputStream = new FileOutputStream(file);\n        workbook.write(outputStream);\n        outputStream.close();\n\n        String importDocumentId = clientHelper.importClientEntityTemplate(file);\n        file.delete();\n        Assertions.assertNotNull(importDocumentId);\n\n        \/\/ Wait for the creation of output excel\n        Thread.sleep(10000);\n\n        \/\/ check status column of output excel\n        String location = clientHelper.getOutputTemplateLocation(importDocumentId);\n        FileInputStream fileInputStream = new FileInputStream(location);\n        Workbook outputWorkbook = new HSSFWorkbook(fileInputStream);\n        Sheet outputClientEntitySheet = outputWorkbook.getSheet(TemplatePopulateImportConstants.CLIENT_ENTITY_SHEET_NAME);\n        Row row = outputClientEntitySheet.getRow(1);\n\n        LOG.info(\"Output location: {}\", location);\n        LOG.info(\"Failure reason column: {}\", row.getCell(ClientEntityConstants.STATUS_COL).getStringCellValue());\n\n        Assertions.assertEquals(\"Imported\", row.getCell(ClientEntityConstants.STATUS_COL).getStringCellValue());\n        outputWorkbook.close();\n    } END"}
{"prompt":"test Office Import\n\n###\n\n","completion":"    @Test\n    public void testOfficeImport() throws IOException, InterruptedException, NoSuchFieldException, ParseException {\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        Workbook workbook = officeHelper.getOfficeWorkBook(\"dd MMMM yyyy\");\n\n        \/\/ insert dummy data into excel\n        Sheet sheet = workbook.getSheet(TemplatePopulateImportConstants.OFFICE_SHEET_NAME);\n        Row firstOfficeRow = sheet.getRow(1);\n        firstOfficeRow.createCell(OfficeConstants.OFFICE_NAME_COL).setCellValue(Utils.uniqueRandomStringGenerator(\"Test_Off_\", 6));\n        firstOfficeRow.createCell(OfficeConstants.PARENT_OFFICE_NAME_COL)\n                .setCellValue(firstOfficeRow.getCell(OfficeConstants.LOOKUP_OFFICE_COL).getStringCellValue());\n        firstOfficeRow.createCell(OfficeConstants.PARENT_OFFICE_ID_COL)\n                .setCellValue(firstOfficeRow.getCell(OfficeConstants.LOOKUP_OFFICE_ID_COL).getNumericCellValue());\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Date date = simpleDateFormat.parse(\"14 May 2001\");\n        firstOfficeRow.createCell(OfficeConstants.OPENED_ON_COL).setCellValue(date);\n\n        String currentdirectory = new File(\"\").getAbsolutePath();\n        File directory = new File(currentdirectory + File.separator + \"src\" + File.separator + \"integrationTest\" + File.separator\n                + \"resources\" + File.separator + \"bulkimport\" + File.separator + \"importhandler\" + File.separator + \"office\");\n        if (!directory.exists()) {\n            directory.mkdirs();\n        }\n        File file = new File(directory + File.separator + \"Office.xls\");\n        OutputStream outputStream = new FileOutputStream(file);\n        workbook.write(outputStream);\n        outputStream.close();\n\n        String importDocumentId = officeHelper.importOfficeTemplate(file);\n        file.delete();\n        Assertions.assertNotNull(importDocumentId);\n\n        \/\/ Wait for the creation of output excel\n        Thread.sleep(10000);\n\n        \/\/ check status column of output excel\n        String location = officeHelper.getOutputTemplateLocation(importDocumentId);\n        FileInputStream fileInputStream = new FileInputStream(location);\n        Workbook outputWorkbook = new HSSFWorkbook(fileInputStream);\n        Sheet officeSheet = outputWorkbook.getSheet(TemplatePopulateImportConstants.OFFICE_SHEET_NAME);\n        Row row = officeSheet.getRow(1);\n\n        LOG.info(\"Output location: {}\", location);\n        LOG.info(\"Failure reason column: {}\", row.getCell(OfficeConstants.STATUS_COL).getStringCellValue());\n\n        Assertions.assertEquals(\"Imported\", row.getCell(OfficeConstants.STATUS_COL).getStringCellValue());\n        outputWorkbook.close();\n    } END"}
{"prompt":"test Savings Import\n\n###\n\n","completion":"    @Test\n    public void testSavingsImport() throws InterruptedException, IOException, ParseException {\n\n        requestSpec.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON);\n        \/\/ in order to populate helper sheets\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        Integer outcome_office_creation = officeHelper.createOffice(\"02 May 2000\");\n        Assertions.assertNotNull(outcome_office_creation, \"Could not create office\");\n\n        OfficeDomain office = officeHelper.retrieveOfficeByID(outcome_office_creation);\n        Assertions.assertNotNull(office, \"Could not retrieve created office\");\n\n        String firstName = Utils.randomStringGenerator(\"Client_FirstName_\", 5);\n        String lastName = Utils.randomStringGenerator(\"Client_LastName_\", 4);\n        String externalId = UUID.randomUUID().toString();\n\n        final HashMap<String, Object> clientMap = new HashMap<>();\n        clientMap.put(\"officeId\", outcome_office_creation.toString());\n        clientMap.put(\"legalFormId\", 1);\n        clientMap.put(\"firstname\", firstName);\n        clientMap.put(\"lastname\", lastName);\n        clientMap.put(\"externalId\", externalId);\n        clientMap.put(\"dateFormat\", DATE_FORMAT);\n        clientMap.put(\"locale\", \"en\");\n        clientMap.put(\"active\", \"true\");\n        clientMap.put(\"activationDate\", \"04 March 2011\");\n\n        Integer outcome_client_creation = Utils.performServerPost(requestSpec, responseSpec, CREATE_CLIENT_URL,\n                new Gson().toJson(clientMap), \"clientId\");\n        Assertions.assertNotNull(outcome_client_creation, \"Could not create client\");\n\n        \/\/ in order to populate helper sheets\n        Integer outcome_group_creation = GroupHelper.createGroup(requestSpec, responseSpec, true);\n        Assertions.assertNotNull(outcome_group_creation, \"Could not create group\");\n\n        \/\/ in order to populate helper sheets\n        Integer outcome_staff_creation = StaffHelper.createStaff(requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_staff_creation, \"Could not create staff\");\n\n        Map<String, Object> staffMap = StaffHelper.getStaff(requestSpec, responseSpec, outcome_staff_creation);\n        Assertions.assertNotNull(staffMap, \"Could not retrieve created staff\");\n\n        SavingsProductHelper savingsProductHelper = new SavingsProductHelper();\n        String jsonSavingsProduct = savingsProductHelper.build();\n        Integer outcome_sp_creaction = SavingsProductHelper.createSavingsProduct(jsonSavingsProduct, requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_sp_creaction, \"Could not create Savings product\");\n\n        SavingsAccountHelper savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        Workbook workbook = savingsAccountHelper.getSavingsWorkbook(\"dd MMMM yyyy\");\n\n        \/\/ insert dummy data into Savings sheet\n        Sheet savingsSheet = workbook.getSheet(TemplatePopulateImportConstants.SAVINGS_ACCOUNTS_SHEET_NAME);\n        Row firstSavingsRow = savingsSheet.getRow(1);\n        firstSavingsRow.createCell(SavingsConstants.OFFICE_NAME_COL).setCellValue(office.getName());\n        firstSavingsRow.createCell(SavingsConstants.SAVINGS_TYPE_COL).setCellValue(\"Individual\");\n        firstSavingsRow.createCell(SavingsConstants.CLIENT_NAME_COL)\n                .setCellValue(firstName + \" \" + lastName + \"(\" + outcome_client_creation + \")\");\n        Sheet savingsProductSheet = workbook.getSheet(TemplatePopulateImportConstants.PRODUCT_SHEET_NAME);\n        firstSavingsRow.createCell(SavingsConstants.PRODUCT_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(1).getStringCellValue());\n        firstSavingsRow.createCell(SavingsConstants.FIELD_OFFICER_NAME_COL).setCellValue((String) staffMap.get(\"displayName\"));\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Date date = simpleDateFormat.parse(\"13 May 2017\");\n        firstSavingsRow.createCell(SavingsConstants.SUBMITTED_ON_DATE_COL).setCellValue(date);\n        firstSavingsRow.createCell(SavingsConstants.APPROVED_DATE_COL).setCellValue(date);\n        firstSavingsRow.createCell(SavingsConstants.ACTIVATION_DATE_COL).setCellValue(date);\n        firstSavingsRow.createCell(SavingsConstants.CURRENCY_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(10).getStringCellValue());\n        firstSavingsRow.createCell(SavingsConstants.DECIMAL_PLACES_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(11).getNumericCellValue());\n        firstSavingsRow.createCell(SavingsConstants.IN_MULTIPLES_OF_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(12).getNumericCellValue());\n        firstSavingsRow.createCell(SavingsConstants.NOMINAL_ANNUAL_INTEREST_RATE_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(2).getNumericCellValue());\n        firstSavingsRow.createCell(SavingsConstants.INTEREST_COMPOUNDING_PERIOD_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(3).getStringCellValue());\n        firstSavingsRow.createCell(SavingsConstants.INTEREST_POSTING_PERIOD_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(4).getStringCellValue());\n        firstSavingsRow.createCell(SavingsConstants.INTEREST_CALCULATION_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(5).getStringCellValue());\n        firstSavingsRow.createCell(SavingsConstants.INTEREST_CALCULATION_DAYS_IN_YEAR_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(6).getStringCellValue());\n        firstSavingsRow.createCell(SavingsConstants.MIN_OPENING_BALANCE_COL).setCellValue(1000.0);\n        firstSavingsRow.createCell(SavingsConstants.LOCKIN_PERIOD_COL).setCellValue(1);\n        firstSavingsRow.createCell(SavingsConstants.LOCKIN_PERIOD_FREQUENCY_COL).setCellValue(\"Weeks\");\n        firstSavingsRow.createCell(SavingsConstants.APPLY_WITHDRAWAL_FEE_FOR_TRANSFERS).setCellValue(\"False\");\n        firstSavingsRow.createCell(SavingsConstants.ALLOW_OVER_DRAFT_COL).setCellValue(\"False\");\n        firstSavingsRow.createCell(SavingsConstants.OVER_DRAFT_LIMIT_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(15).getNumericCellValue());\n\n        String currentdirectory = new File(\"\").getAbsolutePath();\n        File directory = new File(currentdirectory + File.separator + \"src\" + File.separator + \"integrationTest\" + File.separator\n                + \"resources\" + File.separator + \"bulkimport\" + File.separator + \"importhandler\" + File.separator + \"savings\");\n        if (!directory.exists()) {\n            directory.mkdirs();\n        }\n        File file = new File(directory + File.separator + \"Savings.xls\");\n        OutputStream outputStream = new FileOutputStream(file);\n        workbook.write(outputStream);\n        outputStream.close();\n\n        String importDocumentId = savingsAccountHelper.importSavingsTemplate(file);\n        file.delete();\n        Assertions.assertNotNull(importDocumentId);\n\n        \/\/ Wait for the creation of output excel\n        Thread.sleep(10000);\n\n        \/\/ check status column of output excel\n        String location = savingsAccountHelper.getOutputTemplateLocation(importDocumentId);\n        FileInputStream fileInputStream = new FileInputStream(location);\n        Workbook Outputworkbook = new HSSFWorkbook(fileInputStream);\n        Sheet OutputSavingsSheet = Outputworkbook.getSheet(TemplatePopulateImportConstants.SAVINGS_ACCOUNTS_SHEET_NAME);\n        Row row = OutputSavingsSheet.getRow(1);\n\n        LOG.info(\"Output location: {}\", location);\n        LOG.info(\"Failure reason column: {}\", row.getCell(SavingsConstants.STATUS_COL).getStringCellValue());\n\n        Assertions.assertEquals(\"Imported\", row.getCell(SavingsConstants.STATUS_COL).getStringCellValue());\n        Outputworkbook.close();\n    } END"}
{"prompt":"test Client Entity Workbook Populate\n\n###\n\n","completion":"    @Test\n    public void testClientEntityWorkbookPopulate() throws IOException {\n        \/\/ in order to populate helper sheets\n        requestSpec.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON);\n        Integer outcome_staff_creation = StaffHelper.createStaff(requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_staff_creation, \"Could not create staff\");\n\n        \/\/ in order to populate helper sheets\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        Integer outcome_office_creation = officeHelper.createOffice(\"02 May 2000\");\n        Assertions.assertNotNull(outcome_office_creation, \"Could not create office\");\n\n        ClientHelper clientHelper = new ClientHelper(requestSpec, responseSpec);\n        Workbook workbook = clientHelper.getClientEntityWorkbook(GlobalEntityType.CLIENTS_ENTITY, \"dd MMMM yyyy\");\n        Sheet officeSheet = workbook.getSheet(TemplatePopulateImportConstants.OFFICE_SHEET_NAME);\n        Row firstOfficeRow = officeSheet.getRow(1);\n        Assertions.assertNotNull(firstOfficeRow.getCell(1), \"No offices found for given OfficeId \");\n        Sheet staffSheet = workbook.getSheet(TemplatePopulateImportConstants.STAFF_SHEET_NAME);\n        Row firstStaffRow = staffSheet.getRow(1);\n        Assertions.assertNotNull(firstStaffRow.getCell(1), \"No staff found for given staffId\");\n    } END"}
{"prompt":"test Loan Workbook Populate\n\n###\n\n","completion":"    @Test\n    public void testLoanWorkbookPopulate() throws IOException {\n        requestSpec.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON);\n        \/\/ in order to populate helper sheets\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        Integer outcome_office_creation = officeHelper.createOffice(\"02 May 2000\");\n        Assertions.assertNotNull(outcome_office_creation, \"Could not create office\");\n\n        \/\/ in order to populate helper sheets\n        Integer outcome_client_creation = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_client_creation, \"Could not create client\");\n\n        \/\/ in order to populate helper sheets\n        Integer outcome_group_creation = GroupHelper.createGroup(requestSpec, responseSpec, true);\n        Assertions.assertNotNull(outcome_group_creation, \"Could not create group\");\n\n        \/\/ in order to populate helper sheets\n        Integer outcome_staff_creation = StaffHelper.createStaff(requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_staff_creation, \"Could not create staff\");\n\n        LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n        LoanProductTestBuilder loanProductTestBuilder = new LoanProductTestBuilder();\n        String jsonLoanProduct = loanProductTestBuilder.build(null);\n        Integer outcome_lp_creaion = loanTransactionHelper.getLoanProductId(jsonLoanProduct);\n        Assertions.assertNotNull(outcome_lp_creaion, \"Could not create Loan Product\");\n\n        String jsonFund = \"{\\n\" + \"\\t\\\"name\\\": \\\"\" + Utils.uniqueRandomStringGenerator(\"Fund_Name\", 9) + \"\\\"\\n\" + \"}\";\n        Integer outcome_fund_creation = FundsResourceHandler.createFund(jsonFund, requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_fund_creation, \"Could not create Fund\");\n\n        String name = PaymentTypeHelper.randomNameGenerator(\"P_T\", 5);\n        String description = PaymentTypeHelper.randomNameGenerator(\"PT_Desc\", 15);\n        Boolean isCashPayment = true;\n        Integer position = 1;\n        Integer outcome_payment_creation = PaymentTypeHelper.createPaymentType(requestSpec, responseSpec, name, description, isCashPayment,\n                position);\n        Assertions.assertNotNull(outcome_payment_creation, \"Could not create payment type\");\n\n        Workbook workbook = loanTransactionHelper.getLoanWorkbook(\"dd MMMM yyyy\");\n\n        Sheet officeSheet = workbook.getSheet(TemplatePopulateImportConstants.OFFICE_SHEET_NAME);\n        Row firstOfficeRow = officeSheet.getRow(1);\n        Assertions.assertNotNull(firstOfficeRow.getCell(1), \"No offices found \");\n\n        Sheet clientSheet = workbook.getSheet(TemplatePopulateImportConstants.CLIENT_SHEET_NAME);\n        Row firstClientRow = clientSheet.getRow(1);\n        Assertions.assertNotNull(firstClientRow.getCell(1), \"No clients found \");\n\n        Sheet groupSheet = workbook.getSheet(TemplatePopulateImportConstants.GROUP_SHEET_NAME);\n        Row firstGroupRow = groupSheet.getRow(1);\n        Assertions.assertNotNull(firstGroupRow.getCell(1), \"No groups found \");\n\n        Sheet staffSheet = workbook.getSheet(TemplatePopulateImportConstants.STAFF_SHEET_NAME);\n        Row firstStaffRow = staffSheet.getRow(1);\n        Assertions.assertNotNull(firstStaffRow.getCell(1), \"No staff found \");\n\n        Sheet productSheet = workbook.getSheet(TemplatePopulateImportConstants.PRODUCT_SHEET_NAME);\n        Row firstProductRow = productSheet.getRow(1);\n        Assertions.assertNotNull(firstProductRow.getCell(1), \"No products found \");\n\n        Sheet extrasSheet = workbook.getSheet(TemplatePopulateImportConstants.EXTRAS_SHEET_NAME);\n        Row firstExtrasRow = extrasSheet.getRow(1);\n        Assertions.assertNotNull(firstExtrasRow.getCell(1), \"No Extras found \");\n    } END"}
{"prompt":"test Office Workbook Populate\n\n###\n\n","completion":"    @Test\n    public void testOfficeWorkbookPopulate() throws IOException {\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        Workbook workbook = officeHelper.getOfficeWorkBook(\"dd MMMM yyyy\");\n        Sheet sheet = workbook.getSheet(TemplatePopulateImportConstants.OFFICE_SHEET_NAME);\n        Row firstRow = sheet.getRow(1);\n        Assertions.assertNotNull(\"No parent offices found\", firstRow.getCell(OfficeConstants.LOOKUP_OFFICE_COL).getStringCellValue());\n        Assertions.assertEquals(1, firstRow.getCell(OfficeConstants.LOOKUP_OFFICE_ID_COL).getNumericCellValue(), 0.0);\n\n    } END"}
{"prompt":"test Savings Workbook Populate\n\n###\n\n","completion":"    @Test\n    public void testSavingsWorkbookPopulate() throws IOException {\n        requestSpec.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON);\n        \/\/ in order to populate helper sheets\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        Integer outcome_office_creation = officeHelper.createOffice(\"02 May 2000\");\n        assertNotNull(outcome_office_creation, \"Could not create office\");\n\n        \/\/ in order to populate helper sheets\n        Integer outcome_client_creation = ClientHelper.createClient(requestSpec, responseSpec);\n        assertNotNull(outcome_client_creation, \"Could not create client\");\n\n        \/\/ in order to populate helper sheets\n        Integer outcome_group_creation = GroupHelper.createGroup(requestSpec, responseSpec, true);\n        assertNotNull(outcome_group_creation, \"Could not create group\");\n\n        \/\/ in order to populate helper sheets\n        Integer outcome_staff_creation = StaffHelper.createStaff(requestSpec, responseSpec);\n        assertNotNull(outcome_staff_creation, \"Could not create staff\");\n\n        SavingsProductHelper savingsProductHelper = new SavingsProductHelper();\n        String jsonSavingsProduct = savingsProductHelper.build();\n        Integer outcome_sp_creaction = SavingsProductHelper.createSavingsProduct(jsonSavingsProduct, requestSpec, responseSpec);\n        assertNotNull(outcome_sp_creaction, \"Could not create Savings product\");\n\n        SavingsAccountHelper savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        Workbook workbook = savingsAccountHelper.getSavingsWorkbook(\"dd MMMM yyyy\");\n\n        Sheet officeSheet = workbook.getSheet(TemplatePopulateImportConstants.OFFICE_SHEET_NAME);\n        Row firstOfficeRow = officeSheet.getRow(1);\n        assertNotNull(firstOfficeRow.getCell(1), \"No offices found \");\n\n        Sheet clientSheet = workbook.getSheet(TemplatePopulateImportConstants.CLIENT_SHEET_NAME);\n        Row firstClientRow = clientSheet.getRow(1);\n        assertNotNull(firstClientRow.getCell(1), \"No clients found \");\n\n        Sheet groupSheet = workbook.getSheet(TemplatePopulateImportConstants.GROUP_SHEET_NAME);\n        Row firstGroupRow = groupSheet.getRow(1);\n        assertNotNull(firstGroupRow.getCell(1), \"No groups found \");\n\n        Sheet staffSheet = workbook.getSheet(TemplatePopulateImportConstants.STAFF_SHEET_NAME);\n        Row firstStaffRow = staffSheet.getRow(1);\n        assertNotNull(firstStaffRow.getCell(1), \"No staff found \");\n\n        Sheet productSheet = workbook.getSheet(TemplatePopulateImportConstants.PRODUCT_SHEET_NAME);\n        Row firstProductRow = productSheet.getRow(1);\n        assertNotNull(firstProductRow.getCell(1), \"No products found \");\n    } END"}
{"prompt":"test Client Search Works With Lastname Text With Paging\n\n###\n\n","completion":"    @Test\n    public void testClientSearchWorks_WithLastnameText_WithPaging() {\n        \/\/ given\n        String lastname = Utils.randomStringGenerator(\"Client_LastName_\", 5);\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        request1.setLastname(lastname);\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        request2.setLastname(lastname);\n        clientHelper.createClient(request2);\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        request3.setLastname(lastname);\n        clientHelper.createClient(request3);\n        \/\/ when\n        PageClientSearchData result = clientHelper.searchClients(lastname, 0, 1);\n        \/\/ then\n        assertThat(result.getTotalElements()).isEqualTo(3);\n        assertThat(result.getNumberOfElements()).isEqualTo(1);\n        assertThat(result.getTotalPages()).isEqualTo(3);\n    } END"}
{"prompt":"test Client Search Works With Lastname Text On Default Ordering\n\n###\n\n","completion":"    @Test\n    public void testClientSearchWorks_WithLastnameTextOnDefaultOrdering() {\n        \/\/ given\n        String lastname = Utils.randomStringGenerator(\"Client_LastName_\", 5);\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        request1.setLastname(lastname);\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        request2.setLastname(lastname);\n        clientHelper.createClient(request2);\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        request3.setLastname(lastname);\n        clientHelper.createClient(request3);\n        \/\/ when\n        PageClientSearchData result = clientHelper.searchClients(lastname);\n        \/\/ then\n        assertThat(result.getTotalElements()).isEqualTo(3);\n        assertThat(result.getContent().get(0).getExternalId().getValue()).isEqualTo(request3.getExternalId());\n        assertThat(result.getContent().get(1).getExternalId().getValue()).isEqualTo(request2.getExternalId());\n        assertThat(result.getContent().get(2).getExternalId().getValue()).isEqualTo(request1.getExternalId());\n    } END"}
{"prompt":"test Client Search Works With Lastname Text Ordered By Id Asc\n\n###\n\n","completion":"    @Test\n    public void testClientSearchWorks_WithLastnameText_OrderedByIdAsc() {\n        \/\/ given\n        String lastname = Utils.randomStringGenerator(\"Client_LastName_\", 5);\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        request1.setLastname(lastname);\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        request2.setLastname(lastname);\n        clientHelper.createClient(request2);\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        request3.setLastname(lastname);\n        clientHelper.createClient(request3);\n\n        SortOrder sortOrder = new SortOrder().property(\"id\").direction(SortOrder.DirectionEnum.ASC);\n        \/\/ when\n        PageClientSearchData result = clientHelper.searchClients(lastname, sortOrder);\n        \/\/ then\n        assertThat(result.getTotalElements()).isEqualTo(3);\n        assertThat(result.getContent().get(0).getExternalId().getValue()).isEqualTo(request1.getExternalId());\n        assertThat(result.getContent().get(1).getExternalId().getValue()).isEqualTo(request2.getExternalId());\n        assertThat(result.getContent().get(2).getExternalId().getValue()).isEqualTo(request3.getExternalId());\n    } END"}
{"prompt":"test Client Search Works By External Id\n\n###\n\n","completion":"    @Test\n    public void testClientSearchWorks_ByExternalId() {\n        \/\/ given\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request2);\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request3);\n        \/\/ when\n        PageClientSearchData result = clientHelper.searchClients(request2.getExternalId());\n        \/\/ then\n        assertThat(result.getTotalElements()).isEqualTo(1);\n        assertThat(result.getContent().get(0).getExternalId().getValue()).isEqualTo(request2.getExternalId());\n    } END"}
{"prompt":"test Client Search Works By Account Number\n\n###\n\n","completion":"    @Test\n    public void testClientSearchWorks_ByAccountNumber() {\n        \/\/ given\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        PostClientsResponse response2 = clientHelper.createClient(request2);\n        GetClientsClientIdResponse client2Data = ClientHelper.getClient(requestSpec, responseSpec,\n                Math.toIntExact(response2.getClientId()));\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request3);\n        \/\/ when\n        PageClientSearchData result = clientHelper.searchClients(client2Data.getAccountNo());\n        \/\/ then\n        assertThat(result.getTotalElements()).isEqualTo(1);\n        assertThat(result.getContent().get(0).getAccountNumber()).isEqualTo(client2Data.getAccountNo());\n    } END"}
{"prompt":"test Client Search Works By Display Name\n\n###\n\n","completion":"    @Test\n    public void testClientSearchWorks_ByDisplayName() {\n        \/\/ given\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request2);\n        String client2DisplayName = \"%s %s\".formatted(request2.getFirstname(), request2.getLastname());\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request3);\n        \/\/ when\n        PageClientSearchData result = clientHelper.searchClients(client2DisplayName);\n        \/\/ then\n        assertThat(result.getTotalElements()).isEqualTo(1);\n        assertThat(result.getContent().get(0).getDisplayName()).isEqualTo(client2DisplayName);\n    } END"}
{"prompt":"test Client Search Works By Mobile No\n\n###\n\n","completion":"    @Test\n    public void testClientSearchWorks_ByMobileNo() {\n        \/\/ given\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        request2.setMobileNo(Utils.randomNumberGenerator(8).toString());\n        clientHelper.createClient(request2);\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request3);\n        \/\/ when\n        PageClientSearchData result = clientHelper.searchClients(request2.getMobileNo());\n        \/\/ then\n        assertThat(result.getTotalElements()).isEqualTo(1);\n        assertThat(result.getContent().get(0).getMobileNo()).isEqualTo(request2.getMobileNo());\n    } END"}
{"prompt":"test Client Search Doesnt Return Anything By Mobile No\n\n###\n\n","completion":"    @Test\n    public void testClientSearchDoesntReturnAnything_ByMobileNo() {\n        \/\/ given\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request2);\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request3);\n        \/\/ when\n        PageClientSearchData result = clientHelper.searchClients(Utils.randomNumberGenerator(8).toString());\n        \/\/ then\n        assertThat(result.getTotalElements()).isEqualTo(0);\n        assertThat(result.getContent()).isEmpty();\n    } END"}
{"prompt":"retrieve Any Existing\n\n###\n\n","completion":"    @Test\n    @Order(2)\n    void retrieveAnyExisting() {\n        assertThat(retrieveFirst()).isPresent();\n    } END"}
{"prompt":"create Document\n\n###\n\n","completion":"    @Test\n    @Order(2)\n    void createDocument() {\n        String name = \"Test\";\n        Part part = Parts.fromFile(testFile);\n        String description = \"The Description\";\n        var response = ok(fineract().documents.createDocument(\"clients\", clientId, part, name, description));\n        assertThat(response.getResourceId()).isNotNull();\n        assertThat(response.getResourceIdentifier()).isNotEmpty();\n        documentId = response.getResourceId();\n    } END"}
{"prompt":"get Document\n\n###\n\n","completion":"    @Test\n    @Order(3)\n    void getDocument() {\n        GetEntityTypeEntityIdDocumentsResponse doc = ok(fineract().documents.getDocument(\"clients\", clientId, documentId));\n        assertThat(doc.getName()).isEqualTo(\"Test\");\n        assertThat(doc.getFileName()).isEqualTo(testFile.getName());\n        assertThat(doc.getDescription()).isEqualTo(\"The Description\");\n        assertThat(doc.getId()).isEqualTo(documentId);\n        assertThat(doc.getParentEntityType()).isEqualTo(\"clients\");\n        assertThat(doc.getParentEntityId()).isEqualTo(clientId);\n        \/\/ TODO FINERACT-1251 It's more than uploaded file; seems like a bug - it's including create body, not just file\n        \/\/ size\n        assertThat(doc.getSize()).isEqualTo(testFile.length() + 618);\n        assertThat(doc.getType()).isEqualTo(\"image\/jpeg\");\n        \/\/ TODO doc.getStorageType() shouldn't be exposed by the API?!\n    } END"}
{"prompt":"download File\n\n###\n\n","completion":"    @Test\n    @Order(4)\n    void downloadFile() throws IOException {\n        Response<ResponseBody> r = okR(fineract().documents.downloadFile(\"clients\", clientId, documentId));\n        try (ResponseBody body = r.body()) {\n            assertThat(body.contentType()).isEqualTo(MediaType.get(\"image\/jpeg\"));\n            assertThat(body.bytes().length).isEqualTo(testFile.length());\n            assertThat(body.contentLength()).isEqualTo(testFile.length());\n        }\n        assertThat(Parts.fileName(r)).hasValue(testFile.getName());\n    } END"}
{"prompt":"update Document Without New Upload\n\n###\n\n","completion":"    @Test\n    @Order(10)\n    void updateDocumentWithoutNewUpload() {\n        String newName = \"Test changed name\";\n        String newDescription = getClass().getName();\n        ok(fineract().documents.updateDocument(\"clients\", clientId, documentId, null, newName, newDescription));\n\n        GetEntityTypeEntityIdDocumentsResponse doc = ok(fineract().documents.getDocument(\"clients\", clientId, documentId));\n        assertThat(doc.getName()).isEqualTo(newName);\n        assertThat(doc.getDescription()).isEqualTo(newDescription);\n        \/\/ TODO FINERACT-1251 It's more than uploaded file; seems like a bug - it's including create body, not just file\n        \/\/ size\n        assertThat(doc.getSize()).isEqualTo(testFile.length() + 618);\n    } END"}
{"prompt":"delete Document\n\n###\n\n","completion":"    @Test\n    @Order(99)\n    void deleteDocument() {\n        ok(fineract().documents.deleteDocument(\"clients\", clientId, documentId));\n        assertThat(fineract().documents.getDocument(\"clients\", clientId, documentId)).hasHttpStatus(404);\n    } END"}
{"prompt":"create Document Bad Args\n\n###\n\n","completion":"    @Order(9999)\n    @Test \/\/ FINERACT-1036\n    void createDocumentBadArgs() {\n        assertThat(fineract().documents.createDocument(\"clients\", 123L, null, \"test.pdf\", null)).hasHttpStatus(400);\n    } END"}
{"prompt":"get Original Size\n\n###\n\n","completion":"    @Test\n    @Order(2)\n    void getOriginalSize() throws IOException {\n        ResponseBody r = ok(fineract().images.get(\"staff\", staffId, 3505, 1972, null));\n        assertThat(r.contentType()).isEqualTo(MediaType.get(\"text\/plain\"));\n        String encodedImage = r.string();\n        assertThat(encodedImage).startsWith(\"data:image\/jpeg;base64,\");\n        assertThat(encodedImage).hasLength(2846549);\n        assertThat(r.contentLength()).isEqualTo(-1);\n    } END"}
{"prompt":"get Smaller Size\n\n###\n\n","completion":"    @Test\n    @Order(3)\n    void getSmallerSize() throws IOException {\n        ResponseBody r = ok(fineract().images.get(\"staff\", staffId, 128, 128, null));\n        assertThat(r.string()).hasLength(6591);\n    } END"}
{"prompt":"get Bigger Size\n\n###\n\n","completion":"    @Test\n    @Order(4)\n    void getBiggerSize() throws IOException {\n        ResponseBody r = ok(fineract().images.get(\"staff\", staffId, 9000, 6000, null));\n        assertThat(r.string()).hasLength(2846549);\n    } END"}
{"prompt":"get Inline Octet Output\n\n###\n\n","completion":"    @Test\n    @Order(5)\n    void getInlineOctetOutput() throws IOException {\n        \/\/ 3505x1972 is the exact original size of testFile\n        Response<ResponseBody> r = okR(fineract().images.get(\"staff\", staffId, 3505, 1972, \"inline_octet\"));\n        try (ResponseBody body = r.body()) {\n            assertThat(body.contentType()).isEqualTo(MediaType.get(\"image\/jpeg\"));\n            assertThat(body.bytes().length).isEqualTo(testPart.body().contentLength());\n            assertThat(body.contentLength()).isEqualTo(testPart.body().contentLength());\n        }\n\n        var staff = ok(fineract().staff.retrieveOne8(staffId));\n        String expectedFileName = staff.getDisplayName() + \"JPEG\"; \/\/ without dot!\n        assertThat(Parts.fileName(r)).hasValue(expectedFileName);\n    } END"}
{"prompt":"get Octet Output\n\n###\n\n","completion":"    @Test\n    @Order(6)\n    void getOctetOutput() throws IOException {\n        ResponseBody r = ok(fineract().images.get(\"staff\", staffId, 3505, 1972, \"octet\"));\n        assertThat(r.contentType()).isEqualTo(MediaType.get(\"image\/jpeg\"));\n        assertThat(r.bytes().length).isEqualTo(testPart.body().contentLength());\n        assertThat(r.contentLength()).isEqualTo(testPart.body().contentLength());\n    } END"}
{"prompt":"get Another Output\n\n###\n\n","completion":"    @Test\n    @Order(7)\n    void getAnotherOutput() throws IOException {\n        ResponseBody r = ok(fineract().images.get(\"staff\", staffId, 3505, 1972, \"abcd\"));\n        assertThat(r.contentType()).isEqualTo(MediaType.get(\"text\/plain\"));\n        assertThat(r.string()).startsWith(\"data:image\/jpeg;base64,\");\n    } END"}
{"prompt":"get Text\n\n###\n\n","completion":"    @Test\n    @Order(8)\n    void getText() throws IOException {\n        ResponseBody r = ok(fineract().createService(ImagesApiWithHeadersForTest.class).getText(\"staff\", staffId, 3505, 1972, null));\n        assertThat(r.contentType()).isEqualTo(MediaType.get(\"text\/plain\"));\n        assertThat(r.string()).startsWith(\"data:image\/jpeg;base64,\");\n    } END"}
{"prompt":"get Bytes\n\n###\n\n","completion":"    @Test\n    @Order(9)\n    void getBytes() throws IOException {\n        ResponseBody r = ok(fineract().createService(ImagesApiWithHeadersForTest.class).getBytes(\"staff\", staffId, 3505, 1972, null));\n        assertThat(r.contentType()).isEqualTo(MediaType.get(\"image\/jpeg\"));\n        assertThat(r.bytes().length).isEqualTo(testPart.body().contentLength());\n    } END"}
{"prompt":"update\n\n###\n\n","completion":"    @Test\n    @Order(50)\n    void update() {\n        ok(fineract().images.update(\"staff\", staffId, testPart));\n    } END"}
{"prompt":"delete\n\n###\n\n","completion":"    @Test\n    @Order(99)\n    void delete() {\n        ok(fineract().images.delete(\"staff\", staffId));\n        ok(fineract().images.delete(\"clients\", clientId));\n    } END"}
{"prompt":"path Traversal Jsp\n\n###\n\n","completion":"    @Test\n    @Order(100)\n    void pathTraversalJsp() {\n        final MultipartBody.Part part = createPart(\"image-text-wrong-content.jsp\",\n                \"..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/tmp\/image-text-wrong-content.jsp\", \"image\/gif\");\n\n        assertThat(part).isNotNull();\n\n        Exception exception = assertThrows(Exception.class, () -> {\n            ok(fineract().images.create(\"clients\", clientId, part));\n        });\n\n        assertThat(exception).isNotNull();\n\n        log.warn(\"Should not be able to upload a file that doesn't match the indicated content type: {}\", exception.getMessage());\n    } END"}
{"prompt":"gif With Png Extension\n\n###\n\n","completion":"    @Test\n    @Order(101)\n    void gifWithPngExtension() {\n        final MultipartBody.Part part = createPart(\"image-gif-wrong-extension.png\", \"image-gif-wrong-extension.png\", \"image\/png\");\n\n        assertThat(part).isNotNull();\n\n        Exception exception = assertThrows(Exception.class, () -> {\n            ok(fineract().images.create(\"clients\", clientId, part));\n        });\n\n        assertThat(exception).isNotNull();\n\n        log.warn(\"Should not be able to upload a gif by just renaming the file extension: {}\", exception.getMessage());\n    } END"}
{"prompt":"gif Image\n\n###\n\n","completion":"    @Test\n    @Order(102)\n    void gifImage() {\n        final MultipartBody.Part part = createPart(\"image-gif-correct-extension.gif\", \"image-gif-correct-extension.gif\", \"image\/png\");\n\n        assertThat(part).isNotNull();\n\n        Exception exception = assertThrows(Exception.class, () -> {\n            ok(fineract().images.create(\"clients\", clientId, part));\n        });\n\n        assertThat(exception).isNotNull();\n\n        log.warn(\"Should not be able to upload a gif it is not whitelisted: {}\", exception.getMessage());\n    } END"}
{"prompt":"path Traversal Jpg\n\n###\n\n","completion":"    @Test\n    @Order(103)\n    void pathTraversalJpg() {\n        final MultipartBody.Part part = createPart(\"michael.vorburger-crepes.jpg\",\n                \"..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/tmp\/michael.vorburger-crepes.jpg\", \"image\/jpeg\");\n\n        assertThat(part).isNotNull();\n\n        Exception exception = assertThrows(Exception.class, () -> {\n            ok(fineract().images.create(\"clients\", clientId, part));\n        });\n\n        assertThat(exception).isNotNull();\n\n        log.warn(\"Should not be able to upload a file with a forbidden name pattern: {}\", exception.getMessage());\n    } END"}
{"prompt":"path Traversal With Absolute Path Jpg\n\n###\n\n","completion":"    @Test\n    @Order(104)\n    void pathTraversalWithAbsolutePathJpg() {\n        final MultipartBody.Part part = createPart(\"michael.vorburger-crepes.jpg\", \"..\/17\/michael.vorburger-crepes.jpg\", \"image\/jpeg\");\n\n        assertThat(part).isNotNull();\n\n        Exception exception = assertThrows(Exception.class, () -> {\n            ok(fineract().images.create(\"clients\", clientId, part));\n        });\n\n        assertThat(exception).isNotNull();\n\n        log.warn(\"Should not be able to upload a file with a forbidden name pattern: {}\", exception.getMessage());\n    } END"}
{"prompt":"path Traversal With Absolute Path Jpg2\n\n###\n\n","completion":"    @Test\n    @Order(105)\n    void pathTraversalWithAbsolutePathJpg2() {\n        final MultipartBody.Part part = createPart(\"michael.vorburger-crepes.jpg\", \"..\/\/17\/\/michael.vorburger-crepes.jpg\", \"image\/jpeg\");\n\n        assertThat(part).isNotNull();\n\n        Exception exception = assertThrows(Exception.class, () -> {\n            ok(fineract().images.create(\"clients\", clientId, part));\n        });\n\n        assertThat(exception).isNotNull();\n\n        log.warn(\"Should not be able to upload a file with a forbidden name pattern: {}\", exception.getMessage());\n    } END"}
{"prompt":"retrieve One Existing Incl Date Format\n\n###\n\n","completion":"    @Test\n    @Order(2)\n    void retrieveOneExistingInclDateFormat() { \/\/ see FINERACT-1220 re. what this tests re. Date Format\n        List<GetOfficesResponse> response = ok(fineract().offices.retrieveOffices(true, null, null));\n        assertThat(response.size()).isAtLeast(1);\n        assertThat(response.get(0).getOpeningDate()).isNotNull();\n    } END"}
{"prompt":"run Client Listing Table Report CSV\n\n###\n\n","completion":"    @Test\n    void runClientListingTableReportCSV() throws IOException {\n        Response<ResponseBody> result = okR(\n                fineract().reportsRun.runReportGetFile(\"Client Listing\", Map.of(\"R_officeId\", \"1\", \"exportCSV\", \"true\"), false));\n        assertThat(result.body().contentType()).isEqualTo(MediaType.parse(\"text\/csv\"));\n        assertThat(result.body().string()).contains(\"Office\/Branch\");\n    } END"}
{"prompt":"run Client Listing Table Report S3\n\n###\n\n","completion":"    @Test\n    @CIOnly\n    void runClientListingTableReportS3() throws IOException {\n        Response<ResponseBody> result = okR(\n                fineract().reportsRun.runReportGetFile(\"Client Listing\", Map.of(\"R_officeId\", \"1\", \"exportS3\", \"true\"), false));\n        assertThat(result.code()).isEqualTo(204);\n    } END"}
{"prompt":"list Reports\n\n###\n\n","completion":"    @Test\n    void listReports() {\n        assertThat(ok(fineract().reports.retrieveReportList())).hasSize(126);\n    } END"}
{"prompt":"run Client Listing Table Report\n\n###\n\n","completion":"    @Test\n    void runClientListingTableReport() {\n        assertThat(ok(fineract().reportsRun.runReportGetData(\"Client Listing\", Map.of(\"R_officeId\", \"1\"), false)).getColumnHeaders().get(0)\n                .getColumnName()).isEqualTo(\"Office\/Branch\");\n    } END"}
{"prompt":"run Report Category\n\n###\n\n","completion":"    @Test \/\/ see FINERACT-1306\n    void runReportCategory() throws IOException {\n        \/\/ Using raw OkHttp instead of Retrofit API here, because \/runreports\/reportCategoryList returns JSON Array -\n        \/\/ but runReportGetData() expects columnHeaders\/data JSON.\n        var req = new Request.Builder().url(fineract().baseURL().resolve(\n                \"\/fineract-provider\/api\/v1\/runreports\/reportCategoryList?R_reportCategory=Fund&genericResultSet=false&parameterType=true&tenantIdentifier=default\"))\n                .build();\n        try (var response = fineract().okHttpClient().newCall(req).execute()) {\n            assertThat(response.code()).isEqualTo(200);\n        }\n    } END"}
{"prompt":"run Expected Payments Pentaho Report Without Plugin\n\n###\n\n","completion":"    @Test\n    void runExpectedPaymentsPentahoReportWithoutPlugin() {\n        assertThat(fineract().reportsRun.runReportGetFile(\"Expected Payments By Date - Formatted\", Map.of(\"R_endDate\", \"2013-04-30\",\n                \"R_loanOfficerId\", \"-1\", \"R_officeId\", \"1\", \"R_startDate\", \"2013-04-16\", \"output-type\", \"PDF\"), false)).hasHttpStatus(503);\n    } END"}
{"prompt":"run Expected Payments Pentaho Report\n\n###\n\n","completion":"    @Test\n    @Disabled\n    void runExpectedPaymentsPentahoReport() {\n        ResponseBody r = ok(fineract().reportsRun.runReportGetFile(\"Expected Payments By Date - Formatted\", Map.of(\"R_endDate\",\n                \"2013-04-30\", \"R_loanOfficerId\", \"-1\", \"R_officeId\", \"1\", \"R_startDate\", \"2013-04-16\", \"output-type\", \"PDF\"), false));\n        assertThat(r.contentType()).isEqualTo(MediaType.get(\"application\/pdf\"));\n    } END"}
{"prompt":"test Trial Balance Table Report Runs Successfully\n\n###\n\n","completion":"    @Test\n    void testTrialBalanceTableReportRunsSuccessfully() {\n        assertThat(fineract().reportsRun.runReportGetData(\"Trial Balance Table\",\n                Map.of(\"R_endDate\", \"2013-04-30\", \"R_officeId\", \"1\", \"R_startDate\", \"2013-04-16\"), false)).hasHttpStatus(200);\n    } END"}
{"prompt":"test Income Statement Table Report Runs Successfully\n\n###\n\n","completion":"    @Test\n    void testIncomeStatementTableReportRunsSuccessfully() {\n        assertThat(fineract().reportsRun.runReportGetData(\"Income Statement Table\",\n                Map.of(\"R_endDate\", \"2013-04-30\", \"R_officeId\", \"1\", \"R_startDate\", \"2013-04-16\"), false)).hasHttpStatus(200);\n    } END"}
{"prompt":"test General Ledger Report Table Report Runs Successfully\n\n###\n\n","completion":"    @Test\n    void testGeneralLedgerReportTableReportRunsSuccessfully() {\n        assertThat(fineract().reportsRun.runReportGetData(\"GeneralLedgerReport Table\",\n                Map.of(\"R_endDate\", \"2013-04-30\", \"R_officeId\", \"1\", \"R_startDate\", \"2013-04-16\", \"R_GLAccountNO\", \"1\"), false))\n                        .hasHttpStatus(200);\n    } END"}
{"prompt":"test Balance Sheet Table Report Runs Successfully\n\n###\n\n","completion":"    @Test\n    void testBalanceSheetTableReportRunsSuccessfully() {\n        assertThat(\n                fineract().reportsRun.runReportGetData(\"Balance Sheet Table\", Map.of(\"R_endDate\", \"2013-04-30\", \"R_officeId\", \"1\"), false))\n                        .hasHttpStatus(200);\n    } END"}
{"prompt":"client Charge Test\n\n###\n\n","completion":"    @Test\n    public void clientChargeTest() {\n\n        \/\/ Creates clientCharge\n        final Integer chargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getChargeSpecifiedDueDateJSON());\n        Assertions.assertNotNull(chargeId);\n\n        \/\/ creates client with activation date\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 October 2011\");\n        Assertions.assertNotNull(clientId);\n\n        \/**\n         * create a charge for loan and try to associate to client created in the above lines.it will be an invalid\n         * scenario the reason is client is not allowed to have only client charge.\n         *\n         *\/\n        final Integer loanChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON());\n        Assertions.assertNotNull(loanChargeId);\n        ResponseSpecification responseLoanChargeFailure = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final Integer clientLoanChargeId = ClientHelper.addChargesForClient(this.requestSpec, responseLoanChargeFailure, clientId,\n                ClientHelper.getSpecifiedDueDateChargesClientAsJSON(loanChargeId.toString(), \"29 October 2011\"));\n        Assertions.assertNull(clientLoanChargeId);\n\n        \/**\n         * associates a clientCharge to a client and pay client charge for 10 USD--success scenario\n         **\/\n        final Integer clientChargeId = ClientHelper.addChargesForClient(this.requestSpec, this.responseSpec, clientId,\n                ClientHelper.getSpecifiedDueDateChargesClientAsJSON(chargeId.toString(), \"29 October 2011\"));\n        Assertions.assertNotNull(clientChargeId);\n        final String clientChargePaidTransactionId = ClientHelper.payChargesForClients(this.requestSpec, this.responseSpec, clientId,\n                clientChargeId, ClientHelper.getPayChargeJSON(\"25 AUGUST 2015\", \"10\"));\n        Assertions.assertNotNull(clientChargePaidTransactionId);\n        isValidOutstandingAmount(ClientHelper.getClientCharge(requestSpec, responseSpec, clientId.toString(), clientChargeId.toString()),\n                (float) 190.0);\n\n        \/**\n         * Revert the paid client charge transaction by passing the clientChargePaidTransactionId and ensure the same is\n         * reverted.\n         *\/\n        final Integer undoTrxnId = ClientHelper.revertClientChargeTransaction(this.requestSpec, this.responseSpec, clientId.toString(),\n                clientChargePaidTransactionId);\n        Assertions.assertNotNull(undoTrxnId);\n        isReversedTransaction(clientId.toString(), undoTrxnId.toString());\n        \/**\n         * Now pay client charge for 20 USD and ensure the outstanding amount is updated properly\n         *\/\n        ResponseSpecification responseSpecFailure = new ResponseSpecBuilder().expectStatusCode(400).build();\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n        Calendar today = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        today.add(Calendar.DAY_OF_MONTH, 2);\n        final String responseId_futureDate_failure = ClientHelper.payChargesForClients(this.requestSpec, responseSpecFailure, clientId,\n                clientChargeId, ClientHelper.getPayChargeJSON(dateFormat.format(today.getTime()), \"20\"));\n        Assertions.assertNull(responseId_futureDate_failure);\n\n        \/\/ waived off the outstanding client charge\n        final String waiveOffClientChargeTransactionId = ClientHelper.waiveChargesForClients(this.requestSpec, this.responseSpec, clientId,\n                clientChargeId, ClientHelper.getWaiveChargeJSON(\"100\", clientChargeId.toString()));\n        Assertions.assertNotNull(waiveOffClientChargeTransactionId);\n\n        \/**\n         * Revert the waived off client charge transaction by passing the waiveOffClientChargeTransactionId and ensured\n         * the transaction is reversed.\n         *\/\n        final Integer undoWaiveTrxnId = ClientHelper.revertClientChargeTransaction(this.requestSpec, this.responseSpec, clientId.toString(),\n                waiveOffClientChargeTransactionId);\n        Assertions.assertNotNull(undoWaiveTrxnId);\n        isReversedTransaction(clientId.toString(), undoWaiveTrxnId.toString());\n        \/**\n         * pay client charge before client activation date and ensured its a failure test case\n         *\/\n\n        final String responseId_activationDate_failure = ClientHelper.payChargesForClients(this.requestSpec, responseSpecFailure, clientId,\n                clientChargeId, ClientHelper.getPayChargeJSON(\"30 September 2011\", \"20\"));\n        Assertions.assertNull(responseId_activationDate_failure);\n        \/**\n         * pay client charge more than outstanding amount amount and ensured its a failure test case\n         *\/\n        final String responseId_moreAmount_failure = ClientHelper.payChargesForClients(this.requestSpec, responseSpecFailure, clientId,\n                clientChargeId, ClientHelper.getPayChargeJSON(\"25 AUGUST 2015\", \"300\"));\n        Assertions.assertNull(responseId_moreAmount_failure);\n        \/**\n         * pay client charge for 10 USD and ensure outstanding amount is updated properly\n         *\/\n        final String chargePaid_responseId = ClientHelper.payChargesForClients(this.requestSpec, this.responseSpec, clientId,\n                clientChargeId, ClientHelper.getPayChargeJSON(\"25 AUGUST 2015\", \"100\"));\n        Assertions.assertNotNull(chargePaid_responseId);\n\n        isValidOutstandingAmount(ClientHelper.getClientCharge(requestSpec, responseSpec, clientId.toString(), clientChargeId.toString()),\n                (float) 100.0);\n\n    } END"}
{"prompt":"test Create Provisioning Criteria\n\n###\n\n","completion":"    @Test\n    public void testCreateProvisioningCriteria() {\n        ProvisioningTransactionHelper transactionHelper = new ProvisioningTransactionHelper(requestSpec, responseSpec);\n        ArrayList<Integer> loanProducts = new ArrayList<>(LOANPRODUCTS_SIZE);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        for (int i = 0; i < LOANPRODUCTS_SIZE; i++) {\n            final Integer loanProductID = createLoanProduct(false, NONE);\n            loanProducts.add(loanProductID);\n            Assertions.assertNotNull(loanProductID);\n            List<HashMap> collaterals = new ArrayList<>();\n            final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n            Assertions.assertNotNull(collateralId);\n            final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                    String.valueOf(clientID), collateralId);\n            Assertions.assertNotNull(clientCollateralId);\n            addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, null, null, \"1,00,000.00\", collaterals);\n            HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n            LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n            String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n            Assertions.assertNotNull(loanID);\n        }\n\n        ArrayList categories = transactionHelper.retrieveAllProvisioningCategories();\n        Assertions.assertTrue(categories.size() > 0);\n        Account liability = accountHelper.createLiabilityAccount();\n        Account expense = accountHelper.createExpenseAccount();\n        Map requestCriteria = ProvisioningHelper.createProvisioingCriteriaJson(loanProducts, categories, liability, expense);\n        String provisioningCriteriaCreateJson = new Gson().toJson(requestCriteria);\n        Integer criteriaId = transactionHelper.createProvisioningCriteria(provisioningCriteriaCreateJson);\n        Assertions.assertNotNull(criteriaId);\n\n        Map newCriteria = transactionHelper.retrieveProvisioningCriteria(criteriaId);\n        validateProvisioningCriteria(requestCriteria, newCriteria);\n\n        ArrayList definitions = (ArrayList) newCriteria.get(\"definitions\");\n        for (int i = 0; i < definitions.size(); i++) {\n            Map criteriadefinition = (Map) definitions.get(i);\n            criteriadefinition.put(\"provisioningPercentage\", Float.valueOf((float) 20.0));\n        }\n        newCriteria.put(\"locale\", \"en\");\n        String updateCriteriaString = new Gson().toJson(newCriteria);\n        Integer criteriaId1 = transactionHelper.updateProvisioningCriteria(criteriaId, updateCriteriaString);\n        Map updatedCriteria = transactionHelper.retrieveProvisioningCriteria(criteriaId1);\n        validateProvisioningCriteria(newCriteria, updatedCriteria);\n\n        transactionHelper.deleteProvisioningCriteria(criteriaId1);\n\n        categories = transactionHelper.retrieveAllProvisioningCategories();\n        liability = accountHelper.createLiabilityAccount();\n        expense = accountHelper.createExpenseAccount();\n        requestCriteria = ProvisioningHelper.createProvisioingCriteriaJson(loanProducts, categories, liability, expense);\n        provisioningCriteriaCreateJson = new Gson().toJson(requestCriteria);\n        criteriaId = transactionHelper.createProvisioningCriteria(provisioningCriteriaCreateJson);\n        Assertions.assertNotNull(criteriaId);\n\n        String provisioningEntryJson = ProvisioningHelper.createProvisioningEntryJson();\n        Integer provisioningEntryId = transactionHelper.createProvisioningEntries(provisioningEntryJson);\n        Assertions.assertNotNull(provisioningEntryId);\n\n        transactionHelper.updateProvisioningEntry(\"recreateprovisioningentry\", provisioningEntryId, \"\");\n        transactionHelper.updateProvisioningEntry(\"createjournalentry\", provisioningEntryId, \"\");\n        Map entry = transactionHelper.retrieveProvisioningEntry(provisioningEntryId);\n        Assertions.assertTrue((Boolean) entry.get(\"journalEntry\"));\n        Map provisioningEntry = transactionHelper.retrieveProvisioningEntries(provisioningEntryId);\n        Assertions.assertTrue(((ArrayList) provisioningEntry.get(\"pageItems\")).size() > 0);\n    } END"}
{"prompt":"test Supported Actions For Campaign With Trigger Type As Direct\n\n###\n\n","completion":"    @Test\n    public void testSupportedActionsForCampaignWithTriggerTypeAsDirect() {\n        \/\/ creating new campaign\n        Integer campaignId = this.campaignsHelper.createCampaign(NON_TRIGGERED_REPORT_NAME, DIRECT_TRIGGER_TYPE);\n        this.campaignsHelper.verifyCampaignCreatedOnServer(this.requestSpec, this.responseSpec, campaignId);\n\n        \/\/ updating campaign\n        Integer updatedCampaignId = this.campaignsHelper.updateCampaign(this.requestSpec, this.responseSpec, campaignId,\n                NON_TRIGGERED_REPORT_NAME, DIRECT_TRIGGER_TYPE);\n        assertEquals(campaignId, updatedCampaignId);\n\n        \/\/ activating campaign\n        Integer activatedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                ACTIVATE_COMMAND);\n        assertEquals(activatedCampaignId, campaignId);\n\n        \/\/ closing campaign\n        Integer closedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                CLOSE_COMMAND);\n        assertEquals(closedCampaignId, campaignId);\n\n        \/\/ reactivating campaign\n        Integer reactivateCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                REACTIVATE_COMMAND);\n        assertEquals(reactivateCampaignId, campaignId);\n\n        \/\/ closing campaign again for deletion\n        closedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId, CLOSE_COMMAND);\n        assertEquals(closedCampaignId, campaignId);\n\n        \/\/ deleting campaign\n        Integer deletedCampaignId = this.campaignsHelper.deleteCampaign(this.requestSpec, this.responseSpec, campaignId);\n        assertEquals(deletedCampaignId, campaignId);\n    } END"}
{"prompt":"test Supported Actions For Campaign With Trigger Type As Scheduled\n\n###\n\n","completion":"    @Test\n    public void testSupportedActionsForCampaignWithTriggerTypeAsScheduled() {\n        \/\/ creating new campaign\n        Integer campaignId = this.campaignsHelper.createCampaign(NON_TRIGGERED_REPORT_NAME, SCHEDULED_TRIGGER_TYPE);\n        this.campaignsHelper.verifyCampaignCreatedOnServer(this.requestSpec, this.responseSpec, campaignId);\n\n        \/\/ updating campaign\n        Integer updatedCampaignId = this.campaignsHelper.updateCampaign(this.requestSpec, this.responseSpec, campaignId,\n                NON_TRIGGERED_REPORT_NAME, SCHEDULED_TRIGGER_TYPE);\n        assertEquals(campaignId, updatedCampaignId);\n\n        \/\/ activating campaign\n        Integer activatedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                ACTIVATE_COMMAND);\n        assertEquals(activatedCampaignId, campaignId);\n\n        \/\/ closing campaign\n        Integer closedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                CLOSE_COMMAND);\n        assertEquals(closedCampaignId, campaignId);\n\n        \/\/ reactivating campaign\n        Integer reactivateCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                REACTIVATE_COMMAND);\n        assertEquals(reactivateCampaignId, campaignId);\n\n        \/\/ closing campaign again for deletion\n        closedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId, CLOSE_COMMAND);\n        assertEquals(closedCampaignId, campaignId);\n\n        \/\/ deleting campaign\n        Integer deletedCampaignId = this.campaignsHelper.deleteCampaign(this.requestSpec, this.responseSpec, campaignId);\n        assertEquals(deletedCampaignId, campaignId);\n    } END"}
{"prompt":"test Supported Actions For Campaign With Trigger Type As Triggered\n\n###\n\n","completion":"    @Test\n    public void testSupportedActionsForCampaignWithTriggerTypeAsTriggered() {\n        \/\/ creating new campaign\n        Integer campaignId = this.campaignsHelper.createCampaign(TRIGGERED_REPORT_NAME, TRIGGERED_TRIGGER_TYPE);\n        this.campaignsHelper.verifyCampaignCreatedOnServer(this.requestSpec, this.responseSpec, campaignId);\n\n        \/\/ updating campaign\n        Integer updatedCampaignId = this.campaignsHelper.updateCampaign(this.requestSpec, this.responseSpec, campaignId,\n                TRIGGERED_REPORT_NAME, TRIGGERED_TRIGGER_TYPE);\n        assertEquals(campaignId, updatedCampaignId);\n\n        \/\/ activating campaign\n        Integer activatedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                ACTIVATE_COMMAND);\n        assertEquals(activatedCampaignId, campaignId);\n\n        \/\/ closing campaign\n        Integer closedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                CLOSE_COMMAND);\n        assertEquals(closedCampaignId, campaignId);\n\n        \/\/ reactivating campaign\n        Integer reactivateCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                REACTIVATE_COMMAND);\n        assertEquals(reactivateCampaignId, campaignId);\n\n        \/\/ closing campaign again for deletion\n        closedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId, CLOSE_COMMAND);\n        assertEquals(closedCampaignId, campaignId);\n\n        \/\/ deleting campaign\n        Integer deletedCampaignId = this.campaignsHelper.deleteCampaign(this.requestSpec, this.responseSpec, campaignId);\n        assertEquals(deletedCampaignId, campaignId);\n    } END"}
{"prompt":"test Supported Actions For Campaign With Error\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSupportedActionsForCampaignWithError() {\n        final ResponseSpecification responseSpecWithError = new ResponseSpecBuilder().expectStatusCode(400).build();\n        CampaignsHelper campaignsHelperWithError = new CampaignsHelper(this.requestSpec, responseSpecWithError);\n        \/\/ creating new campaign\n        Integer campaignId = this.campaignsHelper.createCampaign(NON_TRIGGERED_REPORT_NAME, DIRECT_TRIGGER_TYPE);\n        this.campaignsHelper.verifyCampaignCreatedOnServer(this.requestSpec, this.responseSpec, campaignId);\n\n        \/\/ activating campaign with failure\n        ArrayList<HashMap<String, Object>> campaignDateValidationData = (ArrayList<HashMap<String, Object>>) campaignsHelperWithError\n                .performActionsOnCampaignWithFailure(campaignId, ACTIVATE_COMMAND,\n                        Utils.getLocalDateOfTenant().plusDays(1).format(DateTimeFormatter.ofPattern(DATE_FORMAT)),\n                        CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.campaign.activationDate.in.the.future\",\n                campaignDateValidationData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        \/\/ activating campaign\n        Integer activatedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                ACTIVATE_COMMAND);\n        assertEquals(activatedCampaignId, campaignId);\n\n        \/\/ activating campaign with failure\n        ArrayList<HashMap<String, Object>> campaignErrorData = (ArrayList<HashMap<String, Object>>) campaignsHelperWithError\n                .performActionsOnCampaignWithFailure(activatedCampaignId, ACTIVATE_COMMAND,\n                        Utils.getLocalDateOfTenant().format(DateTimeFormatter.ofPattern(DATE_FORMAT)), CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.campaign.already.active\", campaignErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        \/\/ closing campaign again for deletion\n        Integer closedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                CLOSE_COMMAND);\n        assertEquals(closedCampaignId, campaignId);\n\n        \/\/ deleting campaign\n        Integer deletedCampaignId = this.campaignsHelper.deleteCampaign(this.requestSpec, this.responseSpec, campaignId);\n        assertEquals(deletedCampaignId, campaignId);\n\n    } END"}
{"prompt":"validate Create Delete Datatable Check\n\n###\n\n","completion":"    @Test\n    public void validateCreateDeleteDatatableCheck() {\n        \/\/ creating datatable\n        String datatableName = this.datatableHelper.createDatatable(CLIENT_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, datatableName);\n\n        \/\/ creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(CLIENT_APP_TABLE_NAME, datatableName,\n                100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(datatableName);\n        assertEquals(datatableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    } END"}
{"prompt":"validate Create Delete Entity Datatable Check\n\n###\n\n","completion":"    @Test\n    public void validateCreateDeleteEntityDatatableCheck() {\n        \/\/ creating datatable\n        String datatableName = this.datatableHelper.createDatatable(CLIENT_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, datatableName);\n\n        \/\/ creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(CLIENT_APP_TABLE_NAME, datatableName,\n                100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(datatableName);\n        assertEquals(datatableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    } END"}
{"prompt":"validate Retrive Entity Datatable Checks List\n\n###\n\n","completion":"    @Test\n    public void validateRetriveEntityDatatableChecksList() {\n        \/\/ retrieving entity datatable check\n        String entityDatatableChecksList = this.entityDatatableChecksHelper.retrieveEntityDatatableCheck();\n        assertNotNull(\"ERROR IN RETRIEVING THE ENTITY DATATABLE CHECKS\", entityDatatableChecksList);\n    } END"}
{"prompt":"validate Create Client With Entity Datatable Check\n\n###\n\n","completion":"    @Test\n    public void validateCreateClientWithEntityDatatableCheck() {\n\n        \/\/ creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(CLIENT_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        \/\/ creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(CLIENT_APP_TABLE_NAME,\n                registeredTableName, 100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ creating client with datatables\n        final Integer clientID = ClientHelper.createClientPendingWithDatatable(requestSpec, responseSpec, registeredTableName);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        \/\/ deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ deleting datatable entries\n        Integer appTableId = this.datatableHelper.deleteDatatableEntries(registeredTableName, clientID, \"clientId\");\n        assertEquals(clientID, appTableId, \"ERROR IN DELETING THE DATATABLE ENTRIES\");\n\n        \/\/ deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    } END"}
{"prompt":"validate Create Client With Entity Datatable Check With Failure\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void validateCreateClientWithEntityDatatableCheckWithFailure() {\n        \/\/ building error response with status code 403\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n\n        \/\/ creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(CLIENT_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        \/\/ creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(CLIENT_APP_TABLE_NAME,\n                registeredTableName, 100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ creating client with datatables with error\n        ArrayList<HashMap<Object, Object>> clientErrorData = (ArrayList<HashMap<Object, Object>>) validationErrorHelper\n                .createClientPendingWithError(CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.entry.required.in.datatable.[\" + registeredTableName + \"]\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        \/\/ deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    } END"}
{"prompt":"validate Create Group With Entity Datatable Check\n\n###\n\n","completion":"    @Test\n    public void validateCreateGroupWithEntityDatatableCheck() {\n\n        \/\/ creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(GROUP_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        \/\/ creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(GROUP_APP_TABLE_NAME,\n                registeredTableName, 100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ creating group with datatables\n        final Integer groupId = GroupHelper.createGroupPendingWithDatatable(this.requestSpec, this.responseSpec, registeredTableName);\n        GroupHelper.verifyGroupCreatedOnServer(this.requestSpec, this.responseSpec, groupId);\n\n        \/\/ deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ deleting datatable entries\n        Integer appTableId = this.datatableHelper.deleteDatatableEntries(registeredTableName, groupId, \"groupId\");\n        assertEquals(groupId, appTableId, \"ERROR IN DELETING THE DATATABLE ENTRIES\");\n\n        \/\/ deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    } END"}
{"prompt":"validate Create Group With Entity Datatable Check With Failure\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void validateCreateGroupWithEntityDatatableCheckWithFailure() {\n        \/\/ building error response with status code 403\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final GroupHelper validationErrorHelper = new GroupHelper(this.requestSpec, errorResponse);\n\n        \/\/ creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(GROUP_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        \/\/ creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(GROUP_APP_TABLE_NAME,\n                registeredTableName, 100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ creating group with datatables with error\n        ArrayList<HashMap<Object, Object>> groupErrorData = (ArrayList<HashMap<Object, Object>>) validationErrorHelper\n                .createGroupWithError(CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.entry.required.in.datatable.[\" + registeredTableName + \"]\",\n                groupErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        \/\/ deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    } END"}
{"prompt":"validate Create Savings With Entity Datatable Check\n\n###\n\n","completion":"    @Test\n    public void validateCreateSavingsWithEntityDatatableCheck() {\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n\n        \/\/ creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(SAVINGS_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        \/\/ creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(SAVINGS_APP_TABLE_NAME,\n                registeredTableName, 100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        \/\/ creating savings with datatables\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplicationWithDatatables(clientID, savingsProductID,\n                ACCOUNT_TYPE_INDIVIDUAL, \"01 December 2016\", registeredTableName);\n        Assertions.assertNotNull(savingsId);\n\n        \/\/ deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ deleting datatable entries\n        Integer appTableId = this.datatableHelper.deleteDatatableEntries(registeredTableName, savingsId, \"savingsId\");\n        assertEquals(savingsId, appTableId, \"ERROR IN DELETING THE DATATABLE ENTRIES\");\n\n        \/\/ deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    } END"}
{"prompt":"validate Create Savings With Entity Datatable Check With Failure\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void validateCreateSavingsWithEntityDatatableCheckWithFailure() {\n        \/\/ building error response with status code 403\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n\n        \/\/ creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(SAVINGS_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        \/\/ creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(SAVINGS_APP_TABLE_NAME,\n                registeredTableName, 100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        \/\/ creating savings with datatables with error\n        ArrayList<HashMap<Object, Object>> groupErrorData = (ArrayList<HashMap<Object, Object>>) validationErrorHelper\n                .applyForSavingsApplicationWithFailure(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL, \"01 December 2016\",\n                        CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.entry.required.in.datatable.[\" + registeredTableName + \"]\",\n                groupErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        \/\/ deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    } END"}
{"prompt":"validate Create Loan With Entity Datatable Check\n\n###\n\n","completion":"    @Test\n    public void validateCreateLoanWithEntityDatatableCheck() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        \/\/ creating client\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        \/\/ creating loan product\n        final Integer loanProductID = createLoanProduct(\"100\", \"0\", LoanProductTestBuilder.DEFAULT_STRATEGY);\n        Assertions.assertNotNull(loanProductID);\n\n        \/\/ creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(LOAN_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        \/\/ creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(LOAN_APP_TABLE_NAME,\n                registeredTableName, 100, loanProductID);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ creating new loan application\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"5\", registeredTableName);\n        Assertions.assertNotNull(loanID);\n\n        \/\/ deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ deleting datatable entries\n        Integer appTableId = this.datatableHelper.deleteDatatableEntries(registeredTableName, loanID, \"loanId\");\n        assertEquals(loanID, appTableId, \"ERROR IN DELETING THE DATATABLE ENTRIES\");\n\n        \/\/ deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    } END"}
{"prompt":"validate Create Loan With Entity Datatable Check With Failure\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void validateCreateLoanWithEntityDatatableCheckWithFailure() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        \/\/ building error response with status code 403\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        this.validationErrorHelper = new LoanTransactionHelper(this.requestSpec, errorResponse);\n\n        \/\/ creating client\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        \/\/ creating loan product\n        final Integer loanProductID = createLoanProduct(\"100\", \"0\", LoanProductTestBuilder.DEFAULT_STRATEGY);\n        Assertions.assertNotNull(loanProductID);\n\n        \/\/ creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(LOAN_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        \/\/ creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(LOAN_APP_TABLE_NAME,\n                registeredTableName, 100, loanProductID);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ creating new loan application with error\n        ArrayList<HashMap<Object, Object>> loanErrorData = (ArrayList<HashMap<Object, Object>>) applyForLoanApplicationWithError(clientID,\n                loanProductID, \"5\", CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.entry.required.in.datatable.[\" + registeredTableName + \"]\",\n                loanErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        \/\/ deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        \/\/ deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    } END"}
{"prompt":"create Client With Datatable Using Entity Subtype\n\n###\n\n","completion":"    @Test\n    public void createClientWithDatatableUsingEntitySubtype() {\n        \/\/ creating datatable for client entity person subentity\n        HashMap<String, Object> columnMap = new HashMap<>();\n        final List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n        final String datatableNamePerson = Utils.uniqueRandomStringGenerator(CLIENT_APP_TABLE_NAME + \"_person_\", 5).toLowerCase()\n                .toLowerCase();\n        final String datatableNameEntity = Utils.uniqueRandomStringGenerator(CLIENT_APP_TABLE_NAME + \"_entity_\", 5).toLowerCase()\n                .toLowerCase();\n\n        String itsAString = \"itsastring\";\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsAString, \"String\", true, 10, null);\n\n        \/\/ Person Subtype\n        columnMap.put(\"datatableName\", datatableNamePerson);\n        columnMap.put(\"apptableName\", CLIENT_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"PERSON\");\n        columnMap.put(\"multiRow\", false);\n        String dateFormat = \"dateFormat\";\n\n        columnMap.put(\"columns\", datatableColumnsList);\n        String datatabelRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"map : {}\", datatabelRequestJsonString);\n\n        datatableHelper.createDatatable(datatabelRequestJsonString, \"\");\n\n        PostEntityDatatableChecksTemplateResponse entityDatatableChecksResponse = entityDatatableChecksHelper\n                .addEntityDatatableCheck(CLIENT_APP_TABLE_NAME, datatableNamePerson, 100, null);\n        assertNotNull(entityDatatableChecksResponse);\n        final Long personDatatableCheck = entityDatatableChecksResponse.getResourceId();\n        LOG.info(\"entityDatatableChecksResponse Person: {}\", entityDatatableChecksResponse.getResourceId());\n\n        \/\/ Entity Subtype\n        columnMap = new HashMap<>();\n        columnMap.put(\"datatableName\", datatableNameEntity);\n        columnMap.put(\"apptableName\", CLIENT_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"ENTITY\");\n        columnMap.put(\"multiRow\", false);\n\n        columnMap.put(\"columns\", datatableColumnsList);\n        datatabelRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"map : {}\", datatabelRequestJsonString);\n\n        datatableHelper.createDatatable(datatabelRequestJsonString, \"\");\n\n        entityDatatableChecksResponse = entityDatatableChecksHelper.addEntityDatatableCheck(CLIENT_APP_TABLE_NAME, datatableNameEntity, 100,\n                null);\n        assertNotNull(entityDatatableChecksResponse);\n        final Long entityDatatableCheck = entityDatatableChecksResponse.getResourceId();\n        LOG.info(\"entityDatatableChecksResponse Entity: {}\", entityDatatableChecksResponse.getResourceId());\n\n        final HashMap<String, Object> datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(itsAString, Utils.randomStringGenerator(\"\", 8));\n        datatableEntryMap.put(\"locale\", \"en\");\n\n        final HashMap<String, Object> datatablesMap = new HashMap<>();\n        datatablesMap.put(\"registeredTableName\", datatableNamePerson);\n        datatablesMap.put(\"data\", datatableEntryMap);\n\n        String datatablesJsonString = new Gson().toJson(datatablesMap);\n        LOG.info(\"map : {}\", datatablesJsonString);\n\n        PostClientsResponse postClientsResponse = ClientHelper.createClientAsPersonWithDatatable(requestSpec, responseSpec, \"04 March 2011\",\n                \"1\", datatablesMap);\n        assertNotNull(postClientsResponse);\n        assertNotNull(postClientsResponse.getResourceId());\n\n        \/\/ Remove the Entity Datatable checks for others tests\n        entityDatatableChecksHelper.deleteEntityDatatableCheck(personDatatableCheck.intValue());\n        entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheck.intValue());\n    } END"}
{"prompt":"test Create Dividends\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testCreateDividends() {\n        DateFormat simple = new SimpleDateFormat(\"dd MMM yyyy\");\n        final Integer productId = createShareProduct();\n        ArrayList<Integer> shareAccounts = new ArrayList<>();\n        for (int i = 0; i < 5; i++) {\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n            Assertions.assertNotNull(clientId);\n            Integer savingsAccountId = SavingsAccountHelper.openSavingsAccount(requestSpec, responseSpec, clientId, \"1000\");\n            Assertions.assertNotNull(savingsAccountId);\n            final Integer shareAccountId = createShareAccount(clientId, productId, savingsAccountId, dates[i], shares[i]);\n            shareAccounts.add(shareAccountId);\n            Assertions.assertNotNull(shareAccountId);\n            Map<String, Object> shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec,\n                    responseSpec);\n            Assertions.assertNotNull(shareAccountData);\n            \/\/ Approve share Account\n            Map<String, Object> approveMap = new HashMap<>();\n            approveMap.put(\"note\", \"Share Account Approval Note\");\n            approveMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n            approveMap.put(\"approvedDate\", \"01 Jan 2016\");\n            approveMap.put(\"locale\", \"en\");\n            String approve = new Gson().toJson(approveMap);\n            ShareAccountTransactionHelper.postCommand(\"approve\", shareAccountId, approve, requestSpec, responseSpec);\n            \/\/ Activate Share Account\n            Map<String, Object> activateMap = new HashMap<>();\n            activateMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n            activateMap.put(\"activatedDate\", \"01 Jan 2016\");\n            activateMap.put(\"locale\", \"en\");\n            String activateJson = new Gson().toJson(activateMap);\n            ShareAccountTransactionHelper.postCommand(\"activate\", shareAccountId, activateJson, requestSpec, responseSpec);\n        }\n\n        Map<String, Object> dividendsMap = new HashMap<>();\n        dividendsMap.put(\"dividendPeriodStartDate\", \"01 Jan 2015\");\n        dividendsMap.put(\"dividendPeriodEndDate\", \"01 Apr 2016\");\n        dividendsMap.put(\"dividendAmount\", \"50000\");\n        dividendsMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n        dividendsMap.put(\"locale\", \"en\");\n        String createDividendsJson = new Gson().toJson(dividendsMap);\n        final Integer dividendId = ShareDividendsTransactionHelper.createShareProductDividends(productId, createDividendsJson, requestSpec,\n                responseSpec);\n\n        Map<String, Object> productdividends = ShareDividendsTransactionHelper.retrieveAllDividends(productId, requestSpec, responseSpec);\n        Assertions.assertEquals(\"1\", String.valueOf(productdividends.get(\"totalFilteredRecords\")));\n        Map<String, Object> dividend = ((List<Map<String, Object>>) productdividends.get(\"pageItems\")).get(0);\n        Assertions.assertEquals(\"50000.0\", String.valueOf(dividend.get(\"amount\")));\n        Map<String, Object> status = (Map<String, Object>) dividend.get(\"status\");\n        Assertions.assertEquals(\"shareAccountDividendStatusType.initiated\", String.valueOf(status.get(\"code\")));\n        List<Integer> startdateList = (List<Integer>) dividend.get(\"dividendPeriodStartDate\");\n        Calendar cal = Calendar.getInstance();\n        cal.set(startdateList.get(0), startdateList.get(1) - 1, startdateList.get(2));\n        Date startDate = cal.getTime();\n        Assertions.assertEquals(\"01 Jan 2015\", simple.format(startDate));\n        List<Integer> enddateList = (List<Integer>) dividend.get(\"dividendPeriodEndDate\");\n        cal = Calendar.getInstance();\n        cal.set(enddateList.get(0), enddateList.get(1) - 1, enddateList.get(2));\n        Date endDate = cal.getTime();\n        Assertions.assertEquals(\"01 Apr 2016\", simple.format(endDate));\n\n        Map<String, Object> dividenddetails = ShareDividendsTransactionHelper.retrieveDividendDetails(productId, dividendId, requestSpec,\n                responseSpec);\n        Assertions.assertEquals(\"5\", String.valueOf(dividenddetails.get(\"totalFilteredRecords\")));\n        List<Map<String, Object>> pageItems = (List<Map<String, Object>>) dividenddetails.get(\"pageItems\");\n        for (Map<String, Object> dividendData : pageItems) {\n            Map<String, Object> accountData = (Map<String, Object>) dividendData.get(\"accountData\");\n            String accountId = String.valueOf(accountData.get(\"id\"));\n            if (String.valueOf(shareAccounts.get(0)).equals(accountId)) {\n                Assertions.assertEquals(\"11320.755\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(1)).equals(accountId)) {\n                Assertions.assertEquals(\"18172.791\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(2)).equals(accountId)) {\n                Assertions.assertEquals(\"13629.593\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(3)).equals(accountId)) {\n                Assertions.assertEquals(\"3028.7983\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(4)).equals(accountId)) {\n                Assertions.assertEquals(\"3848.0637\", String.valueOf(dividendData.get(\"amount\")));\n            }\n            Map<String, Object> statusMap = (Map<String, Object>) dividendData.get(\"status\");\n            Assertions.assertEquals(\"shareAccountDividendStatusType.initiated\", String.valueOf(statusMap.get(\"code\")));\n        }\n\n        String jsonString = \"\";\n        ShareDividendsTransactionHelper.postCommand(\"approve\", productId, dividendId, jsonString, requestSpec, responseSpec);\n\n        productdividends = ShareDividendsTransactionHelper.retrieveAllDividends(productId, requestSpec, responseSpec);\n        Assertions.assertEquals(\"1\", String.valueOf(productdividends.get(\"totalFilteredRecords\")));\n        dividend = ((List<Map<String, Object>>) productdividends.get(\"pageItems\")).get(0);\n        Assertions.assertEquals(\"50000.0\", String.valueOf(dividend.get(\"amount\")));\n        status = (Map<String, Object>) dividend.get(\"status\");\n        Assertions.assertEquals(\"shareAccountDividendStatusType.approved\", String.valueOf(status.get(\"code\")));\n        startdateList = (List<Integer>) dividend.get(\"dividendPeriodStartDate\");\n        cal = Calendar.getInstance();\n        cal.set(startdateList.get(0), startdateList.get(1) - 1, startdateList.get(2));\n        startDate = cal.getTime();\n        Assertions.assertEquals(\"01 Jan 2015\", simple.format(startDate));\n        enddateList = (List<Integer>) dividend.get(\"dividendPeriodEndDate\");\n        cal = Calendar.getInstance();\n        cal.set(enddateList.get(0), enddateList.get(1) - 1, enddateList.get(2));\n        endDate = cal.getTime();\n        Assertions.assertEquals(\"01 Apr 2016\", simple.format(endDate));\n\n        dividenddetails = ShareDividendsTransactionHelper.retrieveDividendDetails(productId, dividendId, requestSpec, responseSpec);\n        Assertions.assertEquals(\"5\", String.valueOf(dividenddetails.get(\"totalFilteredRecords\")));\n        pageItems = (List<Map<String, Object>>) dividenddetails.get(\"pageItems\");\n        for (Map<String, Object> dividendData : pageItems) {\n            Map<String, Object> accountData = (Map<String, Object>) dividendData.get(\"accountData\");\n            String accountId = String.valueOf(accountData.get(\"id\"));\n            if (String.valueOf(shareAccounts.get(0)).equals(accountId)) {\n                Assertions.assertEquals(\"11320.755\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(1)).equals(accountId)) {\n                Assertions.assertEquals(\"18172.791\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(2)).equals(accountId)) {\n                Assertions.assertEquals(\"13629.593\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(3)).equals(accountId)) {\n                Assertions.assertEquals(\"3028.7983\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(4)).equals(accountId)) {\n                Assertions.assertEquals(\"3848.0637\", String.valueOf(dividendData.get(\"amount\")));\n            }\n            Map<String, Object> statusMap = (Map<String, Object>) dividendData.get(\"status\");\n            Assertions.assertEquals(\"shareAccountDividendStatusType.initiated\", String.valueOf(statusMap.get(\"code\")));\n        }\n\n    } END"}
{"prompt":"test Create Share Product\n\n###\n\n","completion":"    @Test\n    public void testCreateShareProduct() {\n        \/\/ This method will check create share product, get share product,\n        \/\/ update share product.\n        LOG.info(\"------------------------------CREATING NEW SHARE PRODUCT ---------------------------------------\");\n        shareProductHelper = new ShareProductHelper();\n        final Integer shareProductId = createShareProduct();\n        Assertions.assertNotNull(shareProductId);\n        LOG.info(\"------------------------------CREATING SHARE PRODUCT COMPLETE---------------------------------------\");\n\n        LOG.info(\"------------------------------RETRIEVING SHARE PRODUCT---------------------------------------\");\n        Map<String, Object> shareProductData = ShareProductTransactionHelper.retrieveShareProduct(shareProductId, requestSpec,\n                responseSpec);\n        Assertions.assertNotNull(shareProductData);\n        shareProductHelper.verifyShareProduct(shareProductData);\n\n        LOG.info(\"------------------------------RETRIEVING SHARE PRODUCT COMPLETE---------------------------------------\");\n\n        LOG.info(\"------------------------------UPDATING SHARE PRODUCT---------------------------------------\");\n\n        Map<String, Object> shareProductDataForUpdate = new HashMap<>();\n\n        shareProductDataForUpdate.put(\"totalShares\", \"2000\");\n        shareProductDataForUpdate.put(\"sharesIssued\", \"2000\");\n\n        String updateShareProductJsonString = new Gson().toJson(shareProductDataForUpdate);\n        Integer updatedProductId = ShareProductTransactionHelper.updateShareProduct(shareProductId, updateShareProductJsonString,\n                requestSpec, responseSpec);\n        Assertions.assertNotNull(updatedProductId);\n        Map<String, Object> updatedShareProductData = ShareProductTransactionHelper.retrieveShareProduct(updatedProductId, requestSpec,\n                responseSpec);\n        String updatedTotalShares = String.valueOf(updatedShareProductData.get(\"totalShares\"));\n        String updatedSharesIssued = String.valueOf(updatedShareProductData.get(\"totalSharesIssued\"));\n        Assertions.assertEquals(\"2000\", updatedTotalShares);\n        Assertions.assertEquals(\"2000\", updatedSharesIssued);\n        LOG.info(\"------------------------------UPDATING SHARE PRODUCT COMPLETE---------------------------------------\");\n\n    } END"}
{"prompt":"test Create Share Account\n\n###\n\n","completion":"    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testCreateShareAccount() {\n        shareProductHelper = new ShareProductHelper();\n        final Integer productId = createShareProduct();\n        Assertions.assertNotNull(productId);\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n        Integer savingsAccountId = SavingsAccountHelper.openSavingsAccount(requestSpec, responseSpec, clientId, \"1000\");\n        Assertions.assertNotNull(savingsAccountId);\n        final Integer shareAccountId = createShareAccount(clientId, productId, savingsAccountId);\n        Assertions.assertNotNull(shareAccountId);\n        Map<String, Object> shareProductData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec,\n                responseSpec);\n        Assertions.assertNotNull(shareProductData);\n\n        Map<String, Object> shareAccountDataForUpdate = new HashMap<>();\n        shareAccountDataForUpdate.put(\"requestedShares\", 30);\n        shareAccountDataForUpdate.put(\"applicationDate\", \"02 March 2016\");\n        shareAccountDataForUpdate.put(\"dateFormat\", \"dd MMMM yyyy\");\n        shareAccountDataForUpdate.put(\"locale\", \"en_GB\");\n        String updateShareAccountJsonString = new Gson().toJson(shareAccountDataForUpdate);\n        ShareAccountTransactionHelper.updateShareAccount(shareAccountId, updateShareAccountJsonString, requestSpec, responseSpec);\n        shareProductData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        List<Map<String, Object>> transactions = (List<Map<String, Object>>) shareProductData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(1, transactions.size());\n        Map<String, Object> transaction = transactions.get(0);\n        Assertions.assertEquals(\"30\", String.valueOf(transaction.get(\"numberOfShares\")));\n        Assertions.assertEquals(\"60.0\", String.valueOf(transaction.get(\"amount\")));\n        Assertions.assertEquals(\"60.0\", String.valueOf(transaction.get(\"amountPaid\")));\n        List<Integer> dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n        Calendar cal = Calendar.getInstance();\n        cal.set(dateList.get(0), dateList.get(1) - 1, dateList.get(2));\n        Date date = cal.getTime();\n        DateFormat simple = new SimpleDateFormat(\"dd MMMM yyyy\");\n        Assertions.assertEquals(\"02 March 2016\", simple.format(date));\n    } END"}
{"prompt":"test Share Account Approval\n\n###\n\n","completion":"    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testShareAccountApproval() {\n        shareProductHelper = new ShareProductHelper();\n        final Integer productId = createShareProduct();\n        Assertions.assertNotNull(productId);\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n        Integer savingsAccountId = SavingsAccountHelper.openSavingsAccount(requestSpec, responseSpec, clientId, \"1000\");\n        Assertions.assertNotNull(savingsAccountId);\n        String activationCharge = ChargesHelper.getShareAccountActivationChargeJson();\n        Integer activationChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, activationCharge);\n        String purchaseCharge = ChargesHelper.getShareAccountPurchaseChargeJson();\n        Integer purchaseChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, purchaseCharge);\n        String redeemCharge = ChargesHelper.getShareAccountRedeemChargeJson();\n        Integer redeemChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, redeemCharge);\n        List<Map<String, Object>> charges = new ArrayList<>();\n        charges.add(createCharge(activationChargeId, \"2\"));\n        charges.add(createCharge(purchaseChargeId, \"2\"));\n        charges.add(createCharge(redeemChargeId, \"1\"));\n        final Integer shareAccountId = createShareAccount(clientId, productId, savingsAccountId, charges);\n        Assertions.assertNotNull(shareAccountId);\n        Map<String, Object> shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec,\n                responseSpec);\n        Assertions.assertNotNull(shareAccountData);\n\n        \/\/ Approve share Account\n        Map<String, Object> approveMap = new HashMap<>();\n        approveMap.put(\"note\", \"Share Account Approval Note\");\n        approveMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n        approveMap.put(\"approvedDate\", \"01 January 2016\");\n        approveMap.put(\"locale\", \"en\");\n        String approve = new Gson().toJson(approveMap);\n        ShareAccountTransactionHelper.postCommand(\"approve\", shareAccountId, approve, requestSpec, responseSpec);\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        Map<String, Object> statusMap = (Map<String, Object>) shareAccountData.get(\"status\");\n        Assertions.assertEquals(\"shareAccountStatusType.approved\", String.valueOf(statusMap.get(\"code\")));\n        Map<String, Object> timelineMap = (Map<String, Object>) shareAccountData.get(\"timeline\");\n        List<Integer> dateList = (List<Integer>) timelineMap.get(\"approvedDate\");\n        LocalDate approvedDate = LocalDate.of(dateList.get(0), dateList.get(1), dateList.get(2));\n        Assertions.assertEquals(\"01 January 2016\", approvedDate.format(Utils.dateFormatter));\n        List<Map<String, Object>> transactions = (List<Map<String, Object>>) shareAccountData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(2, transactions.size());\n        for (int i = 0; i < transactions.size(); i++) {\n            Map<String, Object> transaction = transactions.get(i);\n            Map<String, Object> transactionTypeMap = (Map<String, Object>) transaction.get(\"type\");\n            dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n            LocalDate transactionDate = LocalDate.of(dateList.get(0), dateList.get(1), dateList.get(2));\n            String transactionType = (String) transactionTypeMap.get(\"code\");\n            if (transactionType.equals(\"purchasedSharesType.purchased\")) {\n                Assertions.assertEquals(\"25\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"52.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"52.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n                Assertions.assertEquals(\"01 January 2016\", transactionDate.format(Utils.dateFormatter));\n            } else if (transactionType.equals(\"charge.payment\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(Utils.getLocalDateOfTenant(), transactionDate);\n            }\n        }\n\n        Map<String, Object> summaryMap = (Map<String, Object>) shareAccountData.get(\"summary\");\n        Assertions.assertEquals(\"25\", String.valueOf(summaryMap.get(\"totalApprovedShares\")));\n        Assertions.assertEquals(\"0\", String.valueOf(summaryMap.get(\"totalPendingForApprovalShares\")));\n    } END"}
{"prompt":"reject Share Account\n\n###\n\n","completion":"    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void rejectShareAccount() {\n        shareProductHelper = new ShareProductHelper();\n        final Integer productId = createShareProduct();\n        Assertions.assertNotNull(productId);\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n        Integer savingsAccountId = SavingsAccountHelper.openSavingsAccount(requestSpec, responseSpec, clientId, \"1000\");\n        Assertions.assertNotNull(savingsAccountId);\n        String activationCharge = ChargesHelper.getShareAccountActivationChargeJson();\n        Integer activationChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, activationCharge);\n        String purchaseCharge = ChargesHelper.getShareAccountPurchaseChargeJson();\n        Integer purchaseChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, purchaseCharge);\n        String redeemCharge = ChargesHelper.getShareAccountRedeemChargeJson();\n        Integer redeemChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, redeemCharge);\n        List<Map<String, Object>> charges = new ArrayList<>();\n        charges.add(createCharge(activationChargeId, \"2\"));\n        charges.add(createCharge(purchaseChargeId, \"2\"));\n        charges.add(createCharge(redeemChargeId, \"1\"));\n        final Integer shareAccountId = createShareAccount(clientId, productId, savingsAccountId, charges);\n        Assertions.assertNotNull(shareAccountId);\n        Map<String, Object> shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec,\n                responseSpec);\n        Assertions.assertNotNull(shareAccountData);\n\n        \/\/ Reject share Account\n        Map<String, Object> rejectMap = new HashMap<>();\n        rejectMap.put(\"note\", \"Share Account Rejection Note\");\n        String rejectJson = new Gson().toJson(rejectMap);\n        ShareAccountTransactionHelper.postCommand(\"reject\", shareAccountId, rejectJson, requestSpec, responseSpec);\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        Map<String, Object> statusMap = (Map<String, Object>) shareAccountData.get(\"status\");\n        Assertions.assertEquals(\"shareAccountStatusType.rejected\", String.valueOf(statusMap.get(\"code\")));\n        Map<String, Object> timelineMap = (Map<String, Object>) shareAccountData.get(\"timeline\");\n        List<Integer> dateList = (List<Integer>) timelineMap.get(\"rejectedDate\");\n        LocalDate rejectedDate = LocalDate.of(dateList.get(0), dateList.get(1), dateList.get(2));\n        Assertions.assertEquals(Utils.getLocalDateOfTenant(), rejectedDate);\n\n        List<Map<String, Object>> transactions = (List<Map<String, Object>>) shareAccountData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(2, transactions.size());\n        for (int i = 0; i < transactions.size(); i++) {\n            Map<String, Object> transaction = transactions.get(i);\n            Map<String, Object> transactionTypeMap = (Map<String, Object>) transaction.get(\"type\");\n            dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n            LocalDate date = LocalDate.of(dateList.get(0), dateList.get(1), dateList.get(2));\n            String transactionType = (String) transactionTypeMap.get(\"code\");\n            if (transactionType.equals(\"purchasedSharesType.purchased\")) {\n                Assertions.assertEquals(\"25\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"50.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"50.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n                Assertions.assertEquals(\"01 January 2016\", date.format(Utils.dateFormatter));\n            } else if (transactionType.equals(\"charge.payment\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"0\", String.valueOf(transaction.get(\"amountPaid\")));\n                LocalDate transactionDate = Utils.getLocalDateOfTenant();\n                Assertions.assertEquals(transactionDate, date);\n            }\n        }\n\n        Map<String, Object> summaryMap = (Map<String, Object>) shareAccountData.get(\"summary\");\n        Assertions.assertEquals(\"0\", String.valueOf(summaryMap.get(\"totalApprovedShares\")));\n        Assertions.assertEquals(\"0\", String.valueOf(summaryMap.get(\"totalPendingForApprovalShares\")));\n    } END"}
{"prompt":"test Share Account Undo Approval\n\n###\n\n","completion":"    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testShareAccountUndoApproval() {\n        shareProductHelper = new ShareProductHelper();\n        final Integer productId = createShareProduct();\n        Assertions.assertNotNull(productId);\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n        Integer savingsAccountId = SavingsAccountHelper.openSavingsAccount(requestSpec, responseSpec, clientId, \"1000\");\n        Assertions.assertNotNull(savingsAccountId);\n        String activationCharge = ChargesHelper.getShareAccountActivationChargeJson();\n        Integer activationChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, activationCharge);\n        String purchaseCharge = ChargesHelper.getShareAccountPurchaseChargeJson();\n        Integer purchaseChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, purchaseCharge);\n        String redeemCharge = ChargesHelper.getShareAccountRedeemChargeJson();\n        Integer redeemChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, redeemCharge);\n        List<Map<String, Object>> charges = new ArrayList<>();\n        charges.add(createCharge(activationChargeId, \"2\"));\n        charges.add(createCharge(purchaseChargeId, \"2\"));\n        charges.add(createCharge(redeemChargeId, \"1\"));\n        final Integer shareAccountId = createShareAccount(clientId, productId, savingsAccountId, charges);\n        Assertions.assertNotNull(shareAccountId);\n        Map<String, Object> shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec,\n                responseSpec);\n        Assertions.assertNotNull(shareAccountData);\n\n        \/\/ Approve share Account\n        Map<String, Object> approveMap = new HashMap<>();\n        approveMap.put(\"note\", \"Share Account Approval Note\");\n        approveMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n        approveMap.put(\"approvedDate\", \"01 January 2016\");\n        approveMap.put(\"locale\", \"en\");\n        String approve = new Gson().toJson(approveMap);\n        ShareAccountTransactionHelper.postCommand(\"approve\", shareAccountId, approve, requestSpec, responseSpec);\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        Map<String, Object> statusMap = (Map<String, Object>) shareAccountData.get(\"status\");\n        Assertions.assertEquals(\"shareAccountStatusType.approved\", String.valueOf(statusMap.get(\"code\")));\n        Map<String, Object> timelineMap = (Map<String, Object>) shareAccountData.get(\"timeline\");\n        List<Integer> dateList = (List<Integer>) timelineMap.get(\"approvedDate\");\n\n        LocalDate approvedDate = LocalDate.of(dateList.get(0), dateList.get(1), dateList.get(2));\n        Assertions.assertEquals(\"01 January 2016\", approvedDate.format(Utils.dateFormatter));\n\n        \/\/ Undo Approval share Account\n        Map<String, Object> undoApprovalMap = new HashMap<>();\n        String undoApprovalJson = new Gson().toJson(undoApprovalMap);\n        ShareAccountTransactionHelper.postCommand(\"undoapproval\", shareAccountId, undoApprovalJson, requestSpec, responseSpec);\n\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n\n        statusMap = (Map<String, Object>) shareAccountData.get(\"status\");\n        Assertions.assertEquals(\"shareAccountStatusType.submitted.and.pending.approval\", String.valueOf(statusMap.get(\"code\")));\n\n        List<Map<String, Object>> transactions = (List<Map<String, Object>>) shareAccountData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(2, transactions.size());\n        for (int i = 0; i < transactions.size(); i++) {\n            Map<String, Object> transaction = transactions.get(i);\n            Map<String, Object> transactionTypeMap = (Map<String, Object>) transaction.get(\"type\");\n            dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n            LocalDate transactionDate = LocalDate.of(dateList.get(0), dateList.get(1), dateList.get(2));\n            String transactionType = (String) transactionTypeMap.get(\"code\");\n            if (transactionType.equals(\"purchasedSharesType.purchased\")) {\n                Assertions.assertEquals(\"25\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"52.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n                Assertions.assertEquals(\"01 January 2016\", transactionDate.format(Utils.dateFormatter));\n            } else if (transactionType.equals(\"charge.payment\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(Utils.getLocalDateOfTenant(), transactionDate);\n            }\n        }\n\n        Map<String, Object> summaryMap = (Map<String, Object>) shareAccountData.get(\"summary\");\n        Assertions.assertEquals(\"0\", String.valueOf(summaryMap.get(\"totalApprovedShares\")));\n        Assertions.assertEquals(\"25\", String.valueOf(summaryMap.get(\"totalPendingForApprovalShares\")));\n    } END"}
{"prompt":"validate Create Read Delete Datatable With Case Sensitive\n\n###\n\n","completion":"    @Test\n    public void validateCreateReadDeleteDatatableWithCaseSensitive() throws ParseException {\n\n        \/\/ creating datatable for client entity\n        final HashMap<String, Object> columnMap = new HashMap<>();\n        final List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n        columnMap.put(\"datatableName\", Utils.uniqueRandomStringGenerator(CLIENT_APP_TABLE_NAME + \"_\", 5));\n        columnMap.put(\"apptableName\", CLIENT_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"PERSON\");\n        columnMap.put(\"multiRow\", false);\n        String itsADate = \"itsADate\";\n        String itsADecimal = \"itsADecimal\";\n        String itsAString = \"itsAString\";\n        String dateFormat = \"dateFormat\";\n\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsADate, \"Date\", true, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsADecimal, \"Decimal\", true, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsAString, \"String\", true, 10, null);\n        columnMap.put(\"columns\", datatableColumnsList);\n        String datatabelRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"map : {}\", datatabelRequestJsonString);\n\n        HashMap<String, Object> datatableResponse = this.datatableHelper.createDatatable(datatabelRequestJsonString, \"\");\n        String datatableName = (String) datatableResponse.get(\"resourceIdentifier\");\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, datatableName);\n\n        \/\/ creating client with datatables\n        final Integer clientID = ClientHelper.createClientAsPerson(requestSpec, responseSpec);\n\n        \/\/ creating new client datatable entry\n        final boolean genericResultSet = true;\n\n        final HashMap<String, Object> datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(itsADate, Utils.randomDateGenerator(\"yyyy-MM-dd\"));\n        datatableEntryMap.put(itsADecimal, Utils.randomDecimalGenerator(4, 3));\n        datatableEntryMap.put(itsAString, Utils.randomStringGenerator(\"\", 8));\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(dateFormat, \"yyyy-MM-dd\");\n\n        String datatabelEntryRequestJsonString = new Gson().toJson(datatableEntryMap);\n        LOG.info(\"map : {}\", datatabelEntryRequestJsonString);\n\n        HashMap<String, Object> datatableEntryResponse = this.datatableHelper.createDatatableEntry(datatableName, clientID,\n                genericResultSet, datatabelEntryRequestJsonString);\n        assertNotNull(datatableEntryResponse.get(\"resourceId\"), \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n\n        \/\/ Read the Datatable entry generated with genericResultSet in true (default)\n        final HashMap<String, Object> items = this.datatableHelper.readDatatableEntry(datatableName, clientID, genericResultSet,\n                (Integer) datatableEntryResponse.get(\"resourceId\"), \"\");\n        assertNotNull(items);\n        assertEquals(1, ((List) items.get(\"data\")).size());\n\n        assertEquals(\"client_id\", ((Map) ((List) items.get(\"columnHeaders\")).get(0)).get(\"columnName\"));\n        assertEquals(clientID, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(0));\n\n        assertEquals(itsADate, ((Map) ((List) items.get(\"columnHeaders\")).get(1)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(itsADate),\n                Utils.arrayDateToString((List) ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(1)));\n\n        assertEquals(itsADecimal, ((Map) ((List) items.get(\"columnHeaders\")).get(2)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(itsADecimal), ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(2));\n\n        assertEquals(itsAString, ((Map) ((List) items.get(\"columnHeaders\")).get(3)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(itsAString), ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(3));\n\n        \/\/ Update datatable entry\n        final String randomValue = Utils.randomStringGenerator(\"\", 8);\n        datatableEntryMap.put(itsADate, Utils.randomDateGenerator(\"yyyy-MM-dd\"));\n        datatableEntryMap.put(itsADecimal, Utils.randomDecimalGenerator(4, 3));\n        datatableEntryMap.put(itsAString, randomValue);\n\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(dateFormat, \"yyyy-MM-dd\");\n\n        datatabelEntryRequestJsonString = new Gson().toJson(datatableEntryMap);\n        LOG.info(\"map : {}\", datatabelEntryRequestJsonString);\n\n        HashMap<String, Object> updatedDatatableEntryResponse = this.datatableHelper.updateDatatableEntry(datatableName, clientID, false,\n                datatabelEntryRequestJsonString);\n\n        assertEquals(clientID, updatedDatatableEntryResponse.get(\"clientId\"));\n\n        assertEquals(datatableEntryMap.get(itsADate),\n                Utils.arrayDateToString((List) ((Map) updatedDatatableEntryResponse.get(\"changes\")).get(itsADate)));\n        assertEquals(datatableEntryMap.get(itsADecimal), ((Map) updatedDatatableEntryResponse.get(\"changes\")).get(itsADecimal));\n        assertEquals(datatableEntryMap.get(itsAString), ((Map) updatedDatatableEntryResponse.get(\"changes\")).get(itsAString));\n\n        \/\/ Read the datatable with a query\n        LOG.info(\"query in {} for value : {}\", itsAString, randomValue);\n        final String queryResult = this.datatableHelper.runDatatableQuery(datatableName, itsAString, randomValue, \"client_id,itsADecimal\");\n        assertNotNull(queryResult);\n        LOG.info(\"query result : {}\", queryResult);\n\n        \/\/ deleting datatable entries\n        Integer appTableId = this.datatableHelper.deleteDatatableEntries(datatableName, clientID, \"clientId\");\n        assertEquals(clientID, appTableId, \"ERROR IN DELETING THE DATATABLE ENTRIES\");\n\n        \/\/ deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(datatableName);\n        assertEquals(datatableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    } END"}
{"prompt":"validate Insert Null Values\n\n###\n\n","completion":"    @Test\n    public void validateInsertNullValues() {\n        \/\/ Fetch \/ Create TST code\n        HashMap<String, Object> codeResponse = CodeHelper.getCodeByName(this.requestSpec, this.responseSpec, \"TST_TST_TST\");\n\n        \/\/ creating datatable for client entity\n        final HashMap<String, Object> columnMap = new HashMap<>();\n        final List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n        columnMap.put(\"datatableName\", Utils.uniqueRandomStringGenerator(LOAN_APP_TABLE_NAME + \"_\", 5));\n        columnMap.put(\"apptableName\", LOAN_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"\");\n        columnMap.put(\"multiRow\", true);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsABoolean\", \"Boolean\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsADate\", \"Date\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsADatetime\", \"Datetime\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsADecimal\", \"Decimal\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsADropdown\", \"Dropdown\", false, null, \"TST_TST_TST\");\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsANumber\", \"Number\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsAString\", \"String\", false, 10, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsAText\", \"Text\", false, null, null);\n        columnMap.put(\"columns\", datatableColumnsList);\n        String datatabelRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"map : {}\", datatabelRequestJsonString);\n\n        HashMap<String, Object> datatableResponse = this.datatableHelper.createDatatable(datatabelRequestJsonString, \"\");\n        String datatableName = (String) datatableResponse.get(\"resourceIdentifier\");\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, datatableName);\n\n        \/\/ try to create with the same name\n        ResponseSpecification responseSpecError400 = new ResponseSpecBuilder().expectStatusCode(400).build();\n        this.datatableHelper = new DatatableHelper(this.requestSpec, responseSpecError400);\n        HashMap<String, Object> response = this.datatableHelper.createDatatable(datatabelRequestJsonString, \"\");\n        assertEquals(\"validation.msg.validation.errors.exist\", ((Map) response).get(\"userMessageGlobalisationCode\"));\n        this.datatableHelper = new DatatableHelper(this.requestSpec, this.responseSpec);\n\n        \/\/ creating client with datatables\n        final Integer clientID = ClientHelper.createClientAsPerson(requestSpec, responseSpec);\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingEnabled();\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        \/\/ creating new client datatable entry\n        final boolean genericResultSet = true;\n\n        HashMap<String, Object> datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(\"itsABoolean\", null);\n        datatableEntryMap.put(\"itsADate\", null);\n        datatableEntryMap.put(\"itsADatetime\", null);\n        datatableEntryMap.put(\"itsADecimal\", null);\n        datatableEntryMap.put(\"TST_TST_TST_cd_itsADropdown\", null);\n        datatableEntryMap.put(\"itsANumber\", null);\n        datatableEntryMap.put(\"itsAString\", null);\n        datatableEntryMap.put(\"itsAText\", null);\n\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(\"dateFormat\", \"yyyy-MM-dd\");\n\n        String datatableEntryRequestJsonString = new GsonBuilder().serializeNulls().create().toJson(datatableEntryMap);\n        LOG.info(\"map : {}\", datatableEntryRequestJsonString);\n\n        HashMap<String, Object> datatableEntryResponseFirst = this.datatableHelper.createDatatableEntry(datatableName, loanID,\n                genericResultSet, datatableEntryRequestJsonString);\n\n        datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(\"itsABoolean\", \"\");\n        datatableEntryMap.put(\"itsADate\", \"\");\n        datatableEntryMap.put(\"itsADatetime\", \"\");\n        datatableEntryMap.put(\"itsADecimal\", \"\");\n        datatableEntryMap.put(\"TST_TST_TST_cd_itsADropdown\", \"\");\n        datatableEntryMap.put(\"itsANumber\", \"\");\n        datatableEntryMap.put(\"itsAString\", \"\");\n        datatableEntryMap.put(\"itsAText\", \"\");\n\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(\"dateFormat\", \"yyyy-MM-dd\");\n\n        datatableEntryRequestJsonString = new GsonBuilder().serializeNulls().create().toJson(datatableEntryMap);\n        HashMap<String, Object> datatableEntryResponseSecond = this.datatableHelper.createDatatableEntry(datatableName, loanID,\n                genericResultSet, datatableEntryRequestJsonString);\n        assertNotNull(datatableEntryResponseFirst.get(\"resourceId\"), \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n        assertNotNull(datatableEntryResponseSecond.get(\"resourceId\"), \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n\n        \/\/ Read the Datatable entry generated with genericResultSet in true (default)\n        HashMap<String, Object> items = this.datatableHelper.readDatatableEntry(datatableName, loanID, genericResultSet, null, \"\");\n        assertNotNull(items);\n        assertEquals(2, ((List) items.get(\"data\")).size());\n\n        assertEquals(\"id\", ((Map) ((List) items.get(\"columnHeaders\")).get(0)).get(\"columnName\"));\n        assertEquals(1, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(0));\n        assertEquals(\"loan_id\", ((Map) ((List) items.get(\"columnHeaders\")).get(1)).get(\"columnName\"));\n        assertEquals(loanID, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(1));\n        assertEquals(\"itsABoolean\", ((Map) ((List) items.get(\"columnHeaders\")).get(2)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(2));\n        assertEquals(\"itsADate\", ((Map) ((List) items.get(\"columnHeaders\")).get(3)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(3));\n        assertEquals(\"itsADatetime\", ((Map) ((List) items.get(\"columnHeaders\")).get(4)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(4));\n        assertEquals(\"itsADecimal\", ((Map) ((List) items.get(\"columnHeaders\")).get(5)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(5));\n        assertEquals(\"TST_TST_TST_cd_itsADropdown\", ((Map) ((List) items.get(\"columnHeaders\")).get(6)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(6));\n        assertEquals(\"itsANumber\", ((Map) ((List) items.get(\"columnHeaders\")).get(7)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(7));\n        assertEquals(\"itsAString\", ((Map) ((List) items.get(\"columnHeaders\")).get(8)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(8));\n        assertEquals(\"itsAText\", ((Map) ((List) items.get(\"columnHeaders\")).get(9)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(9));\n\n        assertEquals(2, ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(0));\n        assertEquals(loanID, ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(1));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(2));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(3));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(4));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(5));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(6));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(7));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(8));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(9));\n\n        PutDataTablesAppTableIdDatatableIdResponse updatedDatatableEntryResponse = this.datatableHelper.updateDatatableEntry(datatableName,\n                loanID, 1, datatableEntryRequestJsonString);\n        assertNotNull(updatedDatatableEntryResponse);\n        assertEquals(0, updatedDatatableEntryResponse.getChanges().size());\n    } END"}
{"prompt":"validate Create And Edit Datatable\n\n###\n\n","completion":"    @Test\n    public void validateCreateAndEditDatatable() {\n        \/\/ Creating client\n        final Integer clientId = ClientHelper.createClientAsPerson(requestSpec, responseSpec);\n        final Integer randomNumber = Utils.randomNumberGenerator(3);\n\n        \/\/ Creating datatable for Client Person\n        final String datatableName = Utils.uniqueRandomStringGenerator(CLIENT_APP_TABLE_NAME + \"_\", 5);\n        final boolean genericResultSet = true;\n\n        HashMap<String, Object> columnMap = new HashMap<>();\n        List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n        columnMap.put(\"datatableName\", datatableName);\n        columnMap.put(\"apptableName\", CLIENT_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", CLIENT_PERSON_SUBTYPE_NAME);\n        columnMap.put(\"multiRow\", false);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsANumber\", \"Number\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsAString\", \"String\", false, 10, null);\n        columnMap.put(\"columns\", datatableColumnsList);\n        String datatabelRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"map : {}\", datatabelRequestJsonString);\n\n        PostDataTablesResponse datatableCreateResponse = this.datatableHelper.createDatatable(datatabelRequestJsonString);\n        assertEquals(datatableName, datatableCreateResponse.getResourceIdentifier());\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, datatableName);\n\n        \/\/ Insert first values\n        final String value = Utils.randomStringGenerator(\"Q\", 8);\n        HashMap<String, Object> datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(\"itsANumber\", randomNumber);\n        datatableEntryMap.put(\"itsAString\", value);\n\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(\"dateFormat\", \"yyyy-MM-dd\");\n\n        String datatableEntryRequestJsonString = new GsonBuilder().serializeNulls().create().toJson(datatableEntryMap);\n        PostDataTablesAppTableIdResponse datatableEntryResponse = this.datatableHelper.addDatatableEntry(datatableName, clientId,\n                genericResultSet, datatableEntryRequestJsonString);\n        assertNotNull(datatableEntryResponse.getResourceId(), \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n\n        \/\/ Read the Datatable entry generated with genericResultSet in true (default)\n        HashMap<String, Object> items = this.datatableHelper.readDatatableEntry(datatableName, clientId, genericResultSet, null, \"\");\n        assertNotNull(items);\n        assertEquals(1, ((List) items.get(\"data\")).size());\n        LOG.info(\"Record created at {}\", ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(3));\n        LOG.info(\"Record updated at {}\", ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(4));\n\n        assertEquals(clientId, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(0));\n        assertEquals(value, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(2));\n\n        \/\/ Update DataTable\n        columnMap = new HashMap<>();\n        columnMap.put(\"apptableName\", CLIENT_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", CLIENT_PERSON_SUBTYPE_NAME);\n        datatableColumnsList = new ArrayList<>();\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsAText\", \"Text\", false, null, null);\n        columnMap.put(\"addColumns\", datatableColumnsList);\n        datatabelRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"map to update : {}\", datatabelRequestJsonString);\n        PutDataTablesResponse datatableUpdateResponse = this.datatableHelper.updateDatatable(datatableName, datatabelRequestJsonString);\n        assertNotNull(datatableUpdateResponse);\n        assertEquals(datatableName, datatableUpdateResponse.getResourceIdentifier());\n\n        \/\/ Update DataTable Entry after Update DataTable schema\n        datatableEntryMap = new HashMap<>();\n        final String textValue = Utils.randomStringGenerator(value, 120);\n        datatableEntryMap.put(\"itsAText\", textValue);\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(\"dateFormat\", \"yyyy-MM-dd\");\n\n        datatableEntryRequestJsonString = new GsonBuilder().serializeNulls().create().toJson(datatableEntryMap);\n        LOG.info(\"map to update : {}\", datatableEntryRequestJsonString);\n        PutDataTablesAppTableIdDatatableIdResponse updatedDatatableEntryResponse = this.datatableHelper.updateDatatableEntry(datatableName,\n                clientId, datatableEntryRequestJsonString);\n        assertNotNull(updatedDatatableEntryResponse);\n        assertEquals(1, updatedDatatableEntryResponse.getChanges().size());\n\n        \/\/ Read the Datatable entry generated with genericResultSet in true (default)\n        items = this.datatableHelper.readDatatableEntry(datatableName, clientId, genericResultSet, null, \"\");\n        assertNotNull(items);\n        assertEquals(1, ((List) items.get(\"data\")).size());\n        LOG.info(\"Record created at {}\", ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(3));\n        LOG.info(\"Record updated at {}\", ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(4));\n\n        assertEquals(clientId, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(0));\n        assertEquals(value, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(2));\n        assertEquals(textValue, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(5));\n    } END"}
{"prompt":"test Datable Creation With Unique And Indexed Columns\n\n###\n\n","completion":"    @Test\n    public void testDatableCreationWithUniqueAndIndexedColumns() {\n        \/\/ given\n        String datatableName = DatatableTestNameGenerator.generateDatatableName(LOAN);\n        String column1Name = \"itsanumber\";\n        String column2Name = \"itsastring\";\n\n        PostDataTablesRequest request = new PostDataTablesRequest();\n        request.setDatatableName(datatableName);\n        request.setApptableName(LOAN.getReferencedTableName());\n        request.setMultiRow(false);\n\n        PostColumnHeaderData column1HeaderRequestData = new PostColumnHeaderData();\n        column1HeaderRequestData.setName(column1Name);\n        column1HeaderRequestData.setType(\"Number\");\n        column1HeaderRequestData.setMandatory(false);\n        column1HeaderRequestData.setLength(10L);\n        column1HeaderRequestData.setCode(\"\");\n        column1HeaderRequestData.setUnique(true);\n        column1HeaderRequestData.setIndexed(true);\n\n        request.addColumnsItem(column1HeaderRequestData);\n\n        PostColumnHeaderData column2HeaderRequestData = new PostColumnHeaderData();\n        column2HeaderRequestData.setName(column2Name);\n        column2HeaderRequestData.setType(\"String\");\n        column2HeaderRequestData.setMandatory(false);\n        column2HeaderRequestData.setLength(10L);\n        column2HeaderRequestData.setCode(\"\");\n        column2HeaderRequestData.setUnique(false);\n        column2HeaderRequestData.setIndexed(true);\n\n        request.addColumnsItem(column2HeaderRequestData);\n\n        \/\/ when\n        PostDataTablesResponse response = datatableHelper.createDatatable(request);\n\n        \/\/ then\n        assertThat(response.getResourceIdentifier()).isNotBlank();\n\n        GetDataTablesResponse dataTable = datatableHelper.getDataTableDetails(datatableName);\n\n        List<ResultsetColumnHeaderData> columnHeaderData = dataTable.getColumnHeaderData();\n        assertThat(columnHeaderData).isNotNull().hasSize(5);\n\n        List<NameUniqueIndexedHeaderData> expected = List.of(new NameUniqueIndexedHeaderData(column1Name, true, true),\n                new NameUniqueIndexedHeaderData(column2Name, false, true));\n\n        NameUniqueIndexedHeaderData.Mapper mapper = Mappers.getMapper(NameUniqueIndexedHeaderData.Mapper.class);\n        List<NameUniqueIndexedHeaderData> data = mapper.map(columnHeaderData);\n\n        assertThat(data).containsAll(expected);\n    } END"}
{"prompt":"test Datable Modification With Unique And Indexed Columns\n\n###\n\n","completion":"    @Test\n    public void testDatableModificationWithUniqueAndIndexedColumns() {\n        \/\/ given\n        \/\/ region Datatable creation\n        String datatableName = DatatableTestNameGenerator.generateDatatableName(LOAN);\n        String column1Name = \"itsanumber\";\n        String column2Name = \"itsastring\";\n\n        PostDataTablesRequest request = new PostDataTablesRequest();\n        request.setDatatableName(datatableName);\n        request.setApptableName(LOAN.getReferencedTableName());\n        request.setMultiRow(false);\n\n        PostColumnHeaderData column1HeaderRequestData = new PostColumnHeaderData();\n        column1HeaderRequestData.setName(column1Name);\n        column1HeaderRequestData.setType(\"Number\");\n        column1HeaderRequestData.setMandatory(false);\n        column1HeaderRequestData.setLength(10L);\n        column1HeaderRequestData.setCode(\"\");\n        column1HeaderRequestData.setUnique(true);\n        column1HeaderRequestData.setIndexed(true);\n\n        request.addColumnsItem(column1HeaderRequestData);\n\n        PostColumnHeaderData column2HeaderRequestData = new PostColumnHeaderData();\n        column2HeaderRequestData.setName(column2Name);\n        column2HeaderRequestData.setType(\"String\");\n        column2HeaderRequestData.setMandatory(false);\n        column2HeaderRequestData.setLength(10L);\n        column2HeaderRequestData.setCode(\"\");\n        column2HeaderRequestData.setUnique(false);\n        column2HeaderRequestData.setIndexed(true);\n\n        request.addColumnsItem(column2HeaderRequestData);\n\n        PostDataTablesResponse response = datatableHelper.createDatatable(request);\n\n        assertThat(response.getResourceIdentifier()).isNotBlank();\n        \/\/ endregion\n\n        \/\/ region Datatable update\n        PutDataTablesRequest updateRequest = new PutDataTablesRequest();\n        updateRequest.setApptableName(LOAN.getReferencedTableName());\n\n        String column3Name = \"number1\";\n        String column4Name = \"number2\";\n\n        PutDataTablesRequestAddColumns addColumn1 = new PutDataTablesRequestAddColumns();\n        addColumn1.setName(column3Name);\n        addColumn1.setType(\"Number\");\n        addColumn1.setMandatory(false);\n        addColumn1.setCode(\"\");\n        addColumn1.setUnique(true);\n        addColumn1.setIndexed(false);\n\n        updateRequest.addAddColumnsItem(addColumn1);\n\n        PutDataTablesRequestAddColumns addColumn2 = new PutDataTablesRequestAddColumns();\n        addColumn2.setName(column4Name);\n        addColumn2.setType(\"Number\");\n        addColumn2.setMandatory(false);\n        addColumn2.setCode(\"\");\n        addColumn2.setUnique(false);\n        addColumn2.setIndexed(true);\n\n        updateRequest.addAddColumnsItem(addColumn2);\n\n        PutDataTablesRequestChangeColumns changeColumns = new PutDataTablesRequestChangeColumns();\n        changeColumns.setName(column1Name);\n        String newColumnName = column1Name + \"new\";\n        changeColumns.setNewName(newColumnName);\n        changeColumns.setIndexed(true);\n\n        updateRequest.addChangeColumnsItem(changeColumns);\n\n        \/\/ endregion\n        \/\/ when\n        PutDataTablesResponse updateResponse = datatableHelper.updateDatatable(datatableName, updateRequest);\n\n        \/\/ then\n        GetDataTablesResponse dataTable = datatableHelper.getDataTableDetails(datatableName);\n\n        List<ResultsetColumnHeaderData> columnHeaderData = dataTable.getColumnHeaderData();\n        assertThat(columnHeaderData).isNotNull().hasSize(7);\n\n        List<NameUniqueIndexedHeaderData> expected = List.of(new NameUniqueIndexedHeaderData(column3Name, true, true),\n                new NameUniqueIndexedHeaderData(column4Name, false, true), new NameUniqueIndexedHeaderData(newColumnName, false, true));\n\n        NameUniqueIndexedHeaderData.Mapper mapper = Mappers.getMapper(NameUniqueIndexedHeaderData.Mapper.class);\n        List<NameUniqueIndexedHeaderData> data = mapper.map(columnHeaderData);\n\n        assertThat(data).containsAll(expected);\n    } END"}
{"prompt":"test Datable Creation Makes Fk Column Indexed If Multirow\n\n###\n\n","completion":"    @Test\n    public void testDatableCreationMakesFkColumnIndexedIfMultirow() {\n        \/\/ given\n        String datatableName = DatatableTestNameGenerator.generateDatatableName(LOAN);\n        String column1Name = \"itsanumber\";\n\n        PostDataTablesRequest request = new PostDataTablesRequest();\n        request.setDatatableName(datatableName);\n        request.setApptableName(LOAN.getReferencedTableName());\n        request.setMultiRow(true);\n\n        PostColumnHeaderData column1HeaderRequestData = new PostColumnHeaderData();\n        column1HeaderRequestData.setName(column1Name);\n        column1HeaderRequestData.setType(\"Number\");\n        column1HeaderRequestData.setMandatory(false);\n        column1HeaderRequestData.setLength(10L);\n        column1HeaderRequestData.setCode(\"\");\n        column1HeaderRequestData.setUnique(false);\n        column1HeaderRequestData.setIndexed(false);\n\n        request.addColumnsItem(column1HeaderRequestData);\n\n        \/\/ when\n        PostDataTablesResponse response = datatableHelper.createDatatable(request);\n\n        \/\/ then\n        assertThat(response.getResourceIdentifier()).isNotBlank();\n\n        GetDataTablesResponse dataTable = datatableHelper.getDataTableDetails(datatableName);\n\n        List<ResultsetColumnHeaderData> columnHeaderData = dataTable.getColumnHeaderData();\n        assertThat(columnHeaderData).isNotNull().hasSize(5);\n\n        List<NameUniqueIndexedHeaderData> expected = List.of(new NameUniqueIndexedHeaderData(\"id\", true, true),\n                new NameUniqueIndexedHeaderData(\"loan_id\", false, true), new NameUniqueIndexedHeaderData(column1Name, false, false),\n                new NameUniqueIndexedHeaderData(\"created_at\", false, false), new NameUniqueIndexedHeaderData(\"updated_at\", false, false));\n\n        NameUniqueIndexedHeaderData.Mapper mapper = Mappers.getMapper(NameUniqueIndexedHeaderData.Mapper.class);\n        List<NameUniqueIndexedHeaderData> data = mapper.map(columnHeaderData);\n\n        assertThat(data).containsExactlyInAnyOrderElementsOf(expected);\n    } END"}
{"prompt":"test Datable Creation Makes Fk Column Indexed If Not Multirow\n\n###\n\n","completion":"    @Test\n    public void testDatableCreationMakesFkColumnIndexedIfNotMultirow() {\n        \/\/ given\n        String datatableName = DatatableTestNameGenerator.generateDatatableName(LOAN);\n        String column1Name = \"itsanumber\";\n\n        PostDataTablesRequest request = new PostDataTablesRequest();\n        request.setDatatableName(datatableName);\n        request.setApptableName(LOAN.getReferencedTableName());\n        request.setMultiRow(false);\n\n        PostColumnHeaderData column1HeaderRequestData = new PostColumnHeaderData();\n        column1HeaderRequestData.setName(column1Name);\n        column1HeaderRequestData.setType(\"Number\");\n        column1HeaderRequestData.setMandatory(false);\n        column1HeaderRequestData.setLength(10L);\n        column1HeaderRequestData.setCode(\"\");\n        column1HeaderRequestData.setUnique(false);\n        column1HeaderRequestData.setIndexed(false);\n\n        request.addColumnsItem(column1HeaderRequestData);\n\n        \/\/ when\n        PostDataTablesResponse response = datatableHelper.createDatatable(request);\n\n        \/\/ then\n        assertThat(response.getResourceIdentifier()).isNotBlank();\n\n        GetDataTablesResponse dataTable = datatableHelper.getDataTableDetails(datatableName);\n\n        List<ResultsetColumnHeaderData> columnHeaderData = dataTable.getColumnHeaderData();\n        assertThat(columnHeaderData).isNotNull().hasSize(4);\n\n        List<NameUniqueIndexedHeaderData> expected = List.of(new NameUniqueIndexedHeaderData(\"loan_id\", true, true),\n                new NameUniqueIndexedHeaderData(column1Name, false, false), new NameUniqueIndexedHeaderData(\"created_at\", false, false),\n                new NameUniqueIndexedHeaderData(\"updated_at\", false, false));\n\n        NameUniqueIndexedHeaderData.Mapper mapper = Mappers.getMapper(NameUniqueIndexedHeaderData.Mapper.class);\n        List<NameUniqueIndexedHeaderData> data = mapper.map(columnHeaderData);\n\n        assertThat(data).containsExactlyInAnyOrderElementsOf(expected);\n    } END"}
{"prompt":"test Guarantor RECOVER GUARANTEES\n\n###\n\n","completion":"    @Test\n    public void testGuarantor_RECOVER_GUARANTEES() {\n\n        Float self1_hold_funds = Float.valueOf((float) 0);\n        Float external1_hold_funds = Float.valueOf((float) 0);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer clientID_external = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID_external);\n\n        final Integer selfSavigsId = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID,\n                String.valueOf(SELF1_BALANCE));\n        final Integer externalSavigsId_1 = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID_external,\n                String.valueOf(EXTERNAL1_BALANCE));\n\n        final Integer loanProductID = createLoanProductWithHoldFunds(\"40\", \"20\", \"20\");\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -21);\n        final String loanDisbursementDate = dateFormat.format(todaysDate.getTime());\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, loanDisbursementDate);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        String guarantorJSON = new GuarantorTestBuilder()\n                .existingCustomerWithGuaranteeAmount(String.valueOf(clientID), String.valueOf(selfSavigsId), String.valueOf(SELF1_GURANTEE))\n                .build();\n        Integer selfGuarantee = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(selfSavigsId, null);\n        Assertions.assertNotNull(selfGuarantee);\n\n        guarantorJSON = new GuarantorTestBuilder().existingCustomerWithGuaranteeAmount(String.valueOf(clientID_external),\n                String.valueOf(externalSavigsId_1), String.valueOf(EXTERNAL1_GURANTEE)).build();\n        Integer externalGuarantee_1 = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(externalSavigsId_1, null);\n        Assertions.assertNotNull(externalGuarantee_1);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        self1_hold_funds += SELF1_GURANTEE;\n        external1_hold_funds += EXTERNAL1_GURANTEE;\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        \/\/ First repayment\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        external1_hold_funds -= Float.valueOf((float) 993.104);\n        this.loanTransactionHelper.makeRepayment(LOAN_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n\n        this.loanTransactionHelper.recoverFromGuarantor(loanID);\n        verifySavingsBalanceAndOnHoldBalance(selfSavigsId, Float.valueOf((float) 0), SELF1_BALANCE - self1_hold_funds);\n        verifySavingsBalanceAndOnHoldBalance(externalSavigsId_1, Float.valueOf((float) 0), EXTERNAL1_BALANCE - external1_hold_funds);\n\n    }\n\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" } END"}
{"prompt":"test Guarantor RECOVER GUARANTEES WITH MORE GUARANTEE\n\n###\n\n","completion":"    @Test\n    public void testGuarantor_RECOVER_GUARANTEES_WITH_MORE_GUARANTEE() {\n\n        Float self1_hold_funds = Float.valueOf((float) 0);\n        Float external1_hold_funds = Float.valueOf((float) 0);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer clientID_external = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID_external);\n\n        Float selfBalance = Float.valueOf((float) 10000);\n        Float externalBalance = Float.valueOf((float) 10000);\n        Float selfguarantee = Float.valueOf((float) 6000);\n        Float externalguarantee = Float.valueOf((float) 7000);\n\n        final Integer selfSavigsId = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID,\n                String.valueOf(selfBalance));\n        final Integer externalSavigsId_1 = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID_external,\n                String.valueOf(externalBalance));\n\n        final Integer loanProductID = createLoanProductWithHoldFunds(\"40\", \"20\", \"20\");\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -21);\n        final String loanDisbursementDate = dateFormat.format(todaysDate.getTime());\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, loanDisbursementDate);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        String guarantorJSON = new GuarantorTestBuilder()\n                .existingCustomerWithGuaranteeAmount(String.valueOf(clientID), String.valueOf(selfSavigsId), String.valueOf(selfguarantee))\n                .build();\n        Integer selfGuarantee = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(selfSavigsId, null);\n        Assertions.assertNotNull(selfGuarantee);\n\n        guarantorJSON = new GuarantorTestBuilder().existingCustomerWithGuaranteeAmount(String.valueOf(clientID_external),\n                String.valueOf(externalSavigsId_1), String.valueOf(externalguarantee)).build();\n        Integer externalGuarantee_1 = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(externalSavigsId_1, null);\n        Assertions.assertNotNull(externalGuarantee_1);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        self1_hold_funds += selfguarantee;\n        external1_hold_funds += externalguarantee;\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        \/\/ First repayment\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        external1_hold_funds -= Float.valueOf((float) 3227.588);\n        this.loanTransactionHelper.makeRepayment(LOAN_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n\n        this.loanTransactionHelper.recoverFromGuarantor(loanID);\n        verifySavingsBalanceAndOnHoldBalance(selfSavigsId, Float.valueOf((float) 0), selfBalance - Float.valueOf((float) 4615.385));\n        verifySavingsBalanceAndOnHoldBalance(externalSavigsId_1, Float.valueOf((float) 0),\n                externalBalance - Float.valueOf((float) 2901.8553));\n\n    }\n\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" } END"}
{"prompt":"test Guarantor WRITE OFF LOAN\n\n###\n\n","completion":"    @Test\n    public void testGuarantor_WRITE_OFF_LOAN() {\n\n        Float self1_hold_funds = Float.valueOf((float) 0);\n        Float external1_hold_funds = Float.valueOf((float) 0);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer clientID_external = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID_external);\n\n        final Integer selfSavigsId = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID,\n                String.valueOf(SELF1_BALANCE));\n        final Integer externalSavigsId_1 = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID_external,\n                String.valueOf(EXTERNAL1_BALANCE));\n\n        final Integer loanProductID = createLoanProductWithHoldFunds(\"40\", \"20\", \"20\");\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -21);\n        final String loanDisbursementDate = dateFormat.format(todaysDate.getTime());\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, loanDisbursementDate);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        String guarantorJSON = new GuarantorTestBuilder()\n                .existingCustomerWithGuaranteeAmount(String.valueOf(clientID), String.valueOf(selfSavigsId), String.valueOf(SELF1_GURANTEE))\n                .build();\n        Integer selfGuarantee = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(selfSavigsId, null);\n        Assertions.assertNotNull(selfGuarantee);\n\n        guarantorJSON = new GuarantorTestBuilder().existingCustomerWithGuaranteeAmount(String.valueOf(clientID_external),\n                String.valueOf(externalSavigsId_1), String.valueOf(EXTERNAL1_GURANTEE)).build();\n        Integer externalGuarantee_1 = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        Assertions.assertNotNull(externalGuarantee_1);\n        verifySavingsOnHoldBalance(externalSavigsId_1, null);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        self1_hold_funds += SELF1_GURANTEE;\n        external1_hold_funds += EXTERNAL1_GURANTEE;\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        \/\/ First repayment\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        external1_hold_funds -= Float.valueOf((float) 993.104);\n        this.loanTransactionHelper.makeRepayment(LOAN_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n\n        todaysDate = Calendar.getInstance();\n        final String LOAN_WRITEOFF_DATE = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.writeOffLoan(LOAN_WRITEOFF_DATE, loanID);\n        verifySavingsBalanceAndOnHoldBalance(selfSavigsId, Float.valueOf((float) 0), SELF1_BALANCE);\n        verifySavingsBalanceAndOnHoldBalance(externalSavigsId_1, Float.valueOf((float) 0), EXTERNAL1_BALANCE);\n\n    } END"}
{"prompt":"test Inline COB\n\n###\n\n","completion":"    @Test\n    public void testInlineCOB() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"0\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 2), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 3));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 3), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 10));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 10), loan.getLastClosedBusinessDate());\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Inline COBCatch Up Loans\n\n###\n\n","completion":"    @Test\n    public void testInlineCOBCatchUpLoans() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            ArrayList<Integer> rangeIds = new ArrayList<>();\n            \/\/ First Range\n            String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n            PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec,\n                    responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n            jsonRange = DelinquencyRangesHelper.getAsJSON(4, 60);\n\n            GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                    delinquencyRangeResponse.getResourceId());\n\n            \/\/ Second Range\n            delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n\n            range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec, delinquencyRangeResponse.getResourceId());\n            final String classificationExpected = range.getClassification();\n            log.info(\"Expected Delinquency Range classification after Disbursement {}\", classificationExpected);\n\n            String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n            PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                    responseSpec, jsonBucket);\n            assertNotNull(delinquencyBucketResponse);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketResponse.getResourceId());\n\n            final Integer loanProductID = createLoanProduct(loanTransactionHelper, delinquencyBucket.getId());\n\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            ArrayList<GetDelinquencyTagHistoryResponse> loanDelinquencyTags = loanTransactionHelper.getLoanDelinquencyTags(requestSpec,\n                    responseSpec, loanID);\n            Assertions.assertTrue(loanDelinquencyTags.isEmpty());\n            Assertions.assertEquals(LocalDate.of(2020, 3, 2), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 4, 4));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            loanDelinquencyTags = loanTransactionHelper.getLoanDelinquencyTags(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 4, 4), loan.getLastClosedBusinessDate());\n            Assertions.assertEquals(1, loanDelinquencyTags.size());\n            Assertions.assertEquals(LocalDate.of(2020, 4, 3), loanDelinquencyTags.get(0).getAddedOnDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 4, 10));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            loanDelinquencyTags = loanTransactionHelper.getLoanDelinquencyTags(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 4, 10), loan.getLastClosedBusinessDate());\n            Assertions.assertEquals(2, loanDelinquencyTags.size());\n            Assertions.assertEquals(LocalDate.of(2020, 4, 3), loanDelinquencyTags.get(1).getAddedOnDate());\n            Assertions.assertEquals(LocalDate.of(2020, 4, 6), loanDelinquencyTags.get(0).getAddedOnDate());\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Inline COBOn Repayment With Soft Locked Loan\n\n###\n\n","completion":"    @Test\n    public void testInlineCOBOnRepaymentWithSoftLockedLoan() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"0\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n            loanAccountLockHelper = new LoanAccountLockHelper(requestSpec, new ResponseSpecBuilder().expectStatusCode(202).build());\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 2), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 10));\n\n            requestSpec = UserHelper.getSimpleUserWithoutBypassPermission(requestSpec, responseSpec);\n\n            loanAccountLockHelper.placeSoftLockOnLoanAccount(loanID, \"LOAN_COB_PARTITIONING\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            loanTransactionHelper.makeRepayment(\"10 March 2020\", 10.0f, loanID);\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 9), loan.getLastClosedBusinessDate());\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Inline COBCatch Up On Repayment With Not Locked Loan\n\n###\n\n","completion":"    @Test\n    public void testInlineCOBCatchUpOnRepaymentWithNotLockedLoan() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"0\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n            loanAccountLockHelper = new LoanAccountLockHelper(requestSpec, new ResponseSpecBuilder().expectStatusCode(202).build());\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 2), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 10));\n\n            requestSpec = UserHelper.getSimpleUserWithoutBypassPermission(requestSpec, responseSpec);\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            loanTransactionHelper.makeRepayment(\"10 March 2020\", 10.0f, loanID);\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 9), loan.getLastClosedBusinessDate());\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Inline COBOn Batch APIWith Old Relative Urls\n\n###\n\n","completion":"    @Test\n    public void testInlineCOBOnBatchAPIWithOldRelativeUrls() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"0\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n            loanAccountLockHelper = new LoanAccountLockHelper(requestSpec, new ResponseSpecBuilder().expectStatusCode(202).build());\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 2), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 10));\n\n            requestSpec = UserHelper.getSimpleUserWithoutBypassPermission(requestSpec, responseSpec);\n\n            loanAccountLockHelper.placeSoftLockOnLoanAccount(loanID, \"LOAN_COB_PARTITIONING\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            final BatchRequest br1 = BatchHelper.oldRepayLoanRequestWithGivenLoanId(4730L, loanID, \"10\", LocalDate.of(2020, 3, 10));\n\n            final List<BatchRequest> batchRequests = new ArrayList<>();\n\n            batchRequests.add(br1);\n\n            final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n            final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec,\n                    this.responseSpec, jsonifiedRequest);\n            Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(0).getStatusCode(), \"Verify Status Code 200 for Repayment\");\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 9), loan.getLastClosedBusinessDate());\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Inline COBOn Batch API\n\n###\n\n","completion":"    @Test\n    public void testInlineCOBOnBatchAPI() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"0\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n            loanAccountLockHelper = new LoanAccountLockHelper(requestSpec, new ResponseSpecBuilder().expectStatusCode(202).build());\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 2), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 10));\n\n            requestSpec = UserHelper.getSimpleUserWithoutBypassPermission(requestSpec, responseSpec);\n\n            loanAccountLockHelper.placeSoftLockOnLoanAccount(loanID, \"LOAN_COB_PARTITIONING\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            final BatchRequest br1 = BatchHelper.repayLoanRequestWithGivenLoanId(4730L, loanID, \"10\", LocalDate.of(2020, 3, 10));\n\n            final List<BatchRequest> batchRequests = new ArrayList<>();\n\n            batchRequests.add(br1);\n\n            final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n            final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec,\n                    this.responseSpec, jsonifiedRequest);\n            Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(0).getStatusCode(), \"Verify Status Code 200 for Repayment\");\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 9), loan.getLastClosedBusinessDate());\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Inline COBRequest Body Item Limit Validation\n\n###\n\n","completion":"    @Test\n    public void testInlineCOBRequestBodyItemLimitValidation() {\n        responseSpec = new ResponseSpecBuilder().expectStatusCode(400).build();\n        inlineLoanCOBHelper = new InlineLoanCOBHelper(requestSpec, responseSpec);\n        List<Long> loanIds = LongStream.rangeClosed(1, 1001).boxed().toList();\n        String responseUserMessage = inlineLoanCOBHelper.executeInlineCOB(loanIds, \"defaultUserMessage\");\n        assertEquals(\"Size of the loan IDs list cannot be over 1000\", responseUserMessage);\n    } END"}
{"prompt":"test Validate Action\n\n###\n\n","completion":"    @Test\n    public void testValidateAction() {\n        interopHelper.setResponseSpec(responseClientErrorSpec);\n        interopHelper.postTransferMissingAction(UUID.randomUUID().toString(), InteropTransactionRole.PAYER);\n        interopHelper.postTransfer(UUID.randomUUID().toString(), null, InteropTransactionRole.PAYER);\n        interopHelper.setResponseSpec(responseSpec);\n    } END"}
{"prompt":"test Interoperation\n\n###\n\n","completion":"    @Test\n    public void testInteroperation() {\n        createClient();\n        createSavingsProduct();\n        createCharge();\n        openSavingsAccount();\n\n        testParties();\n        testRequests();\n        testQuotes();\n        testTransfers();\n    } END"}
{"prompt":"sale Active Loan To External Asset Owner\n\n###\n\n","completion":"    @Test\n    public void saleActiveLoanToExternalAssetOwner() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(requestSpec, responseSpec, \"10\", \"0\");\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            String transferExternalId = \"36efeb06-d835-48a1-99eb-09bd1d348c1e\";\n            String saleResponse = externalAssetOwnerHelper.initiateTransferByLoanId(loanID.longValue(), \"sale\",\n                    getSaleRequestJson(\"04 March 2020\", transferExternalId));\n            Type type = new TypeToken<Map<String, Object>>() {}.getType();\n            Map<String, Object> responseMap = new Gson().fromJson(saleResponse, type);\n            assertEquals(responseMap.get(\"resourceExternalId\"), transferExternalId);\n\n            String retrieveResponse = externalAssetOwnerHelper.retrieveTransferByLoanId(loanID.longValue());\n            Type retrieveType = new TypeToken<List<Map<String, Object>>>() {}.getType();\n            List<Map<String, Object>> retrieveResponseMap = new Gson().fromJson(retrieveResponse, retrieveType);\n            assertEquals(1, retrieveResponseMap.size());\n            assertEquals(retrieveResponseMap.get(0).get(\"transferExternalId\"), transferExternalId);\n            assertEquals(retrieveResponseMap.get(0).get(\"status\"), \"PENDING\");\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"sale Is Not Allowed When Transfer Is Already Pending\n\n###\n\n","completion":"    @Test\n    public void saleIsNotAllowedWhenTransferIsAlreadyPending() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(requestSpec, responseSpec, \"10\", \"0\");\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            String transferExternalId = \"36efeb06-d835-48a1-99eb-09bd1d348c1e\";\n            String saleResponse = externalAssetOwnerHelper.initiateTransferByLoanId(loanID.longValue(), \"sale\",\n                    getSaleRequestJson(\"04 March 2020\", transferExternalId));\n            Type type = new TypeToken<Map<String, Object>>() {}.getType();\n            Map<String, Object> responseMap = new Gson().fromJson(saleResponse, type);\n            assertEquals(responseMap.get(\"resourceExternalId\"), transferExternalId);\n\n            externalAssetOwnerHelper = new ExternalAssetOwnerHelper(requestSpec, responseSpecError);\n            String errorResponse = externalAssetOwnerHelper.initiateTransferByLoanId(loanID.longValue(), \"sale\",\n                    getSaleRequestJson(\"04 March 2020\", transferExternalId));\n            Map<String, Object> errorResponseMap = new Gson().fromJson(errorResponse, type);\n            assertEquals(\"External asset owner transfer is already in PENDING state for this loan.\",\n                    errorResponseMap.get(\"developerMessage\"));\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"sale And Buyback On The Same Day\n\n###\n\n","completion":"    @Test\n    public void saleAndBuybackOnTheSameDay() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(requestSpec, responseSpec, \"10\", \"0\");\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            String transferExternalId = \"36efeb06-d835-48a1-99eb-09bd1d348c1e\";\n            String saleResponse = externalAssetOwnerHelper.initiateTransferByLoanId(loanID.longValue(), \"sale\",\n                    getSaleRequestJson(\"04 March 2020\", transferExternalId));\n            Type type = new TypeToken<Map<String, Object>>() {}.getType();\n            Map<String, Object> responseMap = new Gson().fromJson(saleResponse, type);\n            assertEquals(responseMap.get(\"resourceExternalId\"), transferExternalId);\n\n            String buybackTransferExternalId = \"36efeb06-d835-48a1-99eb-09bd1d348c1e\";\n            String buybackResponse = externalAssetOwnerHelper.initiateTransferByLoanId(loanID.longValue(), \"buyback\",\n                    getSaleRequestJson(\"04 March 2020\", buybackTransferExternalId));\n            Map<String, Object> buybackResponseMap = new Gson().fromJson(buybackResponse, type);\n            assertEquals(buybackResponseMap.get(\"resourceExternalId\"), buybackTransferExternalId);\n\n            String retrieveResponse = externalAssetOwnerHelper.retrieveTransferByLoanId(loanID.longValue());\n            Type retrieveType = new TypeToken<List<Map<String, Object>>>() {}.getType();\n            List<Map<String, Object>> retrieveResponseMap = new Gson().fromJson(retrieveResponse, retrieveType);\n            assertEquals(2, retrieveResponseMap.size());\n            assertEquals(retrieveResponseMap.get(0).get(\"transferExternalId\"), transferExternalId);\n            assertEquals(retrieveResponseMap.get(0).get(\"status\"), \"PENDING\");\n            assertEquals(retrieveResponseMap.get(1).get(\"transferExternalId\"), buybackTransferExternalId);\n            assertEquals(retrieveResponseMap.get(1).get(\"status\"), \"BUYBACK\");\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    } END"}
{"prompt":"test Variable Loan Product Creation\n\n###\n\n","completion":"    @Test\n    public void testVariableLoanProductCreation() {\n        final String json = VariableInstallmentsDecliningBalanceHelper.createLoanProductWithVaribleConfig(false, NONE);\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(json);\n        LOG.info(\"------------------------------RETRIEVING CREATED LOAN PRODUCT DETAILS ---------------------------------------\");\n        Map loanProduct = (Map) loanTransactionHelper.getLoanProductDetail(requestSpec, responseSpec, loanProductID, \"\");\n        Assertions.assertTrue((Boolean) loanProduct.get(\"allowVariableInstallments\"));\n        Assertions.assertEquals(Integer.valueOf(5), loanProduct.get(\"minimumGap\"));\n        Assertions.assertEquals(Integer.valueOf(90), loanProduct.get(\"maximumGap\"));\n    } END"}
{"prompt":"test Loan Product Creation\n\n###\n\n","completion":"    @Test\n    public void testLoanProductCreation() {\n        final String josn = VariableInstallmentsDecliningBalanceHelper.createLoanProductWithoutVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(josn);\n        LOG.info(\"------------------------------RETRIEVING CREATED LOAN PRODUCT DETAILS ---------------------------------------\");\n        Map loanProduct = (Map) loanTransactionHelper.getLoanProductDetail(requestSpec, responseSpec, loanProductID, \"\");\n        Assertions.assertTrue(!(Boolean) loanProduct.get(\"allowVariableInstallments\"));\n    } END"}
{"prompt":"test Delete Installments With Declining Balance Equal Installments\n\n###\n\n","completion":"    @Test\n    public void testDeleteInstallmentsWithDecliningBalanceEqualInstallments() {\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsDecliningBalanceHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final String json = VariableInstallmentsDecliningBalanceHelper.applyForLoanApplication(clientID, loanProductID, null, null,\n                \"1,00,000.00\", collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        \/\/ Integer loanID = 49 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        ArrayList toDelete = new ArrayList<>();\n        toDelete.add(periods.get(1));\n        String toDeletedata = VariableInstallmentsDecliningBalanceHelper.createDeleteVariations(toDelete);\n        HashMap modifiedReschdule = transactionHelper.validateVariations(toDeletedata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsDecliningBalanceHelper.constructVerifyData(\n                new String[] { \"20 November 2011\", \"20 December 2011\", \"20 January 2012\" },\n                new String[] { \"34675.47\", \"34675.47\", \"36756.26\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(toDeletedata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); \/\/ Repayments Schedule includes disbursement also. So\n                           \/\/ remove this.\n        assertAfterSubmit(periods, toVerifyData);\n\n    } END"}
{"prompt":"test Add Installments With Declining Balance Equal Installments\n\n###\n\n","completion":"    @Test\n    public void testAddInstallmentsWithDecliningBalanceEqualInstallments() {\n        \/\/ 31 October 2011 - 5000\n        \/\/ Result: 20 October 2011 - 21,215.84, 31 October 2011 - 5000, 20\n        \/\/ November 2011 26,477.31, 20 December 2011 26,477.31, 20 January 2012\n        \/\/ 25,947.7\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsDecliningBalanceHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final String json = VariableInstallmentsDecliningBalanceHelper.applyForLoanApplication(clientID, loanProductID, null, null,\n                \"1,00,000.00\", collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        \/\/ Integer loanID = 57 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        String addVariationsjsondata = VariableInstallmentsDecliningBalanceHelper.createAddVariations();\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsDecliningBalanceHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"31 October 2011\", \"20 November 2011\", \"20 December 2011\", \"20 January 2012\" },\n                new String[] { \"21215.84\", \"5000.0\", \"26477.31\", \"26477.31\", \"25947.7\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); \/\/ Repayments Schedule includes disbursement also. So\n                           \/\/ remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    } END"}
{"prompt":"test Modify Installment With Declining Balance Equal Installments\n\n###\n\n","completion":"    @Test\n    public void testModifyInstallmentWithDecliningBalanceEqualInstallments() {\n        \/\/ 20 October 2011 - 30000 modify\n        \/\/ Result 20 October 2011 - 30000.0, 20 November 2011 - 24,966.34, 20\n        \/\/ December 2011 - 24,966.34, 20 January 2012 - 24,966.33\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsDecliningBalanceHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final String json = VariableInstallmentsDecliningBalanceHelper.applyForLoanApplication(clientID, loanProductID, null, null,\n                \"1,00,000.00\", collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        \/\/ Integer loanID = 57 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        String addVariationsjsondata = VariableInstallmentsDecliningBalanceHelper.createModifiyVariations((Map) periods.get(1)); \/\/ 0th\n                                                                                                                                 \/\/ position\n                                                                                                                                 \/\/ will\n                                                                                                                                 \/\/ have\n                                                                                                                                 \/\/ disbursement\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsDecliningBalanceHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"20 November 2011\", \"20 December 2011\", \"20 January 2012\" },\n                new String[] { \"30000.0\", \"24966.34\", \"24966.34\", \"24966.33\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); \/\/ Repayments Schedule includes disbursement also. So\n                           \/\/ remove this.\n        assertAfterSubmit(periods, toVerifyData);\n\n    } END"}
{"prompt":"test All Variations Declining Balancewith Equal Installments\n\n###\n\n","completion":"    @Test\n    public void testAllVariationsDecliningBalancewithEqualInstallments() {\n        \/\/ Request: Delete 20 December 2011 26,262.38, Modify 20 November 2011\n        \/\/ from 26,262.38 to 30000, Add 25 December 2011 5000\n        \/\/ Result: 20 October 2011 - 26262.38, 20 November 2011 - 30000, 25\n        \/\/ December 2011 - 5000, 20 January 2012 - 44077\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsDecliningBalanceHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsDecliningBalanceHelper.applyForLoanApplication(clientID, loanProductID, null, null,\n                \"1,00,000.00\", collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        \/\/ Integer loanID = 57 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n\n        String addVariationsjsondata = VariableInstallmentsDecliningBalanceHelper.createAllVariations(); \/\/ 0th\n                                                                                                         \/\/ position\n                                                                                                         \/\/ will\n                                                                                                         \/\/ have\n                                                                                                         \/\/ disbursement\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsDecliningBalanceHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"20 November 2011\", \"25 December 2011\", \"20 January 2012\" },\n                new String[] { \"26262.38\", \"30000.0\", \"5000.0\", \"44077.0\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); \/\/ Repayments Schedule includes disbursement also. So\n                           \/\/ remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    } END"}
{"prompt":"test All Variations Declining Balancewith Equal Principal\n\n###\n\n","completion":"    @Test\n    public void testAllVariationsDecliningBalancewithEqualPrincipal() {\n        \/\/ Request: Delete 20 December 2011 26,262.38, Modify 20 November 2011\n        \/\/ from 26,262.38 to 30000, Add 25 December 2011 5000\n        \/\/ Result: 20 October 2011 - 27000.0, 20 November 2011 - 31500.0, 25\n        \/\/ December 2011 - 6045.16, 20 January 2012 - 40670.97\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsDecliningBalanceHelper\n                .createLoanProductWithVaribleConfigwithEqualPrincipal(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsDecliningBalanceHelper.applyForLoanApplicationWithEqualPrincipal(clientID, loanProductID,\n                null, null, \"1,00,000.00\", collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        \/\/ Integer loanID = 109 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n\n        String addVariationsjsondata = VariableInstallmentsDecliningBalanceHelper.createAllVariationsWithEqualPrincipal(); \/\/ 0th\n                                                                                                                           \/\/ position\n                                                                                                                           \/\/ will\n                                                                                                                           \/\/ have\n                                                                                                                           \/\/ disbursement\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsDecliningBalanceHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"20 November 2011\", \"25 December 2011\", \"20 January 2012\" },\n                new String[] { \"27000.0\", \"31500.0\", \"6045.16\", \"40670.97\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); \/\/ Repayments Schedule includes disbursement also. So\n                           \/\/ remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    } END"}
{"prompt":"test Modify Dates With Declining Balance Equal Installments\n\n###\n\n","completion":"    @Test\n    public void testModifyDatesWithDecliningBalanceEqualInstallments() {\n        \/\/ Modify 20 December 2011:25000 -> 04 January 2012:20000\n        \/\/ Modify 20 January 2012 -> 08 February 2012\n        \/\/ Result 20 October 2011 -26262.38, 20 November 2011 - 26262.38, 04\n        \/\/ January 2012 -20000, 08 February 2012 - 33242.97\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsDecliningBalanceHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsDecliningBalanceHelper.applyForLoanApplication(clientID, loanProductID, null, null,\n                \"1,00,000.00\", collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        \/\/ Integer loanID = 57 ;\n\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        \/\/\n        \/\/\n        String addVariationsjsondata = VariableInstallmentsDecliningBalanceHelper.createModifiyDateVariations(\n                new String[] { \"20 December 2011\", \"20 January 2012\" }, new String[] { \"04 January 2012\", \"08 February 2012\" },\n                new String[] { \"20000\" }); \/\/ 0th position will have\n                                           \/\/ disbursement\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsDecliningBalanceHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"20 November 2011\", \"04 January 2012\", \"08 February 2012\" },\n                new String[] { \"26262.38\", \"26262.38\", \"20000.0\", \"33242.97\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); \/\/ Repayments Schedule includes disbursement also. So\n                           \/\/ remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    } END"}
{"prompt":"test Delete Installments With Interest Type Flat\n\n###\n\n","completion":"    @Test\n    public void testDeleteInstallmentsWithInterestTypeFlat() {\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsFlatHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsFlatHelper.applyForLoanApplication(clientID, loanProductID, null, null, \"1,00,000.00\",\n                collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        ArrayList toDelete = new ArrayList<>();\n        toDelete.add(periods.get(1));\n        String toDeletedata = VariableInstallmentsFlatHelper.createDeleteVariations(toDelete);\n        HashMap modifiedReschdule = transactionHelper.validateVariations(toDeletedata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsFlatHelper.constructVerifyData(\n                new String[] { \"20 November 2011\", \"20 December 2011\", \"20 January 2012\" },\n                new String[] { \"36000.0\", \"36000.0\", \"36000.0\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(toDeletedata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); \/\/ Repayments Schedule includes disbursement also. So\n                           \/\/ remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    } END"}
{"prompt":"test Add Installments With Interest Type Flat\n\n###\n\n","completion":"    @Test\n    public void testAddInstallmentsWithInterestTypeFlat() {\n        \/\/ 31 October 2011 - 5000\n        \/\/ Result: 20 October 2011 - 21600.0, 31 October 2011 - 6600.0, 20\n        \/\/ November 2011 26600.0, 20 December 2011 26600.0, 20 January 2012\n        \/\/ 26600.0\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsFlatHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsFlatHelper.applyForLoanApplication(clientID, loanProductID, null, null, \"1,00,000.00\",\n                collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        \/\/ Integer loanID = 67 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        String addVariationsjsondata = VariableInstallmentsFlatHelper.createAddVariations();\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsFlatHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"31 October 2011\", \"20 November 2011\", \"20 December 2011\", \"20 January 2012\" },\n                new String[] { \"21600.0\", \"6600.0\", \"26600.0\", \"26600.0\", \"26600.0\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); \/\/ Repayments Schedule includes disbursement also. So\n                           \/\/ remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    } END"}
{"prompt":"test Modify Installments With Interest Typeis Flat\n\n###\n\n","completion":"    @Test\n    public void testModifyInstallmentsWithInterestTypeisFlat() {\n        \/\/ 20 October 2011 - 30000 modify\n        \/\/ Result 20 October 2011 - 32000.0, 20 November 2011 - 25333.33, 20\n        \/\/ December 2011 - 25333.33, 20 January 2012 - 25333.34\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsFlatHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsFlatHelper.applyForLoanApplication(clientID, loanProductID, null, null, \"1,00,000.00\",\n                collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        \/\/ Integer loanID = 67 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        String addVariationsjsondata = VariableInstallmentsFlatHelper.createModifiyVariations((Map) periods.get(1)); \/\/ 0th\n                                                                                                                     \/\/ position\n                                                                                                                     \/\/ will\n                                                                                                                     \/\/ have\n                                                                                                                     \/\/ disbursement\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsFlatHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"20 November 2011\", \"20 December 2011\", \"20 January 2012\" },\n                new String[] { \"32000.0\", \"25333.33\", \"25333.33\", \"25333.34\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); \/\/ Repayments Schedule includes disbursement also. So\n                           \/\/ remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    } END"}
{"prompt":"test All Variations With Interest Type Flat\n\n###\n\n","completion":"    @Test\n    public void testAllVariationsWithInterestTypeFlat() {\n        \/\/ Request: Delete 20 December 2011 25000.0, Modify 20 November 2011\n        \/\/ from 25,000 to 30000, Add 25 December 2011 5000\n        \/\/ Result: 20 October 2011 - 27000.0, 20 November 2011 - 32000.0, 25\n        \/\/ December 2011 - 7000.0, 20 January 2012 - 42000.0\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsFlatHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsFlatHelper.applyForLoanApplication(clientID, loanProductID, null, null, \"1,00,000.00\",\n                collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        \/\/ Integer loanID = 67 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n\n        String addVariationsjsondata = VariableInstallmentsFlatHelper.createAllVariations(); \/\/ 0th\n                                                                                             \/\/ position\n                                                                                             \/\/ will\n                                                                                             \/\/ have\n                                                                                             \/\/ disbursement\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsFlatHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"20 November 2011\", \"25 December 2011\", \"20 January 2012\" },\n                new String[] { \"27000.0\", \"32000.0\", \"7000.0\", \"42000.0\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); \/\/ Repayments Schedule includes disbursement also. So\n                           \/\/ remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    } END"}
{"prompt":"test Modify Dates With Interest Type Flat\n\n###\n\n","completion":"    @Test\n    public void testModifyDatesWithInterestTypeFlat() {\n        \/\/ Modify 20 December 2011:25000 -> 04 January 2012:20000\n        \/\/ Modify 20 January 2012 -> 08 February 2012\n        \/\/ Result 20 October 2011 -27306.45, 20 November 2011 - 27306.45, 04\n        \/\/ January 2012 -22306.45, 08 February 2012 - 32306.46\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsFlatHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsFlatHelper.applyForLoanApplication(clientID, loanProductID, null, null, \"1,00,000.00\",\n                collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        \/\/ Integer loanID = 67 ;\n\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        \/\/\n        \/\/\n        String addVariationsjsondata = VariableInstallmentsFlatHelper.createModifiyDateVariations(\n                new String[] { \"20 December 2011\", \"20 January 2012\" }, new String[] { \"04 January 2012\", \"08 February 2012\" },\n                new String[] { \"20000\" }); \/\/ 0th position will have\n                                           \/\/ disbursement\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsFlatHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"20 November 2011\", \"04 January 2012\", \"08 February 2012\" },\n                new String[] { \"27306.45\", \"27306.45\", \"22306.45\", \"32306.46\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); \/\/ Repayments Schedule includes disbursement also. So\n                           \/\/ remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    } END"}
