{"prompt": "Create a test that tests check Upfront Accrual Accounting Flow", "completion": "    @Test\n    public void checkUpfrontAccrualAccountingFlow() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithUpfrontAccrualAccountingEnabled(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(requestSpec, responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(requestSpec, responseSpec, clientID.toString(),\n                collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, collaterals);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(EXPECTED_DISBURSAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(EXPECTED_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // CHECK ACCOUNT ENTRIES\n        LOG.info(\"Entries ......\");\n        final float PRINCIPAL_VALUE_FOR_EACH_PERIOD = 2000.0f;\n        final float TOTAL_INTEREST = 1000.0f;\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(TOTAL_INTEREST, JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.DEBIT), };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, EXPECTED_DISBURSAL_DATE, assetAccountInitialEntry);\n        LOG.info(\"CHECKING INCOME: ******************************************\");\n        final JournalEntry incomeJournalEntry = new JournalEntry(TOTAL_INTEREST, JournalEntry.TransactionType.CREDIT);\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, EXPECTED_DISBURSAL_DATE, incomeJournalEntry);\n\n        // MAKE 1\n        LOG.info(\"Repayment 1 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[1], REPAYMENT_AMOUNT[1], loanID);\n        final float FIRST_INTEREST = 200.0f;\n        final float FIRST_PRINCIPAL = 2000.0f;\n        float expected_value = LP_PRINCIPAL - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(1, expected_value, loanID);\n        final JournalEntry[] assetAccountFirstEntry = { new JournalEntry(REPAYMENT_AMOUNT[1], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(FIRST_INTEREST + FIRST_PRINCIPAL, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[1], assetAccountFirstEntry);\n        LOG.info(\"Repayment 1 Done......\");\n\n        // REPAYMENT 2\n        LOG.info(\"Repayment 2 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[2], REPAYMENT_AMOUNT[2], loanID);\n        final float SECOND_AND_THIRD_INTEREST = 400.0f;\n        final float SECOND_PRINCIPAL = REPAYMENT_AMOUNT[2] - SECOND_AND_THIRD_INTEREST;\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(2, expected_value, loanID);\n        final JournalEntry[] assetAccountSecondEntry = { new JournalEntry(REPAYMENT_AMOUNT[2], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(SECOND_AND_THIRD_INTEREST + SECOND_PRINCIPAL, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[2], assetAccountSecondEntry);\n        LOG.info(\"Repayment 2 Done ......\");\n\n        // WAIVE INTEREST\n        LOG.info(\"Waive Interest  ......\");\n        this.loanTransactionHelper.waiveInterest(REPAYMENT_DATE[4], AMOUNT_TO_BE_WAIVE.toString(), loanID);\n\n        final JournalEntry waivedEntry = new JournalEntry(AMOUNT_TO_BE_WAIVE, JournalEntry.TransactionType.CREDIT);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[4], waivedEntry);\n\n        final JournalEntry expenseJournalEntry = new JournalEntry(AMOUNT_TO_BE_WAIVE, JournalEntry.TransactionType.DEBIT);\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, REPAYMENT_DATE[4], expenseJournalEntry);\n        LOG.info(\"Waive Interest Done......\");\n\n        // REPAYMENT 3\n        LOG.info(\"Repayment 3 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[3], REPAYMENT_AMOUNT[3], loanID);\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        final JournalEntry[] assetAccountThirdEntry = { new JournalEntry(REPAYMENT_AMOUNT[3], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[3], JournalEntry.TransactionType.CREDIT) };\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(3, expected_value, loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[3], assetAccountThirdEntry);\n        LOG.info(\"Repayment 3 Done ......\");\n\n        // REPAYMENT 4\n        LOG.info(\"Repayment 4 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[4], REPAYMENT_AMOUNT[4], loanID);\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(4, expected_value, loanID);\n        final JournalEntry[] assetAccountFourthEntry = { new JournalEntry(REPAYMENT_AMOUNT[4], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[4], JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[4], assetAccountFourthEntry);\n        LOG.info(\"Repayment 4 Done  ......\");\n\n        // Repayment 5\n        LOG.info(\"Repayment 5 ......\");\n        final JournalEntry[] assetAccountFifthEntry = { new JournalEntry(REPAYMENT_AMOUNT[5], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[5], JournalEntry.TransactionType.CREDIT) };\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[5], REPAYMENT_AMOUNT[5], loanID);\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(5, expected_value, loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[5], assetAccountFifthEntry);\n        LOG.info(\"Repayment 5 Done  ......\");\n    }"}
{"prompt": "Create a test that tests check Accounting With Savings Flow", "completion": "    @Test\n    public void checkAccountingWithSavingsFlow() {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer savingsProductID = createSavingsProduct(MINIMUM_OPENING_BALANCE, assetAccount, incomeAccount, expenseAccount,\n                liabilityAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n        final Integer savingsID = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, savingsID);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsID);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsID);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        // Checking initial Account entries.\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(SP_BALANCE, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountInitialEntry = { new JournalEntry(SP_BALANCE, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, TRANSACTION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, TRANSACTION_DATE, liablilityAccountInitialEntry);\n\n        // First Transaction-Deposit\n        this.savingsAccountHelper.depositToSavingsAccount(savingsID, DEPOSIT_AMOUNT, SavingsAccountHelper.TRANSACTION_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        Float balance = SP_BALANCE + SP_DEPOSIT_AMOUNT;\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsID);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance after Deposit\");\n\n        LOG.info(\"----------------------Verifying Journal Entry after the Transaction Deposit----------------------------\");\n        final JournalEntry[] assetAccountFirstTransactionEntry = {\n                new JournalEntry(SP_DEPOSIT_AMOUNT, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liabililityAccountFirstTransactionEntry = {\n                new JournalEntry(SP_DEPOSIT_AMOUNT, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, TRANSACTION_DATE, assetAccountFirstTransactionEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, TRANSACTION_DATE,\n                liabililityAccountFirstTransactionEntry);\n\n        // Second Transaction-Withdrawal\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsID, WITHDRAWAL_AMOUNT, SavingsAccountHelper.TRANSACTION_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        balance -= SP_WITHDRAWAL_AMOUNT;\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsID);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance after Withdrawal\");\n\n        LOG.info(\"-------------------Verifying Journal Entry after the Transaction Withdrawal----------------------\");\n        final JournalEntry[] assetAccountSecondTransactionEntry = {\n                new JournalEntry(SP_WITHDRAWAL_AMOUNT, JournalEntry.TransactionType.CREDIT) };\n        final JournalEntry[] liabililityAccountSecondTransactionEntry = {\n                new JournalEntry(SP_WITHDRAWAL_AMOUNT, JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, TRANSACTION_DATE, assetAccountSecondTransactionEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, TRANSACTION_DATE,\n                liabililityAccountSecondTransactionEntry);\n\n        // Third Transaction-Add Charges for Withdrawal Fee\n        final Integer withdrawalChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getSavingsWithdrawalFeeJSON());\n        Assertions.assertNotNull(withdrawalChargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsID, withdrawalChargeId, false);\n        ArrayList<HashMap> chargesPendingState = this.savingsAccountHelper.getSavingsCharges(savingsID);\n        Assertions.assertEquals(1, chargesPendingState.size());\n        HashMap savingsChargeForPay = chargesPendingState.get(0);\n        HashMap paidCharge = this.savingsAccountHelper.getSavingsCharge(savingsID, (Integer) savingsChargeForPay.get(\"id\"));\n        Float chargeAmount = (Float) paidCharge.get(\"amount\");\n\n        // Withdrawal after adding Charge of type Withdrawal Fee\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsID, WITHDRAWAL_AMOUNT_ADJUSTED, SavingsAccountHelper.TRANSACTION_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsID);\n        balance = balance - SP_WITHDRAWAL_AMOUNT_ADJUSTED - chargeAmount;\n\n        final JournalEntry[] liabililityAccountThirdTransactionEntry = { new JournalEntry(chargeAmount, JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(SP_WITHDRAWAL_AMOUNT_ADJUSTED, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] assetAccountThirdTransactionEntry = {\n                new JournalEntry(SP_WITHDRAWAL_AMOUNT_ADJUSTED, JournalEntry.TransactionType.CREDIT) };\n        final JournalEntry[] incomeAccountThirdTransactionEntry = { new JournalEntry(chargeAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, TRANSACTION_DATE, assetAccountThirdTransactionEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, TRANSACTION_DATE,\n                liabililityAccountThirdTransactionEntry);\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, TRANSACTION_DATE, incomeAccountThirdTransactionEntry);\n\n        // Verifying Balance after applying Charge for Withdrawal Fee\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance\");\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Accounting Flow", "completion": "    @Test\n    public void testFixedDepositAccountingFlow() {\n        this.accountHelper = new AccountHelper(requestSpec, responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(requestSpec, responseSpec);\n\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(3);\n        final String VALID_FROM = dateFormat.format(todaysDate);\n        todaysDate = todaysDate.plusYears(10);\n        final String VALID_TO = dateFormat.format(todaysDate);\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate);\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate);\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n\n        todaysDate = todaysDate.plusMonths(1).withDayOfMonth(1);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate);\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientId);\n        // Assertions.assertNotNull(clientId);\n\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, assetAccount, incomeAccount, expenseAccount,\n                liabilityAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(), VALID_FROM,\n                VALID_TO, SUBMITTED_ON_DATE, FixedDepositTest.WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(requestSpec,\n                responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n\n        Float depositAmount = (Float) accountSummary.get(\"totalDeposits\");\n\n        // Checking initial Journal entries after Activation.\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, ACTIVATION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, ACTIVATION_DATE, liablilityAccountInitialEntry);\n\n        Integer transactionIdForPostInterest = this.fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n\n        // Checking initial Journal entries after Interest Posting.\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Accounting Flow", "completion": "    @Test\n    public void testRecurringDepositAccountingFlow() {\n        this.accountHelper = new AccountHelper(requestSpec, responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(requestSpec, responseSpec);\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(3);\n        final String VALID_FROM = dateFormat.format(todaysDate);\n        todaysDate = todaysDate.plusYears(10);\n        final String VALID_TO = dateFormat.format(todaysDate);\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate);\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate);\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n        final String EXPECTED_FIRST_DEPOSIT_ON_DATE = dateFormat.format(todaysDate);\n\n        todaysDate = todaysDate.plusMonths(1).withDayOfMonth(1);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate);\n\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientId);\n\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, assetAccount, liabilityAccount,\n                incomeAccount, expenseAccount);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, RecurringDepositTest.WHOLE_TERM, EXPECTED_FIRST_DEPOSIT_ON_DATE);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(requestSpec,\n                responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(requestSpec, responseSpec,\n                recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                depositAmount, EXPECTED_FIRST_DEPOSIT_ON_DATE);\n        Assertions.assertNotNull(depositTransactionId);\n\n        // Checking initial Journal entries after Activation.\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, EXPECTED_FIRST_DEPOSIT_ON_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, EXPECTED_FIRST_DEPOSIT_ON_DATE,\n                liablilityAccountInitialEntry);\n\n        Integer interestPostingTransactionId = this.recurringDepositAccountHelper\n                .postInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(interestPostingTransactionId);\n\n        HashMap accountSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n\n        // Checking initial Journal entries after Interest Posting.\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n    }"}
{"prompt": "Create a test that tests check Periodic Accrual Accounting Flow", "completion": "    @Test\n    public void checkPeriodicAccrualAccountingFlow() throws InterruptedException, ParseException {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingEnabled(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(requestSpec, responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(requestSpec, responseSpec, clientID.toString(),\n                collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, collaterals);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(EXPECTED_DISBURSAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(EXPECTED_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // CHECK ACCOUNT ENTRIES\n        LOG.info(\"Entries ......\");\n        final float PRINCIPAL_VALUE_FOR_EACH_PERIOD = 2000.0f;\n        final float TOTAL_INTEREST = 1000.0f;\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.DEBIT), };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, EXPECTED_DISBURSAL_DATE, assetAccountInitialEntry);\n\n        final String jobName = \"Add Accrual Transactions\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(jobName);\n\n        // MAKE 1\n        LOG.info(\"Repayment 1 ......\");\n        final float FIRST_INTEREST = 200.0f;\n        final float FIRST_PRINCIPAL = 2000.0f;\n        final float FEE_PORTION = 0.0f;\n        final float PENALTY_PORTION = 0.0f;\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(getDateAsLocalDate(REPAYMENT_DATE[1]), FIRST_INTEREST, FEE_PORTION,\n                PENALTY_PORTION, loanID);\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[1], REPAYMENT_AMOUNT[1], loanID);\n        float expected_value = LP_PRINCIPAL - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(1, expected_value, loanID);\n        final JournalEntry[] assetAccountFirstEntry = { new JournalEntry(REPAYMENT_AMOUNT[1], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(FIRST_INTEREST + FIRST_PRINCIPAL, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[1], assetAccountFirstEntry);\n        LOG.info(\"Repayment 1 Done......\");\n\n        // REPAYMENT 2\n        LOG.info(\"Repayment 2 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[2], REPAYMENT_AMOUNT[2], loanID);\n        final float SECOND_AND_THIRD_INTEREST = 400.0f;\n        final float SECOND_PRINCIPAL = REPAYMENT_AMOUNT[2] - SECOND_AND_THIRD_INTEREST;\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(getDateAsLocalDate(REPAYMENT_DATE[2]), FIRST_INTEREST, FEE_PORTION,\n                PENALTY_PORTION, loanID);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(getDateAsLocalDate(REPAYMENT_DATE[3]), FIRST_INTEREST, FEE_PORTION,\n                PENALTY_PORTION, loanID);\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(2, expected_value, loanID);\n        final JournalEntry[] assetAccountSecondEntry = { new JournalEntry(REPAYMENT_AMOUNT[2], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(SECOND_AND_THIRD_INTEREST + SECOND_PRINCIPAL, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[2], assetAccountSecondEntry);\n        LOG.info(\"Repayment 2 Done ......\");\n\n        // WAIVE INTEREST\n        LOG.info(\"Waive Interest  ......\");\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(getDateAsLocalDate(REPAYMENT_DATE[4]), FIRST_INTEREST, FEE_PORTION,\n                PENALTY_PORTION, loanID);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(getDateAsLocalDate(REPAYMENT_DATE[5]), FIRST_INTEREST, FEE_PORTION,\n                PENALTY_PORTION, loanID);\n        this.loanTransactionHelper.waiveInterest(REPAYMENT_DATE[4], AMOUNT_TO_BE_WAIVE.toString(), loanID);\n\n        final JournalEntry waivedEntry = new JournalEntry(AMOUNT_TO_BE_WAIVE, JournalEntry.TransactionType.CREDIT);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[4], waivedEntry);\n\n        final JournalEntry expenseJournalEntry = new JournalEntry(AMOUNT_TO_BE_WAIVE, JournalEntry.TransactionType.DEBIT);\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, REPAYMENT_DATE[4], expenseJournalEntry);\n        LOG.info(\"Waive Interest Done......\");\n\n        // REPAYMENT 3\n        LOG.info(\"Repayment 3 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[3], REPAYMENT_AMOUNT[3], loanID);\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        final JournalEntry[] assetAccountThirdEntry = { new JournalEntry(REPAYMENT_AMOUNT[3], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[3], JournalEntry.TransactionType.CREDIT) };\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(3, expected_value, loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[3], assetAccountThirdEntry);\n        LOG.info(\"Repayment 3 Done ......\");\n\n        // REPAYMENT 4\n        LOG.info(\"Repayment 4 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[4], REPAYMENT_AMOUNT[4], loanID);\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(4, expected_value, loanID);\n        final JournalEntry[] assetAccountFourthEntry = { new JournalEntry(REPAYMENT_AMOUNT[4], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[4], JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[4], assetAccountFourthEntry);\n        LOG.info(\"Repayment 4 Done  ......\");\n\n        // Repayment 5\n        LOG.info(\"Repayment 5 ......\");\n        final JournalEntry[] assetAccountFifthEntry = { new JournalEntry(REPAYMENT_AMOUNT[5], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[5], JournalEntry.TransactionType.CREDIT) };\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[5], REPAYMENT_AMOUNT[5], loanID);\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(5, expected_value, loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[5], assetAccountFifthEntry);\n        LOG.info(\"Repayment 5 Done  ......\");\n    }"}
{"prompt": "Create a test that tests check Periodic Accrual Accounting Flow OVER PAYMENT", "completion": "    @Test\n    public void checkPeriodicAccrualAccountingFlow_OVER_PAYMENT() throws InterruptedException, ParseException {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingEnabled(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(requestSpec, responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(requestSpec, responseSpec, clientID.toString(),\n                collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, collaterals);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(EXPECTED_DISBURSAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(EXPECTED_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // CHECK ACCOUNT ENTRIES\n        LOG.info(\"Entries ......\");\n        final float PRINCIPAL_VALUE_FOR_EACH_PERIOD = 2000.0f;\n        final float TOTAL_INTEREST = 1000.0f;\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.DEBIT), };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, EXPECTED_DISBURSAL_DATE, assetAccountInitialEntry);\n\n        final String jobName = \"Add Accrual Transactions\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(jobName);\n\n        // MAKE 1\n        LOG.info(\"Repayment 1 ......\");\n        final float FIRST_INTEREST = 200.0f;\n        final float FIRST_PRINCIPAL = 2000.0f;\n        final float FEE_PORTION = 0.0f;\n        final float PENALTY_PORTION = 0.0f;\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(getDateAsLocalDate(REPAYMENT_DATE[1]), FIRST_INTEREST, FEE_PORTION,\n                PENALTY_PORTION, loanID);\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[1], 15000f, loanID);\n        float expected_value = LP_PRINCIPAL - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(1, expected_value, loanID);\n        final JournalEntry[] assetAccountEntry = { new JournalEntry(15000f, JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(11000f, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[1], assetAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, REPAYMENT_DATE[1],\n                new JournalEntry(4000f, JournalEntry.TransactionType.CREDIT));\n        LOG.info(\"Repayment  Done......\");\n\n    }"}
{"prompt": "Create a test that tests check Periodic Accrual Accounting Till Current Date Flow", "completion": "    @Test\n    public void checkPeriodicAccrualAccountingTillCurrentDateFlow() throws InterruptedException, ParseException {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingEnabled(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(requestSpec, responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(requestSpec, responseSpec, clientID.toString(),\n                collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, collaterals);\n\n        final float FEE_PORTION = 50.0f;\n        final float PENALTY_PORTION = 100.0f;\n        Integer flat = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(FEE_PORTION), false));\n        Integer flatSpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(PENALTY_PORTION), true));\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(EXPECTED_DISBURSAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n\n        final LocalDate localDate = LocalDate.now(this.systemTimeZone.toZoneId());\n        final ZonedDateTime currentDate = ZonedDateTime.of(localDate, LocalTime.MIDNIGHT, this.systemTimeZone.toZoneId());\n        ZonedDateTime zonedDate = currentDate.minusDays(4);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(zonedDate);\n\n        zonedDate = currentDate.minusDays(2);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(\n                String.valueOf(flatSpecifiedDueDate), dateFormat.format(zonedDate), String.valueOf(PENALTY_PORTION)));\n        zonedDate = zonedDate.plusDays(1);\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flat), dateFormat.format(zonedDate), String.valueOf(FEE_PORTION)));\n\n        // CHECK ACCOUNT ENTRIES\n        LOG.info(\"Entries ......\");\n        final float PRINCIPAL_VALUE_FOR_EACH_PERIOD = 2000.0f;\n        final float TOTAL_INTEREST = 1000.0f;\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.DEBIT), };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, LOAN_DISBURSEMENT_DATE, assetAccountInitialEntry);\n\n        final String jobName = \"Add Periodic Accrual Transactions\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(jobName);\n\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        // MAKE 1\n        List fromDateList = (List) loanSchedule.get(1).get(\"fromDate\");\n        LocalDate fromDateLocal = LocalDate.now(Utils.getZoneIdOfTenant());\n        fromDateLocal = fromDateLocal.withYear((int) fromDateList.get(0));\n        fromDateLocal = fromDateLocal.withMonth((int) fromDateList.get(1));\n        fromDateLocal = fromDateLocal.withDayOfMonth((int) fromDateList.get(2));\n\n        List dueDateList = (List) loanSchedule.get(1).get(\"dueDate\");\n        LocalDate dueDateLocal = LocalDate.now(Utils.getZoneIdOfTenant());\n        dueDateLocal = dueDateLocal.withYear((int) dueDateList.get(0));\n        dueDateLocal = dueDateLocal.withMonth((int) dueDateList.get(1));\n        dueDateLocal = dueDateLocal.withDayOfMonth((int) dueDateList.get(2));\n\n        int totalDaysInPeriod = Math.toIntExact(ChronoUnit.DAYS.between(fromDateLocal, dueDateLocal));\n\n        float totalInterest = (float) loanSchedule.get(1).get(\"interestOriginalDue\");\n        DecimalFormat numberFormat = new DecimalFormat(\"#.00\", new DecimalFormatSymbols(Locale.US));\n        float interest4Days = totalInterest / totalDaysInPeriod * 4;\n        interest4Days = Float.parseFloat(numberFormat.format(interest4Days));\n\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(currentDate.toLocalDate(), interest4Days, FEE_PORTION,\n                PENALTY_PORTION, loanID);\n\n    }"}
{"prompt": "Create a test that tests check Periodic Accrual Accounting APIFlow", "completion": "    @Test\n    public void checkPeriodicAccrualAccountingAPIFlow() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"0\");\n\n        final float FEE_PORTION = 50.0f;\n        final float PENALTY_PORTION = 100.0f;\n        final float NEXT_FEE_PORTION = 55.0f;\n        final float NEXT_PENALTY_PORTION = 105.0f;\n\n        Integer flat = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(FEE_PORTION), false));\n        Integer flatSpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(PENALTY_PORTION), true));\n\n        Integer flatNext = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(NEXT_FEE_PORTION), false));\n        Integer flatSpecifiedDueDateNext = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(NEXT_PENALTY_PORTION), true));\n\n        HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(EXPECTED_DISBURSAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LocalDate targetDate = LocalDate.of(2011, 3, 4);\n        final String loanDisbursementDate = dateFormatter.format(targetDate);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(2, loanSchedule.size());\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesDue\"));\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesOutstanding\"));\n        assertEquals(0, loanSchedule.get(1).get(\"penaltyChargesDue\"));\n        assertEquals(0, loanSchedule.get(1).get(\"penaltyChargesOutstanding\"));\n        assertEquals(10000.0f, loanSchedule.get(1).get(\"totalDueForPeriod\"));\n        assertEquals(10000.0f, loanSchedule.get(1).get(\"totalOutstandingForPeriod\"));\n        targetDate = LocalDate.of(2011, 4, 5);\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatSpecifiedDueDate), penaltyCharge1AddedDate,\n                        String.valueOf(PENALTY_PORTION)));\n\n        this.loanTransactionHelper.noAccrualTransactionForRepayment(loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(3, loanSchedule.size());\n        assertEquals(0, loanSchedule.get(2).get(\"feeChargesDue\"));\n        assertEquals(0, loanSchedule.get(2).get(\"feeChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesDue\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"totalDueForPeriod\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"totalOutstandingForPeriod\"));\n        assertEquals(LocalDate.of(2011, 4, 5), LocalDate.of((int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(0),\n                (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(1), (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(2)));\n\n        String runOnDateStr = penaltyCharge1AddedDate;\n        LocalDate runOnDate = targetDate;\n        this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(runOnDateStr);\n\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(runOnDate, 0.0f, 0.0f, PENALTY_PORTION, loanID);\n\n        targetDate = LocalDate.of(2011, 4, 6);\n        final String feeCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer fee1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flat), feeCharge1AddedDate, String.valueOf(FEE_PORTION)));\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(3, loanSchedule.size());\n        assertEquals(FEE_PORTION, loanSchedule.get(2).get(\"feeChargesDue\"));\n        assertEquals(FEE_PORTION, loanSchedule.get(2).get(\"feeChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesDue\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION + FEE_PORTION, loanSchedule.get(2).get(\"totalDueForPeriod\"));\n        assertEquals(PENALTY_PORTION + FEE_PORTION, loanSchedule.get(2).get(\"totalOutstandingForPeriod\"));\n        assertEquals(LocalDate.of(2011, 4, 6), LocalDate.of((int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(0),\n                (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(1), (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(2)));\n\n        targetDate = LocalDate.of(2011, 4, 7);\n        final String penaltyCharge2AddedDate = dateFormatter.format(targetDate);\n        Integer penalty2LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatSpecifiedDueDateNext),\n                        penaltyCharge2AddedDate, String.valueOf(NEXT_PENALTY_PORTION)));\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(3, loanSchedule.size());\n        assertEquals(FEE_PORTION, loanSchedule.get(2).get(\"feeChargesDue\"));\n        assertEquals(FEE_PORTION, loanSchedule.get(2).get(\"feeChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION + NEXT_PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesDue\"));\n        assertEquals(PENALTY_PORTION + NEXT_PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION + FEE_PORTION + NEXT_PENALTY_PORTION, loanSchedule.get(2).get(\"totalDueForPeriod\"));\n        assertEquals(PENALTY_PORTION + FEE_PORTION + NEXT_PENALTY_PORTION, loanSchedule.get(2).get(\"totalOutstandingForPeriod\"));\n        assertEquals(LocalDate.of(2011, 4, 7), LocalDate.of((int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(0),\n                (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(1), (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(2)));\n\n        targetDate = LocalDate.of(2011, 4, 8);\n        final String feeCharge2AddedDate = dateFormatter.format(targetDate);\n        Integer fee2LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatNext), feeCharge2AddedDate, String.valueOf(NEXT_FEE_PORTION)));\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(3, loanSchedule.size());\n        assertEquals(FEE_PORTION + NEXT_FEE_PORTION, loanSchedule.get(2).get(\"feeChargesDue\"));\n        assertEquals(FEE_PORTION + NEXT_FEE_PORTION, loanSchedule.get(2).get(\"feeChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION + NEXT_PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesDue\"));\n        assertEquals(PENALTY_PORTION + NEXT_PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION + FEE_PORTION + NEXT_PENALTY_PORTION + NEXT_FEE_PORTION, loanSchedule.get(2).get(\"totalDueForPeriod\"));\n        assertEquals(PENALTY_PORTION + FEE_PORTION + NEXT_PENALTY_PORTION + NEXT_FEE_PORTION,\n                loanSchedule.get(2).get(\"totalOutstandingForPeriod\"));\n        assertEquals(LocalDate.of(2011, 4, 8), LocalDate.of((int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(0),\n                (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(1), (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(2)));\n\n        runOnDateStr = penaltyCharge2AddedDate;\n        runOnDate = LocalDate.of(2011, 4, 7);\n        this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(runOnDateStr);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(runOnDate, 0.0f, FEE_PORTION, NEXT_PENALTY_PORTION, loanID);\n    }"}
{"prompt": "Create a test that tests check Cash Based Accounting Flow", "completion": "    @Test\n    public void checkCashBasedAccountingFlow() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithCashBasedAccountingEnabled(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(requestSpec, responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(requestSpec, responseSpec, clientID.toString(),\n                collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, collaterals);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(EXPECTED_DISBURSAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(EXPECTED_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // CHECK ACCOUNT ENTRIES\n        LOG.info(\"Entries ......\");\n        final float PRINCIPAL_VALUE_FOR_EACH_PERIOD = 2000.0f;\n        final float TOTAL_INTEREST = 1000.0f;\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(LP_PRINCIPAL, JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, EXPECTED_DISBURSAL_DATE, assetAccountInitialEntry);\n\n        // MAKE 1\n        LOG.info(\"Repayment 1 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[1], REPAYMENT_AMOUNT[1], loanID);\n        final float FIRST_INTEREST = 200.0f;\n        final float FIRST_PRINCIPAL = 2000.0f;\n        float expected_value = LP_PRINCIPAL - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(1, expected_value, loanID);\n        final JournalEntry[] assetAccountFirstEntry = { new JournalEntry(REPAYMENT_AMOUNT[1], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(FIRST_PRINCIPAL, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[1], assetAccountFirstEntry);\n        LOG.info(\"CHECKING INCOME: ******************************************\");\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, REPAYMENT_DATE[1],\n                new JournalEntry(FIRST_INTEREST, JournalEntry.TransactionType.CREDIT));\n        LOG.info(\"Repayment 1 Done......\");\n\n        // REPAYMENT 2\n        LOG.info(\"Repayment 2 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[2], REPAYMENT_AMOUNT[2], loanID);\n        final float SECOND_AND_THIRD_INTEREST = 400.0f;\n        final float SECOND_PRINCIPAL = REPAYMENT_AMOUNT[2] - SECOND_AND_THIRD_INTEREST;\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(2, expected_value, loanID);\n        final JournalEntry[] assetAccountSecondEntry = { new JournalEntry(REPAYMENT_AMOUNT[2], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(SECOND_PRINCIPAL, JournalEntry.TransactionType.CREDIT), };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[2], assetAccountSecondEntry);\n        LOG.info(\"CHECKING INCOME: ******************************************\");\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, REPAYMENT_DATE[2],\n                new JournalEntry(SECOND_AND_THIRD_INTEREST, JournalEntry.TransactionType.CREDIT));\n        LOG.info(\"Repayment 2 Done ......\");\n\n        // WAIVE INTEREST\n        LOG.info(\"Waive Interest  ......\");\n        Integer transactionId = this.loanTransactionHelper.waiveInterestAndReturnTransactionId(REPAYMENT_DATE[4],\n                AMOUNT_TO_BE_WAIVE.toString(), loanID);\n        // waive of fees and interest are not considered in cash based\n        // accounting,\n        this.journalEntryHelper.ensureNoAccountingTransactionsWithTransactionId(\"L\" + transactionId);\n\n        // REPAYMENT 3\n        LOG.info(\"Repayment 3 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[3], REPAYMENT_AMOUNT[3], loanID);\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        final JournalEntry[] assetAccountThirdEntry = { new JournalEntry(REPAYMENT_AMOUNT[3], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[3], JournalEntry.TransactionType.CREDIT) };\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(3, expected_value, loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[3], assetAccountThirdEntry);\n        LOG.info(\"Repayment 3 Done ......\");\n\n        // REPAYMENT 4\n        LOG.info(\"Repayment 4 ......\");\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[4], REPAYMENT_AMOUNT[4], loanID);\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(4, expected_value, loanID);\n        final JournalEntry[] assetAccountFourthEntry = { new JournalEntry(REPAYMENT_AMOUNT[4], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[4], JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[4], assetAccountFourthEntry);\n        LOG.info(\"Repayment 4 Done  ......\");\n\n        // Repayment 5\n        LOG.info(\"Repayment 5 ......\");\n        final JournalEntry[] assetAccountFifthEntry = { new JournalEntry(REPAYMENT_AMOUNT[5], JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(REPAYMENT_AMOUNT[5], JournalEntry.TransactionType.CREDIT) };\n        expected_value = expected_value - PRINCIPAL_VALUE_FOR_EACH_PERIOD;\n        this.loanTransactionHelper.makeRepayment(REPAYMENT_DATE[5], REPAYMENT_AMOUNT[5], loanID);\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(5, expected_value, loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, REPAYMENT_DATE[5], assetAccountFifthEntry);\n        LOG.info(\"Repayment 5 Done  ......\");\n    }"}
{"prompt": "Create a test that tests test Account Number Preferences", "completion": "    @Test\n    public void testAccountNumberPreferences() {\n\n        /* Create Loan and Savings Product */\n        this.createLoanAndSavingsProduct();\n\n        /* Ensure no account number preferences are present in the system */\n        this.deleteAllAccountNumberPreferences();\n\n        /*\n         * Validate the default account number generation rules for clients, loans and savings accounts.\n         */\n        this.validateDefaultAccountNumberGeneration();\n\n        /* Create and Validate account number preferences */\n        this.createAccountNumberPreference();\n\n        /*\n         * Validate account number preference rules apply to Clients,Loans and Saving Accounts\n         */\n        this.validateAccountNumberGenerationWithPreferences();\n\n        /* Validate account number preferences Updation */\n        this.updateAccountNumberPreference();\n\n        /*\n         * Validate account number preference rules apply to Clients,Loans and Saving Accounts after Updation\n         */\n        this.validateAccountNumberGenerationWithPreferences();\n\n        /* Delete all account number preferences */\n        this.deleteAllAccountNumberPreferences();\n\n    }"}
{"prompt": "Create a test that tests test From Savings To Savings Account Transfer", "completion": "    @Test\n    public void testFromSavingsToSavingsAccountTransfer() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.accountTransferHelper = new AccountTransferHelper(this.requestSpec, this.responseSpec);\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        OfficeHelper officeHelper = new OfficeHelper(this.requestSpec, this.responseSpec);\n        Integer toOfficeId = officeHelper.createOffice(\"01 January 2011\");\n        Assertions.assertNotNull(toOfficeId);\n\n        // Creating Savings Account to which fund to be Transferred\n        final Integer toClientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2011\",\n                String.valueOf(toOfficeId));\n        Assertions.assertNotNull(toClientID);\n\n        final Integer toSavingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE, assetAccount,\n                incomeAccount, expenseAccount, liabilityAccount);\n        Assertions.assertNotNull(toSavingsProductID);\n\n        final Integer toSavingsID = this.savingsAccountHelper.applyForSavingsApplication(toClientID, toSavingsProductID,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(toSavingsProductID);\n\n        HashMap toSavingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, toSavingsID);\n        SavingsStatusChecker.verifySavingsIsPending(toSavingsStatusHashMap);\n\n        toSavingsStatusHashMap = this.savingsAccountHelper.approveSavings(toSavingsID);\n        SavingsStatusChecker.verifySavingsIsApproved(toSavingsStatusHashMap);\n\n        toSavingsStatusHashMap = this.savingsAccountHelper.activateSavings(toSavingsID);\n        SavingsStatusChecker.verifySavingsIsActive(toSavingsStatusHashMap);\n\n        final HashMap toSavingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(toSavingsID);\n\n        Integer fromOfficeId = officeHelper.createOffice(\"01 January 2011\");\n        Assertions.assertNotNull(fromOfficeId);\n\n        // Creating Savings Account from which the Fund has to be Transferred\n        final Integer fromClientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2011\",\n                String.valueOf(fromOfficeId));\n        Assertions.assertNotNull(fromClientID);\n\n        final Integer fromSavingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                assetAccount, incomeAccount, expenseAccount, liabilityAccount);\n        Assertions.assertNotNull(fromSavingsProductID);\n\n        final Integer fromSavingsID = this.savingsAccountHelper.applyForSavingsApplication(fromClientID, fromSavingsProductID,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(fromSavingsID);\n\n        HashMap fromSavingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsPending(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.approveSavings(fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsApproved(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.activateSavings(fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsActive(fromSavingsStatusHashMap);\n\n        final HashMap fromSavingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(fromSavingsID);\n\n        Float fromSavingsBalance = Float.valueOf(MINIMUM_OPENING_BALANCE);\n        Float toSavingsBalance = Float.valueOf(MINIMUM_OPENING_BALANCE);\n\n        this.accountTransferHelper.accountTransfer(fromClientID, fromSavingsID, fromClientID, toSavingsID, FROM_SAVINGS_ACCOUNT_TYPE,\n                TO_SAVINGS_ACCOUNT_TYPE, ACCOUNT_TRANSFER_AMOUNT);\n\n        fromSavingsBalance -= Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT);\n        toSavingsBalance += Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT);\n\n        HashMap fromSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(fromSavingsID);\n        assertEquals(fromSavingsBalance, fromSavingsSummaryAfter.get(\"accountBalance\"),\n                \"Verifying From Savings Account Balance after Account Transfer\");\n\n        HashMap toSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(toSavingsID);\n        assertEquals(toSavingsBalance, toSavingsSummaryAfter.get(\"accountBalance\"),\n                \"Verifying To Savings Account Balance after Account Transfer\");\n        final JournalEntry[] office1LiabilityEntries = {\n                new JournalEntry(Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT), JournalEntry.TransactionType.CREDIT) };\n        final JournalEntry[] office2LiabilityEntries = {\n                new JournalEntry(Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT), JournalEntry.TransactionType.DEBIT) };\n\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(fromOfficeId, liabilityTransferAccount,\n                AccountTransferHelper.ACCOUNT_TRANSFER_DATE, office1LiabilityEntries);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(toOfficeId, liabilityTransferAccount,\n                AccountTransferHelper.ACCOUNT_TRANSFER_DATE, office2LiabilityEntries);\n\n    }"}
{"prompt": "Create a test that tests test From Savings To Loan Account Transfer", "completion": "    @Test\n    public void testFromSavingsToLoanAccountTransfer() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        final Account loanAssetAccount = this.accountHelper.createAssetAccount();\n        final Account loanIncomeAccount = this.accountHelper.createIncomeAccount();\n        final Account loanExpenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        this.accountTransferHelper = new AccountTransferHelper(this.requestSpec, this.responseSpec);\n\n        OfficeHelper officeHelper = new OfficeHelper(this.requestSpec, this.responseSpec);\n        Integer toOfficeId = officeHelper.createOffice(\"01 January 2011\");\n        Assertions.assertNotNull(toOfficeId);\n\n        // Creating Loan Account to which fund to be Transferred\n        final Integer toClientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2011\",\n                String.valueOf(toOfficeId));\n        Assertions.assertNotNull(toClientID);\n\n        Account toTransferAccount = accountHelper.createLiabilityAccount();\n        Assertions.assertNotNull(toTransferAccount);\n\n        final Integer toLoanProductID = createLoanProduct(loanAssetAccount, loanIncomeAccount, loanExpenseAccount, overpaymentAccount);\n        Assertions.assertNotNull(toLoanProductID);\n\n        final Integer toLoanID = applyForLoanApplication(toClientID, toLoanProductID);\n        Assertions.assertNotNull(toLoanID);\n\n        HashMap toLoanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, toLoanID);\n        LoanStatusChecker.verifyLoanIsPending(toLoanStatusHashMap);\n\n        toLoanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_APPROVAL_DATE, toLoanID);\n        LoanStatusChecker.verifyLoanIsApproved(toLoanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, toLoanID);\n        toLoanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSAL_DATE, toLoanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(toLoanStatusHashMap);\n\n        Integer fromOfficeId = officeHelper.createOffice(\"01 January 2011\");\n        Assertions.assertNotNull(fromOfficeId);\n\n        // Creating Savings Account from which the Fund has to be Transferred\n        final Integer fromClientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2011\",\n                String.valueOf(fromOfficeId));\n        Assertions.assertNotNull(fromClientID);\n\n        final Integer fromSavingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                assetAccount, incomeAccount, expenseAccount, liabilityAccount);\n        Assertions.assertNotNull(fromSavingsProductID);\n\n        final Integer fromSavingsID = this.savingsAccountHelper.applyForSavingsApplication(fromClientID, fromSavingsProductID,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(fromSavingsID);\n\n        HashMap fromSavingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsPending(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.approveSavings(fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsApproved(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.activateSavings(fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsActive(fromSavingsStatusHashMap);\n\n        final HashMap fromSavingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(fromSavingsID);\n\n        Float fromSavingsBalance = Float.valueOf(MINIMUM_OPENING_BALANCE);\n\n        this.accountTransferHelper.accountTransfer(fromClientID, fromSavingsID, toClientID, toLoanID, FROM_SAVINGS_ACCOUNT_TYPE,\n                TO_LOAN_ACCOUNT_TYPE, ACCOUNT_TRANSFER_AMOUNT_ADJUST);\n\n        fromSavingsBalance -= TRANSFER_AMOUNT_ADJUST;\n\n        HashMap fromSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(fromSavingsID);\n        assertEquals(fromSavingsBalance, fromSavingsSummaryAfter.get(\"accountBalance\"),\n                \"Verifying From Savings Account Balance after Account Transfer\");\n\n        HashMap toLoanSummaryAfter = this.loanTransactionHelper.getLoanSummary(requestSpec, responseSpec, toLoanID);\n        assertEquals(TRANSFER_AMOUNT_ADJUST, toLoanSummaryAfter.get(\"totalRepayment\"),\n                \"Verifying To Loan Repayment Amount after Account Transfer\");\n\n        final JournalEntry[] office1LiabilityEntries = {\n                new JournalEntry(Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT_ADJUST), JournalEntry.TransactionType.CREDIT) };\n        final JournalEntry[] office2LiabilityEntries = {\n                new JournalEntry(Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT_ADJUST), JournalEntry.TransactionType.DEBIT) };\n\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(fromOfficeId, liabilityTransferAccount,\n                AccountTransferHelper.ACCOUNT_TRANSFER_DATE, office1LiabilityEntries);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(toOfficeId, liabilityTransferAccount,\n                AccountTransferHelper.ACCOUNT_TRANSFER_DATE, office2LiabilityEntries);\n    }"}
{"prompt": "Create a test that tests test From Loan To Savings Account Transfer", "completion": "    @Test\n    public void testFromLoanToSavingsAccountTransfer() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        final Account loanAssetAccount = this.accountHelper.createAssetAccount();\n        final Account loanIncomeAccount = this.accountHelper.createIncomeAccount();\n        final Account loanExpenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        this.accountTransferHelper = new AccountTransferHelper(this.requestSpec, this.responseSpec);\n\n        OfficeHelper officeHelper = new OfficeHelper(this.requestSpec, this.responseSpec);\n        Integer toOfficeId = officeHelper.createOffice(\"01 January 2011\");\n        Assertions.assertNotNull(toOfficeId);\n\n        // Creating Loan Account to which fund to be Transferred\n        final Integer toClientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2011\",\n                String.valueOf(toOfficeId));\n        Assertions.assertNotNull(toClientID);\n\n        final Integer toSavingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE, assetAccount,\n                incomeAccount, expenseAccount, liabilityAccount);\n        Assertions.assertNotNull(toSavingsProductID);\n\n        final Integer toSavingsID = this.savingsAccountHelper.applyForSavingsApplication(toClientID, toSavingsProductID,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(toSavingsID);\n\n        HashMap toSavingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, toSavingsID);\n        SavingsStatusChecker.verifySavingsIsPending(toSavingsStatusHashMap);\n\n        toSavingsStatusHashMap = this.savingsAccountHelper.approveSavings(toSavingsID);\n        SavingsStatusChecker.verifySavingsIsApproved(toSavingsStatusHashMap);\n\n        toSavingsStatusHashMap = this.savingsAccountHelper.activateSavings(toSavingsID);\n        SavingsStatusChecker.verifySavingsIsActive(toSavingsStatusHashMap);\n\n        Integer fromOfficeId = officeHelper.createOffice(\"01 January 2011\");\n        Assertions.assertNotNull(fromOfficeId);\n\n        // Creating Savings Account from which the Fund has to be Transferred\n        final Integer fromClientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2011\",\n                String.valueOf(fromOfficeId));\n        Assertions.assertNotNull(fromClientID);\n\n        final Integer loanProductID = createLoanProduct(loanAssetAccount, loanIncomeAccount, loanExpenseAccount, overpaymentAccount);\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplication(fromClientID, loanProductID);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_APPROVAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final Integer fromSavingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                assetAccount, incomeAccount, expenseAccount, liabilityAccount);\n        Assertions.assertNotNull(fromSavingsProductID);\n\n        final Integer fromSavingsID = this.savingsAccountHelper.applyForSavingsApplication(fromClientID, fromSavingsProductID,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(fromSavingsID);\n\n        HashMap fromSavingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsPending(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.approveSavings(fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsApproved(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.activateSavings(fromSavingsID);\n        SavingsStatusChecker.verifySavingsIsActive(fromSavingsStatusHashMap);\n\n        final HashMap toSavingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(toSavingsID);\n\n        Float fromSavingsBalance = Float.valueOf(MINIMUM_OPENING_BALANCE);\n\n        this.accountTransferHelper.accountTransfer(fromClientID, fromSavingsID, fromClientID, loanID, FROM_SAVINGS_ACCOUNT_TYPE,\n                TO_LOAN_ACCOUNT_TYPE, ACCOUNT_TRANSFER_AMOUNT);\n\n        fromSavingsBalance -= TRANSFER_AMOUNT;\n\n        HashMap fromSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(fromSavingsID);\n\n        // Verifying fromSavings Account Balance after Account Transfer\n        assertEquals(fromSavingsBalance, fromSavingsSummaryAfter.get(\"accountBalance\"),\n                \"Verifying From Savings Account Balance after Account Transfer\");\n\n        Float toSavingsBalance = Float.valueOf(MINIMUM_OPENING_BALANCE);\n\n        this.accountTransferHelper.accountTransfer(fromClientID, loanID, toClientID, toSavingsID, FROM_LOAN_ACCOUNT_TYPE,\n                TO_SAVINGS_ACCOUNT_TYPE, ACCOUNT_TRANSFER_AMOUNT_ADJUST);\n\n        toSavingsBalance += TRANSFER_AMOUNT_ADJUST;\n\n        HashMap toSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(toSavingsID);\n\n        // Verifying toSavings Account Balance after Account Transfer\n        assertEquals(toSavingsBalance, toSavingsSummaryAfter.get(\"accountBalance\"),\n                \"Verifying From Savings Account Balance after Account Transfer\");\n\n        final JournalEntry[] office1LiabilityEntries = {\n                new JournalEntry(Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT_ADJUST), JournalEntry.TransactionType.CREDIT) };\n        final JournalEntry[] office2LiabilityEntries = {\n                new JournalEntry(Float.parseFloat(ACCOUNT_TRANSFER_AMOUNT_ADJUST), JournalEntry.TransactionType.DEBIT) };\n\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(fromOfficeId, liabilityTransferAccount,\n                AccountTransferHelper.ACCOUNT_TRANSFER_DATE, office1LiabilityEntries);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(toOfficeId, liabilityTransferAccount,\n                AccountTransferHelper.ACCOUNT_TRANSFER_DATE, office2LiabilityEntries);\n\n    }"}
{"prompt": "Create a test that tests test Api Docs Access", "completion": "    @Test\n    public void testApiDocsAccess() {\n        Utils.performServerGet(requestSpec, responseSpec, \"/fineract-provider/legacy-docs/apiLive.htm\", null);\n    }"}
{"prompt": "Create a test that tests test Audit Search Template", "completion": "    @Test\n    public void testAuditSearchTemplate() {\n        // given\n        // when\n        LinkedHashMap auditSearchTemplate = this.auditHelper.getAuditSearchTemplate();\n\n        // then\n        assertNotNull(auditSearchTemplate);\n        assertEquals(4, auditSearchTemplate.size()); // appUsers, actionNames, entityNames, processingResults\n        assertTrue(((List) auditSearchTemplate.get(\"actionNames\")).size() > 0);\n    }"}
{"prompt": "Create a test that tests audit Shouldbe Created", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void auditShouldbeCreated() {\n        // Audits recieved after all actions are performed.\n        List<HashMap<String, Object>> auditsRecieved;\n\n        // Audits recieved before any action is performed, needed in special\n        // cases eg: reactivate client, close client\n        List<HashMap<String, Object>> auditsRecievedInitial;\n\n        // When Client is created: Count should be \"1\"\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        auditsRecieved = auditHelper.getAuditDetails(clientId, \"CREATE\", \"CLIENT\");\n        auditHelper.verifyOneAuditOnly(auditsRecieved, clientId, \"CREATE\", \"CLIENT\");\n\n        // Performs multiple close and reactivate on client\n\n        for (int i = 0; i < 4; i++) {\n            // Close\n            auditsRecievedInitial = auditHelper.getAuditDetails(clientId, \"CLOSE\", \"CLIENT\");\n            this.clientHelper.closeClient(clientId);\n            auditsRecieved = auditHelper.getAuditDetails(clientId, \"CLOSE\", \"CLIENT\");\n            auditHelper.verifyMultipleAuditsOnserver(auditsRecievedInitial, auditsRecieved, clientId, \"CLOSE\", \"CLIENT\");\n\n            // Activate\n            auditsRecievedInitial = auditHelper.getAuditDetails(clientId, \"REACTIVATE\", \"CLIENT\");\n            this.clientHelper.reactivateClient(clientId);\n            auditsRecieved = auditHelper.getAuditDetails(clientId, \"REACTIVATE\", \"CLIENT\");\n            auditHelper.verifyMultipleAuditsOnserver(auditsRecievedInitial, auditsRecieved, clientId, \"REACTIVATE\", \"CLIENT\");\n        }\n\n        // When Office is created\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        int officeId = officeHelper.createOffice(\"22 June 2020\");\n        auditsRecieved = auditHelper.getAuditDetails(officeId, \"CREATE\", \"OFFICE\");\n        auditHelper.verifyOneAuditOnly(auditsRecieved, officeId, \"CREATE\", \"OFFICE\");\n    }\n\n    @Test\n    @SuppressFBWarnings(value = {\n            \"DMI_RANDOM_USED_ONLY_ONCE\" }"}
{"prompt": "Create a test that tests check If Order By Supported", "completion": "    @Test\n    public void checkIfOrderBySupported() {\n        final List<String> shouldBeSupportedFor = Arrays.asList(\"checkedOnDate\", \"officeName\", \"resourceId\", \"clientId\", \"processingResult\",\n                \"clientName\", \"maker\", \"subresourceId\", \"checker\", \"savingsAccountNo\", \"loanAccountNo\", \"groupName\", \"entityName\",\n                \"madeOnDate\", \"id\", \"loanId\", \"actionName\");\n\n        for (int i = 0; i < shouldBeSupportedFor.size(); i++) {\n            auditHelper.verifyOrderBysupported(shouldBeSupportedFor.get(i));\n        }\n\n    }"}
{"prompt": "Create a test that tests should Return Status Not Implemented Unknown Command", "completion": "     */\n    @Test\n    public void shouldReturnStatusNotImplementedUnknownCommand() {\n\n        final BatchRequest br = new BatchRequest();\n        br.setRequestId(4711L);\n        br.setRelativeUrl(\"/nirvana\");\n        br.setMethod(\"POST\");\n\n        final List<BatchResponse> response = BatchHelper.postWithSingleRequest(this.requestSpec, this.responseSpec, br);\n\n        // Verify that only 501 is returned as the status code\n        for (BatchResponse resp : response) {\n            Assertions.assertEquals((long) 501, (long) resp.getStatusCode(), \"Verify Status code 501\");\n        }\n    }"}
{"prompt": "Create a test that tests should Return Ok Status For Create Client Command", "completion": "     */\n    @Test\n    public void shouldReturnOkStatusForCreateClientCommand() {\n\n        final BatchRequest br = BatchHelper.createClientRequest(4712L, \"\");\n\n        final List<BatchResponse> response = BatchHelper.postWithSingleRequest(this.requestSpec, this.responseSpec, br);\n\n        // Verify that a 200 response is returned as the status code\n        for (BatchResponse resp : response) {\n            Assertions.assertEquals((long) 200, (long) resp.getStatusCode(), \"Verify Status code 200\");\n        }\n    }"}
{"prompt": "Create a test that tests should Roll Back All Transactions On Failure", "completion": "     * @see org.apache.fineract.batch.api.BatchApiResource\n     * @see org.apache.fineract.batch.service.BatchApiService\n     */\n    @Test\n    public void shouldRollBackAllTransactionsOnFailure() {\n\n        // Create first client request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4713L, \"TestExtId11\");\n\n        // Create second client request\n        final BatchRequest br2 = BatchHelper.createClientRequest(4714L, \"TestExtId12\");\n\n        // Create third client request, having same externalID as second client,\n        // hence cause of error\n        final BatchRequest br3 = BatchHelper.createClientRequest(4715L, \"TestExtId11\");\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        // Verifies that none of the client in BatchRequest is created on the\n        // server\n        BatchHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, \"TestExtId11\");\n        BatchHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, \"TestExtId12\");\n\n        // Asserts that all the transactions have been successfully rolled back\n        Assertions.assertEquals(1, response.size());\n        Assertions.assertEquals((long) 400, (long) response.get(0).getStatusCode(), \"Verify Status code 400\");\n    }"}
{"prompt": "Create a test that tests should Reflect Changes On Client Update", "completion": "     */\n    @Test\n    public void shouldReflectChangesOnClientUpdate() {\n\n        // Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4716L, \"\");\n\n        // Create a clientUpdate Request\n        final BatchRequest br2 = BatchHelper.updateClientRequest(4717L, 4716L);\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        // Get the changes parameter from updateClient Response\n        final JsonObject changes = new FromJsonHelper().parse(response.get(1).getBody()).getAsJsonObject().get(\"changes\").getAsJsonObject();\n\n        // Asserts the client information is successfully updated\n        Assertions.assertEquals(\"TestFirstName\", changes.get(\"firstname\").getAsString());\n        Assertions.assertEquals(\"TestLastName\", changes.get(\"lastname\").getAsString());\n    }"}
{"prompt": "Create a test that tests should Return Ok Status For Apply Loan Command", "completion": "     */\n    @Test\n    public void shouldReturnOkStatusForApplyLoanCommand() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"10000000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4718L, \"\");\n\n        // Create a activateClient Request\n        final BatchRequest br2 = BatchHelper.activateClientRequest(4719L, 4718L);\n\n        // Create a ApplyLoan Request\n        final BatchRequest br3 = BatchHelper.applyLoanRequest(4720L, 4719L, productId, clientCollateralId);\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        // Get the clientId parameter from createClient Response\n        final JsonElement clientId = new FromJsonHelper().parse(response.get(0).getBody()).getAsJsonObject().get(\"clientId\");\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(1).getStatusCode(),\n                \"Verify Status Code 200\" + clientId.getAsString());\n    }"}
{"prompt": "Create a test that tests should Return Ok Status For Apply Savings Command", "completion": "     */\n    @Test\n    public void shouldReturnOkStatusForApplySavingsCommand() {\n\n        final SavingsProductHelper savingsProductHelper = new SavingsProductHelper();\n        final String savingsProductJSON = savingsProductHelper //\n                .withInterestCompoundingPeriodTypeAsDaily() //\n                .withInterestPostingPeriodTypeAsMonthly() //\n                .withInterestCalculationPeriodTypeAsDailyBalance() //\n                .withMinimumOpenningBalance(\"5000\").build();\n\n        final Integer productId = SavingsProductHelper.createSavingsProduct(savingsProductJSON, this.requestSpec, this.responseSpec);\n\n        // Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4720L, \"\");\n\n        // Create a activateClient Request\n        final BatchRequest br2 = BatchHelper.activateClientRequest(4721L, 4720L);\n\n        // Create a applySavings Request\n        final BatchRequest br3 = BatchHelper.applySavingsRequest(4722L, 4721L, productId);\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(1).getStatusCode(), \"Verify Status Code 200\");\n    }"}
{"prompt": "Create a test that tests should Return Ok Status For Collect Charges Command", "completion": "     * @see org.apache.fineract.batch.command.internal.CreateChargeCommandStrategy\n     */\n    @Test\n    public void shouldReturnOkStatusForCollectChargesCommand() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"10000000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4722L, \"\");\n\n        // Create a activateClient Request\n        final BatchRequest br2 = BatchHelper.activateClientRequest(4723L, 4722L);\n\n        // Create a ApplyLoan Request\n        final BatchRequest br3 = BatchHelper.applyLoanRequest(4724L, 4723L, productId, clientCollateralId);\n\n        // Create a Collect Charges Request\n        final BatchRequest br4 = BatchHelper.collectChargesByLoanIdRequest(4725L, 4724L);\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n        batchRequests.add(br4);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(3).getStatusCode(), \"Verify Status Code 200 for Create Loan Charge\");\n    }"}
{"prompt": "Create a test that tests should Return Ok Status For Create And Get Charge By Id Command", "completion": "     * @see org.apache.fineract.batch.command.internal.CreateChargeCommandStrategy\n     */\n    @Test\n    public void shouldReturnOkStatusForCreateAndGetChargeByIdCommand() {\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"1000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = Long.valueOf(RandomStringUtils.randomNumeric(4));\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long createChargeRequestId = disburseLoanRequestId + 1;\n        final Long getChargeByIdRequestId = createChargeRequestId + 1;\n\n        // Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        // Create charge object and get id\n        final Integer chargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON());\n\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        final BatchRequest createChargeRequest = BatchHelper.createChargeByLoanIdRequest(createChargeRequestId, disburseLoanRequestId,\n                chargeId);\n\n        final BatchRequest getChargeByIdRequest = BatchHelper.getChargeByLoanIdChargeId(getChargeByIdRequestId, createChargeRequestId);\n\n        // Create batch requests list\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest,\n                createChargeRequest, getChargeByIdRequest);\n\n        // Create batch responses list\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for Create Charge\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(4).getStatusCode(), \"Verify Status Code 200 for Get Charge By Id\");\n    }"}
{"prompt": "Create a test that tests should Return Ok Status On Successful Charge Adjustment", "completion": "     */\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulChargeAdjustment() {\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"1000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = Long.valueOf(RandomStringUtils.randomNumeric(4));\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long createChargeRequestId = disburseLoanRequestId + 1;\n        final Long adjustChargeRequestId = createChargeRequestId + 1;\n        final Long getTransactionRequestId = adjustChargeRequestId + 1;\n\n        // Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        // Create charge object and get id\n        final Integer chargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON());\n\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        final BatchRequest createChargeRequest = BatchHelper.createChargeByLoanIdRequest(createChargeRequestId, disburseLoanRequestId,\n                chargeId);\n\n        final BatchRequest adjustChargeRequest = BatchHelper.adjustChargeRequest(adjustChargeRequestId, createChargeRequestId);\n\n        final BatchRequest getTransactionRequest = BatchHelper.getTransactionByIdRequest(getTransactionRequestId, adjustChargeRequestId,\n                true);\n\n        // Create batch requests list\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest,\n                createChargeRequest, adjustChargeRequest, getTransactionRequest);\n\n        // Create batch responses list\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for Create Charge\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(4).getStatusCode(), \"Verify Status Code 200 for Adjust Charge\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(5).getStatusCode(), \"Verify Status Code 200 for Get Transaction By Id\");\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final JsonObject chargeAdjustment = jsonHelper.parse(responses.get(5).getBody()).getAsJsonObject().get(\"type\").getAsJsonObject();\n\n        Assertions.assertEquals(\"Charge Adjustment\", chargeAdjustment.get(\"value\").getAsString());\n        Assertions.assertTrue(chargeAdjustment.get(\"chargeAdjustment\").getAsBoolean());\n    }"}
{"prompt": "Create a test that tests should Return Ok Status For Create And Get Charge By External Id Command", "completion": "     * @see org.apache.fineract.batch.command.internal.CreateChargeCommandStrategy\n     */\n    @Test\n    public void shouldReturnOkStatusForCreateAndGetChargeByExternalIdCommand() {\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"1000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = Long.valueOf(RandomStringUtils.randomNumeric(4));\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long getLoanRequestId = disburseLoanRequestId + 1;\n        final Long createChargeRequestId = getLoanRequestId + 1;\n        final Long collectChargesRequestId = createChargeRequestId + 1;\n        final Long adjustChargeRequestId = createChargeRequestId + 1;\n        final Long getTransactionByExternalIdRequestId = adjustChargeRequestId + 1;\n        final Long getChargeByIdRequestId = getTransactionByExternalIdRequestId + 1;\n\n        // Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        // Create charge object and get id\n        final Integer chargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON());\n\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        final BatchRequest approveLoanRequest = BatchHelper.transistionLoanStateByExternalId(approveLoanRequestId, applyLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(10), \"approve\");\n\n        final BatchRequest disburseLoanRequest = BatchHelper.transistionLoanStateByExternalId(disburseLoanRequestId, approveLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(8), \"disburse\");\n\n        final BatchRequest getLoanRequest = BatchHelper.getLoanByExternalIdRequest(getLoanRequestId, approveLoanRequestId,\n                \"associations=all\");\n\n        final BatchRequest createChargeRequest = BatchHelper.createChargeByLoanExternalIdRequest(createChargeRequestId, getLoanRequestId,\n                chargeId);\n\n        final BatchRequest collectChargesRequest = BatchHelper.collectChargesByLoanExternalIdRequest(collectChargesRequestId,\n                getLoanRequestId);\n\n        // Create batch requests list\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest, getLoanRequest,\n                createChargeRequest, collectChargesRequest);\n\n        // Create batch responses list\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for Get Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(4).getStatusCode(), \"Verify Status Code 200 for Create Charge\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(5).getStatusCode(), \"Verify Status Code 200 for Collect charges\");\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final String loanExternalId = jsonHelper.parse(responses.get(3).getBody()).getAsJsonObject().get(\"externalId\").getAsString();\n        final String chargeExternalId = jsonHelper.parse(responses.get(4).getBody()).getAsJsonObject().get(\"resourceExternalId\")\n                .getAsString();\n\n        final BatchRequest adjustChargeByExternalId = BatchHelper.adjustChargeByExternalIdRequest(adjustChargeRequestId, null,\n                loanExternalId, chargeExternalId);\n        final BatchRequest getTransactionByExternalIdRequest = BatchHelper\n                .getTransactionByExternalIdRequest(getTransactionByExternalIdRequestId, adjustChargeRequestId, loanExternalId, true);\n        final BatchRequest getChargeByIdRequest = BatchHelper.getChargeByLoanExternalIdChargeExternalId(getChargeByIdRequestId,\n                getTransactionByExternalIdRequestId, loanExternalId, chargeExternalId);\n\n        // Create batch responses list\n        final List<BatchResponse> adjustChargeAndGetResponses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec,\n                this.responseSpec,\n                BatchHelper.toJsonString(Arrays.asList(adjustChargeByExternalId, getTransactionByExternalIdRequest, getChargeByIdRequest)));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, adjustChargeAndGetResponses.get(0).getStatusCode(),\n                \"Verify Status Code 200 for Adjust Charge By External Id\");\n        Assertions.assertEquals(HttpStatus.SC_OK, adjustChargeAndGetResponses.get(1).getStatusCode(),\n                \"Verify Status Code 200 for Get Transaction By Id\");\n        Assertions.assertEquals(HttpStatus.SC_OK, adjustChargeAndGetResponses.get(2).getStatusCode(),\n                \"Verify Status Code 200 for Get Charge By Id\");\n\n        final JsonObject chargeAdjustment = jsonHelper.parse(adjustChargeAndGetResponses.get(1).getBody()).getAsJsonObject().get(\"type\")\n                .getAsJsonObject();\n\n        Assertions.assertEquals(\"Charge Adjustment\", chargeAdjustment.get(\"value\").getAsString());\n        Assertions.assertTrue(chargeAdjustment.get(\"chargeAdjustment\").getAsBoolean());\n    }"}
{"prompt": "Create a test that tests should Return Ok Status For Batch Repayment", "completion": "     */\n    @Test\n    public void shouldReturnOkStatusForBatchRepayment() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"10000000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4730L, \"\");\n\n        // Create a activateClient Request\n        final BatchRequest br2 = BatchHelper.activateClientRequest(4731L, 4730L);\n\n        // Create a ApplyLoan Request\n        final BatchRequest br3 = BatchHelper.applyLoanRequest(4732L, 4731L, productId, clientCollateralId);\n\n        // Create a approveLoan Request\n        final BatchRequest br4 = BatchHelper.approveLoanRequest(4733L, 4732L);\n\n        // Create a disburseLoan Request\n        final BatchRequest br5 = BatchHelper.disburseLoanRequest(4734L, 4733L);\n\n        // Create a loanRepay Request\n        final BatchRequest br6 = BatchHelper.repayLoanRequest(4735L, 4734L, \"500\");\n\n        // Create a loanRepay Request\n        final BatchRequest br7 = BatchHelper.repayLoanRequest(4736L, 4734L, \"500\");\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n        batchRequests.add(br4);\n        batchRequests.add(br5);\n        batchRequests.add(br6);\n        batchRequests.add(br7);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(5).getStatusCode(), \"Verify Status Code 200 for Repayment\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(6).getStatusCode(), \"Verify Status Code 200 for Repayment\");\n    }"}
{"prompt": "Create a test that tests should Return Ok Status For Batch Credit Balance Refund", "completion": "     */\n    @Test\n    public void shouldReturnOkStatusForBatchCreditBalanceRefund() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"1000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        final Long createActiveClientRequestId = 4730L;\n        final Long applyLoanRequestId = createActiveClientRequestId + 1;\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long repayLoanRequestId = disburseLoanRequestId + 1;\n        final Long creditBalanceRefundRequestId = repayLoanRequestId + 1;\n\n        // Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createActiveClientRequest(createActiveClientRequestId, \"\");\n\n        // Create a ApplyLoan Request\n        final BatchRequest br2 = BatchHelper.applyLoanRequest(applyLoanRequestId, createActiveClientRequestId, productId,\n                clientCollateralId);\n\n        // Create a approveLoan Request\n        final BatchRequest br3 = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        // Create a disburseLoan Request\n        final BatchRequest br4 = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        // Create a loanRepay Request which will result in an overpay.\n        final BatchRequest br5 = BatchHelper.repayLoanRequest(repayLoanRequestId, disburseLoanRequestId, \"20000\");\n\n        // Create a credit balance refund request\n        final BatchRequest br6 = BatchHelper.creditBalanceRefundRequest(creditBalanceRefundRequestId, repayLoanRequestId, \"500\");\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n        batchRequests.add(br4);\n        batchRequests.add(br5);\n        batchRequests.add(br6);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(4).getStatusCode(), \"Verify Status Code 200 for Repayment\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(5).getStatusCode(),\n                \"Verify Status Code 200 for Credit Balance Refund\");\n    }"}
{"prompt": "Create a test that tests partial Fail Test For Batch Request", "completion": "    @Test\n    public void partialFailTestForBatchRequest() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"1000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        final Long createActiveClientRequestId = 4730L;\n        final Long applyLoanRequestId = createActiveClientRequestId + 1;\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long fetchLoanInfoRequestId = disburseLoanRequestId + 1;\n\n        // Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createActiveClientRequest(createActiveClientRequestId, \"\");\n\n        // Create a ApplyLoan Request\n        final BatchRequest br2 = BatchHelper.applyLoanRequest(applyLoanRequestId, createActiveClientRequestId, productId,\n                clientCollateralId);\n\n        // Create a wrong approveLoan Request\n        final BatchRequest br3 = BatchHelper.approveLoanWrongRequest(approveLoanRequestId, applyLoanRequestId);\n\n        // Fetch loan info\n        final BatchRequest br4 = BatchHelper.getLoanByIdRequest(fetchLoanInfoRequestId, applyLoanRequestId, null);\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n        batchRequests.add(br4);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_NOT_IMPLEMENTED, (long) response.get(2).getStatusCode(), \"Resource doesn not exists\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(3).getStatusCode(),\n                \"Verify Status Code 200 for fetch data after the error\");\n    }"}
{"prompt": "Create a test that tests should Return Ok Status For Batch Goodwill Credit", "completion": "     */\n    @Test\n    public void shouldReturnOkStatusForBatchGoodwillCredit() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"1000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        final Long createActiveClientRequestId = 4730L;\n        final Long applyLoanRequestId = createActiveClientRequestId + 1;\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long goodwillCreditRequestId = disburseLoanRequestId + 1;\n\n        // Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createActiveClientRequest(createActiveClientRequestId, \"\");\n\n        // Create a ApplyLoan Request\n        final BatchRequest br2 = BatchHelper.applyLoanRequest(applyLoanRequestId, createActiveClientRequestId, productId,\n                clientCollateralId);\n\n        // Create a approveLoan Request\n        final BatchRequest br3 = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        // Create a disburseLoan Request\n        final BatchRequest br4 = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        // Create a good will credit request.\n        final BatchRequest br5 = BatchHelper.goodwillCreditRequest(goodwillCreditRequestId, disburseLoanRequestId, \"500\");\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n        batchRequests.add(br4);\n        batchRequests.add(br5);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(4).getStatusCode(), \"Verify Status Code 200 for Goodwill credit\");\n    }"}
{"prompt": "Create a test that tests should Return Ok Status On Successful Client Activation", "completion": "     */\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulClientActivation() {\n\n        // Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4726L, \"\");\n\n        // Create an activateClient Request\n        final BatchRequest br2 = BatchHelper.activateClientRequest(4727L, 4726L);\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(0).getStatusCode(), \"Verify Status Code 200 for Create Client\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(1).getStatusCode(), \"Verify Status Code 200 for Activate Client\");\n    }"}
{"prompt": "Create a test that tests should Return Ok Status On Successful Loan Approval And Disburse", "completion": "     * @see org.apache.fineract.batch.command.internal.DisburseLoanCommandStrategy\n     */\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulLoanApprovalAndDisburse() {\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"10000000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createClientRequest(4730L, \"\");\n\n        // Create a activateClient Request\n        final BatchRequest br2 = BatchHelper.activateClientRequest(4731L, 4730L);\n\n        // Create an ApplyLoan Request\n        final BatchRequest br3 = BatchHelper.applyLoanRequest(4732L, 4731L, productId, clientCollateralId);\n\n        // Create an approveLoan Request\n        final BatchRequest br4 = BatchHelper.approveLoanRequest(4733L, 4732L);\n\n        // Create an disburseLoan Request\n        final BatchRequest br5 = BatchHelper.disburseLoanRequest(4734L, 4733L);\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        batchRequests.add(br1);\n        batchRequests.add(br2);\n        batchRequests.add(br3);\n        batchRequests.add(br4);\n        batchRequests.add(br5);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(3).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(4).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n    }"}
{"prompt": "Create a test that tests should Return Ok Status On Successful Loan Approval And Disburse With Transaction", "completion": "     * @see org.apache.fineract.batch.command.internal.DisburseLoanCommandStrategy\n     */\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulLoanApprovalAndDisburseWithTransaction() {\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"10000000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create a createClient Request\n        final BatchRequest br1 = BatchHelper.createActiveClientRequest(4740L, \"\");\n\n        // Create an ApplyLoan Request\n        final BatchRequest br2 = BatchHelper.applyLoanRequest(4742L, 4740L, productId, clientCollateralId);\n\n        // Create an approveLoan Request\n        final BatchRequest br3 = BatchHelper.approveLoanRequest(4743L, 4742L);\n\n        // Create a disburseLoan Request\n        final BatchRequest br4 = BatchHelper.disburseLoanRequest(4744L, 4743L);\n\n        final List<BatchRequest> batchRequests = Arrays.asList(br1, br2, br3, br4);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(0).getStatusCode(), \"Verify Status Code 200 for create client\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(1).getStatusCode(), \"Verify Status Code 200 for apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(2).getStatusCode(), \"Verify Status Code 200 for approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(3).getStatusCode(), \"Verify Status Code 200 for disburse Loan\");\n    }"}
{"prompt": "Create a test that tests should Return Ok Status On Successful Disbursement And Get Transaction", "completion": "     * @see org.apache.fineract.batch.command.internal.GetTransactionByIdCommandStrategy\n     */\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulDisbursementAndGetTransaction() {\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"10000000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = 6730L;\n        final Long approveLoanRequestId = 6731L;\n        final Long disburseLoanRequestId = 6732L;\n        final Long getTransactionRequestId = 6733L;\n\n        // Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        // Create an ApplyLoan Request\n        final BatchRequest batchRequest1 = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        // Create an approveLoan Request\n        final BatchRequest batchRequest2 = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        // Create a disbursement Request\n        final BatchRequest batchRequest3 = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        // Create a getTransaction Request\n        final BatchRequest batchRequest4 = BatchHelper.getTransactionByIdRequest(getTransactionRequestId, disburseLoanRequestId, true);\n\n        final List<BatchRequest> batchRequests = Arrays.asList(batchRequest1, batchRequest2, batchRequest3, batchRequest4);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for Get Transaction By Id\");\n    }"}
{"prompt": "Create a test that tests should Return Ok Status On Successful Disbursement And Reschedule Loan", "completion": "     * @see org.apache.fineract.batch.command.internal.ApproveLoanRescheduleCommandStrategy\n     */\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulDisbursementAndRescheduleLoan() {\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"10000000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long createActiveClientRequestId = 8462L;\n        final Long applyLoanRequestId = createActiveClientRequestId + 1;\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long rescheduleLoanRequestId = disburseLoanRequestId + 1;\n        final Long approveRescheduleLoanRequestId = rescheduleLoanRequestId + 1;\n\n        // Create product\n        LOG.info(\"LoanProduct {}\", loanProductJSON);\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        /* Retrieve/Create Code Values for the Code \"LoanRescheduleReason = 23\" */\n        final HashMap<String, Object> codeValue = CodeHelper.retrieveOrCreateCodeValue(23, this.requestSpec, this.responseSpec);\n\n        final Integer codeValueId = (Integer) codeValue.get(\"id\");\n\n        // Create an ApplyLoan request\n        final BatchRequest applyLoanRequestWithClientId = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        // Create an approveLoan request\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        // Create a disbursement request\n        final LocalDate disburseLoanDate = LocalDate.now(ZoneId.systemDefault()).minusDays(1);\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId,\n                disburseLoanDate);\n\n        // Create a reschedule loan request\n        final BatchRequest rescheduleLoanRequest = BatchHelper.createRescheduleLoanRequest(rescheduleLoanRequestId, disburseLoanRequestId,\n                disburseLoanDate.plusMonths(1), codeValueId);\n\n        // Approve reschedule loan request\n        final BatchRequest approveRescheduleLoanRequest = BatchHelper.approveRescheduleLoanRequest(approveRescheduleLoanRequestId,\n                rescheduleLoanRequestId);\n\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequestWithClientId, approveLoanRequest, disburseLoanRequest,\n                rescheduleLoanRequest, approveRescheduleLoanRequest);\n\n        LOG.info(\"shouldReturnOkStatusOnSuccessfulDisbursementAndRescheduleLoan Request - {}\", BatchHelper.toJsonString(batchRequests));\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(),\n                \"Verify Status Code 200 for Create Reschedule Loan request\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(4).getStatusCode(),\n                \"Verify Status Code 200 for Approve Reschedule Loan request\");\n    }"}
{"prompt": "Create a test that tests should Return Ok Status On Successful Create Client Create Approve And Get Loan", "completion": "     * @see org.apache.fineract.batch.command.internal.ApplyLoanCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.ApproveLoanCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.GetLoanByIdCommandStrategy\n     */\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulCreateClientCreateApproveAndGetLoan() {\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"10000000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long createActiveClientRequestId = 4730L;\n        final Long applyLoanRequestId = 4731L;\n        final Long approveLoanRequestId = 4732L;\n        final Long getLoanByIdRequestId = 4733L;\n\n        // Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create createClient Request\n        final BatchRequest batchRequest1 = BatchHelper.createActiveClientRequest(createActiveClientRequestId, \"\");\n\n        // Create an ApplyLoan Request\n        final BatchRequest batchRequest2 = BatchHelper.applyLoanRequest(applyLoanRequestId, createActiveClientRequestId, productId, null);\n\n        // Create an approveLoan Request\n        final BatchRequest batchRequest3 = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        // Get loan by id Request\n        final BatchRequest batchRequest4 = BatchHelper.getLoanByIdRequest(getLoanByIdRequestId, applyLoanRequestId, null);\n\n        final List<BatchRequest> batchRequests = Arrays.asList(batchRequest1, batchRequest2, batchRequest3, batchRequest4);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Create Client\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for Get Loan By Id\");\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long loanId = jsonHelper.extractLongNamed(\"loanId\", jsonHelper.parse(responses.get(1).getBody()).getAsJsonObject());\n        final Long loanIdInGetResponse = jsonHelper.extractLongNamed(\"id\", jsonHelper.parse(responses.get(3).getBody()).getAsJsonObject());\n        final JsonObject statusInGetResponse = jsonHelper.parse(responses.get(3).getBody()).getAsJsonObject().get(\"status\")\n                .getAsJsonObject();\n\n        Assertions.assertEquals(loanId, loanIdInGetResponse);\n        Assertions.assertEquals(LoanStatus.APPROVED.getCode(), jsonHelper.extractStringNamed(\"code\", statusInGetResponse));\n        Assertions.assertEquals(\"Approved\", jsonHelper.extractStringNamed(\"value\", statusInGetResponse));\n    }"}
{"prompt": "Create a test that tests should Return Ok Status On Successful Create Approve And Get Loan", "completion": "     * @see org.apache.fineract.batch.command.internal.ApproveLoanCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.GetLoanByIdCommandStrategy\n     */\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulCreateApproveAndGetLoan() {\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"10000000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = 5730L;\n        final Long approveLoanRequestId = 5731L;\n        final Long getLoanByIdRequestId = 5732L;\n        final Long getLoanByIdWithQueryParametersRequestId = 5733L;\n\n        // Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        // Create an ApplyLoan Request\n        final BatchRequest batchRequest1 = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        // Create an approveLoan Request\n        final BatchRequest batchRequest2 = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        // Get loan by id Request without query param\n        final BatchRequest batchRequest3 = BatchHelper.getLoanByIdRequest(getLoanByIdRequestId, applyLoanRequestId, null);\n\n        // Get loan by id Request with query param\n        final BatchRequest batchRequest4 = BatchHelper.getLoanByIdRequest(getLoanByIdWithQueryParametersRequestId, applyLoanRequestId,\n                \"associations=repaymentSchedule,transactions\");\n\n        final List<BatchRequest> batchRequests = Arrays.asList(batchRequest1, batchRequest2, batchRequest3, batchRequest4);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(),\n                \"Verify Status Code 200 for Get Loan By Id without query parameter\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(),\n                \"Verify Status Code 200 for Get Loan By Id with query parameter\");\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long loanId = jsonHelper.extractLongNamed(\"loanId\", jsonHelper.parse(responses.get(0).getBody()).getAsJsonObject());\n        final Long loanIdInGetResponse = jsonHelper.extractLongNamed(\"id\", jsonHelper.parse(responses.get(2).getBody()).getAsJsonObject());\n        final JsonObject statusInGetResponse = jsonHelper.parse(responses.get(2).getBody()).getAsJsonObject().get(\"status\")\n                .getAsJsonObject();\n\n        Assertions.assertEquals(loanId, loanIdInGetResponse);\n        Assertions.assertEquals(LoanStatus.APPROVED.getCode(), jsonHelper.extractStringNamed(\"code\", statusInGetResponse));\n        Assertions.assertEquals(\"Approved\", jsonHelper.extractStringNamed(\"value\", statusInGetResponse));\n\n        // Repayment schedule will not be available in the response\n        Assertions.assertFalse(responses.get(2).getBody().contains(\"repaymentSchedule\"));\n\n        // Repayment schedule information will be available in the response based on the query parameter\n        Assertions.assertTrue(responses.get(3).getBody().contains(\"repaymentSchedule\"));\n    }"}
{"prompt": "Create a test that tests should Return Ok Status On Successful Get Data Table Entry", "completion": "     * @see org.apache.fineract.batch.command.internal.ApproveLoanCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.GetLoanByIdCommandStrategy\n     */\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulGetDataTableEntry() {\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long loanId = jsonHelper.extractLongNamed(\"loanId\", jsonHelper.parse(setupAccount()).getAsJsonObject());\n        final String datatableName = this.datatableHelper.createDatatable(LOAN_APP_TABLE_NAME, false);\n        try {\n\n            // Get loan by id Request with query param\n            final BatchRequest getLoanBatchRequest = BatchHelper.getLoanByIdRequest(loanId, \"associations=repaymentSchedule,transactions\");\n\n            // Get datatable batch request\n            final BatchRequest getDatatableBatchRequest = BatchHelper.getDatatableByIdRequest(loanId, datatableName,\n                    \"genericResultSet=true\", null);\n\n            final List<BatchRequest> batchRequestsGetLoan = Arrays.asList(getLoanBatchRequest, getDatatableBatchRequest);\n\n            final List<BatchResponse> responsesGetLoan = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec,\n                    this.responseSpec, BatchHelper.toJsonString(batchRequestsGetLoan));\n\n            final String getLoanResponse = responsesGetLoan.get(0).getBody();\n            final String getDatatableResponse = responsesGetLoan.get(1).getBody();\n\n            Assertions.assertEquals(HttpStatus.SC_OK, responsesGetLoan.get(0).getStatusCode(), \"Verify Status Code 200 for get loan\");\n            Assertions.assertEquals(HttpStatus.SC_OK, responsesGetLoan.get(1).getStatusCode(), \"Verify Status Code 200 for datatable\");\n\n            final Long loanIdInGetResponse = jsonHelper.extractLongNamed(\"id\", jsonHelper.parse(getLoanResponse).getAsJsonObject());\n            Assertions.assertEquals(loanId, loanIdInGetResponse);\n\n            // Repayment schedule information will be available in the response based on the query parameter\n            Assertions.assertTrue(getLoanResponse.contains(\"repaymentSchedule\"));\n\n            // Transaction will be available in the response based on the query parameter\n            Assertions.assertTrue(getLoanResponse.contains(\"transactions\"));\n\n            // datatable info will be available in the response based on the query parameter\n            Assertions.assertTrue(getDatatableResponse.contains(\"columnHeaders\"));\n\n            // datatable info will be available in the response based on the query parameter\n            Assertions.assertTrue(getDatatableResponse.contains(\"data\"));\n        } finally {\n            deleteDatatable(datatableName);\n        }\n    }"}
{"prompt": "Create a test that tests should Return Ok Status On Successful Create Data Table Entry", "completion": "     * @see org.apache.fineract.batch.command.internal.UpdateDatatableEntryOneToManyCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.GetDatatableEntryByAppTableIdCommandStrategy\n     * @see GetDatatableEntryByAppTableIdAndDataTableIdCommandStrategy\n     */\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulCreateDataTableEntry() {\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long loanId = jsonHelper.extractLongNamed(\"loanId\", jsonHelper.parse(setupAccount()).getAsJsonObject());\n        // creating datatable with m_loan association\n        final Map<String, Object> columnMap = new HashMap<>();\n        final List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n        final String datatableName = Utils.uniqueRandomStringGenerator(LOAN_APP_TABLE_NAME + \"_\", 5);\n        final String columnName1 = Utils.randomStringGenerator(\"COL1_\", 5);\n        final String columnName2 = Utils.randomStringGenerator(\"COL2_\", 5);\n        columnMap.put(\"datatableName\", datatableName);\n        columnMap.put(\"apptableName\", LOAN_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"PERSON\");\n        columnMap.put(\"multiRow\", true);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, columnName1, \"String\", true, 10, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, columnName2, \"String\", false, 10, null);\n        columnMap.put(\"columns\", datatableColumnsList);\n        final String datatableRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"CreateDataTable map : {}\", datatableRequestJsonString);\n\n        this.datatableHelper.createDatatable(datatableRequestJsonString, \"\");\n\n        // Create a datatable entry so that it can be updated using BatchApi\n        final Map<String, Object> datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(columnName1, Utils.randomStringGenerator(\"VAL1_\", 3));\n        datatableEntryMap.put(columnName2, Utils.randomStringGenerator(\"VAL2_\", 3));\n        final String datatableEntryRequestJsonString = new Gson().toJson(datatableEntryMap);\n        LOG.info(\"CreateDataTableEntry map : {}\", datatableEntryRequestJsonString);\n\n        final Map<String, Object> datatableEntryResponse = this.datatableHelper.createDatatableEntry(datatableName, loanId.intValue(),\n                false, datatableEntryRequestJsonString);\n        final Integer datatableEntryResourceId = (Integer) datatableEntryResponse.get(\"resourceId\");\n        assertNotNull(datatableEntryResourceId, \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n\n        // Create datatable entry batch request\n        final BatchRequest createDatatableEntryRequest = BatchHelper.createDatatableEntryRequest(loanId, datatableName,\n                Arrays.asList(columnName1, columnName2));\n\n        // Update datatable entry batch request\n        final BatchRequest updateDatatableEntryByEntryIdRequest = BatchHelper.updateDatatableEntryByEntryIdRequest(loanId, datatableName,\n                Long.valueOf(datatableEntryResourceId), Arrays.asList(columnName1));\n\n        // Get datatable entries batch request\n        final BatchRequest getDatatableEntriesRequest = BatchHelper.getDatatableByIdRequest(loanId, datatableName, null,\n                updateDatatableEntryByEntryIdRequest.getReference());\n\n        // Get datatable entry by app table id batch request\n        final BatchRequest getDatatableEntryByIdRequest = BatchHelper.getDatatableEntryByIdRequest(loanId, datatableName, \"$.resourceId\",\n                null, updateDatatableEntryByEntryIdRequest.getReference());\n\n        final List<BatchRequest> batchRequestsDatatableEntries = Arrays.asList(createDatatableEntryRequest,\n                updateDatatableEntryByEntryIdRequest, getDatatableEntriesRequest, getDatatableEntryByIdRequest);\n        LOG.info(\"Batch Request : {}\", BatchHelper.toJsonString(batchRequestsDatatableEntries));\n\n        final List<BatchResponse> responseDatatableBatch = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec,\n                this.responseSpec, BatchHelper.toJsonString(batchRequestsDatatableEntries));\n\n        LOG.info(\"Batch Response : {}\", new Gson().toJson(responseDatatableBatch));\n\n        final BatchResponse batchResponse1 = responseDatatableBatch.get(0);\n        final BatchResponse batchResponse2 = responseDatatableBatch.get(1);\n        final BatchResponse batchResponse3 = responseDatatableBatch.get(2);\n        final BatchResponse batchResponse4 = responseDatatableBatch.get(3);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, batchResponse1.getStatusCode(), \"Verify Status Code 200 for create datatable entry\");\n        Assertions.assertEquals(HttpStatus.SC_OK, batchResponse2.getStatusCode(), \"Verify Status Code 200 for update datatable entry\");\n        Assertions.assertEquals(HttpStatus.SC_OK, batchResponse3.getStatusCode(), \"Verify Status Code 200 for get datatable entries\");\n        Assertions.assertEquals(HttpStatus.SC_OK, batchResponse4.getStatusCode(), \"Verify Status Code 200 for get datatable entry by id\");\n\n        final String getDatatableEntriesResponse = batchResponse3.getBody();\n\n        final Long createDatatableEntryId = jsonHelper.extractLongNamed(\"resourceId\",\n                jsonHelper.parse(batchResponse1.getBody()).getAsJsonObject());\n\n        final JsonArray datatableEntries = jsonHelper.parse(getDatatableEntriesResponse).getAsJsonArray();\n        Assertions.assertEquals(2, datatableEntries.size());\n\n        // Ensure both resourceIds are available in response\n        Assertions.assertTrue(getDatatableEntriesResponse.contains(String.format(\"\\\"id\\\": %d\", createDatatableEntryId)));\n        Assertions.assertTrue(getDatatableEntriesResponse.contains(String.format(\"\\\"id\\\": %d\", datatableEntryResourceId)));\n    }"}
{"prompt": "Create a test that tests should Return Ok Status On Successful Get Datatable Entry With No Query Param", "completion": "     * @see org.apache.fineract.batch.command.internal.ApproveLoanCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.GetLoanByIdCommandStrategy\n     */\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulGetDatatableEntryWithNoQueryParam() {\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long loanId = jsonHelper.extractLongNamed(\"loanId\", jsonHelper.parse(setupAccount()).getAsJsonObject());\n        final String datatableName = this.datatableHelper.createDatatable(LOAN_APP_TABLE_NAME, false);\n        try {\n            // Get loan by id Request with query param\n            final BatchRequest getLoanBatchRequest = BatchHelper.getLoanByIdRequest(loanId, \"associations=repaymentSchedule,transactions\");\n\n            // Get datatable batch request\n            final BatchRequest getDatatableBatchRequest = BatchHelper.getDatatableByIdRequest(loanId, datatableName, null, null);\n\n            final List<BatchRequest> batchRequestsGetLoan = Arrays.asList(getLoanBatchRequest, getDatatableBatchRequest);\n\n            final List<BatchResponse> responsesGetLoan = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec,\n                    this.responseSpec, BatchHelper.toJsonString(batchRequestsGetLoan));\n\n            final String getLoanResponse = responsesGetLoan.get(0).getBody();\n\n            Assertions.assertEquals(HttpStatus.SC_OK, responsesGetLoan.get(0).getStatusCode(), \"Verify Status Code 200 for Get Loan\");\n            Assertions.assertEquals(HttpStatus.SC_OK, responsesGetLoan.get(1).getStatusCode(), \"Verify Status Code 200 for Get Datatable\");\n\n            final Long loanIdInGetResponse = jsonHelper.extractLongNamed(\"id\", jsonHelper.parse(getLoanResponse).getAsJsonObject());\n            Assertions.assertEquals(loanId, loanIdInGetResponse);\n\n            Assertions.assertTrue(getLoanResponse.contains(\"repaymentSchedule\"));\n\n            Assertions.assertTrue(getLoanResponse.contains(\"transactions\"));\n        } finally {\n            deleteDatatable(datatableName);\n        }\n\n    }"}
{"prompt": "Create a test that tests should Return Ok Status On Successful Transaction Merchant Issued And Payout Refund", "completion": "     * @see org.apache.fineract.batch.command.internal.ApproveLoanCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.DisburseLoanCommandStrategy\n     * @see org.apache.fineract.batch.command.internal.CreateTransactionLoanCommandStrategy\n     */\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulTransactionMerchantIssuedAndPayoutRefund() {\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"10000000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = 5730L;\n        final Long approveLoanRequestId = 5731L;\n        final Long disburseLoanRequestId = 5732L;\n        final Long merchantIssuedRefundRequestId = 5733L;\n        final Long payoutRefundRequestId = 5734L;\n\n        // Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        // Create an ApplyLoan Request\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        // Create an approveLoan Request\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        // Create a disbursement request\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(1));\n\n        // Create a merchant issued refund request\n        final BatchRequest merchantIssuedRefundRequest = BatchHelper.merchantIssuedRefundRequest(merchantIssuedRefundRequestId,\n                applyLoanRequestId, \"10\");\n\n        // Create a payout refund request\n        final BatchRequest payoutRefundRequest = BatchHelper.payoutRefundRequest(payoutRefundRequestId, applyLoanRequestId, \"10\");\n\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest,\n                merchantIssuedRefundRequest, payoutRefundRequest);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for merchant issued refund\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(4).getStatusCode(), \"Verify Status Code 200 for payout refund\");\n    }"}
{"prompt": "Create a test that tests should Return Ok Status For Batch Repayment Reversal", "completion": "     */\n    @Test\n    public void shouldReturnOkStatusForBatchRepaymentReversal() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"10000000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        final LocalDate date = LocalDate.now(Utils.getZoneIdOfTenant());\n        final Long applyLoanRequestId = 5730L;\n        final Long approveLoanRequestId = 5731L;\n        final Long disburseLoanRequestId = 5732L;\n        final Long repayLoanRequestId = 5733L;\n        final Long repayReversalRequestId = 5734L;\n        final Long getLoanRequestId = 5735L;\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        // Create an apply loan request\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        // Create an approve loan request\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        // Create a disburse loan request\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        // Create a repayment request.\n        final BatchRequest repaymentRequest = BatchHelper.repayLoanRequest(repayLoanRequestId, disburseLoanRequestId, \"500\");\n\n        // Create a repayment reversal request\n        final BatchRequest repaymentReversalRequest = BatchHelper.createAdjustTransactionRequest(repayReversalRequestId, repayLoanRequestId,\n                \"0\", date);\n\n        // Get loan transactions request\n        final BatchRequest getLoanTransactionsRequest = BatchHelper.getLoanByIdRequest(getLoanRequestId, applyLoanRequestId,\n                \"associations=transactions\");\n\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest, repaymentRequest,\n                repaymentReversalRequest, getLoanTransactionsRequest);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final JsonObject repayment = jsonHelper.parse(responses.get(5).getBody()).getAsJsonObject().get(\"transactions\").getAsJsonArray()\n                .get(2).getAsJsonObject();\n        final JsonArray dateArray = repayment.get(\"reversedOnDate\").getAsJsonArray();\n        final LocalDate reversedOnDate = LocalDate.of(dateArray.get(0).getAsInt(), dateArray.get(1).getAsInt(),\n                dateArray.get(2).getAsInt());\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) responses.get(4).getStatusCode(), \"Verify Status Code 200 for repayment reversal\");\n        Assertions.assertEquals(\"Repayment\", repayment.get(\"type\").getAsJsonObject().get(\"value\").getAsString());\n        Assertions.assertTrue(repayment.get(\"manuallyReversed\").getAsBoolean());\n        Assertions.assertEquals(date, reversedOnDate);\n    }"}
{"prompt": "Create a test that tests should Return Ok Status For Batch Repayment Reversal Using External Id", "completion": "     */\n    @Test\n    public void shouldReturnOkStatusForBatchRepaymentReversalUsingExternalId() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"10000000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        final LocalDate date = LocalDate.now(Utils.getZoneIdOfTenant());\n        final Long applyLoanRequestId = Long.valueOf(RandomStringUtils.randomNumeric(4));\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long getLoanBeforeTxnRequestId = disburseLoanRequestId + 1;\n        final Long repayLoanRequestId = getLoanBeforeTxnRequestId + 1;\n        final Long getLoanAfterTxnRequestId = repayLoanRequestId + 1;\n        final Long repayReversalRequestId = getLoanAfterTxnRequestId + 1;\n        final Long getLoanAfterReversal = repayReversalRequestId + 1;\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n        final String loanExternalId = UUID.randomUUID().toString();\n\n        // Create an apply loan request\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientIdAndExternalId(applyLoanRequestId, clientId, productId,\n                loanExternalId);\n\n        // Create an approve loan request\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        // Create a disburse loan request\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        // Get loan transactions request\n        final BatchRequest getLoanTransactionsRequestBeforeTxn = BatchHelper.getLoanByIdRequest(getLoanBeforeTxnRequestId,\n                disburseLoanRequestId, \"associations=transactions\");\n\n        // Create a repayment request by external id\n        final BatchRequest repaymentRequest = BatchHelper.createTransactionRequestByLoanExternalId(repayLoanRequestId,\n                getLoanBeforeTxnRequestId, \"repayment\", \"500\", LocalDate.now(ZoneId.systemDefault()));\n\n        // Get loan transactions request\n        final BatchRequest getLoanTransactionsRequestAfterTxn = BatchHelper.getLoanByIdRequest(getLoanAfterTxnRequestId, repayLoanRequestId,\n                \"associations=transactions\");\n\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest,\n                getLoanTransactionsRequestBeforeTxn, repaymentRequest, getLoanTransactionsRequestAfterTxn);\n\n        // Because loanExternalId & transactionExternalId are coming from 2 different responses, there is no easy way to\n        // use them as reference in 1 batch api call.\n        // So we are splitting repayment & reversal into 2 different batch api invocations\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final String loanExternalIdDisburseLoanResponse = jsonHelper.parse(responses.get(3).getBody()).getAsJsonObject().get(\"externalId\")\n                .getAsString();\n        final Long loanId = jsonHelper.parse(responses.get(3).getBody()).getAsJsonObject().get(\"id\").getAsLong();\n        final String transactionExternalId = jsonHelper.parse(responses.get(4).getBody()).getAsJsonObject().get(\"resourceExternalId\")\n                .getAsString();\n        Assertions.assertNotNull(loanExternalIdDisburseLoanResponse);\n        Assertions.assertEquals(loanExternalId, loanExternalIdDisburseLoanResponse);\n        Assertions.assertNotNull(transactionExternalId);\n\n        // Create a repayment reversal request by external id\n        final BatchRequest repaymentReversalRequest = BatchHelper.createAdjustTransactionByExternalIdRequest(repayReversalRequestId, null,\n                loanExternalIdDisburseLoanResponse, transactionExternalId, \"0\", date);\n\n        final BatchRequest getLoanByIdWithTransactions = BatchHelper.getLoanByIdRequest(loanId, getLoanAfterReversal,\n                repayReversalRequestId, \"associations=transactions\");\n\n        final List<BatchRequest> reversalAndGetBatchRequest = Arrays.asList(repaymentReversalRequest, getLoanByIdWithTransactions);\n\n        final List<BatchResponse> reversalResponses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec,\n                this.responseSpec, BatchHelper.toJsonString(reversalAndGetBatchRequest));\n\n        final JsonObject repayment = jsonHelper.parse(reversalResponses.get(1).getBody()).getAsJsonObject().get(\"transactions\")\n                .getAsJsonArray().get(2).getAsJsonObject();\n\n        final JsonArray dateArray = repayment.get(\"reversedOnDate\").getAsJsonArray();\n        final LocalDate reversedOnDate = LocalDate.of(dateArray.get(0).getAsInt(), dateArray.get(1).getAsInt(),\n                dateArray.get(2).getAsInt());\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) reversalResponses.get(0).getStatusCode(),\n                \"Verify Status Code 200 for repayment reversal\");\n        Assertions.assertEquals(\"Repayment\", repayment.get(\"type\").getAsJsonObject().get(\"value\").getAsString());\n\n        Assertions.assertTrue(repayment.get(\"manuallyReversed\").getAsBoolean());\n        Assertions.assertEquals(date, reversedOnDate);\n    }"}
{"prompt": "Create a test that tests should Return Ok Status For Batch Repayment Chargeback", "completion": "     */\n    @Test\n    public void shouldReturnOkStatusForBatchRepaymentChargeback() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"10000000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        final Long applyLoanRequestId = 5730L;\n        final Long approveLoanRequestId = 5731L;\n        final Long disburseLoanRequestId = 5732L;\n        final Long repayLoanRequestId = 5733L;\n        final Long repayReversalRequestId = 5734L;\n        final Long getLoanRequestId = 5735L;\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        // Create an apply loan request\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        // Create an approve loan request\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        // Create a disburse loan request\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        // Create a repayment request\n        final BatchRequest repaymentRequest = BatchHelper.repayLoanRequest(repayLoanRequestId, disburseLoanRequestId, \"500\");\n\n        // Create a repayment chargeback request\n        final BatchRequest repaymentChargebackRequest = BatchHelper.createChargebackTransactionRequest(repayReversalRequestId,\n                repayLoanRequestId, \"500\");\n\n        // Get loan transactions request\n        final BatchRequest getLoanTransactionsRequest = BatchHelper.getLoanByIdRequest(getLoanRequestId, applyLoanRequestId,\n                \"associations=transactions\");\n\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest, repaymentRequest,\n                repaymentChargebackRequest, getLoanTransactionsRequest);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final JsonObject repayment = jsonHelper.parse(responses.get(5).getBody()).getAsJsonObject().get(\"transactions\").getAsJsonArray()\n                .get(2).getAsJsonObject();\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) responses.get(4).getStatusCode(),\n                \"Verify Status Code 200 for repayment chargeback\");\n        Assertions.assertEquals(\"Repayment\", repayment.get(\"type\").getAsJsonObject().get(\"value\").getAsString());\n        final JsonArray transactionRelations = repayment.get(\"transactionRelations\").getAsJsonArray();\n        Assertions.assertEquals(1, transactionRelations.size());\n        Assertions.assertEquals(\"CHARGEBACK\", transactionRelations.get(0).getAsJsonObject().get(\"relationType\").getAsString());\n    }"}
{"prompt": "Create a test that tests should Return Ok Status For Batch Goodwill Credit Reversal", "completion": "     */\n    @Test\n    public void shouldReturnOkStatusForBatchGoodwillCreditReversal() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"1000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        final LocalDate date = LocalDate.now(Utils.getZoneIdOfTenant());\n        final Long applyLoanRequestId = 5730L;\n        final Long approveLoanRequestId = 5731L;\n        final Long disburseLoanRequestId = 5732L;\n        final Long goodwillCreditRequestId = 5733L;\n        final Long goodwillCreditReversalRequestId = 5734L;\n        final Long getLoanRequestId = 5735L;\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        // Create an apply loan request\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        // Create an approve loan request\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        // Create a disburse loan request\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        // Create a good will credit request\n        final BatchRequest goodwillCreditRequest = BatchHelper.goodwillCreditRequest(goodwillCreditRequestId, disburseLoanRequestId, \"500\");\n\n        // Create a good will credit reversal request\n        final BatchRequest goodwillCreditReversalRequest = BatchHelper.createAdjustTransactionRequest(goodwillCreditReversalRequestId,\n                goodwillCreditRequestId, \"0\", date);\n\n        // Get loan transactions request\n        final BatchRequest getLoanTransactionsRequest = BatchHelper.getLoanByIdRequest(getLoanRequestId, applyLoanRequestId,\n                \"associations=transactions\");\n\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest,\n                goodwillCreditRequest, goodwillCreditReversalRequest, getLoanTransactionsRequest);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final JsonObject goodWillCredit = jsonHelper.parse(responses.get(5).getBody()).getAsJsonObject().get(\"transactions\")\n                .getAsJsonArray().get(2).getAsJsonObject();\n        final JsonArray dateArray = goodWillCredit.get(\"reversedOnDate\").getAsJsonArray();\n        final LocalDate reversedOnDate = LocalDate.of(dateArray.get(0).getAsInt(), dateArray.get(1).getAsInt(),\n                dateArray.get(2).getAsInt());\n\n        Assertions.assertEquals(HttpStatus.SC_OK, (long) responses.get(4).getStatusCode(),\n                \"Verify Status Code 200 for goodwill credit reversal\");\n        Assertions.assertEquals(\"Goodwill Credit\", goodWillCredit.get(\"type\").getAsJsonObject().get(\"value\").getAsString());\n        Assertions.assertTrue(goodWillCredit.get(\"manuallyReversed\").getAsBoolean());\n        Assertions.assertEquals(date, reversedOnDate);\n    }"}
{"prompt": "Create a test that tests should Return Ok Status On Successful Transaction Merchant Issued And Payout Refund Reversal", "completion": "     */\n    @Test\n    public void shouldReturnOkStatusOnSuccessfulTransactionMerchantIssuedAndPayoutRefundReversal() {\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"10000000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final LocalDate date = LocalDate.now(Utils.getZoneIdOfTenant());\n        final Long applyLoanRequestId = 5730L;\n        final Long approveLoanRequestId = 5731L;\n        final Long disburseLoanRequestId = 5732L;\n        final Long merchantIssuedRefundRequestId = 5733L;\n        final Long payoutRefundRequestId = 5734L;\n        final Long merchantIssuedRefundReversalRequestId = 5735L;\n        final Long payoutRefundReversalRequestId = 5736L;\n        final Long getLoanRequestId = 5737L;\n\n        // Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        // Create an apply loan request\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        // Create an approve loan request\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        // Create a disburse loan request\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId,\n                date.minusDays(1));\n\n        // Create a merchant issued refund request\n        final BatchRequest merchantIssuedRefundRequest = BatchHelper.merchantIssuedRefundRequest(merchantIssuedRefundRequestId,\n                applyLoanRequestId, \"10\");\n\n        // Create a payout refund request\n        final BatchRequest payoutRefundRequest = BatchHelper.payoutRefundRequest(payoutRefundRequestId, applyLoanRequestId, \"10\");\n\n        // Create a merchant issued refund reversal request\n        final BatchRequest merchantIssuedRefundReversalRequest = BatchHelper\n                .createAdjustTransactionRequest(merchantIssuedRefundReversalRequestId, merchantIssuedRefundRequestId, \"0\", date);\n\n        // Create a payout refund reversal request\n        final BatchRequest payoutRefundReversalRequest = BatchHelper.createAdjustTransactionRequest(payoutRefundReversalRequestId,\n                payoutRefundRequestId, \"0\", date);\n\n        // Get loan transactions request\n        final BatchRequest getLoanTransactionsRequest = BatchHelper.getLoanByIdRequest(getLoanRequestId, applyLoanRequestId,\n                \"associations=transactions\");\n\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest,\n                merchantIssuedRefundRequest, payoutRefundRequest, merchantIssuedRefundReversalRequest, payoutRefundReversalRequest,\n                getLoanTransactionsRequest);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests));\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final JsonObject merchantIssuedRefund = jsonHelper.parse(responses.get(7).getBody()).getAsJsonObject().get(\"transactions\")\n                .getAsJsonArray().get(2).getAsJsonObject();\n        final JsonObject payoutRefund = jsonHelper.parse(responses.get(7).getBody()).getAsJsonObject().get(\"transactions\").getAsJsonArray()\n                .get(3).getAsJsonObject();\n        final JsonArray merchantIssuedDateArray = merchantIssuedRefund.get(\"reversedOnDate\").getAsJsonArray();\n        final LocalDate merchantIssuedDate = LocalDate.of(merchantIssuedDateArray.get(0).getAsInt(),\n                merchantIssuedDateArray.get(1).getAsInt(), merchantIssuedDateArray.get(2).getAsInt());\n        final JsonArray payoutRefundDateArray = payoutRefund.getAsJsonObject().get(\"reversedOnDate\").getAsJsonArray();\n        final LocalDate payoutRefundDate = LocalDate.of(payoutRefundDateArray.get(0).getAsInt(), payoutRefundDateArray.get(1).getAsInt(),\n                payoutRefundDateArray.get(2).getAsInt());\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(5).getStatusCode(),\n                \"Verify Status Code 200 for merchant issued refund reversal\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(6).getStatusCode(), \"Verify Status Code 200 for payout refund reversal\");\n        Assertions.assertEquals(\"Merchant Issued Refund\", merchantIssuedRefund.get(\"type\").getAsJsonObject().get(\"value\").getAsString());\n        Assertions.assertEquals(\"Payout Refund\", payoutRefund.get(\"type\").getAsJsonObject().get(\"value\").getAsString());\n        Assertions.assertTrue(merchantIssuedRefund.get(\"manuallyReversed\").getAsBoolean());\n        Assertions.assertTrue(payoutRefund.get(\"manuallyReversed\").getAsBoolean());\n        Assertions.assertEquals(date, merchantIssuedDate);\n        Assertions.assertEquals(date, payoutRefundDate);\n    }"}
{"prompt": "Create a test that tests should Return Ok Status On Modifying Saving Account", "completion": "    @Test\n    public void shouldReturnOkStatusOnModifyingSavingAccount() {\n        final String startDate = \"10 April 2022\";\n        final SavingsProductHelper savingsProductHelper = new SavingsProductHelper();\n        final SavingsAccountHelper savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n        final String savingsProductJSON = savingsProductHelper.withInterestCompoundingPeriodTypeAsDaily()\n                .withInterestPostingPeriodTypeAsDaily().withInterestCalculationPeriodTypeAsDailyBalance().build();\n        final Integer savingsProductID = SavingsProductHelper.createSavingsProduct(savingsProductJSON, requestSpec, responseSpec);\n        Assertions.assertNotNull(savingsProductID);\n        final Integer savingsId = savingsAccountHelper.applyForSavingsApplicationOnDate(clientID, savingsProductID, \"INDIVIDUAL\",\n                startDate);\n        Assertions.assertNotNull(savingsId);\n        HashMap savingsStatusHashMap = savingsAccountHelper.approveSavingsOnDate(savingsId, startDate);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n        savingsStatusHashMap = savingsAccountHelper.activateSavingsAccount(savingsId, startDate);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final BatchRequest getSavingAccountRequest = BatchHelper.getSavingAccount(1L, Long.valueOf(savingsId), \"chargeStatus=all\", null);\n        final BatchRequest depositSavingAccountRequest = BatchHelper.depositSavingAccount(2L, 1L);\n        final BatchRequest holdAmountOnSavingAccountRequest = BatchHelper.holdAmountOnSavingAccount(3L, 1L);\n\n        final List<BatchRequest> batchRequests1 = Arrays.asList(getSavingAccountRequest, depositSavingAccountRequest,\n                holdAmountOnSavingAccountRequest);\n        final List<BatchResponse> responses1 = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests1));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses1.get(1).getStatusCode(), \"Verify Status Code 200 for deposit saving account\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses1.get(2).getStatusCode(),\n                \"Verify Status Code 200 for hold amount on saving account\");\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long holdAmountTransactionId = jsonHelper.parse(responses1.get(2).getBody()).getAsJsonObject().get(\"resourceId\").getAsLong();\n\n        final BatchRequest releaseAmountOnSavingAccountRequest = BatchHelper.releaseAmountOnSavingAccount(2L, 1L, holdAmountTransactionId);\n        final BatchRequest withdrawSavingAccountRequest = BatchHelper.withdrawSavingAccount(3L, 1L);\n\n        final List<BatchRequest> batchRequests2 = Arrays.asList(getSavingAccountRequest, releaseAmountOnSavingAccountRequest,\n                withdrawSavingAccountRequest);\n        final List<BatchResponse> responses2 = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec, this.responseSpec,\n                BatchHelper.toJsonString(batchRequests2));\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses2.get(1).getStatusCode(),\n                \"Verify Status Code 200 for release amount on saving account\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses2.get(2).getStatusCode(), \"Verify Status Code 200 for withdraw saving account\");\n    }"}
{"prompt": "Create a test that tests should Find One To One Datatable Entry By Query APIAnd Update One Of Its Column", "completion": "    @Test\n    public void shouldFindOneToOneDatatableEntryByQueryAPIAndUpdateOneOfItsColumn() {\n        final String datatableName = Utils.uniqueRandomStringGenerator(LOAN_APP_TABLE_NAME + \"_\", 5).toLowerCase();\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long loanId = jsonHelper.extractLongNamed(\"loanId\", jsonHelper.parse(setupAccount()).getAsJsonObject());\n        // creating datatable with m_loan association\n        final Map<String, Object> columnMap = new HashMap<>();\n        final List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n\n        final String columnName1 = Utils.randomStringGenerator(\"COL1_\", 5).toLowerCase();\n        final String columnName2 = Utils.randomStringGenerator(\"COL2_\", 5).toLowerCase();\n        columnMap.put(\"datatableName\", datatableName);\n        columnMap.put(\"apptableName\", LOAN_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"PERSON\");\n        columnMap.put(\"multiRow\", false);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, columnName1, \"String\", true, 10, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, columnName2, \"String\", false, 10, null);\n        columnMap.put(\"columns\", datatableColumnsList);\n        final String datatableRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"CreateDataTable map : {}\", datatableRequestJsonString);\n\n        this.datatableHelper.createDatatable(datatableRequestJsonString, \"\");\n\n        // Create a datatable entry so that it can be updated using BatchApi\n        final Map<String, Object> datatableEntryMap = new HashMap<>();\n        String columnValue1 = Utils.randomStringGenerator(\"VAL1_\", 3);\n        String columnValue2 = Utils.randomStringGenerator(\"VAL2_\", 3);\n        datatableEntryMap.put(columnName1, columnValue1);\n        datatableEntryMap.put(columnName2, columnValue2);\n        final String datatableEntryRequestJsonString = new Gson().toJson(datatableEntryMap);\n        LOG.info(\"CreateDataTableEntry map : {}\", datatableEntryRequestJsonString);\n\n        final Map<String, Object> datatableEntryResponse = this.datatableHelper.createDatatableEntry(datatableName, loanId.intValue(),\n                false, datatableEntryRequestJsonString);\n        final Integer datatableEntryResourceId = (Integer) datatableEntryResponse.get(\"resourceId\");\n        assertNotNull(datatableEntryResourceId, \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n\n        final BatchRequest queryDatatableEntriesRequest = BatchHelper.queryDatatableEntries(datatableName, columnName1, columnValue1,\n                \"loan_id\");\n        final BatchRequest updateDatatableEntry = BatchHelper.updateDatatableEntry(datatableName, \"$.[0].loan_id\", columnName2,\n                columnValue2 + \"1\");\n\n        final List<BatchRequest> batchRequestsToQueryAndUpdateDatatableEntries = Arrays.asList(queryDatatableEntriesRequest,\n                updateDatatableEntry);\n        LOG.info(\"Batch Request : {}\", BatchHelper.toJsonString(batchRequestsToQueryAndUpdateDatatableEntries));\n\n        final List<BatchResponse> responseOfQuertAndUpdateDatatableBatch = BatchHelper.postBatchRequestsWithEnclosingTransaction(\n                this.requestSpec, this.responseSpec, BatchHelper.toJsonString(batchRequestsToQueryAndUpdateDatatableEntries));\n\n        LOG.info(\"Batch Response : {}\", new Gson().toJson(responseOfQuertAndUpdateDatatableBatch));\n\n        final BatchResponse batchQueryAndUpdateResponse1 = responseOfQuertAndUpdateDatatableBatch.get(0);\n        final BatchResponse batchQueryAndUpdateResponse2 = responseOfQuertAndUpdateDatatableBatch.get(1);\n        Assertions.assertEquals(HttpStatus.SC_OK, batchQueryAndUpdateResponse1.getStatusCode(),\n                \"Verify Status Code 200 for create datatable entry\");\n        Assertions.assertEquals(HttpStatus.SC_OK, batchQueryAndUpdateResponse2.getStatusCode(),\n                \"Verify Status Code 200 for update datatable entry\");\n\n        final JsonObject changes = jsonHelper.parse(batchQueryAndUpdateResponse2.getBody()).getAsJsonObject().get(\"changes\")\n                .getAsJsonObject();\n        Assertions.assertEquals(changes.get(columnName2).getAsString(), columnValue2 + \"1\");\n    }"}
{"prompt": "Create a test that tests should Find One To Many Datatable Entry By Query APIAnd Update One Of Its Column", "completion": "    @Test\n    public void shouldFindOneToManyDatatableEntryByQueryAPIAndUpdateOneOfItsColumn() {\n        final String datatableName = Utils.uniqueRandomStringGenerator(LOAN_APP_TABLE_NAME + \"_\", 5).toLowerCase();\n\n        final FromJsonHelper jsonHelper = new FromJsonHelper();\n        final Long loanId = jsonHelper.extractLongNamed(\"loanId\", jsonHelper.parse(setupAccount()).getAsJsonObject());\n        // creating datatable with m_loan association\n        final Map<String, Object> columnMap = new HashMap<>();\n        final List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n\n        final String columnName1 = Utils.randomStringGenerator(\"COL1_\", 5).toLowerCase();\n        final String columnName2 = Utils.randomStringGenerator(\"COL2_\", 5).toLowerCase();\n        columnMap.put(\"datatableName\", datatableName);\n        columnMap.put(\"apptableName\", LOAN_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"PERSON\");\n        columnMap.put(\"multiRow\", true);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, columnName1, \"String\", true, 10, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, columnName2, \"String\", false, 10, null);\n        columnMap.put(\"columns\", datatableColumnsList);\n        final String datatableRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"CreateDataTable map : {}\", datatableRequestJsonString);\n\n        this.datatableHelper.createDatatable(datatableRequestJsonString, \"\");\n\n        // Create a datatable entry so that it can be updated using BatchApi\n        final Map<String, Object> datatableEntryMap = new HashMap<>();\n        String columnValue1 = Utils.randomStringGenerator(\"VAL1_\", 3);\n        String columnValue2 = Utils.randomStringGenerator(\"VAL2_\", 3);\n        datatableEntryMap.put(columnName1, columnValue1);\n        datatableEntryMap.put(columnName2, columnValue2);\n        final String datatableEntryRequestJsonString = new Gson().toJson(datatableEntryMap);\n        LOG.info(\"CreateDataTableEntry map : {}\", datatableEntryRequestJsonString);\n\n        final Map<String, Object> datatableEntryResponse = this.datatableHelper.createDatatableEntry(datatableName, loanId.intValue(),\n                false, datatableEntryRequestJsonString);\n        final Integer datatableEntryResourceId = (Integer) datatableEntryResponse.get(\"resourceId\");\n        assertNotNull(datatableEntryResourceId, \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n\n        // Create datatable entry batch request\n        final BatchRequest createDatatableEntryRequest = BatchHelper.createDatatableEntryRequest(loanId, datatableName,\n                Arrays.asList(columnName1, columnName2));\n\n        // Get datatable entries batch request\n        final BatchRequest getDatatableEntriesRequest = BatchHelper.getDatatableByIdRequest(loanId, datatableName, null,\n                createDatatableEntryRequest.getReference());\n\n        final List<BatchRequest> batchRequestsDatatableEntries = Arrays.asList(createDatatableEntryRequest, getDatatableEntriesRequest);\n        LOG.info(\"Batch Request : {}\", BatchHelper.toJsonString(batchRequestsDatatableEntries));\n\n        final List<BatchResponse> responseDatatableBatch = BatchHelper.postBatchRequestsWithEnclosingTransaction(this.requestSpec,\n                this.responseSpec, BatchHelper.toJsonString(batchRequestsDatatableEntries));\n\n        LOG.info(\"Batch Response : {}\", new Gson().toJson(responseDatatableBatch));\n\n        final BatchResponse batchResponse1 = responseDatatableBatch.get(0);\n        final BatchResponse batchResponse2 = responseDatatableBatch.get(1);\n        Assertions.assertEquals(HttpStatus.SC_OK, batchResponse1.getStatusCode(), \"Verify Status Code 200 for create datatable entry\");\n        Assertions.assertEquals(HttpStatus.SC_OK, batchResponse2.getStatusCode(), \"Verify Status Code 200 for update datatable entry\");\n\n        final String getDatatableEntriesResponse = batchResponse2.getBody();\n\n        final Long createDatatableEntryId = jsonHelper.extractLongNamed(\"resourceId\",\n                jsonHelper.parse(batchResponse1.getBody()).getAsJsonObject());\n\n        final JsonArray datatableEntries = jsonHelper.parse(getDatatableEntriesResponse).getAsJsonArray();\n        Assertions.assertEquals(2, datatableEntries.size());\n\n        // Ensure both resourceIds are available in response\n        Assertions.assertTrue(getDatatableEntriesResponse.contains(String.format(\"\\\"id\\\": %d\", createDatatableEntryId)));\n        Assertions.assertTrue(getDatatableEntriesResponse.contains(String.format(\"\\\"id\\\": %d\", datatableEntryResourceId)));\n\n        final BatchRequest queryDatatableEntriesRequest = BatchHelper.queryDatatableEntries(datatableName, columnName1, columnValue1,\n                \"id,loan_id\");\n        final BatchRequest updateDatatableEntry = BatchHelper.updateDatatableEntry(datatableName, \"$.[0].loan_id\", \"$.[0].id\", columnName2,\n                columnValue2 + \"1\");\n\n        final List<BatchRequest> batchRequestsToQueryAndUpdateDatatableEntries = Arrays.asList(queryDatatableEntriesRequest,\n                updateDatatableEntry);\n        LOG.info(\"Batch Request : {}\", BatchHelper.toJsonString(batchRequestsToQueryAndUpdateDatatableEntries));\n\n        final List<BatchResponse> responseOfQuertAndUpdateDatatableBatch = BatchHelper.postBatchRequestsWithEnclosingTransaction(\n                this.requestSpec, this.responseSpec, BatchHelper.toJsonString(batchRequestsToQueryAndUpdateDatatableEntries));\n\n        LOG.info(\"Batch Response : {}\", new Gson().toJson(responseOfQuertAndUpdateDatatableBatch));\n\n        final BatchResponse batchQueryAndUpdateResponse1 = responseOfQuertAndUpdateDatatableBatch.get(0);\n        final BatchResponse batchQueryAndUpdateResponse2 = responseOfQuertAndUpdateDatatableBatch.get(1);\n        Assertions.assertEquals(HttpStatus.SC_OK, batchQueryAndUpdateResponse1.getStatusCode(),\n                \"Verify Status Code 200 for create datatable entry\");\n        Assertions.assertEquals(HttpStatus.SC_OK, batchQueryAndUpdateResponse2.getStatusCode(),\n                \"Verify Status Code 200 for update datatable entry\");\n\n        final JsonObject changes = jsonHelper.parse(batchQueryAndUpdateResponse2.getBody()).getAsJsonObject().get(\"changes\")\n                .getAsJsonObject();\n        Assertions.assertEquals(changes.get(columnName2).getAsString(), columnValue2 + \"1\");\n    }"}
{"prompt": "Create a test that tests should Reflect Changes On Loan Update", "completion": "     */\n    @Test\n    public void shouldReflectChangesOnLoanUpdate() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"1000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = RandomUtils.nextLong(100, 1000);\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long updateLoanRequestId = disburseLoanRequestId + 1;\n\n        // Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        final BatchRequest approveLoanRequest = BatchHelper.approveLoanRequest(approveLoanRequestId, applyLoanRequestId);\n\n        final BatchRequest disburseLoanRequest = BatchHelper.disburseLoanRequest(disburseLoanRequestId, approveLoanRequestId);\n\n        final BatchRequest updateLoanRequest = BatchHelper.createLoanRequestMarkAsFraud(updateLoanRequestId, disburseLoanRequestId);\n\n        // Create batch requests list\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest,\n                updateLoanRequest);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        // Get the changes parameter from updateLoan Response\n        final JsonObject changes = new FromJsonHelper().parse(response.get(3).getBody()).getAsJsonObject().get(\"changes\").getAsJsonObject();\n\n        Assertions.assertEquals(HttpStatus.SC_OK, response.get(3).getStatusCode(), \"Verify Status Code 200 for update loan application\");\n        Assertions.assertEquals(\"true\", changes.get(\"fraud\").getAsString());\n    }"}
{"prompt": "Create a test that tests should Reflect Changes On Loan Update By External Id", "completion": "     */\n    @Test\n    public void shouldReflectChangesOnLoanUpdateByExternalId() {\n\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"1000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = RandomUtils.nextLong(100, 1000);\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long updateLoanRequestId = disburseLoanRequestId + 1;\n        final Long getLoanRequestId = updateLoanRequestId + 1;\n\n        // Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        final BatchRequest approveLoanRequest = BatchHelper.transistionLoanStateByExternalId(approveLoanRequestId, applyLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(10), \"approve\");\n\n        final BatchRequest disburseLoanRequest = BatchHelper.transistionLoanStateByExternalId(disburseLoanRequestId, approveLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(8), \"disburse\");\n\n        final BatchRequest updateLoanRequest = BatchHelper.modifyLoanByExternalIdRequest(updateLoanRequestId, approveLoanRequestId);\n\n        final BatchRequest getLoanRequest = BatchHelper.getLoanByExternalIdRequest(getLoanRequestId, approveLoanRequestId,\n                \"associations=all\");\n\n        // Create batch requests list\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest, updateLoanRequest,\n                getLoanRequest);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for update loan application\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(4).getStatusCode(), \"Verify Status Code 200 for Get Loan\");\n\n        // Get the changes parameter from updateLoan Response\n        final JsonObject changes = new FromJsonHelper().parse(responses.get(3).getBody()).getAsJsonObject().get(\"changes\")\n                .getAsJsonObject();\n        Assertions.assertEquals(\"true\", changes.get(\"fraud\").getAsString());\n    }"}
{"prompt": "Create a test that tests shoul Retrieve The Proper Error During Locked Loan Old Relative Path", "completion": "     */\n    @Test\n    public void shoulRetrieveTheProperErrorDuringLockedLoan_OldRelativePath() {\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(202).build();\n        LoanAccountLockHelper loanAccountLockHelper = new LoanAccountLockHelper(this.requestSpec, responseSpec);\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"1000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = RandomUtils.nextLong(100, 1000);\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long getLoanRequestId = disburseLoanRequestId + 1;\n\n        // Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        final BatchRequest approveLoanRequest = BatchHelper.transistionLoanStateByExternalId(approveLoanRequestId, applyLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(10), \"approve\");\n\n        final BatchRequest disburseLoanRequest = BatchHelper.transistionLoanStateByExternalId(disburseLoanRequestId, approveLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(8), \"disburse\");\n\n        final BatchRequest getLoanRequest = BatchHelper.getLoanByExternalIdRequest(getLoanRequestId, approveLoanRequestId,\n                \"associations=all\");\n\n        // Create batch requests list\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest, getLoanRequest);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for Get Loan\");\n\n        final Long loanId = new FromJsonHelper().parse(responses.get(2).getBody()).getAsJsonObject().get(\"resourceId\").getAsLong();\n\n        loanAccountLockHelper.placeSoftLockOnLoanAccount(loanId.intValue(), \"LOAN_COB_CHUNK_PROCESSING\");\n\n        RequestSpecification requestSpec = UserHelper.getSimpleUserWithoutBypassPermission(this.requestSpec, this.responseSpec);\n\n        // Create a repayment Request\n        final BatchRequest br = new BatchRequest();\n\n        br.setRequestId(1L);\n        br.setRelativeUrl(String.format(\"loans/\" + loanId + \"/transactions?command=repayment\"));\n        br.setMethod(\"POST\");\n        String dateString = LocalDate.now(ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(\"dd MMMM yyyy\"));\n        br.setBody(String.format(\n                \"{\\\"locale\\\": \\\"en\\\", \\\"dateFormat\\\": \\\"dd MMMM yyyy\\\", \" + \"\\\"transactionDate\\\": \\\"%s\\\",  \\\"transactionAmount\\\": \\\"500\\\"}\",\n                dateString));\n\n        final String jsonifiedRepaymentRequest = BatchHelper.toJsonString(List.of(br));\n\n        final List<BatchResponse> repaymentResponse = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(requestSpec,\n                this.responseSpec, jsonifiedRepaymentRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_CONFLICT, repaymentResponse.get(0).getStatusCode(), \"Verify Status Code 409 for Locked Loan\");\n    }"}
{"prompt": "Create a test that tests shoul Retrieve The Proper Error During Locked Loan", "completion": "     */\n    @Test\n    public void shoulRetrieveTheProperErrorDuringLockedLoan() {\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(202).build();\n        LoanAccountLockHelper loanAccountLockHelper = new LoanAccountLockHelper(this.requestSpec, responseSpec);\n        final String loanProductJSON = new LoanProductTestBuilder() //\n                .withPrincipal(\"1000.00\") //\n                .withNumberOfRepayments(\"24\") //\n                .withRepaymentAfterEvery(\"1\") //\n                .withRepaymentTypeAsMonth() //\n                .withinterestRatePerPeriod(\"2\") //\n                .withInterestRateFrequencyTypeAsMonths() //\n                .withAmortizationTypeAsEqualPrincipalPayment() //\n                .withInterestTypeAsDecliningBalance() //\n                .currencyDetails(\"0\", \"100\").build(null);\n\n        final Long applyLoanRequestId = RandomUtils.nextLong(100, 1000);\n        final Long approveLoanRequestId = applyLoanRequestId + 1;\n        final Long disburseLoanRequestId = approveLoanRequestId + 1;\n        final Long getLoanRequestId = disburseLoanRequestId + 1;\n\n        // Create product\n        final Integer productId = new LoanTransactionHelper(this.requestSpec, this.responseSpec).getLoanProductId(loanProductJSON);\n\n        // Create client\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        final BatchRequest applyLoanRequest = BatchHelper.applyLoanRequestWithClientId(applyLoanRequestId, clientId, productId);\n\n        final BatchRequest approveLoanRequest = BatchHelper.transistionLoanStateByExternalId(approveLoanRequestId, applyLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(10), \"approve\");\n\n        final BatchRequest disburseLoanRequest = BatchHelper.transistionLoanStateByExternalId(disburseLoanRequestId, approveLoanRequestId,\n                LocalDate.now(ZoneId.systemDefault()).minusDays(8), \"disburse\");\n\n        final BatchRequest getLoanRequest = BatchHelper.getLoanByExternalIdRequest(getLoanRequestId, approveLoanRequestId,\n                \"associations=all\");\n\n        // Create batch requests list\n        final List<BatchRequest> batchRequests = Arrays.asList(applyLoanRequest, approveLoanRequest, disburseLoanRequest, getLoanRequest);\n\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> responses = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(0).getStatusCode(), \"Verify Status Code 200 for Apply Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(1).getStatusCode(), \"Verify Status Code 200 for Approve Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(2).getStatusCode(), \"Verify Status Code 200 for Disburse Loan\");\n        Assertions.assertEquals(HttpStatus.SC_OK, responses.get(3).getStatusCode(), \"Verify Status Code 200 for Get Loan\");\n\n        final Long loanId = new FromJsonHelper().parse(responses.get(2).getBody()).getAsJsonObject().get(\"resourceId\").getAsLong();\n\n        loanAccountLockHelper.placeSoftLockOnLoanAccount(loanId.intValue(), \"LOAN_COB_CHUNK_PROCESSING\");\n\n        RequestSpecification requestSpec = UserHelper.getSimpleUserWithoutBypassPermission(this.requestSpec, this.responseSpec);\n\n        // Create a repayment Request\n        final BatchRequest br = new BatchRequest();\n\n        br.setRequestId(1L);\n        br.setRelativeUrl(String.format(\"v1/loans/\" + loanId + \"/transactions?command=repayment\"));\n        br.setMethod(\"POST\");\n        String dateString = LocalDate.now(ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(\"dd MMMM yyyy\"));\n        br.setBody(String.format(\n                \"{\\\"locale\\\": \\\"en\\\", \\\"dateFormat\\\": \\\"dd MMMM yyyy\\\", \" + \"\\\"transactionDate\\\": \\\"%s\\\",  \\\"transactionAmount\\\": \\\"500\\\"}\",\n                dateString));\n\n        final String jsonifiedRepaymentRequest = BatchHelper.toJsonString(List.of(br));\n\n        final List<BatchResponse> repaymentResponse = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(requestSpec,\n                this.responseSpec, jsonifiedRepaymentRequest);\n\n        Assertions.assertEquals(HttpStatus.SC_CONFLICT, repaymentResponse.get(0).getStatusCode(), \"Verify Status Code 409 for Locked Loan\");\n    }"}
{"prompt": "Create a test that tests should Return Ok Status With Idempotency Support", "completion": "    @Test\n    public void shouldReturnOkStatusWithIdempotencySupport() {\n\n        // Generate a random count of number of clients to be created\n        final Integer clientsCount = (int) Math.ceil(secureRandom.nextDouble() * 7) + 3;\n        final Integer[] clientIDs = new Integer[clientsCount];\n\n        // Create a new group and get its groupId\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n\n        // Create new clients and add those to this group\n        for (Integer i = 0; i < clientsCount; i++) {\n            clientIDs[i] = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n            groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientIDs[i].toString());\n            LOG.info(\"client {} has been added to the group {}\", clientIDs[i], groupID);\n        }\n\n        // Generate a random count of number of new loan products to be created\n        final Integer loansCount = (int) Math.ceil(secureRandom.nextDouble() * 4) + 1;\n        final Integer[] loanProducts = new Integer[loansCount];\n\n        // Create new loan Products\n        LoanTransactionHelper helper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        for (Integer i = 0; i < loansCount; i++) {\n            final String loanProductJSON = new LoanProductTestBuilder() //\n                    .withPrincipal(String.valueOf(10000.00 + Math.ceil(secureRandom.nextDouble() * 1000000.00))) //\n                    .withNumberOfRepayments(String.valueOf(2 + (int) Math.ceil(secureRandom.nextDouble() * 36))) //\n                    .withRepaymentAfterEvery(String.valueOf(1 + (int) Math.ceil(secureRandom.nextDouble() * 3))) //\n                    .withRepaymentTypeAsMonth() //\n                    .withinterestRatePerPeriod(String.valueOf(1 + (int) Math.ceil(secureRandom.nextDouble() * 4))) //\n                    .withInterestRateFrequencyTypeAsMonths() //\n                    .withAmortizationTypeAsEqualPrincipalPayment() //\n                    .withInterestTypeAsDecliningBalance() //\n                    .currencyDetails(\"0\", \"100\").build(null);\n\n            loanProducts[i] = helper.getLoanProductId(loanProductJSON);\n        }\n\n        // Select anyone of the loan products at random\n        final Integer loanProductID = loanProducts[(int) Math.floor(secureRandom.nextDouble() * (loansCount - 1))];\n\n        final List<BatchRequest> batchRequests = new ArrayList<>();\n\n        // Select a few clients from created group at random\n        Integer selClientsCount = (int) Math.ceil(secureRandom.nextDouble() * clientsCount) + 2;\n        for (int i = 0; i < selClientsCount; i++) {\n\n            final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n            Assertions.assertNotNull(collateralId);\n            final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                    String.valueOf(clientIDs[(int) Math.floor(secureRandom.nextDouble() * (clientsCount - 1))]), collateralId);\n            Assertions.assertNotNull(clientCollateralId);\n\n            BatchRequest br = BatchHelper.applyLoanRequest((long) selClientsCount, null, loanProductID, clientCollateralId);\n            br.setBody(br.getBody().replace(\"$.clientId\",\n                    String.valueOf(clientIDs[(int) Math.floor(secureRandom.nextDouble() * (clientsCount - 1))])));\n            br.setHeaders(new HashSet<>());\n            br.getHeaders().add(new Header(\"Idempotency-Key\", UUID.randomUUID().toString()));\n            batchRequests.add(br);\n        }\n\n        // Send the request to Batch - API\n        final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n        final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec, this.responseSpec,\n                jsonifiedRequest);\n\n        // Verify that each loan has been applied successfully\n        for (BatchResponse res : response) {\n            Assertions.assertFalse(\n                    res.getHeaders().stream()\n                            .anyMatch(header -> header.getName().equals(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER)),\n                    \"First can not be cached!\");\n            Assertions.assertEquals(200L, (long) res.getStatusCode(), \"Verify Status Code 200\");\n        }\n\n        final List<BatchResponse> secondResponse = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec,\n                this.responseSpec, jsonifiedRequest);\n\n        // Verify that each loan has been applied successfully\n        for (BatchResponse res : secondResponse) {\n            Assertions.assertEquals(\"true\",\n                    res.getHeaders().stream()\n                            .filter(header -> header.getName().equals(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER))\n                            .map(Header::getValue).findAny().get(),\n                    \"Not cached by idempotency key!\");\n            Assertions.assertEquals(200L, (long) res.getStatusCode(), \"Verify Status Code 200\");\n        }\n    }"}
{"prompt": "Create a test that tests should Return Apply Charge To Overdue Loan Step Config", "completion": "    @Test\n    public void shouldReturnApplyChargeToOverdueLoanStepConfig() {\n        JobBusinessStepConfigData response = BusinessStepConfigurationHelper.getConfiguredBusinessStepsByJobName(requestSpec, responseSpec,\n                LOAN_JOB_NAME);\n\n        Assertions.assertNotNull(response);\n        assertEquals(LOAN_JOB_NAME, response.getJobName());\n        assertTrue(response.getBusinessSteps().size() > 0);\n        assertTrue(response.getBusinessSteps().stream()\n                .anyMatch(businessStep -> APPLY_CHARGE_TO_OVERDUE_LOANS.equals(businessStep.getStepName())));\n    }"}
{"prompt": "Create a test that tests should Return Apply Charge To Overdue Loan Step Config By Job Category", "completion": "    @Test\n    public void shouldReturnApplyChargeToOverdueLoanStepConfigByJobCategory() {\n        JobBusinessStepDetail response = BusinessStepConfigurationHelper.getAvailableBusinessStepsByJobName(requestSpec, responseSpec,\n                LOAN_CATEGORY_NAME);\n\n        Assertions.assertNotNull(response);\n        assertEquals(LOAN_CATEGORY_NAME, response.getJobName());\n        assertTrue(response.getAvailableBusinessSteps().size() > 0);\n        assertTrue(response.getAvailableBusinessSteps().stream()\n                .anyMatch(businessStep -> APPLY_CHARGE_TO_OVERDUE_LOANS.equals(businessStep.getStepName())));\n    }"}
{"prompt": "Create a test that tests should Update Step Order", "completion": "    @Test\n    public void shouldUpdateStepOrder() {\n        ResponseSpecification updateResponseSpec = new ResponseSpecBuilder().expectStatusCode(204).build();\n        JobBusinessStepConfigData originalStepConfig = IdempotencyHelper.getConfiguredBusinessStepsByJobName(requestSpec, responseSpec,\n                LOAN_JOB_NAME);\n\n        String idempotencyKeyHeader = UUID.randomUUID().toString();\n\n        List<BusinessStep> requestBody = new ArrayList<>();\n        requestBody.add(getBusinessSteps(1L, APPLY_CHARGE_TO_OVERDUE_LOANS));\n        Response response = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKeyHeader);\n        Response responseSecond = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKeyHeader);\n        Assertions.assertEquals(response.getBody().asString(), responseSecond.getBody().asString());\n        Assertions.assertNull(response.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertNotNull(responseSecond.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n\n        idempotencyKeyHeader = UUID.randomUUID().toString();\n\n        JobBusinessStepConfigData newStepConfig = IdempotencyHelper.getConfiguredBusinessStepsByJobName(requestSpec, responseSpec,\n                LOAN_JOB_NAME);\n        BusinessStep applyChargeStep = newStepConfig.getBusinessSteps().stream()\n                .filter(businessStep -> APPLY_CHARGE_TO_OVERDUE_LOANS.equals(businessStep.getStepName())).findFirst().get();\n        assertEquals(1, newStepConfig.getBusinessSteps().size());\n        assertEquals(1L, applyChargeStep.getOrder());\n\n        requestBody.add(getBusinessSteps(2L, LOAN_DELINQUENCY_CLASSIFICATION));\n\n        Response update = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKeyHeader);\n        Response updateSecond = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKeyHeader);\n        Assertions.assertNull(update.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertNotNull(updateSecond.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertEquals(update.getBody().asString(), updateSecond.getBody().asString());\n\n        newStepConfig = IdempotencyHelper.getConfiguredBusinessStepsByJobName(requestSpec, responseSpec, LOAN_JOB_NAME);\n        applyChargeStep = newStepConfig.getBusinessSteps().stream()\n                .filter(businessStep -> APPLY_CHARGE_TO_OVERDUE_LOANS.equals(businessStep.getStepName())).findFirst().get();\n        BusinessStep loanDelinquencyStep = newStepConfig.getBusinessSteps().stream()\n                .filter(businessStep -> LOAN_DELINQUENCY_CLASSIFICATION.equals(businessStep.getStepName())).findFirst().get();\n        assertEquals(2, newStepConfig.getBusinessSteps().size());\n        assertEquals(1L, applyChargeStep.getOrder());\n        assertEquals(2L, loanDelinquencyStep.getOrder());\n\n        requestBody.remove(1);\n        idempotencyKeyHeader = UUID.randomUUID().toString();\n        update = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKeyHeader);\n        updateSecond = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKeyHeader);\n\n        Assertions.assertNull(update.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertNotNull(updateSecond.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertEquals(update.getBody().asString(), updateSecond.getBody().asString());\n\n        newStepConfig = IdempotencyHelper.getConfiguredBusinessStepsByJobName(requestSpec, responseSpec, LOAN_JOB_NAME);\n        applyChargeStep = newStepConfig.getBusinessSteps().stream()\n                .filter(businessStep -> APPLY_CHARGE_TO_OVERDUE_LOANS.equals(businessStep.getStepName())).findFirst().get();\n        assertEquals(1, newStepConfig.getBusinessSteps().size());\n        assertEquals(1L, applyChargeStep.getOrder());\n\n        idempotencyKeyHeader = UUID.randomUUID().toString();\n\n        update = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(originalStepConfig.getBusinessSteps()), idempotencyKeyHeader);\n        updateSecond = IdempotencyHelper.updateBusinessStepOrder(requestSpec, updateResponseSpec, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(originalStepConfig.getBusinessSteps()), idempotencyKeyHeader);\n\n        Assertions.assertNull(update.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertNotNull(updateSecond.header(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertEquals(update.getBody().asString(), updateSecond.getBody().asString());\n\n    }"}
{"prompt": "Create a test that tests should Throw Error When ABusiness Step Does Not Belong To The Given Job", "completion": "    @Test\n    public void shouldThrowErrorWhenABusinessStepDoesNotBelongToTheGivenJob() {\n        ResponseSpecification responseSpecForError = new ResponseSpecBuilder().expectStatusCode(400).build();\n        List<BusinessStep> requestBody = new ArrayList<>();\n        requestBody.add(getBusinessSteps(1L, NOT_BELONGING_BUSINESS_STEP_NAME));\n        ApiParameterError response = BusinessStepConfigurationHelper.updateBusinessStepOrderWithError(requestSpec, responseSpecForError,\n                LOAN_JOB_NAME, BusinessStepConfigurationHelper.toJsonString(requestBody));\n        assertEquals(\"[APPLY_CHARGE_TO_OVERDUE_LOANS_2] Business steps are not configurable for this job.\", response.getDeveloperMessage());\n    }"}
{"prompt": "Create a test that tests should Throw Error When Business Step List Is Empty", "completion": "    @Test\n    public void shouldThrowErrorWhenBusinessStepListIsEmpty() {\n        ResponseSpecification responseSpecForError = new ResponseSpecBuilder().expectStatusCode(400).build();\n        List<BusinessStep> requestBody = Collections.emptyList();\n        ApiParameterError response = BusinessStepConfigurationHelper.updateBusinessStepOrderWithError(requestSpec, responseSpecForError,\n                LOAN_JOB_NAME, BusinessStepConfigurationHelper.toJsonString(requestBody));\n        assertEquals(\"A job needs to have 1 business step at least.\", response.getDeveloperMessage());\n    }"}
{"prompt": "Create a test that tests test Basic Center Creation", "completion": "    @Test\n    public void testBasicCenterCreation() {\n        int officeId = new OfficeHelper(requestSpec, responseSpec).createOffice(\"01 July 2007\");\n\n        String name = \"TestBasicCreation\" + new Timestamp(new java.util.Date().getTime());\n        int resourceId = CenterHelper.createCenter(name, officeId, requestSpec, responseSpec);\n        CenterDomain center = CenterHelper.retrieveByID(resourceId, requestSpec, responseSpec);\n\n        Assertions.assertNotNull(center);\n        Assertions.assertTrue(center.getName().equals(name));\n        Assertions.assertTrue(center.getOfficeId() == officeId);\n        Assertions.assertTrue(center.isActive() == false);\n\n        // Test retrieval by listing all centers\n        int id = CenterHelper.listCenters(requestSpec, responseSpec).get(0).getId();\n        Assertions.assertTrue(id > 0);\n\n        CenterDomain retrievedCenter = CenterHelper.retrieveByID(id, requestSpec, responseSpec);\n        Assertions.assertNotNull(retrievedCenter);\n        Assertions.assertNotNull(retrievedCenter.getName());\n        Assertions.assertNotNull(retrievedCenter.getHierarchy());\n        Assertions.assertNotNull(retrievedCenter.getOfficeName());\n\n    }"}
{"prompt": "Create a test that tests test Full Center Creation", "completion": "    @Test\n    public void testFullCenterCreation() {\n\n        int officeId = new OfficeHelper(requestSpec, responseSpec).createOffice(\"01 July 2007\");\n        String name = \"TestFullCreation\" + new Timestamp(new java.util.Date().getTime());\n        String externalId = UUID.randomUUID().toString();\n        int staffId = StaffHelper.createStaff(requestSpec, responseSpec);\n        int[] groupMembers = generateGroupMembers(3, officeId);\n        int resourceId = CenterHelper.createCenter(name, officeId, externalId, staffId, groupMembers, requestSpec, responseSpec);\n        CenterDomain center = CenterHelper.retrieveByID(resourceId, requestSpec, responseSpec);\n\n        Assertions.assertNotNull(center);\n        Assertions.assertTrue(center.getName().equals(name));\n        Assertions.assertTrue(center.getOfficeId() == officeId);\n        Assertions.assertTrue(center.getExternalId().equals(externalId));\n        Assertions.assertTrue(center.getStaffId() == staffId);\n        Assertions.assertTrue(center.isActive() == false);\n        Assertions.assertArrayEquals(center.getGroupMembers(), groupMembers);\n    }"}
{"prompt": "Create a test that tests test List Centers", "completion": "    @Test\n    public void testListCenters() {\n        ArrayList<CenterDomain> paginatedList = CenterHelper.paginatedListCenters(requestSpec, responseSpec);\n        ArrayList<CenterDomain> list = CenterHelper.listCenters(requestSpec, responseSpec);\n\n        Assertions.assertNotNull(paginatedList);\n        Assertions.assertNotNull(list);\n        Assertions.assertTrue(\n                Arrays.equals(paginatedList.toArray(new CenterDomain[paginatedList.size()]), list.toArray(new CenterDomain[list.size()])));\n    }"}
{"prompt": "Create a test that tests test Void Center Retrieval", "completion": "    @Test\n    public void testVoidCenterRetrieval() {\n        ArrayList<CenterDomain> arr = CenterHelper.listCentersOrdered(requestSpec, responseSpec);\n        int id = arr.get(arr.size() - 1).getId() + 1;\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(404).build();\n        CenterDomain center = CenterHelper.retrieveByID(id, requestSpec, responseSpec);\n        Assertions.assertNotNull(center);\n    }\n\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" }"}
{"prompt": "Create a test that tests test Center Update", "completion": "    @Test\n    public void testCenterUpdate() {\n        int officeId = new OfficeHelper(requestSpec, responseSpec).createOffice(\"01 July 2007\");\n        String name = \"TestFullCreation\" + new Timestamp(new java.util.Date().getTime());\n        String externalId = UUID.randomUUID().toString();\n        int staffId = StaffHelper.createStaff(requestSpec, responseSpec);\n        int[] groupMembers = generateGroupMembers(3, officeId);\n        int resourceId = CenterHelper.createCenter(name, officeId, externalId, staffId, groupMembers, requestSpec, responseSpec);\n\n        String newName = \"TestCenterUpdateNew\" + new Timestamp(new java.util.Date().getTime());\n        String newExternalId = UUID.randomUUID().toString();\n        int newStaffId = StaffHelper.createStaff(requestSpec, responseSpec);\n        int[] associateGroupMembers = generateGroupMembers(2, officeId);\n\n        int[] associateResponse = CenterHelper.associateGroups(resourceId, associateGroupMembers, requestSpec, responseSpec);\n        Arrays.sort(associateResponse);\n        Arrays.sort(associateGroupMembers);\n        Assertions.assertArrayEquals(associateResponse, associateGroupMembers);\n\n        int[] newGroupMembers = new int[5];\n        for (int i = 0; i < 5; i++) {\n            if (i < 3) {\n                newGroupMembers[i] = groupMembers[i];\n            } else {\n                newGroupMembers[i] = associateGroupMembers[i % 3];\n            }\n        }\n\n        HashMap request = new HashMap();\n        request.put(\"name\", newName);\n        request.put(\"externalId\", newExternalId);\n        request.put(\"staffId\", newStaffId);\n        HashMap response = CenterHelper.updateCenter(resourceId, request, requestSpec, responseSpec);\n        Assertions.assertNotNull(response);\n        Assertions.assertEquals(newName, response.get(\"name\"));\n        Assertions.assertEquals(newExternalId, response.get(\"externalId\"));\n        Assertions.assertEquals(Integer.valueOf(newStaffId), Integer.valueOf(response.get(\"staffId\").toString()));\n\n        CenterDomain center = CenterHelper.retrieveByID(resourceId, requestSpec, responseSpec);\n        Assertions.assertNotNull(center);\n        Assertions.assertEquals(newName, center.getName());\n        Assertions.assertEquals(newExternalId, center.getExternalId());\n        Assertions.assertEquals((Integer) newStaffId, center.getStaffId());\n        Assertions.assertArrayEquals(newGroupMembers, center.getGroupMembers());\n    }"}
{"prompt": "Create a test that tests test Center Deletion", "completion": "    @Test\n    public void testCenterDeletion() {\n        int officeId = new OfficeHelper(requestSpec, responseSpec).createOffice(\"01 July 2007\");\n        String name = \"TestBasicCreation\" + new Timestamp(new java.util.Date().getTime());\n        int resourceId = CenterHelper.createCenter(name, officeId, requestSpec, responseSpec);\n\n        CenterHelper.deleteCenter(resourceId, requestSpec, responseSpec);\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(404).build();\n        CenterDomain center = CenterHelper.retrieveByID(resourceId, requestSpec, responseSpec);\n        Assertions.assertNotNull(center);\n    }"}
{"prompt": "Create a test that tests test Staff Assignment During Center Creation", "completion": "    @Test\n    public void testStaffAssignmentDuringCenterCreation() {\n\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        LOG.info(\"--------------creating first staff with id------------- {}\", staffId);\n        Assertions.assertNotNull(staffId);\n\n        final int centerWithStaffId = CenterHelper.createCenterWithStaffId(this.requestSpec, this.responseSpec, staffId);\n        final CenterDomain center = CenterHelper.retrieveByID(centerWithStaffId, requestSpec, responseSpec);\n        Assertions.assertNotNull(center);\n        Assertions.assertTrue(center.getId() == centerWithStaffId);\n        Assertions.assertTrue(center.getStaffId().intValue() == staffId);\n        Assertions.assertTrue(center.isActive() == true);\n    }"}
{"prompt": "Create a test that tests test Assign Staff To Center", "completion": "    @Test\n    public void testAssignStaffToCenter() {\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        LOG.info(\"--------------creating first staff with id------------- {}\", staffId);\n        Assertions.assertNotNull(staffId);\n\n        final Integer groupID = CenterHelper.createCenter(this.requestSpec, this.responseSpec);\n        CenterHelper.verifyCenterCreatedOnServer(this.requestSpec, this.responseSpec, groupID);\n\n        final HashMap assignStaffToCenterResponseMap = (HashMap) CenterHelper.assignStaff(this.requestSpec, this.responseSpec,\n                groupID.toString(), staffId.longValue());\n        assertEquals(assignStaffToCenterResponseMap.get(\"staffId\"), staffId, \"Verify assigned staff id is the same as id sent\");\n\n        final CenterDomain center = CenterHelper.retrieveByID(groupID, requestSpec, responseSpec);\n        Assertions.assertNotNull(center);\n        Assertions.assertTrue(center.getId().intValue() == groupID);\n        Assertions.assertTrue(center.getStaffId().intValue() == staffId);\n\n    }"}
{"prompt": "Create a test that tests test Unassign Staff To Center", "completion": "    @Test\n    public void testUnassignStaffToCenter() {\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        LOG.info(\"--------------creating first staff with id------------- {}\", staffId);\n        Assertions.assertNotNull(staffId);\n\n        final Integer groupID = CenterHelper.createCenter(this.requestSpec, this.responseSpec);\n        CenterHelper.verifyCenterCreatedOnServer(this.requestSpec, this.responseSpec, groupID);\n\n        final HashMap assignStaffToCenterResponseMap = (HashMap) CenterHelper.assignStaff(this.requestSpec, this.responseSpec,\n                groupID.toString(), staffId.longValue());\n        assertEquals(assignStaffToCenterResponseMap.get(\"staffId\"), staffId, \"Verify assigned staff id is the same as id sent\");\n        final CenterDomain centerWithStaffAssigned = CenterHelper.retrieveByID(groupID, requestSpec, responseSpec);\n        Assertions.assertNotNull(centerWithStaffAssigned);\n        Assertions.assertTrue(centerWithStaffAssigned.getId().intValue() == groupID);\n        Assertions.assertTrue(centerWithStaffAssigned.getStaffId().intValue() == staffId);\n\n        final HashMap unassignStaffToCenterResponseMap = (HashMap) CenterHelper.unassignStaff(this.requestSpec, this.responseSpec,\n                groupID.toString(), staffId.longValue());\n        assertEquals(unassignStaffToCenterResponseMap.get(\"staffId\"), null, \"Verify staffId is null after unassigning \");\n        final CenterDomain centerWithStaffUnssigned = CenterHelper.retrieveByID(groupID, requestSpec, responseSpec);\n        Assertions.assertNotNull(centerWithStaffUnssigned);\n        Assertions.assertTrue(centerWithStaffUnssigned.getId().intValue() == groupID);\n        Assertions.assertTrue(centerWithStaffUnssigned.getStaffId() == null);\n\n    }"}
{"prompt": "Create a test that tests test Centers Orphan Groups", "completion": "    @Test\n    public void testCentersOrphanGroups() {\n\n        int officeId = new OfficeHelper(requestSpec, responseSpec).createOffice(\"01 July 2007\");\n\n        String name = \"TestBasicCreation\" + new Timestamp(new java.util.Date().getTime());\n        int resourceId = CenterHelper.createCenter(name, officeId, requestSpec, responseSpec);\n        CenterDomain center = CenterHelper.retrieveByID(resourceId, requestSpec, responseSpec);\n\n        Assertions.assertNotNull(center);\n\n        int id = CenterHelper.listCenters(requestSpec, responseSpec).get(0).getId();\n        Assertions.assertTrue(id > 0);\n\n        CenterDomain retrievedCenter = CenterHelper.retrieveByID(id, requestSpec, responseSpec);\n        Assertions.assertNotNull(retrievedCenter);\n        Assertions.assertNotNull(retrievedCenter.getName());\n        Assertions.assertNotNull(retrievedCenter.getHierarchy());\n        Assertions.assertNotNull(retrievedCenter.getOfficeName());\n\n        int[] groupMembers = generateGroupMembers(2, officeId);\n        CenterHelper.associateGroups(resourceId, groupMembers, requestSpec, responseSpec);\n        GroupHelper.verifyOrphanGroupDetails(requestSpec, responseSpec, officeId);\n    }"}
{"prompt": "Create a test that tests test Charges For Loans", "completion": "    @Test\n    public void testChargesForLoans() {\n\n        // Retrieving all Charges\n        ArrayList<HashMap> allChargesData = ChargesHelper.getCharges(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(allChargesData);\n\n        // Testing Creation, Updation and Deletion of Disbursement Charge\n        final Integer disbursementChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getLoanDisbursementJSON());\n        Assertions.assertNotNull(disbursementChargeId);\n\n        // Updating Charge Amount\n        HashMap changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, disbursementChargeId,\n                ChargesHelper.getModifyChargeJSON());\n\n        HashMap chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, disbursementChargeId);\n        Assertions.assertEquals(chargeDataAfterChanges.get(\"amount\"), changes.get(\"amount\"), \"Verifying Charge after Modification\");\n\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, disbursementChargeId,\n                ChargesHelper.getModifyChargeAsPecentageAmountJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, disbursementChargeId);\n\n        HashMap chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargePaymentMode\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargePaymentMode\"), \"Verifying Charge after Modification\");\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargeCalculationType\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargeCalculationType\"), \"Verifying Charge after Modification\");\n\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, disbursementChargeId,\n                ChargesHelper.getModifyChargeAsPecentageLoanAmountWithInterestJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, disbursementChargeId);\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargeCalculationType\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargeCalculationType\"), \"Verifying Charge after Modification\");\n\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, disbursementChargeId,\n                ChargesHelper.getModifyChargeAsPercentageInterestJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, disbursementChargeId);\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargeCalculationType\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargeCalculationType\"), \"Verifying Charge after Modification\");\n\n        Integer chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, disbursementChargeId);\n        Assertions.assertEquals(disbursementChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n\n        // Testing Creation, Updation and Deletion of Specified due date Charge\n        final Integer specifiedDueDateChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON());\n        Assertions.assertNotNull(specifiedDueDateChargeId);\n\n        // Updating Charge Amount\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, specifiedDueDateChargeId,\n                ChargesHelper.getModifyChargeJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, specifiedDueDateChargeId);\n        Assertions.assertEquals(chargeDataAfterChanges.get(\"amount\"), changes.get(\"amount\"), \"Verifying Charge after Modification\");\n\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, specifiedDueDateChargeId,\n                ChargesHelper.getModifyChargeAsPecentageAmountJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, specifiedDueDateChargeId);\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargePaymentMode\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargePaymentMode\"), \"Verifying Charge after Modification\");\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargeCalculationType\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargeCalculationType\"), \"Verifying Charge after Modification\");\n\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, specifiedDueDateChargeId,\n                ChargesHelper.getModifyChargeAsPecentageLoanAmountWithInterestJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, specifiedDueDateChargeId);\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargeCalculationType\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargeCalculationType\"), \"Verifying Charge after Modification\");\n\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, specifiedDueDateChargeId,\n                ChargesHelper.getModifyChargeAsPercentageInterestJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, specifiedDueDateChargeId);\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargeCalculationType\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargeCalculationType\"), \"Verifying Charge after Modification\");\n\n        chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, specifiedDueDateChargeId);\n        Assertions.assertEquals(specifiedDueDateChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n\n        // Testing Creation, Updation and Deletion of Installment Fee Charge\n        final Integer installmentFeeChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getLoanInstallmentFeeJSON());\n\n        // Updating Charge Amount\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, installmentFeeChargeId,\n                ChargesHelper.getModifyChargeJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, installmentFeeChargeId);\n        Assertions.assertEquals(chargeDataAfterChanges.get(\"amount\"), changes.get(\"amount\"), \"Verifying Charge after Modification\");\n\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, installmentFeeChargeId,\n                ChargesHelper.getModifyChargeAsPecentageAmountJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, installmentFeeChargeId);\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargePaymentMode\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargePaymentMode\"), \"Verifying Charge after Modification\");\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargeCalculationType\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargeCalculationType\"), \"Verifying Charge after Modification\");\n\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, installmentFeeChargeId,\n                ChargesHelper.getModifyChargeAsPecentageLoanAmountWithInterestJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, installmentFeeChargeId);\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargeCalculationType\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargeCalculationType\"), \"Verifying Charge after Modification\");\n\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, installmentFeeChargeId,\n                ChargesHelper.getModifyChargeAsPercentageInterestJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, installmentFeeChargeId);\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargeCalculationType\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargeCalculationType\"), \"Verifying Charge after Modification\");\n\n        chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, installmentFeeChargeId);\n        Assertions.assertEquals(installmentFeeChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n\n        // Testing Creation, Updation and Deletion of Overdue Installment Fee\n        // Charge\n        final Integer overdueFeeChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getLoanOverdueFeeJSON());\n        Assertions.assertNotNull(overdueFeeChargeId);\n\n        // Updating Charge Amount\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, overdueFeeChargeId, ChargesHelper.getModifyChargeJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, overdueFeeChargeId);\n        Assertions.assertEquals(chargeDataAfterChanges.get(\"amount\"), changes.get(\"amount\"), \"Verifying Charge after Modification\");\n\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, overdueFeeChargeId,\n                ChargesHelper.getModifyChargeAsPecentageAmountJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, overdueFeeChargeId);\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargePaymentMode\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargePaymentMode\"), \"Verifying Charge after Modification\");\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargeCalculationType\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargeCalculationType\"), \"Verifying Charge after Modification\");\n\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, overdueFeeChargeId,\n                ChargesHelper.getModifyChargeAsPecentageLoanAmountWithInterestJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, overdueFeeChargeId);\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargeCalculationType\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargeCalculationType\"), \"Verifying Charge after Modification\");\n\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, overdueFeeChargeId,\n                ChargesHelper.getModifyChargeAsPercentageInterestJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, overdueFeeChargeId);\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargeCalculationType\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargeCalculationType\"), \"Verifying Charge after Modification\");\n\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, overdueFeeChargeId,\n                ChargesHelper.getModifyChargeFeeFrequencyAsYearsJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, overdueFeeChargeId);\n\n        chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"feeFrequency\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"feeFrequency\"), \"Verifying Charge after Modification\");\n\n        chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, overdueFeeChargeId);\n        Assertions.assertEquals(overdueFeeChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n    }"}
{"prompt": "Create a test that tests test Charges For Savings", "completion": "    @Test\n    public void testChargesForSavings() {\n\n        // Testing Creation, Updation and Deletion of Specified due date Charge\n        final Integer specifiedDueDateChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsSpecifiedDueDateJSON());\n        Assertions.assertNotNull(specifiedDueDateChargeId);\n\n        // Updating Charge Amount\n        HashMap changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, specifiedDueDateChargeId,\n                ChargesHelper.getModifyChargeJSON());\n\n        HashMap chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, specifiedDueDateChargeId);\n        Assertions.assertEquals(chargeDataAfterChanges.get(\"amount\"), changes.get(\"amount\"), \"Verifying Charge after Modification\");\n\n        Integer chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, specifiedDueDateChargeId);\n        Assertions.assertEquals(specifiedDueDateChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n\n        // Testing Creation, Updation and Deletion of Savings Activation Charge\n        final Integer savingsActivationChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsActivationFeeJSON());\n        Assertions.assertNotNull(savingsActivationChargeId);\n\n        // Updating Charge Amount\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, savingsActivationChargeId,\n                ChargesHelper.getModifyChargeJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, savingsActivationChargeId);\n        Assertions.assertEquals(chargeDataAfterChanges.get(\"amount\"), changes.get(\"amount\"), \"Verifying Charge after Modification\");\n\n        chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, savingsActivationChargeId);\n        Assertions.assertEquals(savingsActivationChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n\n        // Testing Creation, Updation and Deletion of Charge for Withdrawal Fee\n        final Integer withdrawalFeeChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsWithdrawalFeeJSON());\n        Assertions.assertNotNull(withdrawalFeeChargeId);\n\n        // Updating Charge-Calculation-Type to Withdrawal-Fee\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, withdrawalFeeChargeId,\n                ChargesHelper.getModifyWithdrawalFeeSavingsChargeJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, withdrawalFeeChargeId);\n\n        HashMap chargeChangedData = (HashMap) chargeDataAfterChanges.get(\"chargeCalculationType\");\n        Assertions.assertEquals(chargeChangedData.get(\"id\"), changes.get(\"chargeCalculationType\"), \"Verifying Charge after Modification\");\n\n        chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, withdrawalFeeChargeId);\n        Assertions.assertEquals(withdrawalFeeChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n\n        // Testing Creation, Updation and Deletion of Charge for Annual Fee\n        final Integer annualFeeChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsAnnualFeeJSON());\n        Assertions.assertNotNull(annualFeeChargeId);\n\n        // Updating Charge Amount\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, annualFeeChargeId, ChargesHelper.getModifyChargeJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, annualFeeChargeId);\n        Assertions.assertEquals(chargeDataAfterChanges.get(\"amount\"), changes.get(\"amount\"), \"Verifying Charge after Modification\");\n\n        chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, annualFeeChargeId);\n        Assertions.assertEquals(annualFeeChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n\n        // Testing Creation, Updation and Deletion of Charge for Monthly Fee\n        final Integer monthlyFeeChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsMonthlyFeeJSON());\n        Assertions.assertNotNull(monthlyFeeChargeId);\n\n        // Updating Charge Amount\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, monthlyFeeChargeId, ChargesHelper.getModifyChargeJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, monthlyFeeChargeId);\n        Assertions.assertEquals(chargeDataAfterChanges.get(\"amount\"), changes.get(\"amount\"), \"Verifying Charge after Modification\");\n\n        chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, monthlyFeeChargeId);\n        Assertions.assertEquals(monthlyFeeChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n\n        // Testing Creation, Updation and Deletion of Charge for Overdraft Fee\n        final Integer overdraftFeeChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsOverdraftFeeJSON());\n        Assertions.assertNotNull(overdraftFeeChargeId);\n\n        // Updating Charge Amount\n        changes = ChargesHelper.updateCharges(this.requestSpec, this.responseSpec, overdraftFeeChargeId,\n                ChargesHelper.getModifyChargeJSON());\n\n        chargeDataAfterChanges = ChargesHelper.getChargeById(this.requestSpec, this.responseSpec, overdraftFeeChargeId);\n        Assertions.assertEquals(chargeDataAfterChanges.get(\"amount\"), changes.get(\"amount\"), \"Verifying Charge after Modification\");\n\n        chargeIdAfterDeletion = ChargesHelper.deleteCharge(this.responseSpec, this.requestSpec, overdraftFeeChargeId);\n        Assertions.assertEquals(overdraftFeeChargeId, chargeIdAfterDeletion, \"Verifying Charge ID after deletion\");\n    }"}
{"prompt": "Create a test that tests check Audit Dates", "completion": "    @Test\n    public void checkAuditDates() throws InterruptedException {\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        String username = Utils.uniqueRandomStringGenerator(\"user\", 8);\n        final Integer userId = (Integer) UserHelper.createUser(this.requestSpec, this.responseSpec, 1, staffId, username, \"P4ssw0rd\",\n                \"resourceId\");\n\n        LOG.info(\"-------------------------Creating Client---------------------------\");\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientID);\n        LOG.info(\"-------------------------Creating Loan---------------------------\");\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProduct(\"0\", \"0\", LoanProductTestBuilder.DEFAULT_STRATEGY, \"2\", assetAccount, incomeAccount,\n                expenseAccount, overpaymentAccount);\n\n        final Integer loanID = applyForLoanApplicationWithPaymentStrategyAndPastMonth(clientID, loanProductID, Collections.emptyList(),\n                null, \"10000\", LoanApplicationTestBuilder.DEFAULT_STRATEGY, \"10 July 2022\");\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"11 July 2022\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"11 July 2022\", loanID, \"10000\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        OffsetDateTime now = OffsetDateTime.now(ZoneId.of(\"Asia/Kolkata\"));\n        // Testing in minutes precision, but still need to take care around the end of the actual minute\n        if (now.getSecond() > 56) {\n            Thread.sleep(5000);\n            now = OffsetDateTime.now(ZoneId.of(\"Asia/Kolkata\"));\n        }\n        HashMap repaymentDetails = this.loanTransactionHelper.makeRepayment(\"11 July 2022\", 100.0f, loanID);\n        Integer transactionId = (Integer) repaymentDetails.get(\"resourceId\");\n        HashMap auditFieldsResponse = LoanTransactionHelper.getLoanTransactionAuditFields(requestSpec, responseSpec, loanID, transactionId,\n                \"\");\n\n        OffsetDateTime createdDate = OffsetDateTime.parse((String) auditFieldsResponse.get(CREATED_DATE),\n                DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n\n        OffsetDateTime lastModifiedDate = OffsetDateTime.parse((String) auditFieldsResponse.get(LAST_MODIFIED_DATE),\n                DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n\n        LOG.info(\"-------------------------Check Audit dates---------------------------\");\n        assertEquals(1, auditFieldsResponse.get(CREATED_BY));\n        assertEquals(now.getYear(), createdDate.getYear());\n        assertEquals(now.getMonth(), createdDate.getMonth());\n        assertEquals(now.getDayOfMonth(), createdDate.getDayOfMonth());\n        assertEquals(now.getHour(), createdDate.getHour());\n        assertEquals(now.getMinute(), createdDate.getMinute());\n\n        assertEquals(1, auditFieldsResponse.get(LAST_MODIFIED_BY));\n        assertEquals(now.getYear(), lastModifiedDate.getYear());\n        assertEquals(now.getMonth(), lastModifiedDate.getMonth());\n        assertEquals(now.getDayOfMonth(), lastModifiedDate.getDayOfMonth());\n        assertEquals(now.getHour(), lastModifiedDate.getHour());\n        assertEquals(now.getMinute(), lastModifiedDate.getMinute());\n\n        Thread.sleep(2000);\n\n        this.requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n        this.requestSpec.header(\"Authorization\",\n                \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey(username, \"P4ssw0rd\"));\n\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        this.loanTransactionHelper.reverseRepayment(loanID, transactionId, \"11 July 2022\");\n\n        now = OffsetDateTime.now(ZoneId.of(\"Asia/Kolkata\"));\n\n        auditFieldsResponse = LoanTransactionHelper.getLoanTransactionAuditFields(requestSpec, responseSpec, loanID, transactionId, \"\");\n\n        createdDate = OffsetDateTime.parse((String) auditFieldsResponse.get(CREATED_DATE), DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n\n        lastModifiedDate = OffsetDateTime.parse((String) auditFieldsResponse.get(LAST_MODIFIED_DATE),\n                DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n\n        LOG.info(\"-------------------------Check Audit dates---------------------------\");\n        assertEquals(1, auditFieldsResponse.get(CREATED_BY));\n        assertEquals(now.getYear(), createdDate.getYear());\n        assertEquals(now.getMonth(), createdDate.getMonth());\n        assertEquals(now.getDayOfMonth(), createdDate.getDayOfMonth());\n        assertEquals(now.getHour(), createdDate.getHour());\n        assertEquals(now.getMinute(), createdDate.getMinute());\n\n        now = OffsetDateTime.now(ZoneId.of(\"Asia/Kolkata\"));\n\n        assertEquals(userId, auditFieldsResponse.get(LAST_MODIFIED_BY));\n        assertEquals(now.getYear(), lastModifiedDate.getYear());\n        assertEquals(now.getMonth(), lastModifiedDate.getMonth());\n        assertEquals(now.getDayOfMonth(), lastModifiedDate.getDayOfMonth());\n        assertEquals(now.getHour(), lastModifiedDate.getHour());\n        assertEquals(now.getMinute(), lastModifiedDate.getMinute());\n    }"}
{"prompt": "Create a test that tests create Client Collateral Test", "completion": "    @Test\n    public void createClientCollateralTest() {\n        LOG.info(\"-------------------------Creating Client Collateral---------------------------\");\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n    }"}
{"prompt": "Create a test that tests update Client Collateral", "completion": "    @Test\n    public void updateClientCollateral() {\n        LOG.info(\"-------------------------Updating Client Collateral---------------------------\");\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientID);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        final HashMap changes = CollateralManagementHelper.updateClientCollateral(this.requestSpec, this.responseSpec, clientCollateralId);\n        Assertions.assertEquals(\"1\", changes.get(\"quantity\").toString());\n    }"}
{"prompt": "Create a test that tests when Auto External Id Config Is Off Create Client", "completion": "    @Test\n    public void whenAutoExternalIdConfigIsOffCreateClient() {\n        // given\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n        final String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON,\n                null);\n        // when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        // then\n        assertNotNull(clientResponse);\n        assertNull(clientResponse.getResourceExternalId());\n    }"}
{"prompt": "Create a test that tests when Auto External Id Config Is Off Create Client With Value", "completion": "    @Test\n    public void whenAutoExternalIdConfigIsOffCreateClientWithValue() {\n        // given\n        final String externalId = UUID.randomUUID().toString();\n        final String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON,\n                externalId);\n        // when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        // then\n        assertNotNull(clientResponse);\n        assertNotNull(clientResponse.getResourceExternalId());\n        assertEquals(externalId, clientResponse.getResourceExternalId());\n\n        fetchClientByExternalId(clientResponse.getResourceExternalId());\n    }"}
{"prompt": "Create a test that tests when Auto External Id Config Is On Create Client", "completion": "    @Test\n    public void whenAutoExternalIdConfigIsOnCreateClient() {\n        // given\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        final String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON,\n                null);\n        // when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        // then\n        assertNotNull(clientResponse);\n        assertNotNull(clientResponse.getResourceExternalId());\n        assertEquals(36, clientResponse.getResourceExternalId().length());\n\n        fetchClientByExternalId(clientResponse.getResourceExternalId());\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    }"}
{"prompt": "Create a test that tests when Auto External Id Config Is On Create Client With Value", "completion": "    @Test\n    public void whenAutoExternalIdConfigIsOnCreateClientWithValue() {\n        // given\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        final String externalId = UUID.randomUUID().toString();\n        final String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON,\n                externalId);\n        // when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        // then\n        assertNotNull(clientResponse);\n        assertNotNull(clientResponse.getResourceExternalId());\n        assertEquals(externalId, clientResponse.getResourceExternalId());\n\n        fetchClientByExternalId(clientResponse.getResourceExternalId());\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    }"}
{"prompt": "Create a test that tests test Client Status Using External Id", "completion": "    @Test\n    public void testClientStatusUsingExternalId() {\n        ClientHelper clientHelper = new ClientHelper(requestSpec, responseSpec);\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON, null);\n        final PostClientsResponse addClientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        final String clientExternalId = addClientResponse.getResourceExternalId();\n        final Long clientId = addClientResponse.getClientId();\n        assertNotNull(clientExternalId);\n        log.info(\"Client data id {} and external Id {}\", clientId, clientExternalId);\n\n        GetClientsClientIdResponse clientResponse = ClientHelper.getClientByExternalId(requestSpec, responseSpec, clientExternalId);\n        ClientStatusChecker.verifyClientStatus(ClientStatus.ACTIVE, clientResponse);\n        log.info(\"Client data id {} and status {}\", clientExternalId, clientResponse.getStatus().getCode());\n\n        // Close Client action\n        jsonPayload = clientHelper.getCloseClientAsJSON();\n        PostClientsClientIdResponse commandResponse = ClientHelper.performClientActionUsingExternalId(requestSpec, responseSpec,\n                clientExternalId, ClientHelper.CLOSE_CLIENT_COMMAND, jsonPayload);\n        assertNotNull(commandResponse);\n        assertNotNull(commandResponse.getResourceExternalId());\n        assertEquals(clientExternalId, commandResponse.getResourceExternalId());\n        log.info(\"Client data id {} and external Id {}\", commandResponse.getResourceId(), clientExternalId);\n        assertEquals(clientId.intValue(), commandResponse.getResourceId());\n\n        clientResponse = ClientHelper.getClientByExternalId(requestSpec, responseSpec, clientExternalId);\n        ClientStatusChecker.verifyClientStatus(ClientStatus.CLOSED, clientResponse);\n        log.info(\"Client data id {} and status {}\", clientExternalId, clientResponse.getStatus().getCode());\n\n        // Reactivate Client action\n        jsonPayload = clientHelper.getReactivateClientAsJSON();\n        commandResponse = ClientHelper.performClientActionUsingExternalId(requestSpec, responseSpec, clientExternalId,\n                ClientHelper.REACTIVATE_CLIENT_COMMAND, jsonPayload);\n        assertNotNull(commandResponse);\n        assertNotNull(commandResponse.getResourceExternalId());\n        assertEquals(clientExternalId, commandResponse.getResourceExternalId());\n        log.info(\"Client data id {} and external Id {}\", commandResponse.getResourceId(), clientExternalId);\n        assertEquals(clientId.intValue(), commandResponse.getResourceId());\n\n        clientResponse = ClientHelper.getClientByExternalId(requestSpec, responseSpec, clientExternalId);\n        ClientStatusChecker.verifyClientStatus(ClientStatus.PENDING, clientResponse);\n        log.info(\"Client data id {} and status {}\", clientExternalId, clientResponse.getStatus().getCode());\n\n        // Reject Client action\n        jsonPayload = clientHelper.getRejectClientAsJSON();\n        commandResponse = ClientHelper.performClientActionUsingExternalId(requestSpec, responseSpec, clientExternalId,\n                ClientHelper.REJECT_CLIENT_COMMAND, jsonPayload);\n        assertNotNull(commandResponse);\n        assertNotNull(commandResponse.getResourceExternalId());\n        assertEquals(clientExternalId, commandResponse.getResourceExternalId());\n        log.info(\"Client data id {} and external Id {}\", commandResponse.getResourceId(), clientExternalId);\n        assertEquals(clientId.intValue(), commandResponse.getResourceId());\n\n        clientResponse = ClientHelper.getClientByExternalId(requestSpec, responseSpec, clientExternalId);\n        ClientStatusChecker.verifyClientStatus(ClientStatus.REJECTED, clientResponse);\n        log.info(\"Client data id {} and status {}\", clientExternalId, clientResponse.getStatus().getCode());\n\n        // Activate Client action\n        jsonPayload = ClientHelper.getActivateClientAsJSON(ClientHelper.DEFAULT_DATE);\n        commandResponse = ClientHelper.performClientActionUsingExternalId(requestSpec, responseSpec, clientExternalId,\n                ClientHelper.ACTIVATE_CLIENT_COMMAND, jsonPayload);\n        assertNotNull(commandResponse);\n        assertNotNull(commandResponse.getResourceExternalId());\n        assertEquals(clientExternalId, commandResponse.getResourceExternalId());\n        log.info(\"Client data id {} and external Id {}\", commandResponse.getResourceId(), clientExternalId);\n        assertEquals(clientId.intValue(), commandResponse.getResourceId());\n\n        clientResponse = ClientHelper.getClientByExternalId(requestSpec, responseSpec, clientExternalId);\n        ClientStatusChecker.verifyClientStatus(ClientStatus.ACTIVE, clientResponse);\n        log.info(\"Client data id {} and status {}\", clientExternalId, clientResponse.getStatus().getCode());\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    }"}
{"prompt": "Create a test that tests test Update Client Using External Id", "completion": "    @Test\n    public void testUpdateClientUsingExternalId() {\n        // given\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON, null);\n        // when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        final String clientExternalId = clientResponse.getResourceExternalId();\n        jsonPayload = ClientHelper.getBasicClientAsJSON(null, ClientHelper.LEGALFORM_ID_PERSON, clientExternalId);\n        final PutClientsClientIdResponse clientUpdateResponse = ClientHelper.updateClient(requestSpec, responseSpec, clientExternalId,\n                jsonPayload);\n        // then\n        assertNotNull(clientUpdateResponse);\n        assertNotNull(clientUpdateResponse.getResourceExternalId());\n        assertEquals(clientExternalId, clientUpdateResponse.getResourceExternalId());\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    }"}
{"prompt": "Create a test that tests test Delete Client Using External Id", "completion": "    @Test\n    public void testDeleteClientUsingExternalId() {\n        // given\n        ClientHelper clientHelper = new ClientHelper(requestSpec, responseSpec);\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON, null);\n        // when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        final String clientExternalId = clientResponse.getResourceExternalId();\n        jsonPayload = clientHelper.getCloseClientAsJSON();\n        PostClientsClientIdResponse commandResponse = ClientHelper.performClientActionUsingExternalId(requestSpec, responseSpec,\n                clientExternalId, ClientHelper.CLOSE_CLIENT_COMMAND, jsonPayload);\n        jsonPayload = clientHelper.getReactivateClientAsJSON();\n        commandResponse = ClientHelper.performClientActionUsingExternalId(requestSpec, responseSpec, clientExternalId,\n                ClientHelper.REACTIVATE_CLIENT_COMMAND, jsonPayload);\n\n        // then\n        final DeleteClientsClientIdResponse clientDeleteResponse = ClientHelper.deleteClient(requestSpec, responseSpec, clientExternalId);\n        assertNotNull(clientDeleteResponse);\n        assertNotNull(clientDeleteResponse.getResourceExternalId());\n        assertEquals(clientExternalId, clientDeleteResponse.getResourceExternalId());\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    }"}
{"prompt": "Create a test that tests test Get Client Accounts Using External Id", "completion": "    @Test\n    public void testGetClientAccountsUsingExternalId() {\n        // given\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        final String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON,\n                null);\n        // when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        final String clientExternalId = clientResponse.getResourceExternalId();\n\n        GetClientsClientIdAccountsResponse clientAccountsResponse = ClientHelper.getClientAccounts(requestSpec, responseSpec,\n                clientExternalId);\n\n        // then\n        assertNotNull(clientAccountsResponse);\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    }"}
{"prompt": "Create a test that tests test Get Client Transfer Proposal Date", "completion": "    @Test\n    public void testGetClientTransferProposalDate() {\n        // given\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        final String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON,\n                null);\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        ResponseSpecification response204Spec = new ResponseSpecBuilder().expectStatusCode(204).build();\n\n        // when\n        final String clientExternalId = clientResponse.getResourceExternalId();\n        final GetClientTransferProposalDateResponse transferProposalDateResponse = ClientHelper.getProposedTransferDate(requestSpec,\n                response204Spec, clientExternalId);\n\n        fetchClientByExternalId(clientResponse.getResourceExternalId());\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    }"}
{"prompt": "Create a test that tests test Get Client Obligee Data", "completion": "    @Test\n    public void testGetClientObligeeData() {\n        // given\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, true);\n        final String jsonPayload = ClientHelper.getBasicClientAsJSON(ClientHelper.DEFAULT_OFFICE_ID, ClientHelper.LEGALFORM_ID_PERSON,\n                null);\n        // when\n        final PostClientsResponse clientResponse = ClientHelper.addClientAsPerson(requestSpec, responseSpec, jsonPayload);\n        final String clientExternalId = clientResponse.getResourceExternalId();\n        final List<GetObligeeData> obligeeDataResponse = ClientHelper.getObligeeData(requestSpec, responseSpec, clientExternalId);\n\n        // then\n        assertNotNull(obligeeDataResponse);\n\n        fetchClientByExternalId(clientResponse.getResourceExternalId());\n\n        GlobalConfigurationHelper.manageConfigurations(requestSpec, responseSpec,\n                GlobalConfigurationHelper.ENABLE_AUTOGENERATED_EXTERNAL_ID, false);\n    }"}
{"prompt": "Create a test that tests check New Client Loan Charge Saves External Id", "completion": "    @Test\n    public void checkNewClientLoanChargeSavesExternalId() {\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, null, null, \"12,000.00\", collaterals);\n        HashMap loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID, \"12,000.00\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final Integer charge = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\", false));\n\n        final float amount = 1.0f;\n        final String externalId = \"extId\" + loanID.toString();\n        final Integer chargeID = this.loanTransactionHelper.addChargesForLoan(loanID,\n                getLoanChargeAsJSON(String.valueOf(charge), \"22 September 2011\", String.valueOf(amount), externalId));\n        Assertions.assertNotNull(chargeID);\n\n        HashMap loanChargeMap = this.loanTransactionHelper.getLoanCharge(loanID, chargeID);\n        Assertions.assertNotNull(loanChargeMap.get(\"externalId\"));\n        Assertions.assertEquals(loanChargeMap.get(\"externalId\"), externalId, \"Incorrect External Id Saved\");\n\n    }"}
{"prompt": "Create a test that tests check New Client Loan Charge Finds Duplicate External Id", "completion": "    @Test\n    public void checkNewClientLoanChargeFindsDuplicateExternalId() {\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, null, null, \"12,000.00\", collaterals);\n        HashMap loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID, \"12,000.00\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final Integer charge = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\", false));\n\n        final String externalId = \"extId\" + loanID.toString();\n        final float amount = 1.0f;\n        final Integer chargeID = this.loanTransactionHelper.addChargesForLoan(loanID,\n                getLoanChargeAsJSON(String.valueOf(charge), \"22 September 2011\", String.valueOf(amount), externalId));\n        Assertions.assertNotNull(chargeID);\n\n        final float amount2 = 2.0f;\n        ResponseSpecification responseSpec403 = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final Integer chargeID2 = this.loanTransactionHelper.addChargesForLoan(loanID,\n                getLoanChargeAsJSON(String.valueOf(charge), \"23 September 2011\", String.valueOf(amount2), externalId), responseSpec403);\n\n        Assertions.assertNull(chargeID2);\n    }"}
{"prompt": "Create a test that tests full Refund And Reverse Of Paid Charge Succeeds Test Active Active", "completion": "    @Test\n    public void fullRefundAndReverseOfPaidChargeSucceedsTest_Active_Active() {\n        testRefundAndReverseOfPaidChargeSucceeds(oneInstallment + fullChargeRefundAmount, fullChargeRefundAmount, ACTIVE, ACTIVE);\n    }"}
{"prompt": "Create a test that tests full Refund And Reverse Of Paid Charge Succeeds Test Active Com", "completion": "    @Test\n    public void fullRefundAndReverseOfPaidChargeSucceedsTest_Active_Com() {\n        testRefundAndReverseOfPaidChargeSucceeds(fullLoan, fullChargeRefundAmount, ACTIVE, CLOSED_OBLIGATION_MET);\n    }"}
{"prompt": "Create a test that tests full Refund And Reverse Of Paid Charge Succeeds Test Active Overpaid", "completion": "    @Test\n    public void fullRefundAndReverseOfPaidChargeSucceedsTest_Active_Overpaid() {\n        testRefundAndReverseOfPaidChargeSucceeds(fullLoan + 50.00f, fullChargeRefundAmount, ACTIVE, OVERPAID);\n    }"}
{"prompt": "Create a test that tests full Refund And Reverse Of Paid Charge Succeeds Test Com Overpaid", "completion": "    @Test\n    public void fullRefundAndReverseOfPaidChargeSucceedsTest_Com_Overpaid() {\n        testRefundAndReverseOfPaidChargeSucceeds(fullLoan + fullChargeRefundAmount, fullChargeRefundAmount, CLOSED_OBLIGATION_MET,\n                OVERPAID);\n    }"}
{"prompt": "Create a test that tests full Refund And Reverse Of Paid Charge Succeeds Test Overpaid Overpaid", "completion": "    @Test\n    public void fullRefundAndReverseOfPaidChargeSucceedsTest_Overpaid_Overpaid() {\n        testRefundAndReverseOfPaidChargeSucceeds(fullLoan + fullChargeRefundAmount + 50.00f, fullChargeRefundAmount, OVERPAID, OVERPAID);\n    }"}
{"prompt": "Create a test that tests partial Refund And Reverse Of Paid Charge Succeeds Test Active Active", "completion": "    @Test\n    public void partialRefundAndReverseOfPaidChargeSucceedsTest_Active_Active() {\n        testRefundAndReverseOfPaidChargeSucceeds(fullLoan, oneThirdChargeRefundAmount, ACTIVE, ACTIVE);\n    }"}
{"prompt": "Create a test that tests partial Refund And Reverse Of Paid Charge Succeeds Test Active Com", "completion": "    @Test\n    public void partialRefundAndReverseOfPaidChargeSucceedsTest_Active_Com() {\n        testRefundAndReverseOfPaidChargeSucceeds(fullLoan + (oneThirdChargeRefundAmount * 2), oneThirdChargeRefundAmount, ACTIVE,\n                CLOSED_OBLIGATION_MET);\n    }"}
{"prompt": "Create a test that tests partial Refund And Reverse Of Paid Charge Succeeds Test Active Overpaid", "completion": "    @Test\n    public void partialRefundAndReverseOfPaidChargeSucceedsTest_Active_Overpaid() {\n        testRefundAndReverseOfPaidChargeSucceeds(fullLoan + (oneThirdChargeRefundAmount * 2) + 1.0f, oneThirdChargeRefundAmount, ACTIVE,\n                OVERPAID);\n    }"}
{"prompt": "Create a test that tests refund Of Unpaid Charge Fails Test", "completion": "    @Test\n    public void refundOfUnpaidChargeFailsTest() {\n\n        final Float repaymentAmount = 3000.00f; // pays installment one but none of added charge\n        Integer loanChargeId = disburseAddChargeAndRepay(repaymentAmount, ACTIVE, NONE, false);\n\n        LOG.info(\"-------------Loancharge Refund -----------\");\n        final Float refundAmount = 60.00f;\n        final Integer installmentNumber = null;\n        final String externalId = null;\n        ArrayList<HashMap> errors = (ArrayList<HashMap>) this.loanTransactionHelperValidationError.loanChargeRefund(loanChargeId,\n                installmentNumber, refundAmount, externalId, this.disbursedLoanID, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.loan.charge.transaction.amount.is.more.than.is.refundable\",\n                errors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n    }"}
{"prompt": "Create a test that tests refunding More Than Paid Fails Test", "completion": "    @Test\n    public void refundingMoreThanPaidFailsTest() {\n\n        final Float repaymentAmount = 3090.00f; // pays installment one and 90 (not all) of added charge\n        Integer loanChargeId = disburseAddChargeAndRepay(repaymentAmount, ACTIVE, NONE, false);\n\n        LOG.info(\"-------------Loancharge Refund -----------\");\n        final Float refundAmount = 90.01f; // 0.01 more than paid.\n        final Integer installmentNumber = null;\n        final String externalId = null;\n        ArrayList<HashMap> errors = (ArrayList<HashMap>) this.loanTransactionHelperValidationError.loanChargeRefund(loanChargeId,\n                installmentNumber, refundAmount, externalId, this.disbursedLoanID, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.loan.charge.transaction.amount.is.more.than.is.refundable\",\n                errors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    }"}
{"prompt": "Create a test that tests ony Refund Element Not Repayment Element Used To Calculate Refundable Amount Test", "completion": "    @Test\n    public void onyRefundElementNotRepaymentElementUsedToCalculateRefundableAmountTest() {\n        final Float chargeAmountPaid = 60.00f;\n        final Float repaymentAmount = 3000.00f + chargeAmountPaid;\n        // covers Installment 1 plus half of 120 charge added to installment 2\n        Integer loanChargeId = disburseAddChargeAndRepay(repaymentAmount, ACTIVE, NONE, false);\n\n        LOG.info(\"-------------Loancharge Refund 1 -----------\");\n        final Float refundAmount = chargeAmountPaid; // refund charge paid\n        final Integer installmentNumber = null;\n        final String externalId = null;\n        Integer chargeRefundTxnId = (Integer) this.loanTransactionHelper.loanChargeRefund(loanChargeId, installmentNumber, refundAmount,\n                externalId, this.disbursedLoanID, \"resourceId\");\n        HashMap loanDetailsHashMap = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec,\n                disbursedLoanID, \"\");\n        // refund 60 pays off remainder of charge leaving an amount 60 that could be refunded\n\n        LOG.info(\"-------------Loancharge Refund 2 -----------\");\n        final Float smallRefund = 0.01f;\n        chargeRefundTxnId = (Integer) this.loanTransactionHelper.loanChargeRefund(loanChargeId, installmentNumber, smallRefund, externalId,\n                this.disbursedLoanID, \"resourceId\");\n        loanDetailsHashMap = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, disbursedLoanID, \"\");\n\n    }"}
{"prompt": "Create a test that tests refund Of Partially Paid Charge Can Repay More Of Same Charge Test", "completion": "    @Test\n    public void refundOfPartiallyPaidChargeCanRepayMoreOfSameChargeTest() {\n        final Float chargeAmountPaid = 80.00f;\n        final Float chargeAmountFull = 120.00f;\n        final Float chargeAmountOutstanding = chargeAmountFull - chargeAmountPaid;\n        final Float repaymentAmount = 3000.00f + chargeAmountPaid;\n        // covers Installment 1 plus two thirds of 120 charge added to installment 2\n        Integer loanChargeId = disburseAddChargeAndRepay(repaymentAmount, ACTIVE, NONE, false);\n        Float feeChargesPaid = getLoanDetailsSummaryfeeChargesPaid(disbursedLoanID);\n        Assertions.assertEquals(feeChargesPaid, chargeAmountPaid, \"Incorrect Partial feeChargesPaid\");\n\n        LOG.info(\"-------------Loancharge Refund -----------\");\n        final Float refundAmount = chargeAmountPaid; // refund charge paid\n        final Integer installmentNumber = null;\n        final String externalId = null;\n        Integer chargeRefundTxnId = (Integer) this.loanTransactionHelper.loanChargeRefund(loanChargeId, installmentNumber, refundAmount,\n                externalId, this.disbursedLoanID, \"resourceId\");\n        feeChargesPaid = getLoanDetailsSummaryfeeChargesPaid(disbursedLoanID);\n        Assertions.assertEquals(feeChargesPaid, chargeAmountFull, \"Incorrect Full feeChargesPaid\");\n\n        ArrayList<HashMap> loanChargePaidByList = (ArrayList<HashMap>) this.loanTransactionHelper.getLoanTransactionDetails(disbursedLoanID,\n                chargeRefundTxnId, \"loanChargePaidByList\");\n        Assertions.assertNotNull(loanChargePaidByList);\n        Assertions.assertEquals(loanChargePaidByList.size(), 2);\n        // expecting 2 entries 1)-80 refund 2) 40 repayment\n        Float paidByAmount1 = (Float) loanChargePaidByList.get(0).get(\"amount\");\n        Assertions.assertNotNull(paidByAmount1);\n        Assertions.assertNotEquals(paidByAmount1, 0.0f);\n        Float paidByAmount2 = (Float) loanChargePaidByList.get(1).get(\"amount\");\n        Assertions.assertNotNull(paidByAmount2);\n        Assertions.assertNotEquals(paidByAmount2, 0.0f);\n\n        if (paidByAmount1 < 0.0f) {\n            Assertions.assertEquals(paidByAmount1, chargeAmountPaid * -1, \"Refund Element Incorrect\");\n        } else {\n            Assertions.assertEquals(paidByAmount1, chargeAmountOutstanding, \"Repayment Element Incorrect\");\n        }\n        if (paidByAmount2 < 0.0f) {\n            Assertions.assertEquals(paidByAmount2, chargeAmountPaid * -1, \"Refund Element Incorrect\");\n        } else {\n            Assertions.assertEquals(paidByAmount2, chargeAmountOutstanding, \"Repayment Element Incorrect\");\n        }\n\n    }"}
{"prompt": "Create a test that tests charge Refund Creates Correct Journal Entries For Periodic Accruals Fee Test", "completion": "    @Test\n    public void chargeRefundCreatesCorrectJournalEntriesForPeriodicAccruals_Fee_Test() {\n        chargeRefundCreatesCorrectJournalEntries(ACCRUAL_PERIODIC, false);\n    }"}
{"prompt": "Create a test that tests charge Refund Creates Correct Journal Entries For Cash Accounting Fee Test", "completion": "    @Test\n    public void chargeRefundCreatesCorrectJournalEntriesForCashAccounting_Fee_Test() {\n        chargeRefundCreatesCorrectJournalEntries(CASH_BASED, false);\n    }"}
{"prompt": "Create a test that tests charge Refund Creates Correct Journal Entries For Periodic Accruals Penalty Test", "completion": "    @Test\n    public void chargeRefundCreatesCorrectJournalEntriesForPeriodicAccruals_Penalty_Test() {\n        chargeRefundCreatesCorrectJournalEntries(ACCRUAL_PERIODIC, true);\n    }"}
{"prompt": "Create a test that tests charge Refund Creates Correct Journal Entries For Cash Accounting Penalty Test", "completion": "    @Test\n    public void chargeRefundCreatesCorrectJournalEntriesForCashAccounting_Penalty_Test() {\n        chargeRefundCreatesCorrectJournalEntries(CASH_BASED, true);\n    }"}
{"prompt": "Create a test that tests repayment Reversal Disallowed If Later Charge Refund Test", "completion": "    @Test\n    public void repaymentReversalDisallowedIfLaterChargeRefundTest() {\n\n        // repayment covers 2 installments plus charge\n        final Float repaymentAmount = oneInstallment + oneInstallment + fullChargeRefundAmount;\n        final Integer loanChargeId = disburseAddChargeAndRepay(repaymentAmount, ACTIVE, ACCRUAL_PERIODIC, false);\n        final Integer repayment1Id = createdRepaymentTypeResourceId;\n\n        final String repayment2Date = \"20 January 2022\";\n        final Float repayment2Amount = oneInstallment; // installment 3\n        makeRepaymentType(MAKE_REPAYMENT_COMMAND, repayment2Date, repayment2Amount);\n        Integer repayment2Id = createdRepaymentTypeResourceId;\n\n        LOG.info(\"-------------Loancharge Refund -----------\");\n        final Integer installmentNumber = null;\n        final String externalId = null;\n        final Integer chargeRefundTxnId = (Integer) this.loanTransactionHelper.loanChargeRefund(loanChargeId, installmentNumber,\n                oneThirdChargeRefundAmount, externalId, this.disbursedLoanID, \"resourceId\");\n\n        final String reverseDate = getTodaysDate();\n        final Float adjustmentAmount = 0.0f;\n        LOG.info(\"-------------Reverse Repayment 2  -----------\");\n        ArrayList<HashMap> errors = (ArrayList<HashMap>) this.loanTransactionHelperValidationError.adjustLoanTransaction(disbursedLoanID,\n                repayment2Id, reverseDate, adjustmentAmount.toString(), CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.loan.transaction.cant.be.reversed.because.later.charge.refund.exists\",\n                errors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n    }"}
{"prompt": "Create a test that tests repayment Not Allowed If Later Charge Refund Test", "completion": "    @Test\n    public void repaymentNotAllowedIfLaterChargeRefundTest() {\n\n        // repayment covers 2 installments plus charge\n        final Float repaymentAmount = oneInstallment + oneInstallment + fullChargeRefundAmount;\n        final Integer loanChargeId = disburseAddChargeAndRepay(repaymentAmount, ACTIVE, ACCRUAL_PERIODIC, false);\n\n        LOG.info(\"-------------Loancharge Refund -----------\");\n        final Integer installmentNumber = null;\n        final String externalId = null;\n        final Integer chargeRefundTxnId = (Integer) this.loanTransactionHelper.loanChargeRefund(loanChargeId, installmentNumber,\n                oneThirdChargeRefundAmount, externalId, this.disbursedLoanID, \"resourceId\");\n\n        final String repayment2Date = \"20 January 2022\";\n        final Float repayment2Amount = oneInstallment; // installment 3\n        ArrayList<HashMap> errors = (ArrayList<HashMap>) this.loanTransactionHelperValidationError.makeRepaymentTypePayment(\n                MAKE_REPAYMENT_COMMAND, repayment2Date, repayment2Amount, this.disbursedLoanID, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.loan.transaction.cant.be.created.because.later.charge.refund.exists\",\n                errors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    }"}
{"prompt": "Create a test that tests credit Balance Refund Can Only Be Applied Where Loan Status Is Overpaid Test", "completion": "    @Test\n    public void creditBalanceRefundCanOnlyBeAppliedWhereLoanStatusIsOverpaidTest() {\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanStatusHashMap = makeRepayment(\"06 January 2022\", 2000.00f); // not full payment\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        final Float refund = 1000.00f;\n        final String externalId = null;\n        ArrayList<HashMap> cbrErrors = (ArrayList<HashMap>) loanTransactionHelperValidationError\n                .creditBalanceRefund(creditBalanceRefundDate, refund, externalId, disbursedLoanID, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.loan.credit.balance.refund.account.is.not.overpaid\",\n                cbrErrors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    }"}
{"prompt": "Create a test that tests cant Refund More Than Overpaid Test", "completion": "    @Test\n    public void cantRefundMoreThanOverpaidTest() {\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanStatusHashMap = makeRepayment(\"06 January 2022\", 20000.00f); // overpayment\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        Float refund = 10000.00f;\n        final String externalId = null;\n        ArrayList<HashMap> cbrErrors = (ArrayList<HashMap>) loanTransactionHelperValidationError\n                .creditBalanceRefund(creditBalanceRefundDate, refund, externalId, disbursedLoanID, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.transactionAmount.invalid.must.be.>zero.and<=overpaidamount\",\n                cbrErrors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        refund = (float) -1.00;\n        cbrErrors = (ArrayList<HashMap>) loanTransactionHelperValidationError.creditBalanceRefund(creditBalanceRefundDate, refund,\n                externalId, disbursedLoanID, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"validation.msg.loan.transaction.transactionAmount.not.greater.than.zero\",\n                cbrErrors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    }"}
{"prompt": "Create a test that tests full Refund Changes Status To Closed Obligation Met Test", "completion": "    @Test\n    public void fullRefundChangesStatusToClosedObligationMetTest() {\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanStatusHashMap = makeRepayment(\"06 January 2022\", 20000.00f); // overpayment\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n        final Float totalOverpaid = (Float) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, disbursedLoanID,\n                \"totalOverpaid\");\n\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        final String externalId = null;\n        loanTransactionHelper.creditBalanceRefund(creditBalanceRefundDate, totalOverpaid, externalId, disbursedLoanID, null);\n        loanStatusHashMap = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, disbursedLoanID,\n                \"status\");\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n        final Float floatZero = 0.0f;\n        Float totalOverpaidAtEnd = (Float) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, disbursedLoanID,\n                \"totalOverpaid\");\n        if (totalOverpaidAtEnd == null) {\n            totalOverpaidAtEnd = floatZero;\n        }\n        assertEquals(totalOverpaidAtEnd, floatZero);\n\n    }"}
{"prompt": "Create a test that tests partial Refund Keeps Overpaid Status Test", "completion": "    @Test\n    public void partialRefundKeepsOverpaidStatusTest() {\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanStatusHashMap = makeRepayment(\"06 January 2022\", 20000.00f); // overpayment\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n        final Float refund = 5000.00f; // partial refund\n\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        final String externalId = null;\n        loanTransactionHelper.creditBalanceRefund(creditBalanceRefundDate, refund, externalId, disbursedLoanID, null);\n        loanStatusHashMap = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, disbursedLoanID,\n                \"status\");\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests new Credit Balance Refund Saves External Id Test", "completion": "    @Test\n    public void newCreditBalanceRefundSavesExternalIdTest() {\n\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanStatusHashMap = makeRepayment(\"06 January 2022\", 20000.00f); // overpayment\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n        final Float refund = 1000.00f; // partial refund\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        final String externalId = \"cbrextID\" + disbursedLoanID.toString();\n        Integer resourceId = (Integer) loanTransactionHelper.creditBalanceRefund(creditBalanceRefundDate, refund, externalId,\n                disbursedLoanID, \"resourceId\");\n        Assertions.assertNotNull(resourceId);\n\n        HashMap creditBalanceRefundMap = (HashMap) this.loanTransactionHelper.getLoanTransactionDetails(disbursedLoanID, resourceId, \"\");\n        Assertions.assertNotNull(creditBalanceRefundMap.get(\"externalId\"));\n        Assertions.assertEquals(creditBalanceRefundMap.get(\"externalId\"), externalId, \"Incorrect External Id Saved\");\n\n    }"}
{"prompt": "Create a test that tests new Credit Balance Refund Finds Duplicate External Id Test", "completion": "    @Test\n    public void newCreditBalanceRefundFindsDuplicateExternalIdTest() {\n\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanStatusHashMap = makeRepayment(\"06 January 2022\", 20000.00f); // overpayment\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n        final Float refund = 1000.00f; // partial refund\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        final String externalId = \"cbrextID\" + disbursedLoanID.toString();\n        final Integer resourceId = (Integer) loanTransactionHelper.creditBalanceRefund(creditBalanceRefundDate, refund, externalId,\n                disbursedLoanID, \"resourceId\");\n        Assertions.assertNotNull(resourceId);\n\n        final Float refund2 = 10.00f; // partial refund\n        final String creditBalanceRefundDate2 = \"10 January 2022\";\n        ArrayList<HashMap> cbrErrors = (ArrayList<HashMap>) loanTransactionHelperValidationError\n                .creditBalanceRefund(creditBalanceRefundDate2, refund2, externalId, disbursedLoanID, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.loan.creditBalanceRefund.duplicate.externalId\",\n                cbrErrors.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    }"}
{"prompt": "Create a test that tests new Credit Balance Refund Creates Correct Journal Entries For Periodic Accruals Test", "completion": "    @Test\n    public void newCreditBalanceRefundCreatesCorrectJournalEntriesForPeriodicAccrualsTest() {\n\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanStatusHashMap = makeRepayment(\"06 January 2022\", 20000.00f); // overpayment\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n        final Float refund = 1000.00f; // partial refund\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        final String externalId = null;\n        final Integer resourceId = (Integer) loanTransactionHelper.creditBalanceRefund(creditBalanceRefundDate, refund, externalId,\n                disbursedLoanID, \"resourceId\");\n        Assertions.assertNotNull(resourceId);\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, creditBalanceRefundDate,\n                new JournalEntry(refund, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, creditBalanceRefundDate,\n                new JournalEntry(refund, JournalEntry.TransactionType.DEBIT));\n\n    }"}
{"prompt": "Create a test that tests new Credit Balance Refund Creates Correct Journal Entries For Cash Accounting Test", "completion": "    @Test\n    public void newCreditBalanceRefundCreatesCorrectJournalEntriesForCashAccountingTest() {\n\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanStatusHashMap = makeRepayment(\"08 January 2022\", 20000.00f); // overpayment\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n        final Float refund = 1000.00f; // partial refund\n        final String creditBalanceRefundDate = \"09 January 2022\";\n        final String externalId = null;\n        final Integer resourceId = (Integer) loanTransactionHelper.creditBalanceRefund(creditBalanceRefundDate, refund, externalId,\n                disbursedLoanID, \"resourceId\");\n        Assertions.assertNotNull(resourceId);\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, creditBalanceRefundDate,\n                new JournalEntry(refund, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, creditBalanceRefundDate,\n                new JournalEntry(refund, JournalEntry.TransactionType.DEBIT));\n\n    }"}
{"prompt": "Create a test that tests repayment Transaction Type Matches Test", "completion": "    @Test\n    public void repaymentTransactionTypeMatchesTest() {\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        verifyRepaymentTransactionTypeMatches(MERCHANT_ISSUED_REFUND);\n        verifyRepaymentTransactionTypeMatches(PAYOUT_REFUND);\n        verifyRepaymentTransactionTypeMatches(GOODWILL_CREDIT);\n\n    }"}
{"prompt": "Create a test that tests repayment Transaction Type When Paid Test", "completion": "    @Test\n    public void repaymentTransactionTypeWhenPaidTest() {\n        verifyRepaymentTransactionTypeWhenPaid(MERCHANT_ISSUED_REFUND);\n        verifyRepaymentTransactionTypeWhenPaid(PAYOUT_REFUND);\n        verifyRepaymentTransactionTypeWhenPaid(GOODWILL_CREDIT);\n        verifyRepaymentTransactionTypeWhenPaid(REPAYMENT);\n\n    }"}
{"prompt": "Create a test that tests good Will Credit Will Close The Loan Correctly", "completion": "    @Test\n    public void goodWillCreditWillCloseTheLoanCorrectly() {\n\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        // pay off all of principal, interest (no fees or penalties)\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float goodwillAmount = totalOutstanding;\n        final String goodwillDate = \"09 March 2022\";\n        HashMap loanStatusHashMap = (HashMap) this.loanTransactionHelper.makeRepaymentTypePayment(GOODWILL_CREDIT, goodwillDate,\n                goodwillAmount, this.disbursedLoanID, \"\");\n\n        GetLoansLoanIdResponse details = this.loanTransactionHelper.getLoan(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        Assertions.assertNull(details.getSummary().getInArrears());\n        Assertions.assertTrue(details.getStatus().getClosedObligationsMet());\n    }"}
{"prompt": "Create a test that tests payment Refund Will Close The Loan Correctly", "completion": "    @Test\n    public void paymentRefundWillCloseTheLoanCorrectly() {\n\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        // pay off all of principal, interest (no fees or penalties)\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float goodwillAmount = totalOutstanding;\n        final String goodwillDate = \"09 March 2022\";\n        HashMap loanStatusHashMap = (HashMap) this.loanTransactionHelper.makeRepaymentTypePayment(PAYOUT_REFUND, goodwillDate,\n                goodwillAmount, this.disbursedLoanID, \"\");\n\n        GetLoansLoanIdResponse details = this.loanTransactionHelper.getLoan(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        Assertions.assertNull(details.getSummary().getInArrears());\n        Assertions.assertTrue(details.getStatus().getClosedObligationsMet());\n    }"}
{"prompt": "Create a test that tests new Goodwill Credit Creates Correct Journal Entries For Periodic Accruals Test", "completion": "    @Test\n    public void newGoodwillCreditCreatesCorrectJournalEntriesForPeriodicAccrualsTest() {\n\n        disburseLoanOfAccountingRule(ACCRUAL_PERIODIC);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        // pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float goodwillAmount = totalOutstanding + overpaidAmount;\n        final Float goodwillAmountInExpense = principalOutstanding + overpaidAmount;\n        final String goodwillDate = \"09 January 2022\";\n        HashMap loanStatusHashMap = (HashMap) this.loanTransactionHelper.makeRepaymentTypePayment(GOODWILL_CREDIT, goodwillDate,\n                goodwillAmount, this.disbursedLoanID, \"\");\n\n        // only a single credit for principal and interest as test sets up same GL account for both (summed up)\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, goodwillDate,\n                new JournalEntry(totalOutstanding, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, goodwillDate,\n                new JournalEntry(overpaidAmount, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, goodwillDate,\n                new JournalEntry(goodwillAmountInExpense, JournalEntry.TransactionType.DEBIT));\n\n    }"}
{"prompt": "Create a test that tests new Goodwill Credit Creates Correct Journal Entries For Cash Accounting Test", "completion": "    @Test\n    public void newGoodwillCreditCreatesCorrectJournalEntriesForCashAccountingTest() {\n\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        // pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float goodwillAmount = totalOutstanding + overpaidAmount;\n        final Float goodwillAmountInExpense = principalOutstanding + overpaidAmount;\n        final String goodwillDate = \"09 January 2022\";\n        HashMap loanStatusHashMap = (HashMap) this.loanTransactionHelper.makeRepaymentTypePayment(GOODWILL_CREDIT, goodwillDate,\n                goodwillAmount, this.disbursedLoanID, \"\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, goodwillDate,\n                new JournalEntry(principalOutstanding, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, goodwillDate,\n                new JournalEntry(interestOutstanding, JournalEntry.TransactionType.CREDIT));\n\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, goodwillDate,\n                new JournalEntry(overpaidAmount, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, goodwillDate,\n                new JournalEntry(goodwillAmountInExpense, JournalEntry.TransactionType.DEBIT));\n\n    }"}
{"prompt": "Create a test that tests undo Good Will Credit Transaction Test", "completion": "    @Test\n    public void undoGoodWillCreditTransactionTest() {\n        // Given\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        // pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float transactionAmount = totalOutstanding + overpaidAmount;\n        final String transactionDate = \"09 January 2022\";\n        PostLoansLoanIdTransactionsResponse loanTransactionResponse = loanTransactionHelper.makeLoanRepayment(GOODWILL_CREDIT,\n                transactionDate, transactionAmount, this.disbursedLoanID);\n        Assertions.assertNotNull(loanTransactionResponse);\n        Assertions.assertNotNull(loanTransactionResponse.getResourceId());\n\n        // Then\n        loanTransactionHelper.reverseLoanTransaction(this.disbursedLoanID, loanTransactionResponse.getResourceId(), transactionDate,\n                responseSpec);\n    }"}
{"prompt": "Create a test that tests undo Payout Refund Transaction Test", "completion": "    @Test\n    public void undoPayoutRefundTransactionTest() {\n        // Given\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        // pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float transactionAmount = totalOutstanding + overpaidAmount;\n        final String transactionDate = \"09 January 2022\";\n        PostLoansLoanIdTransactionsResponse loanTransactionResponse = loanTransactionHelper.makeLoanRepayment(PAYOUT_REFUND,\n                transactionDate, transactionAmount, this.disbursedLoanID);\n        Assertions.assertNotNull(loanTransactionResponse);\n        Assertions.assertNotNull(loanTransactionResponse.getResourceId());\n\n        // Then\n        loanTransactionHelper.reverseLoanTransaction(this.disbursedLoanID, loanTransactionResponse.getResourceId(), transactionDate,\n                responseSpec);\n    }"}
{"prompt": "Create a test that tests undo Merchant Issued Refund Transaction Test", "completion": "    @Test\n    public void undoMerchantIssuedRefundTransactionTest() {\n        // Given\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        // pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float transactionAmount = totalOutstanding + overpaidAmount;\n        final String transactionDate = \"09 January 2022\";\n        PostLoansLoanIdTransactionsResponse loanTransactionResponse = loanTransactionHelper.makeLoanRepayment(MERCHANT_ISSUED_REFUND,\n                transactionDate, transactionAmount, this.disbursedLoanID);\n        Assertions.assertNotNull(loanTransactionResponse);\n        Assertions.assertNotNull(loanTransactionResponse.getResourceId());\n\n        // Then\n        loanTransactionHelper.reverseLoanTransaction(this.disbursedLoanID, loanTransactionResponse.getResourceId(), transactionDate,\n                responseSpec);\n    }"}
{"prompt": "Create a test that tests adjust Good Will Credit Transaction Test", "completion": "    @Test\n    public void adjustGoodWillCreditTransactionTest() {\n        // Given\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        // pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float transactionAmount = totalOutstanding + overpaidAmount;\n        final String transactionDate = \"09 January 2022\";\n        PostLoansLoanIdTransactionsResponse loanTransactionResponse = loanTransactionHelper.makeLoanRepayment(GOODWILL_CREDIT,\n                transactionDate, transactionAmount, this.disbursedLoanID);\n        Assertions.assertNotNull(loanTransactionResponse);\n        Assertions.assertNotNull(loanTransactionResponse.getResourceId());\n\n        // Then\n        loanTransactionHelper.adjustLoanTransaction(this.disbursedLoanID, loanTransactionResponse.getResourceId(), transactionDate,\n                responseSpec403);\n    }"}
{"prompt": "Create a test that tests adjust Payout Refund Transaction Test", "completion": "    @Test\n    public void adjustPayoutRefundTransactionTest() {\n        // Given\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        // pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float transactionAmount = totalOutstanding + overpaidAmount;\n        final String transactionDate = \"09 January 2022\";\n        PostLoansLoanIdTransactionsResponse loanTransactionResponse = loanTransactionHelper.makeLoanRepayment(PAYOUT_REFUND,\n                transactionDate, transactionAmount, this.disbursedLoanID);\n        Assertions.assertNotNull(loanTransactionResponse);\n        Assertions.assertNotNull(loanTransactionResponse.getResourceId());\n\n        // Then\n        loanTransactionHelper.adjustLoanTransaction(this.disbursedLoanID, loanTransactionResponse.getResourceId(), transactionDate,\n                responseSpec403);\n    }"}
{"prompt": "Create a test that tests adjust Merchant Issued Refund Transaction Test", "completion": "    @Test\n    public void adjustMerchantIssuedRefundTransactionTest() {\n        // Given\n        disburseLoanOfAccountingRule(CASH_BASED);\n        HashMap loanSummaryMap = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, disbursedLoanID);\n\n        // pay off all of principal, interest (no fees or penalties)\n        final Float principalOutstanding = (Float) loanSummaryMap.get(\"principalOutstanding\");\n        final Float interestOutstanding = (Float) loanSummaryMap.get(\"interestOutstanding\");\n        final Float totalOutstanding = (Float) loanSummaryMap.get(\"totalOutstanding\");\n        final Float overpaidAmount = 159.00f;\n        final Float transactionAmount = totalOutstanding + overpaidAmount;\n        final String transactionDate = \"09 January 2022\";\n        PostLoansLoanIdTransactionsResponse loanTransactionResponse = loanTransactionHelper.makeLoanRepayment(MERCHANT_ISSUED_REFUND,\n                transactionDate, transactionAmount, this.disbursedLoanID);\n        Assertions.assertNotNull(loanTransactionResponse);\n        Assertions.assertNotNull(loanTransactionResponse.getResourceId());\n\n        // Then\n        loanTransactionHelper.adjustLoanTransaction(this.disbursedLoanID, loanTransactionResponse.getResourceId(), transactionDate,\n                responseSpec403);\n    }"}
{"prompt": "Create a test that tests check Client Loan Create And Disburse Flow", "completion": "    @Test\n    public void checkClientLoanCreateAndDisburseFlow() {\n        // CREATE CLIENT\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, DATE_OF_JOINING);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        // CREATE LOAN PRODUCT\n        final Integer loanProductID = createLoanProduct();\n        // APPLY FOR LOAN\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"28 September 2010\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        // UNDO APPROVAL\n        loanStatusHashMap = this.loanTransactionHelper.undoApproval(loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------RE-APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 October 2010\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        // DISBURSE\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // PERFORM REPAYMENTS AND CHECK LOAN STATUS\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(1, 4000.0F, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 January 2011\", 540.0f, loanID);\n\n        // UNDO DISBURSE LOAN\n        loanStatusHashMap = this.loanTransactionHelper.undoDisbursal(loanID);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        // DIBURSE AGAIN\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // MAKE REPAYMENTS\n        final float repayment_with_interest = 540.0f;\n        final float repayment_without_interest = 500.0f;\n\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(1, 4000.0F, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 January 2011\", repayment_with_interest, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 March 2011\", repayment_with_interest, loanID);\n        this.loanTransactionHelper.waiveInterest(\"01 May 2011\", INTEREST_VALUE_AMOUNT, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 May 2011\", repayment_without_interest, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 July 2011\", repayment_with_interest, loanID);\n        this.loanTransactionHelper.waiveInterest(\"01 September 2011\", INTEREST_VALUE_AMOUNT, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 September 2011\", repayment_without_interest, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 November 2011\", repayment_with_interest, loanID);\n        this.loanTransactionHelper.waiveInterest(\"01 January 2012\", INTEREST_VALUE_AMOUNT, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 January 2012\", repayment_without_interest, loanID);\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(7, 1000.0f, loanID);\n\n        // WRITE OFF LOAN AND CHECK ACCOUNT IS CLOSED\n        LoanStatusChecker.verifyLoanAccountIsClosed(this.loanTransactionHelper.writeOffLoan(\"01 March 2012\", loanID));\n\n    }"}
{"prompt": "Create a test that tests validate Client Loan With Unique External Id", "completion": "    @Test\n    public void validateClientLoanWithUniqueExternalId() {\n        // Given\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification responseSpec403 = new ResponseSpecBuilder().expectStatusCode(403).build();\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        final String externalId = UUID.randomUUID().toString();\n\n        // When\n        final Integer loanID = applyForLoanApplicationWithExternalId(this.requestSpec, this.responseSpec, clientID, loanProductID,\n                \"12,000.00\", externalId);\n\n        // Then\n        assertNotNull(loanID);\n        applyForLoanApplicationWithExternalId(this.requestSpec, responseSpec403, clientID, loanProductID, \"12,000.00\", externalId);\n    }"}
{"prompt": "Create a test that tests test Adding Loan Charge Includes Loan Id In The Response", "completion": "    @Test\n    public void testAddingLoanChargeIncludesLoanIdInTheResponse() {\n        // given\n        loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Integer loanProductId = createLoanProduct(false, NONE);\n        Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientId), collateralId);\n        List<HashMap> collaterals = List.of(collaterals(clientCollateralId, BigDecimal.ONE));\n\n        Integer chargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\"));\n        List<HashMap> charges = List.of(charges(chargeId, \"1\", null));\n        // when\n        Integer loanId = applyForLoanApplication(clientId, loanProductId, charges, null, \"12,000.00\", collaterals);\n        // then\n        List<HashMap> loanCharges = loanTransactionHelper.getLoanCharges(loanId);\n        Integer loanChargeId = (Integer) loanCharges.get(0).get(\"id\");\n        HashMap loanChargeDetail = loanTransactionHelper.getLoanCharge(loanId, loanChargeId);\n        assertEquals(loanId, loanChargeDetail.get(\"loanId\"));\n    }"}
{"prompt": "Create a test that tests test Loan Charges DISBURSEMENT FEE", "completion": "    @Test\n    public void testLoanCharges_DISBURSEMENT_FEE() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        List<HashMap> charges = new ArrayList<>();\n        Integer flatDisbursement = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper.getLoanDisbursementJSON());\n\n        Integer amountPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\"));\n        addCharges(charges, amountPercentage, \"1\", null);\n        Integer amountPlusInterestPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\"));\n        addCharges(charges, amountPlusInterestPercentage, \"1\", null);\n        Integer interestPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_INTEREST, \"1\"));\n        addCharges(charges, interestPercentage, \"1\", null);\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap disbursementDetail = loanSchedule.get(0);\n\n        List<HashMap> loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n\n        validateCharge(amountPercentage, loanCharges, \"1.0\", \"120.0\", \"0.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"1.0\", \"6.06\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"1.0\", \"126.06\", \"0.0\", \"0.0\");\n\n        validateNumberForEqual(\"252.12\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getDisbursementChargesForLoanAsJSON(String.valueOf(flatDisbursement)));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        disbursementDetail = loanSchedule.get(0);\n\n        validateCharge(flatDisbursement, loanCharges, \"100.0\", \"100.0\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"352.12\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        this.loanTransactionHelper.updateChargesForLoan(loanID, (Integer) getloanCharge(amountPercentage, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"2\"));\n        this.loanTransactionHelper.updateChargesForLoan(loanID, (Integer) getloanCharge(interestPercentage, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"2\"));\n        this.loanTransactionHelper.updateChargesForLoan(loanID,\n                (Integer) getloanCharge(amountPlusInterestPercentage, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"2\"));\n        this.loanTransactionHelper.updateChargesForLoan(loanID, (Integer) getloanCharge(flatDisbursement, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"150\"));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        disbursementDetail = loanSchedule.get(0);\n        validateCharge(amountPercentage, loanCharges, \"2.0\", \"240.0\", \"0.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"2.0\", \"12.12\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"2.0\", \"252.12\", \"0.0\", \"0.0\");\n        validateCharge(flatDisbursement, loanCharges, \"150.0\", \"150.0\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"654.24\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        this.loanTransactionHelper.updateLoan(loanID,\n                updateLoanJson(clientID, loanProductID, copyChargesForUpdate(loanCharges, null, null), null, collaterals));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        disbursementDetail = loanSchedule.get(0);\n        validateCharge(amountPercentage, loanCharges, \"2.0\", \"200.0\", \"0.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"2.0\", \"10.1\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"2.0\", \"210.1\", \"0.0\", \"0.0\");\n        validateCharge(flatDisbursement, loanCharges, \"150.0\", \"150.0\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"570.2\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        this.loanTransactionHelper.updateLoan(loanID,\n                updateLoanJson(clientID, loanProductID, copyChargesForUpdate(loanCharges, flatDisbursement, \"1\"), null, collaterals));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        disbursementDetail = loanSchedule.get(0);\n        validateCharge(amountPercentage, loanCharges, \"1.0\", \"100.0\", \"0.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"1.0\", \"5.05\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"1.0\", \"105.05\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"210.1\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        charges.clear();\n        addCharges(charges, flatDisbursement, \"100\", null);\n        this.loanTransactionHelper.updateLoan(loanID, updateLoanJson(clientID, loanProductID, charges, null, collaterals));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        disbursementDetail = loanSchedule.get(0);\n        validateCharge(flatDisbursement, loanCharges, \"100.0\", \"100.0\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"100.0\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        this.loanTransactionHelper.deleteChargesForLoan(loanID, (Integer) getloanCharge(flatDisbursement, loanCharges).get(\"id\"));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        disbursementDetail = loanSchedule.get(0);\n        Assertions.assertEquals(0, loanCharges.size());\n        validateNumberForEqual(\"0.0\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n    }"}
{"prompt": "Create a test that tests test Loan Charges DISBURSEMENT FEE WITH AMOUNT CHANGE", "completion": "    @Test\n    public void testLoanCharges_DISBURSEMENT_FEE_WITH_AMOUNT_CHANGE() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        List<HashMap> charges = new ArrayList<>();\n        Integer amountPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\"));\n        addCharges(charges, amountPercentage, \"1\", null);\n        Integer amountPlusInterestPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\"));\n        addCharges(charges, amountPlusInterestPercentage, \"1\", null);\n        Integer interestPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_INTEREST, \"1\"));\n        addCharges(charges, interestPercentage, \"1\", null);\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap disbursementDetail = loanSchedule.get(0);\n\n        List<HashMap> loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n\n        validateCharge(amountPercentage, loanCharges, \"1.0\", \"120.0\", \"0.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"1.0\", \"6.06\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"1.0\", \"126.06\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"252.12\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        // DISBURSE\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID, \"10000\",\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        disbursementDetail = loanSchedule.get(0);\n\n        validateCharge(amountPercentage, loanCharges, \"1.0\", \"0.0\", \"100.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"1.0\", \"0.0\", \"5.05\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"1.0\", \"0.0\", \"105.05\", \"0.0\");\n        validateNumberForEqual(\"210.1\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n    }"}
{"prompt": "Create a test that tests test Loan Disbursed Today Is Retrieved", "completion": "    @Test\n    public void testLoanDisbursedTodayIsRetrieved() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"5\", null);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        // DISBURSE on todays date so that loan can't be in arrears\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID, \"10000\",\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        // Test added because loans created without arrears were failing to be retrieved (associations=all) due to inner\n        // join on m_loan_arrears_aging (now left join)\n        Assertions.assertNotNull(loanDetails, \"Empty Loan Details\");\n        Assertions.assertNotNull(JsonPath.from(loanDetails).get(\"id\"), \"No id Found\");\n\n    }"}
{"prompt": "Create a test that tests test Loan Charges SPECIFIED DUE DATE FEE", "completion": "    @Test\n    public void testLoanCharges_SPECIFIED_DUE_DATE_FEE() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        List<HashMap> charges = new ArrayList<>();\n        Integer flat = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"100\", false));\n        Integer flatAccTransfer = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateWithAccountTransferJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"100\", false));\n\n        Integer amountPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\", false));\n        addCharges(charges, amountPercentage, \"1\", \"29 September 2011\");\n        Integer amountPlusInterestPercentage = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\", false));\n        addCharges(charges, amountPlusInterestPercentage, \"1\", \"29 September 2011\");\n        Integer interestPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_INTEREST, \"1\", false));\n        addCharges(charges, interestPercentage, \"1\", \"29 September 2011\");\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap firstInstallment = loanSchedule.get(1);\n\n        List<HashMap> loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n\n        validateCharge(amountPercentage, loanCharges, \"1.0\", \"120.0\", \"0.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"1.0\", \"6.06\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"1.0\", \"126.06\", \"0.0\", \"0.0\");\n\n        validateNumberForEqual(\"252.12\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flat), \"29 September 2011\", \"100\"));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        firstInstallment = loanSchedule.get(1);\n\n        validateCharge(flat, loanCharges, \"100.0\", \"100.0\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"352.12\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        this.loanTransactionHelper.updateChargesForLoan(loanID, (Integer) getloanCharge(amountPercentage, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"2\"));\n        this.loanTransactionHelper.updateChargesForLoan(loanID, (Integer) getloanCharge(interestPercentage, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"2\"));\n        this.loanTransactionHelper.updateChargesForLoan(loanID,\n                (Integer) getloanCharge(amountPlusInterestPercentage, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"2\"));\n        this.loanTransactionHelper.updateChargesForLoan(loanID, (Integer) getloanCharge(flat, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"150\"));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        firstInstallment = loanSchedule.get(1);\n        validateCharge(amountPercentage, loanCharges, \"2.0\", \"240.0\", \"0.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"2.0\", \"12.12\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"2.0\", \"252.12\", \"0.0\", \"0.0\");\n        validateCharge(flat, loanCharges, \"150.0\", \"150.0\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"654.24\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        final Integer savingsId = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID,\n                MINIMUM_OPENING_BALANCE);\n        this.loanTransactionHelper.updateLoan(loanID, updateLoanJson(clientID, loanProductID, copyChargesForUpdate(loanCharges, null, null),\n                String.valueOf(savingsId), collaterals));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        firstInstallment = loanSchedule.get(1);\n        validateCharge(amountPercentage, loanCharges, \"2.0\", \"200.0\", \"0.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"2.0\", \"10.1\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"2.0\", \"210.1\", \"0.0\", \"0.0\");\n        validateCharge(flat, loanCharges, \"150.0\", \"150.0\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"570.2\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        this.loanTransactionHelper.updateLoan(loanID,\n                updateLoanJson(clientID, loanProductID, copyChargesForUpdate(loanCharges, flat, \"1\"), null, collaterals));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        firstInstallment = loanSchedule.get(1);\n        validateCharge(amountPercentage, loanCharges, \"1.0\", \"100.0\", \"0.0\", \"0.0\");\n        validateCharge(interestPercentage, loanCharges, \"1.0\", \"5.05\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentage, loanCharges, \"1.0\", \"105.05\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"210.1\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        charges.clear();\n        addCharges(charges, flat, \"100\", \"29 September 2011\");\n        this.loanTransactionHelper.updateLoan(loanID, updateLoanJson(clientID, loanProductID, charges, null, collaterals));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        firstInstallment = loanSchedule.get(1);\n        validateCharge(flat, loanCharges, \"100.0\", \"100.0\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"100.0\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        this.loanTransactionHelper.deleteChargesForLoan(loanID, (Integer) getloanCharge(flat, loanCharges).get(\"id\"));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        firstInstallment = loanSchedule.get(1);\n        Assertions.assertEquals(0, loanCharges.size());\n        validateNumberForEqual(\"0\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatAccTransfer), \"29 September 2011\", \"100\"));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        firstInstallment = loanSchedule.get(1);\n        validateCharge(flatAccTransfer, loanCharges, \"100.0\", \"100.0\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"100.0\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        // DISBURSE\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID, \"10000\",\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(amountPercentage), \"29 September 2011\", \"1\"));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        firstInstallment = loanSchedule.get(1);\n        validateCharge(amountPercentage, loanCharges, \"1.0\", \"100.0\", \"0.0\", \"0.0\");\n        validateCharge(flatAccTransfer, loanCharges, \"100.0\", \"100.0\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"200.0\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        this.loanTransactionHelper.waiveChargesForLoan(loanID, (Integer) getloanCharge(amountPercentage, loanCharges).get(\"id\"), \"\");\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        firstInstallment = loanSchedule.get(1);\n        validateCharge(amountPercentage, loanCharges, \"1.0\", \"0.0\", \"0.0\", \"100.0\");\n        validateCharge(flatAccTransfer, loanCharges, \"100.0\", \"100.0\", \"0.0\", \"0.0\");\n        validateNumberForEqual(\"200.0\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n        validateNumberForEqual(\"100.0\", String.valueOf(firstInstallment.get(\"feeChargesOutstanding\")));\n        validateNumberForEqual(\"100.0\", String.valueOf(firstInstallment.get(\"feeChargesWaived\")));\n\n        this.loanTransactionHelper.payChargesForLoan(loanID, (Integer) getloanCharge(flatAccTransfer, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getPayChargeJSON(SavingsAccountHelper.TRANSACTION_DATE, null));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        firstInstallment = loanSchedule.get(1);\n        validateCharge(amountPercentage, loanCharges, \"1.0\", \"0.0\", \"0.0\", \"100.0\");\n        validateCharge(flatAccTransfer, loanCharges, \"100.0\", \"0.0\", \"100.0\", \"0.0\");\n        validateNumberForEqual(\"200.0\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n        validateNumberForEqual(\"100.0\", String.valueOf(firstInstallment.get(\"feeChargesWaived\")));\n        validateNumberForEqual(\"100.0\", String.valueOf(firstInstallment.get(\"feeChargesPaid\")));\n        validateNumberForEqual(\"0.0\", String.valueOf(firstInstallment.get(\"feeChargesOutstanding\")));\n    }"}
{"prompt": "Create a test that tests test Loan Charges INSTALMENT FEE", "completion": "    @Test\n    public void testLoanCharges_INSTALMENT_FEE() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        List<HashMap> charges = new ArrayList<>();\n        Integer flat = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n        Integer flatAccTransfer = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentWithAccountTransferJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n\n        Integer amountPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\", false));\n        addCharges(charges, amountPercentage, \"1\", \"29 September 2011\");\n        Integer amountPlusInterestPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\", false));\n        addCharges(charges, amountPlusInterestPercentage, \"1\", \"29 September 2011\");\n        Integer interestPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_INTEREST, \"1\", false));\n        addCharges(charges, interestPercentage, \"1\", \"29 September 2011\");\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanSchedule.remove(0);\n        List<HashMap> loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n\n        Float totalPerOfAmout = 0F;\n        Float totalPerOfAmoutPlusInt = 0F;\n        Float totalPerOfint = 0F;\n        for (HashMap installment : loanSchedule) {\n            Float principalDue = (Float) installment.get(\"principalDue\");\n            Float interestDue = (Float) installment.get(\"interestDue\");\n            Float principalFee = principalDue / 100;\n            Float interestFee = interestDue / 100;\n            Float totalInstallmentFee = (principalFee * 2) + (interestFee * 2);\n            validateNumberForEqualExcludePrecission(String.valueOf(totalInstallmentFee), String.valueOf(installment.get(\"feeChargesDue\")));\n            totalPerOfAmout = totalPerOfAmout + principalFee;\n            totalPerOfAmoutPlusInt = totalPerOfAmoutPlusInt + principalFee + interestFee;\n            totalPerOfint = totalPerOfint + interestFee;\n        }\n\n        validateChargeExcludePrecission(amountPercentage, loanCharges, \"1.0\", String.valueOf(totalPerOfAmout), \"0.0\", \"0.0\");\n        validateChargeExcludePrecission(interestPercentage, loanCharges, \"1.0\", String.valueOf(totalPerOfint), \"0.0\", \"0.0\");\n        validateChargeExcludePrecission(amountPlusInterestPercentage, loanCharges, \"1.0\", String.valueOf(totalPerOfAmoutPlusInt), \"0.0\",\n                \"0.0\");\n\n        this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getInstallmentChargesForLoanAsJSON(String.valueOf(flat), \"50\"));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanSchedule.remove(0);\n        totalPerOfAmout = 0F;\n        totalPerOfAmoutPlusInt = 0F;\n        totalPerOfint = 0F;\n        for (HashMap installment : loanSchedule) {\n            Float principalDue = (Float) installment.get(\"principalDue\");\n            Float interestDue = (Float) installment.get(\"interestDue\");\n            Float principalFee = principalDue / 100;\n            Float interestFee = interestDue / 100;\n            Float totalInstallmentFee = (principalFee * 2) + (interestFee * 2) + 50;\n            validateNumberForEqualExcludePrecission(String.valueOf(totalInstallmentFee), String.valueOf(installment.get(\"feeChargesDue\")));\n            totalPerOfAmout = totalPerOfAmout + principalFee;\n            totalPerOfAmoutPlusInt = totalPerOfAmoutPlusInt + principalFee + interestFee;\n            totalPerOfint = totalPerOfint + interestFee;\n        }\n\n        validateChargeExcludePrecission(amountPercentage, loanCharges, \"1.0\", String.valueOf(totalPerOfAmout), \"0.0\", \"0.0\");\n        validateChargeExcludePrecission(interestPercentage, loanCharges, \"1.0\", String.valueOf(totalPerOfint), \"0.0\", \"0.0\");\n        validateChargeExcludePrecission(amountPlusInterestPercentage, loanCharges, \"1.0\", String.valueOf(totalPerOfAmoutPlusInt), \"0.0\",\n                \"0.0\");\n        validateChargeExcludePrecission(flat, loanCharges, \"50.0\", \"200\", \"0.0\", \"0.0\");\n\n        this.loanTransactionHelper.updateChargesForLoan(loanID, (Integer) getloanCharge(amountPercentage, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"2\"));\n        this.loanTransactionHelper.updateChargesForLoan(loanID, (Integer) getloanCharge(interestPercentage, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"2\"));\n        this.loanTransactionHelper.updateChargesForLoan(loanID,\n                (Integer) getloanCharge(amountPlusInterestPercentage, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"2\"));\n        this.loanTransactionHelper.updateChargesForLoan(loanID, (Integer) getloanCharge(flat, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getUpdateChargesForLoanAsJSON(\"100\"));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanSchedule.remove(0);\n        totalPerOfAmout = 0F;\n        totalPerOfAmoutPlusInt = 0F;\n        totalPerOfint = 0F;\n        for (HashMap installment : loanSchedule) {\n            Float principalDue = (Float) installment.get(\"principalDue\");\n            Float interestDue = (Float) installment.get(\"interestDue\");\n            Float principalFee = principalDue * 2 / 100;\n            Float interestFee = interestDue * 2 / 100;\n            Float totalInstallmentFee = (principalFee * 2) + (interestFee * 2) + 100;\n            validateNumberForEqualExcludePrecission(String.valueOf(totalInstallmentFee), String.valueOf(installment.get(\"feeChargesDue\")));\n            totalPerOfAmout = totalPerOfAmout + principalFee;\n            totalPerOfAmoutPlusInt = totalPerOfAmoutPlusInt + principalFee + interestFee;\n            totalPerOfint = totalPerOfint + interestFee;\n        }\n\n        validateChargeExcludePrecission(amountPercentage, loanCharges, \"2.0\", String.valueOf(totalPerOfAmout), \"0.0\", \"0.0\");\n        validateChargeExcludePrecission(interestPercentage, loanCharges, \"2.0\", String.valueOf(totalPerOfint), \"0.0\", \"0.0\");\n        validateChargeExcludePrecission(amountPlusInterestPercentage, loanCharges, \"2.0\", String.valueOf(totalPerOfAmoutPlusInt), \"0.0\",\n                \"0.0\");\n        validateChargeExcludePrecission(flat, loanCharges, \"100.0\", \"400\", \"0.0\", \"0.0\");\n\n        final Integer savingsId = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID,\n                MINIMUM_OPENING_BALANCE);\n        this.loanTransactionHelper.updateLoan(loanID, updateLoanJson(clientID, loanProductID, copyChargesForUpdate(loanCharges, null, null),\n                String.valueOf(savingsId), collaterals));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanSchedule.remove(0);\n        totalPerOfAmout = 0F;\n        totalPerOfAmoutPlusInt = 0F;\n        totalPerOfint = 0F;\n        for (HashMap installment : loanSchedule) {\n            Float principalDue = (Float) installment.get(\"principalDue\");\n            Float interestDue = (Float) installment.get(\"interestDue\");\n            Float principalFee = principalDue * 2 / 100;\n            Float interestFee = interestDue * 2 / 100;\n            Float totalInstallmentFee = (principalFee * 2) + (interestFee * 2) + 100;\n            validateNumberForEqualExcludePrecission(String.valueOf(totalInstallmentFee), String.valueOf(installment.get(\"feeChargesDue\")));\n            totalPerOfAmout = totalPerOfAmout + principalFee;\n            totalPerOfAmoutPlusInt = totalPerOfAmoutPlusInt + principalFee + interestFee;\n            totalPerOfint = totalPerOfint + interestFee;\n        }\n\n        validateChargeExcludePrecission(amountPercentage, loanCharges, \"2.0\", String.valueOf(totalPerOfAmout), \"0.0\", \"0.0\");\n        validateChargeExcludePrecission(interestPercentage, loanCharges, \"2.0\", String.valueOf(totalPerOfint), \"0.0\", \"0.0\");\n        validateChargeExcludePrecission(amountPlusInterestPercentage, loanCharges, \"2.0\", String.valueOf(totalPerOfAmoutPlusInt), \"0.0\",\n                \"0.0\");\n        validateChargeExcludePrecission(flat, loanCharges, \"100.0\", \"400\", \"0.0\", \"0.0\");\n\n        this.loanTransactionHelper.updateLoan(loanID,\n                updateLoanJson(clientID, loanProductID, copyChargesForUpdate(loanCharges, flat, \"1\"), null, collaterals));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanSchedule.remove(0);\n        totalPerOfAmout = 0F;\n        totalPerOfAmoutPlusInt = 0F;\n        totalPerOfint = 0F;\n        for (HashMap installment : loanSchedule) {\n            Float principalDue = (Float) installment.get(\"principalDue\");\n            Float interestDue = (Float) installment.get(\"interestDue\");\n            Float principalFee = principalDue / 100;\n            Float interestFee = interestDue / 100;\n            Float totalInstallmentFee = (principalFee * 2) + (interestFee * 2);\n            validateNumberForEqualExcludePrecission(String.valueOf(totalInstallmentFee), String.valueOf(installment.get(\"feeChargesDue\")));\n            totalPerOfAmout = totalPerOfAmout + principalFee;\n            totalPerOfAmoutPlusInt = totalPerOfAmoutPlusInt + principalFee + interestFee;\n            totalPerOfint = totalPerOfint + interestFee;\n        }\n\n        validateChargeExcludePrecission(amountPercentage, loanCharges, \"1.0\", String.valueOf(totalPerOfAmout), \"0.0\", \"0.0\");\n        validateChargeExcludePrecission(interestPercentage, loanCharges, \"1.0\", String.valueOf(totalPerOfint), \"0.0\", \"0.0\");\n        validateChargeExcludePrecission(amountPlusInterestPercentage, loanCharges, \"1.0\", String.valueOf(totalPerOfAmoutPlusInt), \"0.0\",\n                \"0.0\");\n\n        charges.clear();\n        addCharges(charges, flat, \"50\", \"29 September 2011\");\n        this.loanTransactionHelper.updateLoan(loanID, updateLoanJson(clientID, loanProductID, charges, null, collaterals));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanSchedule.remove(0);\n        for (HashMap installment : loanSchedule) {\n            validateNumberForEqualExcludePrecission(\"50\", String.valueOf(installment.get(\"feeChargesDue\")));\n        }\n        validateChargeExcludePrecission(flat, loanCharges, \"50.0\", \"200\", \"0.0\", \"0.0\");\n\n        this.loanTransactionHelper.deleteChargesForLoan(loanID, (Integer) getloanCharge(flat, loanCharges).get(\"id\"));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanSchedule.remove(0);\n        for (HashMap installment : loanSchedule) {\n            validateNumberForEqualExcludePrecission(\"0\", String.valueOf(installment.get(\"feeChargesDue\")));\n        }\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getInstallmentChargesForLoanAsJSON(String.valueOf(flatAccTransfer), \"100\"));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanSchedule.remove(0);\n        for (HashMap installment : loanSchedule) {\n            validateNumberForEqualExcludePrecission(\"100\", String.valueOf(installment.get(\"feeChargesDue\")));\n        }\n        validateChargeExcludePrecission(flatAccTransfer, loanCharges, \"100.0\", \"400\", \"0.0\", \"0.0\");\n\n        // DISBURSE\n        String loanDetail = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID, \"10000\",\n                JsonPath.from(loanDetail).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getInstallmentChargesForLoanAsJSON(String.valueOf(flat), \"50\"));\n\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanSchedule.remove(0);\n        for (HashMap installment : loanSchedule) {\n            validateNumberForEqualExcludePrecission(\"150\", String.valueOf(installment.get(\"feeChargesDue\")));\n        }\n        validateChargeExcludePrecission(flatAccTransfer, loanCharges, \"100.0\", \"400\", \"0.0\", \"0.0\");\n        validateChargeExcludePrecission(flat, loanCharges, \"50.0\", \"200\", \"0.0\", \"0.0\");\n\n        Integer waivePeriodnum = 1;\n        final Integer waivedChargeId = this.loanTransactionHelper.waiveChargesForLoan(loanID,\n                (Integer) getloanCharge(flat, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getWaiveChargeJSON(String.valueOf(waivePeriodnum)));\n\n        // Get loan transaction details\n        ArrayList<HashMap> loanDetails = this.loanTransactionHelper.getLoanTransactionDetails(this.requestSpec, this.responseSpec, loanID);\n        Assertions.assertNotNull(loanDetails, \"Empty Loan Details\");\n        Gson gson = new Gson();\n        Integer transId = null;\n        Integer chargeId = null;\n        for (int i = 0; i < loanDetails.size(); i++) {\n            String resultObject = gson.toJson(loanDetails.get(i));\n            JsonObject reportObject = JsonParser.parseString(resultObject).getAsJsonObject();\n            JsonObject type = reportObject.getAsJsonObject(\"type\");\n            final Integer transTypeId = type.get(\"id\").getAsInt();\n            Assertions.assertNotNull(transTypeId);\n            if (Integer.valueOf(9).compareTo(transTypeId) == 0) {\n                transId = reportObject.get(\"id\").getAsInt();\n                Assertions.assertNotNull(transId);\n                final HashMap<String, String> map = new HashMap<>();\n                map.put(\"id\", transId.toString());\n                map.put(\"loanId\", loanID.toString());\n                final String putBody = gson.toJson(map);\n                chargeId = this.loanTransactionHelper.undoWaiveChargesForLoanReturnResourceId(loanID, transId, putBody);\n                break;\n            }\n        }\n\n        Assertions.assertEquals(waivedChargeId, chargeId);\n\n        // Validate the undo process\n        ArrayList<HashMap> loanTransactionDetails = this.loanTransactionHelper.getLoanTransactionDetails(this.requestSpec,\n                this.responseSpec, loanID);\n        Assertions.assertNotNull(loanTransactionDetails, \"Empty Loan Transaction Details\");\n        for (int i = 0; i < loanTransactionDetails.size(); i++) {\n            String resultObject = gson.toJson(loanTransactionDetails.get(i));\n            JsonObject reportObject = JsonParser.parseString(resultObject).getAsJsonObject();\n            final Boolean isReversed = reportObject.get(\"manuallyReversed\").getAsBoolean();\n            final Integer id = reportObject.get(\"id\").getAsInt();\n\n            if (transId.compareTo(id) == 0) {\n                final HashMap chargeDetails = this.loanTransactionHelper.getLoanCharge(loanID, waivedChargeId);\n                String resultChargeObject = gson.toJson(chargeDetails);\n                JsonObject reportChargeObject = JsonParser.parseString(resultChargeObject).getAsJsonObject();\n                BigDecimal waiveAmount = reportChargeObject.get(\"amountWaived\").getAsBigDecimal();\n\n                Assertions.assertEquals(true, isReversed);\n                Assertions.assertEquals(Double.valueOf(0), waiveAmount.doubleValue());\n                break;\n            } else if (transId.compareTo(id) != 0 && i == loanTransactionDetails.size() - 1) {\n                Assertions.assertEquals(transId, id);\n            }\n        }\n\n        // Re-waive charge\n        this.loanTransactionHelper.waiveChargesForLoan(loanID, waivedChargeId,\n                LoanTransactionHelper.getWaiveChargeJSON(String.valueOf(waivePeriodnum)));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanSchedule.remove(0);\n        for (HashMap installment : loanSchedule) {\n            validateNumberForEqualExcludePrecission(\"150\", String.valueOf(installment.get(\"feeChargesDue\")));\n            if (waivePeriodnum.equals(installment.get(\"period\"))) {\n                validateNumberForEqualExcludePrecission(\"100.0\", String.valueOf(installment.get(\"feeChargesOutstanding\")));\n                validateNumberForEqualExcludePrecission(\"50.0\", String.valueOf(installment.get(\"feeChargesWaived\")));\n            } else {\n                validateNumberForEqualExcludePrecission(\"150.0\", String.valueOf(installment.get(\"feeChargesOutstanding\")));\n                validateNumberForEqualExcludePrecission(\"0.0\", String.valueOf(installment.get(\"feeChargesWaived\")));\n\n            }\n        }\n        validateChargeExcludePrecission(flatAccTransfer, loanCharges, \"100.0\", \"400\", \"0.0\", \"0.0\");\n        validateChargeExcludePrecission(flat, loanCharges, \"50.0\", \"150\", \"0.0\", \"50.0\");\n\n        Integer payPeriodnum = 2;\n        this.loanTransactionHelper.payChargesForLoan(loanID, (Integer) getloanCharge(flatAccTransfer, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getPayChargeJSON(SavingsAccountHelper.TRANSACTION_DATE, String.valueOf(payPeriodnum)));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanSchedule.remove(0);\n        for (HashMap installment : loanSchedule) {\n            validateNumberForEqualExcludePrecission(\"150\", String.valueOf(installment.get(\"feeChargesDue\")));\n            if (payPeriodnum.equals(installment.get(\"period\"))) {\n                validateNumberForEqualExcludePrecission(\"50.0\", String.valueOf(installment.get(\"feeChargesOutstanding\")));\n                validateNumberForEqualExcludePrecission(\"100.0\", String.valueOf(installment.get(\"feeChargesPaid\")));\n            } else if (waivePeriodnum.equals(installment.get(\"period\"))) {\n                validateNumberForEqualExcludePrecission(\"100.0\", String.valueOf(installment.get(\"feeChargesOutstanding\")));\n                validateNumberForEqualExcludePrecission(\"50.0\", String.valueOf(installment.get(\"feeChargesWaived\")));\n            } else {\n                validateNumberForEqualExcludePrecission(\"150.0\", String.valueOf(installment.get(\"feeChargesOutstanding\")));\n                validateNumberForEqualExcludePrecission(\"0.0\", String.valueOf(installment.get(\"feeChargesPaid\")));\n\n            }\n        }\n        validateChargeExcludePrecission(flatAccTransfer, loanCharges, \"100.0\", \"300\", \"100.0\", \"0.0\");\n        validateChargeExcludePrecission(flat, loanCharges, \"50.0\", \"150\", \"0.0\", \"50.0\");\n\n        // Loan Charges with US Locale using the amount as a number in the JSON body\n        this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getInstallmentChargesForLoanAsJSON(String.valueOf(flat), 50.05, Locale.US));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanSchedule.remove(0);\n        for (HashMap installment : loanSchedule) {\n            validateNumberForEqualExcludePrecission(\"200.05\", String.valueOf(installment.get(\"feeChargesDue\")));\n        }\n\n        // Loan Charges with other Locale using comma (,) as decimal delimiter\n        this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getInstallmentChargesForLoanAsJSON(String.valueOf(flat), \"50,05\", Locale.GERMAN));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanSchedule.remove(0);\n        for (HashMap installment : loanSchedule) {\n            validateNumberForEqualExcludePrecission(\"250.10\", String.valueOf(installment.get(\"feeChargesDue\")));\n        }\n\n        // Loan Charges with German Locale (where the comma is the decimal delimiter) using the amount as a number in\n        // the JSON body\n        this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getInstallmentChargesForLoanAsJSON(String.valueOf(flat), 50.05, Locale.GERMAN));\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanSchedule.remove(0);\n        for (HashMap installment : loanSchedule) {\n            validateNumberForEqualExcludePrecission(\"300.15\", String.valueOf(installment.get(\"feeChargesDue\")));\n        }\n    }"}
{"prompt": "Create a test that tests test Loan Charges DISBURSEMENT TO SAVINGS", "completion": "    @Test\n    public void testLoanCharges_DISBURSEMENT_TO_SAVINGS() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        final Integer savingsId = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID,\n                MINIMUM_OPENING_BALANCE);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, null, savingsId.toString(), \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        HashMap summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(MINIMUM_OPENING_BALANCE);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        // DISBURSE\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanToSavings(SavingsAccountHelper.TRANSACTION_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(MINIMUM_OPENING_BALANCE) + Float.parseFloat(\"12000\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        loanStatusHashMap = this.loanTransactionHelper.undoDisbursal(loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(MINIMUM_OPENING_BALANCE);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n    }"}
{"prompt": "Create a test that tests test Loan Charges DISBURSEMENT WITH TRANCHES", "completion": "    @Test\n    public void testLoanCharges_DISBURSEMENT_WITH_TRANCHES() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(true, NONE);\n\n        List<HashMap> tranches = new ArrayList<>();\n        tranches.add(createTrancheDetail(\"01 March 2014\", \"25000\"));\n        tranches.add(createTrancheDetail(\"23 April 2014\", \"20000\"));\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, null, null, \"45,000.00\", tranches, collaterals);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 March 2014\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        // DISBURSE first Tranche\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 March 2014\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // DISBURSE Second Tranche\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"23 April 2014\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.undoDisbursal(loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Loan Charges DISBURSEMENT TO SAVINGS WITH TRANCHES", "completion": "    @Test\n    public void testLoanCharges_DISBURSEMENT_TO_SAVINGS_WITH_TRANCHES() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(true, NONE);\n\n        final Integer savingsId = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID,\n                MINIMUM_OPENING_BALANCE);\n\n        List<HashMap> tranches = new ArrayList<>();\n        tranches.add(createTrancheDetail(\"01 March 2014\", \"25000\"));\n        tranches.add(createTrancheDetail(\"23 April 2014\", \"20000\"));\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, null, savingsId.toString(), \"45,000.00\",\n                tranches, collaterals);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 March 2014\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        HashMap summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(MINIMUM_OPENING_BALANCE);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        // DISBURSE first Tranche\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanToSavings(\"01 March 2014\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(MINIMUM_OPENING_BALANCE) + Float.parseFloat(\"25000\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        // DISBURSE Second Tranche\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanToSavings(\"23 April 2014\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap.toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(MINIMUM_OPENING_BALANCE) + Float.parseFloat(\"25000\") + Float.parseFloat(\"20000\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        loanStatusHashMap = this.loanTransactionHelper.undoDisbursal(loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(MINIMUM_OPENING_BALANCE);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n    }"}
{"prompt": "Create a test that tests loan With Flat Caharges And Cash Based Accounting Enabled", "completion": "    @Test\n    public void loanWithFlatCahargesAndCashBasedAccountingEnabled() {\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        // Add charges with payment mode regular\n        List<HashMap> charges = new ArrayList<>();\n        Integer flatDisbursement = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper.getLoanDisbursementJSON());\n        addCharges(charges, flatDisbursement, \"100\", null);\n        Integer flatSpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"100\", false));\n        addCharges(charges, flatSpecifiedDueDate, \"100\", \"29 September 2011\");\n        Integer flatInstallmentFee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n        addCharges(charges, flatInstallmentFee, \"50\", null);\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanProductID = createLoanProduct(false, CASH_BASED, assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        verifyLoanRepaymentSchedule(loanSchedule);\n\n        List<HashMap> loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(flatDisbursement, loanCharges, \"100\", \"100.00\", \"0.0\", \"0.0\");\n        validateCharge(flatSpecifiedDueDate, loanCharges, \"100\", \"100.00\", \"0.0\", \"0.0\");\n        validateCharge(flatInstallmentFee, loanCharges, \"50\", \"200.00\", \"0.0\", \"0.0\");\n\n        // check for disbursement fee\n        HashMap disbursementDetail = loanSchedule.get(0);\n        validateNumberForEqual(\"100.00\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        // check for charge at specified date and installment fee\n        HashMap firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"150.00\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        // check for installment fee\n        HashMap secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"50.00\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(Float.parseFloat(\"100.00\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 September 2011\", assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 September 2011\",\n                new JournalEntry(Float.parseFloat(\"100.00\"), JournalEntry.TransactionType.CREDIT));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(flatDisbursement, loanCharges, \"100\", \"0.00\", \"100.0\", \"0.0\");\n\n        LOG.info(\"-------------Make repayment 1-----------\");\n        this.loanTransactionHelper.makeRepayment(\"20 October 2011\", Float.parseFloat(\"3301.49\"), loanID);\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(flatDisbursement, loanCharges, \"100\", \"0.00\", \"100.0\", \"0.0\");\n        validateCharge(flatSpecifiedDueDate, loanCharges, \"100\", \"0.00\", \"100.0\", \"0.0\");\n        validateCharge(flatInstallmentFee, loanCharges, \"50\", \"150.00\", \"50.0\", \"0.0\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3301.49\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"2911.49\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"150.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"240.00\"), JournalEntry.TransactionType.CREDIT));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatSpecifiedDueDate), \"29 October 2011\", \"100\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"150.00\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n        this.loanTransactionHelper.waiveChargesForLoan(loanID, (Integer) getloanCharge(flatInstallmentFee, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getWaiveChargeJSON(String.valueOf(2)));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(flatInstallmentFee, loanCharges, \"50\", \"100.00\", \"50.0\", \"50.0\");\n\n        LOG.info(\"----------Make repayment 2------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3251.49\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3251.49\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"2969.72\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"100.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"181.77\"), JournalEntry.TransactionType.CREDIT));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"0\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"--------------Waive interest---------------\");\n        this.loanTransactionHelper.waiveInterest(\"20 December 2011\", String.valueOf(61.79), loanID);\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap thirdInstallment = loanSchedule.get(3);\n        validateNumberForEqual(\"60.59\", String.valueOf(thirdInstallment.get(\"interestOutstanding\")));\n\n        Integer flatPenaltySpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"100\", true));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatPenaltySpecifiedDueDate), \"29 September 2011\", \"100\"));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(flatPenaltySpecifiedDueDate, loanCharges, \"100\", \"0.00\", \"100.0\", \"0.0\");\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"100\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3301.49\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"2811.49\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"100.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"150.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"240\"), JournalEntry.TransactionType.CREDIT));\n\n        LOG.info(\"----------Make repayment 3 advance------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3301.49\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3301.49\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3129.11\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"50.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"122.38\"), JournalEntry.TransactionType.CREDIT));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatPenaltySpecifiedDueDate), \"10 January 2012\", \"100\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"100\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3239.68\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Pay applied penalty ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"100\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"100\"), JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"100.00\"), JournalEntry.TransactionType.CREDIT));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"0\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3139.68\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Make repayment 4 ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"3139.68\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"3139.68\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3089.68\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"50.00\"), JournalEntry.TransactionType.CREDIT));\n    }"}
{"prompt": "Create a test that tests loan With Caharges Of Type Amount Percentage And Cash Based Accounting Enabled", "completion": "    @Test\n    public void loanWithCahargesOfTypeAmountPercentageAndCashBasedAccountingEnabled() {\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        // Add charges with payment mode regular\n        List<HashMap> charges = new ArrayList<>();\n        Integer percentageDisbursementCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\"));\n        addCharges(charges, percentageDisbursementCharge, \"1\", null);\n\n        Integer percentageSpecifiedDueDateCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\", false));\n        addCharges(charges, percentageSpecifiedDueDateCharge, \"1\", \"29 September 2011\");\n\n        Integer percentageInstallmentFee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\", false));\n        addCharges(charges, percentageInstallmentFee, \"1\", \"29 September 2011\");\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanProductID = createLoanProduct(false, CASH_BASED, assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        verifyLoanRepaymentSchedule(loanSchedule);\n\n        List<HashMap> loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(percentageDisbursementCharge, loanCharges, \"1\", \"120.00\", \"0.0\", \"0.0\");\n        validateCharge(percentageSpecifiedDueDateCharge, loanCharges, \"1\", \"120.00\", \"0.0\", \"0.0\");\n        validateCharge(percentageInstallmentFee, loanCharges, \"1\", \"120.00\", \"0.0\", \"0.0\");\n\n        // check for disbursement fee\n        HashMap disbursementDetail = loanSchedule.get(0);\n        validateNumberForEqual(\"120.00\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        // check for charge at specified date and installment fee\n        HashMap firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"149.11\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        // check for installment fee\n        HashMap secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"29.70\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(Float.parseFloat(\"120.00\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 September 2011\", assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 September 2011\",\n                new JournalEntry(Float.parseFloat(\"120.00\"), JournalEntry.TransactionType.CREDIT));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(percentageDisbursementCharge, loanCharges, \"1\", \"0.0\", \"120.00\", \"0.0\");\n\n        LOG.info(\"-------------Make repayment 1-----------\");\n        this.loanTransactionHelper.makeRepayment(\"20 October 2011\", Float.parseFloat(\"3300.60\"), loanID);\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(percentageDisbursementCharge, loanCharges, \"1\", \"0.00\", \"120.00\", \"0.0\");\n        validateCharge(percentageSpecifiedDueDateCharge, loanCharges, \"1\", \"0.00\", \"120.0\", \"0.0\");\n        validateCharge(percentageInstallmentFee, loanCharges, \"1\", \"90.89\", \"29.11\", \"0.0\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3300.60\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"2911.49\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"149.11\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"240.00\"), JournalEntry.TransactionType.CREDIT));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(percentageSpecifiedDueDateCharge), \"29 October 2011\", \"1\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"149.70\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n        this.loanTransactionHelper.waiveChargesForLoan(loanID, (Integer) getloanCharge(percentageInstallmentFee, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getWaiveChargeJSON(String.valueOf(2)));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(percentageInstallmentFee, loanCharges, \"1\", \"61.19\", \"29.11\", \"29.70\");\n\n        LOG.info(\"----------Make repayment 2------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3271.49\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3271.49\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"2969.72\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"120.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"181.77\"), JournalEntry.TransactionType.CREDIT));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"0\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"--------------Waive interest---------------\");\n        this.loanTransactionHelper.waiveInterest(\"20 December 2011\", String.valueOf(61.79), loanID);\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap thirdInstallment = loanSchedule.get(3);\n        validateNumberForEqual(\"60.59\", String.valueOf(thirdInstallment.get(\"interestOutstanding\")));\n\n        Integer percentagePenaltySpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\", true));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(percentagePenaltySpecifiedDueDate), \"29 September 2011\", \"1\"));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(percentagePenaltySpecifiedDueDate, loanCharges, \"1\", \"0.00\", \"120.0\", \"0.0\");\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"120\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3300.60\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"2791.49\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"120.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"149.11\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"240\"), JournalEntry.TransactionType.CREDIT));\n\n        LOG.info(\"----------Make repayment 3 advance------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3301.78\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3301.78\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3149.11\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"30.29\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"122.38\"), JournalEntry.TransactionType.CREDIT));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(percentagePenaltySpecifiedDueDate), \"10 January 2012\", \"1\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"120\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3240.58\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Pay applied penalty ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"120\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"120\"), JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"120.00\"), JournalEntry.TransactionType.CREDIT));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"0\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3120.58\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Make repayment 4 ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"3120.58\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"3120.58\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3089.68\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"30.90\"), JournalEntry.TransactionType.CREDIT));\n    }"}
{"prompt": "Create a test that tests loan With Caharges Of Type Amount Plus Interest Percentage And Cash Based Accounting Enabled", "completion": "    @Test\n    public void loanWithCahargesOfTypeAmountPlusInterestPercentageAndCashBasedAccountingEnabled() {\n        this.journalEntryHelper = new JournalEntryHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        // Add charges with payment mode regular\n        List<HashMap> charges = new ArrayList<>();\n        Integer amountPlusInterestPercentageDisbursementCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\"));\n        addCharges(charges, amountPlusInterestPercentageDisbursementCharge, \"1\", null);\n\n        Integer amountPlusInterestPercentageSpecifiedDueDateCharge = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\", false));\n        addCharges(charges, amountPlusInterestPercentageSpecifiedDueDateCharge, \"1\", \"29 September 2011\");\n\n        Integer amountPlusInterestPercentageInstallmentFee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\", false));\n        addCharges(charges, amountPlusInterestPercentageInstallmentFee, \"1\", \"29 September 2011\");\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanProductID = createLoanProduct(false, CASH_BASED, assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        verifyLoanRepaymentSchedule(loanSchedule);\n\n        List<HashMap> loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(amountPlusInterestPercentageDisbursementCharge, loanCharges, \"1\", \"126.06\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentageSpecifiedDueDateCharge, loanCharges, \"1\", \"126.06\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentageInstallmentFee, loanCharges, \"1\", \"126.04\", \"0.0\", \"0.0\");\n\n        // check for disbursement fee\n        HashMap disbursementDetail = loanSchedule.get(0);\n        validateNumberForEqual(\"126.06\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        // check for charge at specified date and installment fee\n        HashMap firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"157.57\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        // check for installment fee\n        HashMap secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"31.51\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(Float.parseFloat(\"126.06\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 September 2011\", assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 September 2011\",\n                new JournalEntry(Float.parseFloat(\"126.06\"), JournalEntry.TransactionType.CREDIT));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(amountPlusInterestPercentageDisbursementCharge, loanCharges, \"1\", \"0.0\", \"126.06\", \"0.0\");\n\n        LOG.info(\"-------------Make repayment 1-----------\");\n        this.loanTransactionHelper.makeRepayment(\"20 October 2011\", Float.parseFloat(\"3309.06\"), loanID);\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(amountPlusInterestPercentageDisbursementCharge, loanCharges, \"1\", \"0.00\", \"126.06\", \"0.0\");\n        validateCharge(amountPlusInterestPercentageSpecifiedDueDateCharge, loanCharges, \"1\", \"0.00\", \"126.06\", \"0.0\");\n        validateCharge(amountPlusInterestPercentageInstallmentFee, loanCharges, \"1\", \"94.53\", \"31.51\", \"0.0\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3309.06\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"2911.49\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"157.57\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"240.00\"), JournalEntry.TransactionType.CREDIT));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(\n                String.valueOf(amountPlusInterestPercentageSpecifiedDueDateCharge), \"29 October 2011\", \"1\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"157.57\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n        this.loanTransactionHelper.waiveChargesForLoan(loanID,\n                (Integer) getloanCharge(amountPlusInterestPercentageInstallmentFee, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getWaiveChargeJSON(String.valueOf(2)));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(amountPlusInterestPercentageInstallmentFee, loanCharges, \"1\", \"63.02\", \"31.51\", \"31.51\");\n\n        LOG.info(\"----------Make repayment 2------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3277.55\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3277.55\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"2969.72\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"126.06\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"181.77\"), JournalEntry.TransactionType.CREDIT));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"0\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"--------------Waive interest---------------\");\n        this.loanTransactionHelper.waiveInterest(\"20 December 2011\", String.valueOf(61.79), loanID);\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap thirdInstallment = loanSchedule.get(3);\n        validateNumberForEqual(\"60.59\", String.valueOf(thirdInstallment.get(\"interestOutstanding\")));\n\n        Integer amountPlusInterestPercentagePenaltySpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\", true));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(\n                String.valueOf(amountPlusInterestPercentagePenaltySpecifiedDueDate), \"29 September 2011\", \"1\"));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(amountPlusInterestPercentagePenaltySpecifiedDueDate, loanCharges, \"1\", \"0.0\", \"120.0\", \"0.0\");\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"120\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3309.06\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"2791.49\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"120.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"157.57\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"240\"), JournalEntry.TransactionType.CREDIT));\n\n        LOG.info(\"----------Make repayment 3 advance------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3303\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3303\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3149.11\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"31.51\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"122.38\"), JournalEntry.TransactionType.CREDIT));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(\n                String.valueOf(amountPlusInterestPercentagePenaltySpecifiedDueDate), \"10 January 2012\", \"1\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"120\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3241.19\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Pay applied penalty ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"120\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"120\"), JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"120.00\"), JournalEntry.TransactionType.CREDIT));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"0\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3121.19\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Make repayment 4 ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"3121.19\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"3121.19\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3089.68\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"31.51\"), JournalEntry.TransactionType.CREDIT));\n    }"}
{"prompt": "Create a test that tests loan With Flat Caharges And Upfront Accrual Accounting Enabled", "completion": "    @Test\n    public void loanWithFlatCahargesAndUpfrontAccrualAccountingEnabled() {\n        this.journalEntryHelper = new JournalEntryHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        // Add charges with payment mode regular\n        List<HashMap> charges = new ArrayList<>();\n        Integer flatDisbursement = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper.getLoanDisbursementJSON());\n        addCharges(charges, flatDisbursement, \"100\", null);\n        Integer flatSpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"100\", false));\n\n        Integer flatInstallmentFee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n        addCharges(charges, flatInstallmentFee, \"50\", null);\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanProductID = createLoanProduct(false, ACCRUAL_UPFRONT, assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        verifyLoanRepaymentSchedule(loanSchedule);\n\n        List<HashMap> loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(flatDisbursement, loanCharges, \"100\", \"100.00\", \"0.0\", \"0.0\");\n        validateCharge(flatInstallmentFee, loanCharges, \"50\", \"200.00\", \"0.0\", \"0.0\");\n\n        // check for disbursement fee\n        HashMap disbursementDetail = loanSchedule.get(0);\n        validateNumberForEqual(\"100.00\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        // check for charge at specified date and installment fee\n        HashMap firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"50.00\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        // check for installment fee\n        HashMap secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"50.00\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(Float.parseFloat(\"605.94\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"100.00\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"200.00\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 September 2011\", assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 September 2011\",\n                new JournalEntry(Float.parseFloat(\"605.94\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"100.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"200.00\"), JournalEntry.TransactionType.CREDIT));\n\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatSpecifiedDueDate), \"29 September 2011\", \"100\"));\n\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(flatDisbursement, loanCharges, \"100\", \"0.00\", \"100.0\", \"0.0\");\n        validateCharge(flatSpecifiedDueDate, loanCharges, \"100\", \"100.00\", \"0.0\", \"0.0\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"29 September 2011\",\n                new JournalEntry(Float.parseFloat(\"100.00\"), JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"29 September 2011\",\n                new JournalEntry(Float.parseFloat(\"100.00\"), JournalEntry.TransactionType.CREDIT));\n\n        LOG.info(\"-------------Make repayment 1-----------\");\n        this.loanTransactionHelper.makeRepayment(\"20 October 2011\", Float.parseFloat(\"3301.49\"), loanID);\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(flatDisbursement, loanCharges, \"100\", \"0.00\", \"100.0\", \"0.0\");\n        validateCharge(flatSpecifiedDueDate, loanCharges, \"100\", \"0.00\", \"100.0\", \"0.0\");\n        validateCharge(flatInstallmentFee, loanCharges, \"50\", \"150.00\", \"50.0\", \"0.0\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3301.49\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3301.49\"), JournalEntry.TransactionType.CREDIT));\n\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatSpecifiedDueDate), \"29 October 2011\", \"100\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"150.00\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n        LOG.info(\"----------- Waive installment charge for 2nd installment ---------\");\n        this.loanTransactionHelper.waiveChargesForLoan(loanID, (Integer) getloanCharge(flatInstallmentFee, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getWaiveChargeJSON(String.valueOf(2)));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(flatInstallmentFee, loanCharges, \"50\", \"100.00\", \"50.0\", \"50.0\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"50.0\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"50.0\"), JournalEntry.TransactionType.DEBIT));\n\n        LOG.info(\"----------Make repayment 2------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3251.49\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3251.49\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3251.49\"), JournalEntry.TransactionType.CREDIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"0\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"--------------Waive interest---------------\");\n        this.loanTransactionHelper.waiveInterest(\"20 December 2011\", String.valueOf(61.79), loanID);\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap thirdInstallment = loanSchedule.get(3);\n        validateNumberForEqual(\"60.59\", String.valueOf(thirdInstallment.get(\"interestOutstanding\")));\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 December 2011\",\n                new JournalEntry(Float.parseFloat(\"61.79\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"20 December 2011\",\n                new JournalEntry(Float.parseFloat(\"61.79\"), JournalEntry.TransactionType.DEBIT));\n\n        Integer flatPenaltySpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"100\", true));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatPenaltySpecifiedDueDate), \"29 September 2011\", \"100\"));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(flatPenaltySpecifiedDueDate, loanCharges, \"100\", \"0.00\", \"100.0\", \"0.0\");\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"100\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // checking the journal entry as applied penalty has been collected\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3301.49\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3301.49\"), JournalEntry.TransactionType.CREDIT));\n\n        LOG.info(\"----------Make repayment 3 advance------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3301.49\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3301.49\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3301.49\"), JournalEntry.TransactionType.CREDIT));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatPenaltySpecifiedDueDate), \"10 January 2012\", \"100\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"100\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3239.68\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Pay applied penalty ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"100\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"100\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"100\"), JournalEntry.TransactionType.CREDIT));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"0\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3139.68\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Make over payment for repayment 4 ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"3220.60\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"3220.60\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3139.68\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"80.92\"), JournalEntry.TransactionType.CREDIT));\n        loanStatusHashMap = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"status\");\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n    }"}
{"prompt": "Create a test that tests loan With Caharges And Upfront Accrual Accounting Enabled", "completion": "    @Test\n    public void loanWithCahargesAndUpfrontAccrualAccountingEnabled() {\n        this.journalEntryHelper = new JournalEntryHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        // Add charges with payment mode regular\n        List<HashMap> charges = new ArrayList<>();\n        Integer percentageDisbursementCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\"));\n        addCharges(charges, percentageDisbursementCharge, \"1\", null);\n\n        Integer percentageSpecifiedDueDateCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\", false));\n        addCharges(charges, percentageSpecifiedDueDateCharge, \"1\", \"29 September 2011\");\n\n        Integer percentageInstallmentFee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\", false));\n        addCharges(charges, percentageInstallmentFee, \"1\", \"29 September 2011\");\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanProductID = createLoanProduct(false, ACCRUAL_UPFRONT, assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        verifyLoanRepaymentSchedule(loanSchedule);\n\n        List<HashMap> loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(percentageDisbursementCharge, loanCharges, \"1\", \"120.00\", \"0.0\", \"0.0\");\n        validateCharge(percentageSpecifiedDueDateCharge, loanCharges, \"1\", \"120.00\", \"0.0\", \"0.0\");\n        validateCharge(percentageInstallmentFee, loanCharges, \"1\", \"120.00\", \"0.0\", \"0.0\");\n\n        // check for disbursement fee\n        HashMap disbursementDetail = loanSchedule.get(0);\n        validateNumberForEqual(\"120.00\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        // check for charge at specified date and installment fee\n        HashMap firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"149.11\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        // check for installment fee\n        HashMap secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"29.70\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(Float.parseFloat(\"605.94\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"120.00\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"120.00\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"120.00\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 September 2011\", assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 September 2011\",\n                new JournalEntry(Float.parseFloat(\"605.94\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"120.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"120.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"120.00\"), JournalEntry.TransactionType.CREDIT));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(percentageDisbursementCharge, loanCharges, \"1\", \"0.0\", \"120.00\", \"0.0\");\n\n        LOG.info(\"-------------Make repayment 1-----------\");\n        this.loanTransactionHelper.makeRepayment(\"20 October 2011\", Float.parseFloat(\"3300.60\"), loanID);\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(percentageDisbursementCharge, loanCharges, \"1\", \"0.00\", \"120.00\", \"0.0\");\n        validateCharge(percentageSpecifiedDueDateCharge, loanCharges, \"1\", \"0.00\", \"120.0\", \"0.0\");\n        validateCharge(percentageInstallmentFee, loanCharges, \"1\", \"90.89\", \"29.11\", \"0.0\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3300.60\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3300.60\"), JournalEntry.TransactionType.CREDIT));\n\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(percentageSpecifiedDueDateCharge), \"29 October 2011\", \"1\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"149.70\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n        LOG.info(\"----------- Waive installment charge for 2nd installment ---------\");\n        this.loanTransactionHelper.waiveChargesForLoan(loanID, (Integer) getloanCharge(percentageInstallmentFee, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getWaiveChargeJSON(String.valueOf(2)));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(percentageInstallmentFee, loanCharges, \"1\", \"61.19\", \"29.11\", \"29.70\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"29.7\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"29.7\"), JournalEntry.TransactionType.DEBIT));\n\n        LOG.info(\"----------Make repayment 2------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3271.49\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3271.49\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3271.49\"), JournalEntry.TransactionType.CREDIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"0\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"--------------Waive interest---------------\");\n        this.loanTransactionHelper.waiveInterest(\"20 December 2011\", String.valueOf(61.79), loanID);\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap thirdInstallment = loanSchedule.get(3);\n        validateNumberForEqual(\"60.59\", String.valueOf(thirdInstallment.get(\"interestOutstanding\")));\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 December 2011\",\n                new JournalEntry(Float.parseFloat(\"61.79\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"20 December 2011\",\n                new JournalEntry(Float.parseFloat(\"61.79\"), JournalEntry.TransactionType.DEBIT));\n\n        Integer percentagePenaltySpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\", true));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(percentagePenaltySpecifiedDueDate), \"29 September 2011\", \"1\"));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(percentagePenaltySpecifiedDueDate, loanCharges, \"1\", \"0.00\", \"120.0\", \"0.0\");\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"120\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // checking the journal entry as applied penalty has been collected\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3300.60\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3300.60\"), JournalEntry.TransactionType.CREDIT));\n\n        LOG.info(\"----------Make repayment 3 advance------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3301.78\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3301.78\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3301.78\"), JournalEntry.TransactionType.CREDIT));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(percentagePenaltySpecifiedDueDate), \"10 January 2012\", \"1\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"120\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3240.58\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Pay applied penalty ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"120\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"120\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"120\"), JournalEntry.TransactionType.CREDIT));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"0\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3120.58\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Make over payment for repayment 4 ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"3220.58\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"3220.58\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3120.58\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"100.00\"), JournalEntry.TransactionType.CREDIT));\n        loanStatusHashMap = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"status\");\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n    }"}
{"prompt": "Create a test that tests loan With Caharges Of Type Amount Plus Interest Percentage And Upfront Accrual Accounting Enabled", "completion": "    @Test\n    public void loanWithCahargesOfTypeAmountPlusInterestPercentageAndUpfrontAccrualAccountingEnabled() {\n        this.journalEntryHelper = new JournalEntryHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        // Add charges with payment mode regular\n        List<HashMap> charges = new ArrayList<>();\n        Integer amountPlusInterestPercentageDisbursementCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\"));\n        addCharges(charges, amountPlusInterestPercentageDisbursementCharge, \"1\", null);\n\n        Integer amountPlusInterestPercentageSpecifiedDueDateCharge = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\", false));\n\n        Integer amountPlusInterestPercentageInstallmentFee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\", false));\n        addCharges(charges, amountPlusInterestPercentageInstallmentFee, \"1\", \"29 September 2011\");\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanProductID = createLoanProduct(false, ACCRUAL_UPFRONT, assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        verifyLoanRepaymentSchedule(loanSchedule);\n\n        List<HashMap> loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(amountPlusInterestPercentageDisbursementCharge, loanCharges, \"1\", \"126.06\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentageInstallmentFee, loanCharges, \"1\", \"126.04\", \"0.0\", \"0.0\");\n\n        // check for disbursement fee\n        HashMap disbursementDetail = loanSchedule.get(0);\n        validateNumberForEqual(\"126.06\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        // check for charge at specified date and installment fee\n        HashMap firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"31.51\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        // check for installment fee\n        HashMap secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"31.51\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(Float.parseFloat(\"605.94\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"126.06\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"126.04\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 September 2011\", assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 September 2011\",\n                new JournalEntry(Float.parseFloat(\"605.94\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"126.06\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"126.04\"), JournalEntry.TransactionType.CREDIT));\n\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(\n                String.valueOf(amountPlusInterestPercentageSpecifiedDueDateCharge), \"29 September 2011\", \"1\"));\n\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(amountPlusInterestPercentageDisbursementCharge, loanCharges, \"1\", \"0.0\", \"126.06\", \"0.0\");\n        validateCharge(amountPlusInterestPercentageSpecifiedDueDateCharge, loanCharges, \"1\", \"126.06\", \"0.0\", \"0.0\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"29 September 2011\",\n                new JournalEntry(Float.parseFloat(\"126.06\"), JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"29 September 2011\",\n                new JournalEntry(Float.parseFloat(\"126.06\"), JournalEntry.TransactionType.CREDIT));\n\n        LOG.info(\"-------------Make repayment 1-----------\");\n        this.loanTransactionHelper.makeRepayment(\"20 October 2011\", Float.parseFloat(\"3309.06\"), loanID);\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(amountPlusInterestPercentageDisbursementCharge, loanCharges, \"1\", \"0.00\", \"126.06\", \"0.0\");\n        validateCharge(amountPlusInterestPercentageSpecifiedDueDateCharge, loanCharges, \"1\", \"0.00\", \"126.06\", \"0.0\");\n        validateCharge(amountPlusInterestPercentageInstallmentFee, loanCharges, \"1\", \"94.53\", \"31.51\", \"0.0\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3309.06\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3309.06\"), JournalEntry.TransactionType.CREDIT));\n\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(\n                String.valueOf(amountPlusInterestPercentageSpecifiedDueDateCharge), \"29 October 2011\", \"1\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"157.57\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n        LOG.info(\"----------- Waive installment charge for 2nd installment ---------\");\n        this.loanTransactionHelper.waiveChargesForLoan(loanID,\n                (Integer) getloanCharge(amountPlusInterestPercentageInstallmentFee, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getWaiveChargeJSON(String.valueOf(2)));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(amountPlusInterestPercentageInstallmentFee, loanCharges, \"1\", \"63.02\", \"31.51\", \"31.51\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"31.51\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"31.51\"), JournalEntry.TransactionType.DEBIT));\n\n        LOG.info(\"----------Make repayment 2------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3277.55\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3277.55\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3277.55\"), JournalEntry.TransactionType.CREDIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"0\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"--------------Waive interest---------------\");\n        this.loanTransactionHelper.waiveInterest(\"20 December 2011\", String.valueOf(61.79), loanID);\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap thirdInstallment = loanSchedule.get(3);\n        validateNumberForEqual(\"60.59\", String.valueOf(thirdInstallment.get(\"interestOutstanding\")));\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 December 2011\",\n                new JournalEntry(Float.parseFloat(\"61.79\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"20 December 2011\",\n                new JournalEntry(Float.parseFloat(\"61.79\"), JournalEntry.TransactionType.DEBIT));\n\n        Integer amountPlusInterestPercentagePenaltySpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\", true));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(\n                String.valueOf(amountPlusInterestPercentagePenaltySpecifiedDueDate), \"29 September 2011\", \"1\"));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(amountPlusInterestPercentagePenaltySpecifiedDueDate, loanCharges, \"1\", \"0.0\", \"120.0\", \"0.0\");\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"120\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // checking the journal entry as applied penalty has been collected\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3309.06\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3309.06\"), JournalEntry.TransactionType.CREDIT));\n\n        LOG.info(\"----------Make repayment 3 advance------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3303\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3303\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3303\"), JournalEntry.TransactionType.CREDIT));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(\n                String.valueOf(amountPlusInterestPercentagePenaltySpecifiedDueDate), \"10 January 2012\", \"1\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"120\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3241.19\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Pay applied penalty ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"120\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"120\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"120\"), JournalEntry.TransactionType.CREDIT));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"0\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3121.19\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Make over payment for repayment 4 ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"3221.61\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"3221.61\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3121.19\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"100.42\"), JournalEntry.TransactionType.CREDIT));\n        loanStatusHashMap = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"status\");\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n    }"}
{"prompt": "Create a test that tests loan With Flat Charges And Periodic Accrual Accounting Enabled", "completion": "    @Test\n    public void loanWithFlatChargesAndPeriodicAccrualAccountingEnabled() throws InterruptedException {\n        this.journalEntryHelper = new JournalEntryHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        // Add charges with payment mode regular\n        List<HashMap> charges = new ArrayList<>();\n        Integer flatDisbursement = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper.getLoanDisbursementJSON());\n        addCharges(charges, flatDisbursement, \"100\", null);\n        Integer flatSpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"100\", false));\n        addCharges(charges, flatSpecifiedDueDate, \"100\", \"29 September 2011\");\n        Integer flatInstallmentFee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n        addCharges(charges, flatInstallmentFee, \"50\", null);\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanProductID = createLoanProduct(false, ACCRUAL_PERIODIC, assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        verifyLoanRepaymentSchedule(loanSchedule);\n\n        List<HashMap> loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(flatDisbursement, loanCharges, \"100\", \"100.00\", \"0.0\", \"0.0\");\n        validateCharge(flatSpecifiedDueDate, loanCharges, \"100\", \"100.00\", \"0.0\", \"0.0\");\n        validateCharge(flatInstallmentFee, loanCharges, \"50\", \"200.00\", \"0.0\", \"0.0\");\n\n        // check for disbursement fee\n        HashMap disbursementDetail = loanSchedule.get(0);\n        validateNumberForEqual(\"100.00\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        // check for charge at specified date and installment fee\n        HashMap firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"150.00\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        // check for installment fee\n        HashMap secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"50.00\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(Float.parseFloat(\"100.00\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 September 2011\", assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 September 2011\",\n                new JournalEntry(Float.parseFloat(\"100.00\"), JournalEntry.TransactionType.CREDIT));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(flatDisbursement, loanCharges, \"100\", \"0.00\", \"100.0\", \"0.0\");\n\n        LOG.info(\"-------------Make repayment 1-----------\");\n        this.loanTransactionHelper.makeRepayment(\"20 October 2011\", Float.parseFloat(\"3301.49\"), loanID);\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(flatDisbursement, loanCharges, \"100\", \"0.00\", \"100.0\", \"0.0\");\n        validateCharge(flatSpecifiedDueDate, loanCharges, \"100\", \"0.00\", \"100.0\", \"0.0\");\n        validateCharge(flatInstallmentFee, loanCharges, \"50\", \"150.00\", \"50.0\", \"0.0\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3301.49\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3301.49\"), JournalEntry.TransactionType.CREDIT));\n\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatSpecifiedDueDate), \"29 October 2011\", \"100\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"150.00\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n        LOG.info(\"----------- Waive installment charge for 2nd installment ---------\");\n        this.loanTransactionHelper.waiveChargesForLoan(loanID, (Integer) getloanCharge(flatInstallmentFee, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getWaiveChargeJSON(String.valueOf(2)));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(flatInstallmentFee, loanCharges, \"50\", \"100.00\", \"50.0\", \"50.0\");\n\n        /*\n         * this.journalEntryHelper.checkJournalEntryForAssetAccount( assetAccount, \"20 September 2011\", new\n         * JournalEntry(Float.parseFloat(\"50.0\"), JournalEntry.TransactionType.CREDIT));\n         * this.journalEntryHelper.checkJournalEntryForExpenseAccount (expenseAccount, \"20 September 2011\", new\n         * JournalEntry(Float.parseFloat(\"50.0\"), JournalEntry.TransactionType.DEBIT));\n         */\n        final String jobName = \"Add Accrual Transactions\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(jobName);\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        checkAccrualTransactions(loanSchedule, loanID);\n\n        LOG.info(\"----------Make repayment 2------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3251.49\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3251.49\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3251.49\"), JournalEntry.TransactionType.CREDIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"0\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"--------------Waive interest---------------\");\n        this.loanTransactionHelper.waiveInterest(\"20 December 2011\", String.valueOf(61.79), loanID);\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap thirdInstallment = loanSchedule.get(3);\n        validateNumberForEqual(\"60.59\", String.valueOf(thirdInstallment.get(\"interestOutstanding\")));\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 December 2011\",\n                new JournalEntry(Float.parseFloat(\"61.79\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"20 December 2011\",\n                new JournalEntry(Float.parseFloat(\"61.79\"), JournalEntry.TransactionType.DEBIT));\n\n        Integer flatPenaltySpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"100\", true));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatPenaltySpecifiedDueDate), \"29 September 2011\", \"100\"));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(flatPenaltySpecifiedDueDate, loanCharges, \"100\", \"0.00\", \"100.0\", \"0.0\");\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"100\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // checking the journal entry as applied penalty has been collected\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3301.49\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3301.49\"), JournalEntry.TransactionType.CREDIT));\n\n        LOG.info(\"----------Make repayment 3 advance------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3301.49\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3301.49\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3301.49\"), JournalEntry.TransactionType.CREDIT));\n\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatPenaltySpecifiedDueDate), \"10 January 2012\", \"100\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"100\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3239.68\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Pay applied penalty ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"100\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"100\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"100\"), JournalEntry.TransactionType.CREDIT));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"0\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3139.68\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Make repayment 4 ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"3139.68\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"3139.68\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3139.68\"), JournalEntry.TransactionType.CREDIT));\n        loanStatusHashMap = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"status\");\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n    }"}
{"prompt": "Create a test that tests loan With Charges Of Type Amount Percentage And Periodic Accrual Accounting Enabled", "completion": "    @Test\n    public void loanWithChargesOfTypeAmountPercentageAndPeriodicAccrualAccountingEnabled() throws InterruptedException {\n        this.journalEntryHelper = new JournalEntryHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        // Add charges with payment mode regular\n        List<HashMap> charges = new ArrayList<>();\n        Integer percentageDisbursementCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\"));\n        addCharges(charges, percentageDisbursementCharge, \"1\", null);\n\n        Integer percentageSpecifiedDueDateCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\", false));\n        addCharges(charges, percentageSpecifiedDueDateCharge, \"1\", \"29 September 2011\");\n\n        Integer percentageInstallmentFee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\", false));\n        addCharges(charges, percentageInstallmentFee, \"1\", \"29 September 2011\");\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanProductID = createLoanProduct(false, ACCRUAL_PERIODIC, assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        verifyLoanRepaymentSchedule(loanSchedule);\n\n        List<HashMap> loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(percentageDisbursementCharge, loanCharges, \"1\", \"120.00\", \"0.0\", \"0.0\");\n        validateCharge(percentageSpecifiedDueDateCharge, loanCharges, \"1\", \"120.00\", \"0.0\", \"0.0\");\n        validateCharge(percentageInstallmentFee, loanCharges, \"1\", \"120.00\", \"0.0\", \"0.0\");\n\n        // check for disbursement fee\n        HashMap disbursementDetail = loanSchedule.get(0);\n        validateNumberForEqual(\"120.00\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        // check for charge at specified date and installment fee\n        HashMap firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"149.11\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        // check for installment fee\n        HashMap secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"29.70\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanTransactionDetails = loanTransactionHelper.getLoanTransactionDetails(requestSpec, responseSpec, loanID);\n        validateAccrualTransactionForDisbursementCharge(loanTransactionDetails);\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(Float.parseFloat(\"120.00\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 September 2011\", assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 September 2011\",\n                new JournalEntry(Float.parseFloat(\"120.00\"), JournalEntry.TransactionType.CREDIT));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(percentageDisbursementCharge, loanCharges, \"1\", \"0.0\", \"120.00\", \"0.0\");\n\n        LOG.info(\"-------------Make repayment 1-----------\");\n        this.loanTransactionHelper.makeRepayment(\"20 October 2011\", Float.parseFloat(\"3300.60\"), loanID);\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(percentageDisbursementCharge, loanCharges, \"1\", \"0.00\", \"120.00\", \"0.0\");\n        validateCharge(percentageSpecifiedDueDateCharge, loanCharges, \"1\", \"0.00\", \"120.0\", \"0.0\");\n        validateCharge(percentageInstallmentFee, loanCharges, \"1\", \"90.89\", \"29.11\", \"0.0\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3300.60\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3300.60\"), JournalEntry.TransactionType.CREDIT));\n\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(percentageSpecifiedDueDateCharge), \"29 October 2011\", \"1\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"149.70\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n        LOG.info(\"----------- Waive installment charge for 2nd installment ---------\");\n        this.loanTransactionHelper.waiveChargesForLoan(loanID, (Integer) getloanCharge(percentageInstallmentFee, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getWaiveChargeJSON(String.valueOf(2)));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(percentageInstallmentFee, loanCharges, \"1\", \"61.19\", \"29.11\", \"29.70\");\n\n        /*\n         * this.journalEntryHelper.checkJournalEntryForAssetAccount( assetAccount, \"20 September 2011\", new\n         * JournalEntry(Float.parseFloat(\"29.7\"), JournalEntry.TransactionType.CREDIT));\n         * this.journalEntryHelper.checkJournalEntryForExpenseAccount (expenseAccount, \"20 September 2011\", new\n         * JournalEntry(Float.parseFloat(\"29.7\"), JournalEntry.TransactionType.DEBIT));\n         */\n\n        final String jobName = \"Add Accrual Transactions\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(jobName);\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        checkAccrualTransactions(loanSchedule, loanID);\n\n        LOG.info(\"----------Make repayment 2------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3271.49\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3271.49\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3271.49\"), JournalEntry.TransactionType.CREDIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"0\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"--------------Waive interest---------------\");\n        this.loanTransactionHelper.waiveInterest(\"20 December 2011\", String.valueOf(61.79), loanID);\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap thirdInstallment = loanSchedule.get(3);\n        validateNumberForEqual(\"60.59\", String.valueOf(thirdInstallment.get(\"interestOutstanding\")));\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 December 2011\",\n                new JournalEntry(Float.parseFloat(\"61.79\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"20 December 2011\",\n                new JournalEntry(Float.parseFloat(\"61.79\"), JournalEntry.TransactionType.DEBIT));\n\n        Integer percentagePenaltySpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\", true));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(percentagePenaltySpecifiedDueDate), \"29 September 2011\", \"1\"));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(percentagePenaltySpecifiedDueDate, loanCharges, \"1\", \"0.00\", \"120.0\", \"0.0\");\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"120\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // checking the journal entry as applied penalty has been collected\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3300.60\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3300.60\"), JournalEntry.TransactionType.CREDIT));\n\n        LOG.info(\"----------Make repayment 3 advance------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3301.78\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3301.78\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3301.78\"), JournalEntry.TransactionType.CREDIT));\n\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(percentagePenaltySpecifiedDueDate), \"10 January 2012\", \"1\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"120\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3240.58\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Pay applied penalty ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"120\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"120\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"120\"), JournalEntry.TransactionType.CREDIT));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"0\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3120.58\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Make repayment 4 ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"3120.58\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"3120.58\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3120.58\"), JournalEntry.TransactionType.CREDIT));\n        loanStatusHashMap = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"status\");\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n    }"}
{"prompt": "Create a test that tests loan With Charges Of Type Amount Plus Interest Percentage And Periodic Accrual Accounting Enabled", "completion": "    @Test\n    public void loanWithChargesOfTypeAmountPlusInterestPercentageAndPeriodicAccrualAccountingEnabled() throws InterruptedException {\n        this.journalEntryHelper = new JournalEntryHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        // Add charges with payment mode regular\n        List<HashMap> charges = new ArrayList<>();\n        Integer amountPlusInterestPercentageDisbursementCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanDisbursementJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\"));\n        addCharges(charges, amountPlusInterestPercentageDisbursementCharge, \"1\", null);\n\n        Integer amountPlusInterestPercentageSpecifiedDueDateCharge = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\", false));\n        addCharges(charges, amountPlusInterestPercentageSpecifiedDueDateCharge, \"1\", \"29 September 2011\");\n\n        Integer amountPlusInterestPercentageInstallmentFee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT_AND_INTEREST, \"1\", false));\n        addCharges(charges, amountPlusInterestPercentageInstallmentFee, \"1\", \"29 September 2011\");\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanProductID = createLoanProduct(false, ACCRUAL_PERIODIC, assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"12,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        verifyLoanRepaymentSchedule(loanSchedule);\n\n        List<HashMap> loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(amountPlusInterestPercentageDisbursementCharge, loanCharges, \"1\", \"126.06\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentageSpecifiedDueDateCharge, loanCharges, \"1\", \"126.06\", \"0.0\", \"0.0\");\n        validateCharge(amountPlusInterestPercentageInstallmentFee, loanCharges, \"1\", \"126.04\", \"0.0\", \"0.0\");\n\n        // check for disbursement fee\n        HashMap disbursementDetail = loanSchedule.get(0);\n        validateNumberForEqual(\"126.06\", String.valueOf(disbursementDetail.get(\"feeChargesDue\")));\n\n        // check for charge at specified date and installment fee\n        HashMap firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"157.57\", String.valueOf(firstInstallment.get(\"feeChargesDue\")));\n\n        // check for installment fee\n        HashMap secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"31.51\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(Float.parseFloat(\"126.06\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 September 2011\", assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"20 September 2011\",\n                new JournalEntry(Float.parseFloat(\"126.06\"), JournalEntry.TransactionType.CREDIT));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(amountPlusInterestPercentageDisbursementCharge, loanCharges, \"1\", \"0.0\", \"126.06\", \"0.0\");\n\n        LOG.info(\"-------------Make repayment 1-----------\");\n        this.loanTransactionHelper.makeRepayment(\"20 October 2011\", Float.parseFloat(\"3309.06\"), loanID);\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(amountPlusInterestPercentageDisbursementCharge, loanCharges, \"1\", \"0.00\", \"126.06\", \"0.0\");\n        validateCharge(amountPlusInterestPercentageSpecifiedDueDateCharge, loanCharges, \"1\", \"0.00\", \"126.06\", \"0.0\");\n        validateCharge(amountPlusInterestPercentageInstallmentFee, loanCharges, \"1\", \"94.53\", \"31.51\", \"0.0\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3309.06\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3309.06\"), JournalEntry.TransactionType.CREDIT));\n\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(\n                String.valueOf(amountPlusInterestPercentageSpecifiedDueDateCharge), \"29 October 2011\", \"1\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"157.57\", String.valueOf(secondInstallment.get(\"feeChargesDue\")));\n        LOG.info(\"----------- Waive installment charge for 2nd installment ---------\");\n        this.loanTransactionHelper.waiveChargesForLoan(loanID,\n                (Integer) getloanCharge(amountPlusInterestPercentageInstallmentFee, loanCharges).get(\"id\"),\n                LoanTransactionHelper.getWaiveChargeJSON(String.valueOf(2)));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(amountPlusInterestPercentageInstallmentFee, loanCharges, \"1\", \"63.02\", \"31.51\", \"31.51\");\n\n        /*\n         * this.journalEntryHelper.checkJournalEntryForAssetAccount( assetAccount, \"20 September 2011\", new\n         * JournalEntry( Float.parseFloat(\"31.51\"), JournalEntry.TransactionType.CREDIT));\n         * this.journalEntryHelper.checkJournalEntryForExpenseAccount (expenseAccount, \"20 September 2011\", new\n         * JournalEntry(Float.parseFloat(\"31.51\"), JournalEntry.TransactionType.DEBIT));\n         */\n\n        final String jobName = \"Add Accrual Transactions\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(jobName);\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        checkAccrualTransactions(loanSchedule, loanID);\n\n        LOG.info(\"----------Make repayment 2------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3277.55\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3277.55\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3277.55\"), JournalEntry.TransactionType.CREDIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"0\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"--------------Waive interest---------------\");\n        this.loanTransactionHelper.waiveInterest(\"20 December 2011\", String.valueOf(61.79), loanID);\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap thirdInstallment = loanSchedule.get(3);\n        validateNumberForEqual(\"60.59\", String.valueOf(thirdInstallment.get(\"interestOutstanding\")));\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 December 2011\",\n                new JournalEntry(Float.parseFloat(\"61.79\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"20 December 2011\",\n                new JournalEntry(Float.parseFloat(\"61.79\"), JournalEntry.TransactionType.DEBIT));\n\n        Integer amountPlusInterestPercentagePenaltySpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"1\", true));\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(\n                String.valueOf(amountPlusInterestPercentagePenaltySpecifiedDueDate), \"29 September 2011\", \"1\"));\n        loanCharges.clear();\n        loanCharges = this.loanTransactionHelper.getLoanCharges(loanID);\n        validateCharge(amountPlusInterestPercentagePenaltySpecifiedDueDate, loanCharges, \"1\", \"0.0\", \"120.0\", \"0.0\");\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"120\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // checking the journal entry as applied penalty has been collected\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 October 2011\",\n                new JournalEntry(Float.parseFloat(\"3309.06\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3309.06\"), JournalEntry.TransactionType.CREDIT));\n\n        LOG.info(\"----------Make repayment 3 advance------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3303\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 November 2011\",\n                new JournalEntry(Float.parseFloat(\"3303\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3303\"), JournalEntry.TransactionType.CREDIT));\n\n        this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(\n                String.valueOf(amountPlusInterestPercentagePenaltySpecifiedDueDate), \"10 January 2012\", \"1\"));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"120\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3241.19\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Pay applied penalty ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"120\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"120\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"120\"), JournalEntry.TransactionType.CREDIT));\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"0\", String.valueOf(fourthInstallment.get(\"penaltyChargesOutstanding\")));\n        validateNumberForEqual(\"3121.19\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n\n        LOG.info(\"----------Make repayment 4 ------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"3121.19\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"20 January 2012\",\n                new JournalEntry(Float.parseFloat(\"3121.19\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"3121.19\"), JournalEntry.TransactionType.CREDIT));\n        loanStatusHashMap = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"status\");\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n    }"}
{"prompt": "Create a test that tests test Client Loan Schedule With Currency Details", "completion": "    @Test\n    public void testClientLoanScheduleWithCurrencyDetails() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanProductID = createLoanProduct(\"100\", \"0\", LoanProductTestBuilder.DEFAULT_STRATEGY);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, null, collaterals);\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec,\n                loanID);\n        verifyLoanRepaymentScheduleForEqualPrincipal(loanSchedule);\n\n    }"}
{"prompt": "Create a test that tests test Client Loan Schedule With Currency Details with grace", "completion": "    @Test\n    public void testClientLoanScheduleWithCurrencyDetails_with_grace() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanProductID = createLoanProduct(\"100\", \"0\", LoanProductTestBuilder.DEFAULT_STRATEGY);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"5\", collaterals);\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec,\n                loanID);\n        verifyLoanRepaymentScheduleForEqualPrincipalWithGrace(loanSchedule);\n\n    }"}
{"prompt": "Create a test that tests test RBIPayment Strategy", "completion": "    @Test\n    public void testRBIPaymentStrategy() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        /***\n         * Create loan product with RBI strategy\n         */\n        final Integer loanProductID = createLoanProduct(\"100\", \"0\", LoanProductTestBuilder.RBI_INDIA_STRATEGY);\n        Assertions.assertNotNull(loanProductID);\n\n        /***\n         * Apply for loan application and verify loan status\n         */\n        final String savingsId = null;\n        final String principal = \"12,000.00\";\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplicationWithPaymentStrategy(clientID, loanProductID, null, savingsId, principal,\n                LoanApplicationTestBuilder.RBI_INDIA_STRATEGY, collaterals);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"3200\", String.valueOf(firstInstallment.get(\"totalOutstandingForPeriod\")));\n\n        /***\n         * Make payment for installment #1\n         */\n        this.loanTransactionHelper.makeRepayment(\"20 October 2011\", Float.parseFloat(\"3200\"), loanID);\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"0.00\", String.valueOf(firstInstallment.get(\"totalOutstandingForPeriod\")));\n\n        /***\n         * Verify 2nd and 3rd repayments dues before making excess payment for installment no 2\n         */\n        HashMap secondInstallment = loanSchedule.get(2);\n        HashMap thirdInstallment = loanSchedule.get(3);\n\n        validateNumberForEqual(\"3200\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n        validateNumberForEqual(\"3200\", String.valueOf(thirdInstallment.get(\"totalOutstandingForPeriod\")));\n\n        validateNumberForEqual(\"3000\", String.valueOf(secondInstallment.get(\"principalOutstanding\")));\n        validateNumberForEqual(\"3100\", String.valueOf(thirdInstallment.get(\"principalOutstanding\")));\n\n        /***\n         * Make payment for installment #2\n         */\n        this.loanTransactionHelper.makeRepayment(\"20 November 2011\", Float.parseFloat(\"3200\"), loanID);\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        /***\n         * Verify 2nd and 3rd repayments after making excess payment for installment no 2\n         */\n        secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"0.00\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        /***\n         * According to RBI Excess payment should go to principal portion of next installment, but as interest\n         * recalculation is not implemented, it wont make any difference to schedule even though if we made excess\n         * payment, so excess payments will behave the same as regular payment with the excess amount\n         */\n        thirdInstallment = loanSchedule.get(3);\n        validateNumberForEqual(\"3200\", String.valueOf(thirdInstallment.get(\"totalOutstandingForPeriod\")));\n        validateNumberForEqual(\"3100\", String.valueOf(thirdInstallment.get(\"principalOutstanding\")));\n        validateNumberForEqual(\"0\", String.valueOf(thirdInstallment.get(\"principalPaid\")));\n        validateNumberForEqual(\"0\", String.valueOf(thirdInstallment.get(\"interestPaid\")));\n        validateNumberForEqual(\"100.00\", String.valueOf(thirdInstallment.get(\"interestOutstanding\")));\n\n        /***\n         * Make payment with due amount of 3rd installment on 4th installment date\n         */\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"3200\"), loanID);\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n\n        /***\n         * Verify overdue interests are deducted first and then remaining amount for interest portion of due installment\n         */\n        thirdInstallment = loanSchedule.get(3);\n        HashMap fourthInstallment = loanSchedule.get(4);\n\n        validateNumberForEqual(\"100\", String.valueOf(thirdInstallment.get(\"totalOutstandingForPeriod\")));\n        validateNumberForEqual(\"100\", String.valueOf(thirdInstallment.get(\"principalOutstanding\")));\n\n        validateNumberForEqual(\"2900\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n        validateNumberForEqual(\"100\", String.valueOf(fourthInstallment.get(\"interestPaid\")));\n        validateNumberForEqual(\"0.00\", String.valueOf(fourthInstallment.get(\"interestOutstanding\")));\n\n        this.loanTransactionHelper.makeRepayment(\"20 January 2012\", Float.parseFloat(\"3000\"), loanID);\n\n        /***\n         * verify loan is closed as we paid full amount\n         */\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation WITH REST SAME AS REPAYMENT INTEREST COMPOUND NONE STRATEGY REDUCE EMI", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_SAME_AS_REPAYMENT_INTEREST_COMPOUND_NONE_STRATEGY_REDUCE_EMI() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.DEFAULT_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_EMI_AMOUN,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD, \"0\", null,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, null, null);\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE, null,\n                LoanApplicationTestBuilder.DEFAULT_STRATEGY, new ArrayList<HashMap>(0));\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2528.81\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        Float earlyPayment = Float.parseFloat(\"4000\");\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -5);\n        final String LOAN_SECOND_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(LOAN_SECOND_REPAYMENT_DATE, earlyPayment, loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"3965.31\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"1771.88\", \"16.39\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"1780.05\", \"8.22\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        validateNumberForEqualWithMsg(\"verify pre-close amount\", \"3551.93\", prepayAmount);\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation WITH REST SAME AS REPAYMENT INTEREST COMPOUND NONE STRATEGY REDUCE EMI PRE CLOSE INTEREST PRE CLOSE DATE", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_SAME_AS_REPAYMENT_INTEREST_COMPOUND_NONE_STRATEGY_REDUCE_EMI_PRE_CLOSE_INTEREST_PRE_CLOSE_DATE() {\n        String preCloseInterestStrategy = LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE;\n        String preCloseAmount = \"7561.84\";\n        testLoanScheduleWithInterestRecalculation_WITH_REST_SAME_AS_REPAYMENT_INTEREST_COMPOUND_NONE_STRATEGY_REDUCE_EMI_PRE_CLOSE_INTEREST(\n                preCloseInterestStrategy, preCloseAmount);\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation WITH REST SAME AS REPAYMENT INTEREST COMPOUND NONE STRATEGY REDUCE EMI PRE CLOSE INTEREST REST DATE", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_SAME_AS_REPAYMENT_INTEREST_COMPOUND_NONE_STRATEGY_REDUCE_EMI_PRE_CLOSE_INTEREST_REST_DATE() {\n        String preCloseInterestStrategy = LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_REST_DATE;\n        String preCloseAmount = \"7586.62\";\n        testLoanScheduleWithInterestRecalculation_WITH_REST_SAME_AS_REPAYMENT_INTEREST_COMPOUND_NONE_STRATEGY_REDUCE_EMI_PRE_CLOSE_INTEREST(\n                preCloseInterestStrategy, preCloseAmount);\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation WITH REST SAME AS REPAYMENT INTEREST COMPOUND NONE STRATEGY REDUCE EMI WITH INSTALLMENT CHARGE", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_SAME_AS_REPAYMENT_INTEREST_COMPOUND_NONE_STRATEGY_REDUCE_EMI_WITH_INSTALLMENT_CHARGE() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.DEFAULT_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_EMI_AMOUN,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD, \"0\", null,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, null, null);\n\n        List<HashMap> charges = new ArrayList<>();\n        Integer installmentCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_INTEREST, \"10\", false));\n        addCharges(charges, installmentCharge, \"10\", null);\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE, null,\n                LoanApplicationTestBuilder.DEFAULT_STRATEGY, charges);\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"4.62\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"3.47\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"2.32\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"1.16\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"4.62\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.76\", \"46.15\", \"4.62\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"2.32\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2528.81\", \"11.67\", \"1.17\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"4.62\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"3.47\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"2.32\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"1.16\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        Float earlyPayment = Float.parseFloat(\"4000\");\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -5);\n        final String LOAN_SECOND_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(LOAN_SECOND_REPAYMENT_DATE, earlyPayment, loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"4.62\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"3961.84\", \"34.69\", \"3.47\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"1773.61\", \"16.41\", \"1.64\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"1781.79\", \"8.22\", \"0.82\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation WITH REST DAILY INTEREST COMPOUND INTEREST STRATEGY REDUCE NUMBER OF INSTALLMENTS", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_DAILY_INTEREST_COMPOUND_INTEREST_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Integer dayOfWeek = getDayOfWeek(todaysDate);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.RBI_INDIA_STRATEGY, LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_INTEREST,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_WEEKLY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, null, dayOfWeek, null, dayOfWeek);\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE,\n                LoanApplicationTestBuilder.RBI_INDIA_STRATEGY, new ArrayList<HashMap>(0));\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.54\", \"46.37\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        loanSchedule = this.loanTransactionHelper.getLoanFutureRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, 0, false, \"4965.3\", \"92.52\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues, 0);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        Float earlyPayment = Float.parseFloat(\"4000\");\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -5);\n        final String LOAN_SECOND_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(LOAN_SECOND_REPAYMENT_DATE, earlyPayment, loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        Calendar today = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        Map<String, Object> paymentday = new HashMap<>(3);\n        paymentday.put(\"dueDate\", getDateAsArray(today, -5, Calendar.DAY_OF_MONTH));\n        paymentday.put(\"principalDue\", \"3990.09\");\n        paymentday.put(\"interestDue\", \"9.91\");\n        paymentday.put(\"feeChargesDue\", \"0\");\n        paymentday.put(\"penaltyChargesDue\", \"0\");\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        expectedvalues.add(paymentday);\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.31\", \"11.6\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"1009.84\", \"4.66\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Interoperation Loan Repayment API", "completion": "    @Test\n    public void testInteroperationLoanRepaymentAPI() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"42\", true);\n        Calendar startDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        startDate.add(Calendar.MONTH, -8);\n\n        Calendar firstRepaymentDate = (Calendar) startDate.clone();\n        firstRepaymentDate.add(Calendar.MONTH, 1);\n        firstRepaymentDate.add(Calendar.DAY_OF_MONTH, firstRepaymentDate.getActualMaximum(Calendar.DAY_OF_MONTH) - Calendar.DAY_OF_MONTH);\n        String firstRepayment = dateFormat.format(firstRepaymentDate.getTime());\n\n        final String loanDisbursementDate = dateFormat.format(startDate.getTime());\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, \"12\");\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, loanDisbursementDate,\n                LoanApplicationTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY, firstRepayment);\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        Assertions.assertNotNull(loanSchedule);\n        startDate.add(Calendar.DAY_OF_MONTH, 2);\n        String loanFirstRepaymentDate = dateFormat.format(startDate.getTime());\n\n        Float earlyPayment = Float.parseFloat(\"3000\");\n        String accountNo = JsonPath.from(loanDetails).get(\"accountNo\").toString();\n\n        HashMap loanRepayment = this.loanTransactionHelper.makeRepaymentWithAccountNo(loanFirstRepaymentDate, earlyPayment, accountNo);\n        assertNotNull(loanRepayment);\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation WITH REST WEEKLY INTEREST COMPOUND INTEREST FEE STRATEGY REDUCE NEXT INSTALLMENTS", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_WEEKLY_INTEREST_COMPOUND_INTEREST_FEE_STRATEGY_REDUCE_NEXT_INSTALLMENTS() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        Integer compoundingDayOfMonth = getDayOfMonth(todaysDate);\n        Integer compoundingDayOfWeek = getDayOfWeek(todaysDate);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -2);\n        Integer restDayOfMonth = getDayOfMonth(todaysDate);\n        Integer restDayOfWeek = getDayOfWeek(todaysDate);\n        final String REST_START_DATE = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        todaysDate.add(Calendar.DAY_OF_MONTH, 2);\n        final String LOAN_FLAT_CHARGE_DATE = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.DAY_OF_MONTH, 14);\n        final String LOAN_INTEREST_CHARGE_DATE = dateFormat.format(todaysDate.getTime());\n        List<HashMap> charges = new ArrayList<>(2);\n        Integer flat = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"100\", false));\n        Integer principalPercentage = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_PERCENTAGE_AMOUNT, \"2\", false));\n\n        addCharges(charges, flat, \"100\", LOAN_FLAT_CHARGE_DATE);\n        addCharges(charges, principalPercentage, \"2\", LOAN_INTEREST_CHARGE_DATE);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.DEFAULT_STRATEGY, LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_INTEREST_AND_FEE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_RESCHEDULE_NEXT_REPAYMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_WEEKLY, \"1\", REST_START_DATE,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_WEEKLY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, compoundingDayOfMonth, compoundingDayOfWeek,\n                restDayOfMonth, restDayOfWeek);\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE,\n                LOAN_DISBURSEMENT_DATE, LoanApplicationTestBuilder.DEFAULT_STRATEGY, charges);\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"100.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"200\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"100.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.08\", \"46.83\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"200\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.49\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        Calendar repaymentDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        repaymentDate.add(Calendar.DAY_OF_MONTH, -7);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(repaymentDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"100.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"200\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        Float earlyPayment = Float.parseFloat(\"5100\");\n        repaymentDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        repaymentDate.add(Calendar.DAY_OF_MONTH, -5);\n        final String LOAN_SECOND_REPAYMENT_DATE = dateFormat.format(repaymentDate.getTime());\n        this.loanTransactionHelper.makeRepayment(LOAN_SECOND_REPAYMENT_DATE, earlyPayment, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"100.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"5065.31\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"0\", \"11.32\", \"200\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2451.93\", \"11.32\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation WITH REST WEEKLY INTEREST COMPOUND INTEREST FEE STRATEGY REDUCE NEXT INSTALLMENTS PRE CLOSE INTEREST PRE CLOSE DATE", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_WEEKLY_INTEREST_COMPOUND_INTEREST_FEE_STRATEGY_REDUCE_NEXT_INSTALLMENTS_PRE_CLOSE_INTEREST_PRE_CLOSE_DATE() {\n        String preCloseInterestStrategy = LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE;\n        String preCloseAmount = \"7761.89\";\n        testLoanScheduleWithInterestRecalculation_WITH_REST_WEEKLY_INTEREST_COMPOUND_INTEREST_FEE_STRATEGY_REDUCE_NEXT_INSTALLMENTS_PRE_CLOSE_INTEREST(\n                preCloseInterestStrategy, preCloseAmount);\n\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation WITH REST WEEKLY INTEREST COMPOUND INTEREST FEE STRATEGY REDUCE NEXT INSTALLMENTS PRE CLOSE INTEREST REST DATE", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_WEEKLY_INTEREST_COMPOUND_INTEREST_FEE_STRATEGY_REDUCE_NEXT_INSTALLMENTS_PRE_CLOSE_INTEREST_REST_DATE() {\n        String preCloseInterestStrategy = LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_REST_DATE;\n        String preCloseAmount = \"7786.79\";\n        testLoanScheduleWithInterestRecalculation_WITH_REST_WEEKLY_INTEREST_COMPOUND_INTEREST_FEE_STRATEGY_REDUCE_NEXT_INSTALLMENTS_PRE_CLOSE_INTEREST(\n                preCloseInterestStrategy, preCloseAmount);\n\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation WITH REST DAILY INTEREST COMPOUND INTEREST FEE STRATEGY WITH OVERDUE CHARGE", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_REST_DAILY_INTEREST_COMPOUND_INTEREST_FEE_STRATEGY_WITH_OVERDUE_CHARGE()\n            throws InterruptedException {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7 * 3);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -2);\n        final String REST_START_DATE = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n\n        Integer overdueFeeChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"10\"));\n        Assertions.assertNotNull(overdueFeeChargeId);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final String recalculationCompoundingFrequencyInterval = null;\n        final String recalculationCompoundingFrequencyDate = null;\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.DEFAULT_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_INTEREST_AND_FEE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_RESCHEDULE_NEXT_REPAYMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"1\", REST_START_DATE,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD, recalculationCompoundingFrequencyInterval,\n                recalculationCompoundingFrequencyDate, LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null,\n                overdueFeeChargeId.toString(), false, null, null, null, null);\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE,\n                REST_START_DATE, LoanApplicationTestBuilder.DEFAULT_STRATEGY, null);\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -2, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n\n        addRepaymentValues(expectedvalues, todaysDate, -2, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.54\", \"46.37\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.33\", \"46.58\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2552.37\", \"11.78\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        String JobName = \"Apply penalty to overdue loans\";\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -2, false, \"2482.76\", \"46.15\", \"0.0\", \"252.89\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2481.38\", \"47.53\", \"0.0\", \"252.89\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2479.99\", \"48.92\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2555.87\", \"11.8\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        Calendar repaymentDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        repaymentDate.add(Calendar.DAY_OF_MONTH, -7 * 2);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(repaymentDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        totalDueForCurrentPeriod = totalDueForCurrentPeriod - Float.parseFloat(\"252.89\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -2, false, \"2482.76\", \"46.15\", \"0.0\", \"252.89\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2493.05\", \"35.86\", \"0.0\", \"252.89\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2491.72\", \"37.19\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2532.47\", \"11.69\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        repaymentDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        repaymentDate.add(Calendar.DAY_OF_MONTH, -3);\n        final String LOAN_SECOND_REPAYMENT_DATE = dateFormat.format(repaymentDate.getTime());\n        totalDueForCurrentPeriod = (Float) loanSchedule.get(2).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_SECOND_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -2, false, \"2482.76\", \"46.15\", \"0.0\", \"252.89\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2493.05\", \"35.86\", \"0.0\", \"252.89\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2497.22\", \"31.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2526.97\", \"11.66\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation WITH PERIODIC ACCOUNTING", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_PERIODIC_ACCOUNTING() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        this.periodicAccrualAccountingHelper = new PeriodicAccrualAccountingHelper(this.requestSpec, this.responseSpec);\n        this.journalEntryHelper = new JournalEntryHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        LOG.info(\"Disbursal Date Calendar {}\", todaysDate.getTime());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        Account[] accounts = { assetAccount, incomeAccount, expenseAccount, overpaymentAccount };\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.DEFAULT_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_EMI_AMOUN,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD, \"0\", null,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, accounts, null, null);\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE, null,\n                LoanApplicationTestBuilder.DEFAULT_STRATEGY, new ArrayList<HashMap>(0));\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        LOG.info(\"Date during repayment schedule {}\", todaysDate.getTime());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2528.81\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(10000.0f, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(10000.0f, JournalEntry.TransactionType.DEBIT), };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, LOAN_DISBURSEMENT_DATE, assetAccountInitialEntry);\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        String runOndate = dateFormat.format(todaysDate.getTime());\n        LOG.info(\"runOndate : {}\", runOndate);\n        this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(runOndate);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(Utils.getLocalDateOfTenant().minusDays(7), 46.15f, 0f, 0f, loanID);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(Utils.getLocalDateOfTenant(), 46.15f, 0f, 0f, loanID);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(runOndate);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(Utils.getLocalDateOfTenant().minusDays(7), 46.15f, 0f, 0f, loanID);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(Utils.getLocalDateOfTenant(), 34.69f, 0f, 0f, loanID);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(Utils.getLocalDateOfTenant().minusDays(7), 46.15f, 0f, 0f, loanID);\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(Utils.getLocalDateOfTenant(), 34.69f, 0f, 0f, loanID);\n\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation WITH CURRENT REPAYMENT BASED ARREARS AGEING", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_CURRENT_REPAYMENT_BASED_ARREARS_AGEING() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.RBI_INDIA_STRATEGY, LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_INTEREST,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_RESCHEDULE_NEXT_REPAYMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, getDayOfMonth(todaysDate),\n                getDayOfWeek(todaysDate), getDayOfMonth(todaysDate), getDayOfWeek(todaysDate));\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE,\n                LOAN_DISBURSEMENT_DATE, LoanApplicationTestBuilder.RBI_INDIA_STRATEGY, new ArrayList<HashMap>(0));\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.54\", \"46.37\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        HashMap loanSummary = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, loanID);\n        List dates = (List) loanSummary.get(\"overdueSinceDate\");\n        assertEquals(todaysDate.get(Calendar.YEAR), dates.get(0));\n        assertEquals(todaysDate.get(Calendar.MONTH) + 1, dates.get(1));\n        assertEquals(todaysDate.get(Calendar.DAY_OF_MONTH), dates.get(2));\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -8);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        loanSummary = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, loanID);\n        dates = (List) loanSummary.get(\"overdueSinceDate\");\n        assertEquals(todaysDate.get(Calendar.YEAR), dates.get(0));\n        assertEquals(todaysDate.get(Calendar.MONTH) + 1, dates.get(1));\n        assertEquals(todaysDate.get(Calendar.DAY_OF_MONTH), dates.get(2));\n\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation WITH ORIGINAL REPAYMENT BASED ARREARS AGEING", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_ORIGINAL_REPAYMENT_BASED_ARREARS_AGEING() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        LOG.info(\"----timeeeeeeeeeeeeee------> {}\", dateFormat.format(todaysDate.getTime()));\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final String recalculationCompoundingFrequencyInterval = null;\n        final String recalculationCompoundingFrequencyDate = null;\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.RBI_INDIA_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_INTEREST,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_RESCHEDULE_NEXT_REPAYMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD, recalculationCompoundingFrequencyInterval,\n                recalculationCompoundingFrequencyDate, LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, null,\n                true, null, null, getDayOfMonth(todaysDate), getDayOfWeek(todaysDate));\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE,\n                LOAN_DISBURSEMENT_DATE, LoanApplicationTestBuilder.RBI_INDIA_STRATEGY, new ArrayList<HashMap>(0));\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.54\", \"46.37\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        HashMap loanSummary = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, loanID);\n        List dates = (List) loanSummary.get(\"overdueSinceDate\");\n        assertEquals(todaysDate.get(Calendar.YEAR), dates.get(0));\n        assertEquals(todaysDate.get(Calendar.MONTH) + 1, dates.get(1));\n        assertEquals(todaysDate.get(Calendar.DAY_OF_MONTH), dates.get(2));\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -8);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        loanSummary = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, loanID);\n        dates = (List) loanSummary.get(\"overdueSinceDate\");\n        Assertions.assertNull(dates);\n\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation FOR PRE CLOSE WITH MORATORIUM INTEREST APPLICABLE STRATEGY ON PRE CLOSE DATE", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_FOR_PRE_CLOSE_WITH_MORATORIUM_INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE() {\n        testLoanScheduleWithInterestRecalculation_FOR_PRE_CLOSE_WITH_MORATORIUM(\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, \"10006.59\");\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation FOR PRE CLOSE WITH MORATORIUM INTEREST APPLICABLE STRATEGY REST DATE", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_FOR_PRE_CLOSE_WITH_MORATORIUM_INTEREST_APPLICABLE_STRATEGY_REST_DATE() {\n        testLoanScheduleWithInterestRecalculation_FOR_PRE_CLOSE_WITH_MORATORIUM(\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_REST_DATE, \"10046.15\");\n    }"}
{"prompt": "Create a test that tests test Loan Refund By Cash Cash Based Accounting", "completion": "    @Test\n    public void testLoanRefundByCashCashBasedAccounting() {\n        this.journalEntryHelper = new JournalEntryHelper(this.requestSpec, this.responseSpec);\n\n        Calendar fourMonthsfromNowCalendar = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        fourMonthsfromNowCalendar.add(Calendar.MONTH, -4);\n\n        // FINERACT-885: If the loan starts on day 27-31th of month and not all months have that\n        // many days, then loan payment will get reset to a day of month less than today's day\n        // and 4th payment will be in the past. In such case, start the loan a few days later,\n        // so that 4th payment is guaranteed to be in the future.\n        if (fourMonthsfromNowCalendar.get(Calendar.DAY_OF_MONTH) > 27) {\n            fourMonthsfromNowCalendar.add(Calendar.DAY_OF_MONTH, 4);\n        }\n\n        String fourMonthsfromNow = Utils.convertDateToURLFormat(fourMonthsfromNowCalendar);\n\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        /***\n         * Create loan product with Default STYLE strategy\n         */\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProduct(\"0\", \"0\", LoanProductTestBuilder.DEFAULT_STRATEGY, CASH_BASED, assetAccount,\n                incomeAccount, expenseAccount, overpaymentAccount);\n        Assertions.assertNotNull(loanProductID);\n\n        /***\n         * Apply for loan application and verify loan status\n         */\n        final String savingsId = null;\n        final String principal = \"12,000.00\";\n\n        // Add charges with payment mode regular\n        List<HashMap> charges = new ArrayList<>();\n\n        Integer flatInstallmentFee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n        addCharges(charges, flatInstallmentFee, \"50\", null);\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplicationWithPaymentStrategyAndPastMonth(clientID, loanProductID, charges, savingsId,\n                principal, LoanApplicationTestBuilder.DEFAULT_STRATEGY, -4, collaterals);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(fourMonthsfromNow, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(fourMonthsfromNow, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final JournalEntry[] assetAccountInitialEntry = {\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, fourMonthsfromNow, assetAccountInitialEntry);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"2290\", String.valueOf(firstInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // Make payment for installment #1\n\n        fourMonthsfromNowCalendar.add(Calendar.MONTH, 1);\n\n        final String threeMonthsfromNow = Utils.convertDateToURLFormat(fourMonthsfromNowCalendar);\n\n        this.loanTransactionHelper.makeRepayment(threeMonthsfromNow, Float.parseFloat(\"2290\"), loanID);\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"0.00\", String.valueOf(firstInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // Make payment for installment #2\n        fourMonthsfromNowCalendar.add(Calendar.MONTH, 1);\n\n        final String twoMonthsfromNow = Utils.convertDateToURLFormat(fourMonthsfromNowCalendar);\n\n        this.loanTransactionHelper.makeRepayment(twoMonthsfromNow, Float.parseFloat(\"2290\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, twoMonthsfromNow,\n                new JournalEntry(Float.parseFloat(\"2290\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"2000\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, twoMonthsfromNow,\n                new JournalEntry(Float.parseFloat(\"50\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"240\"), JournalEntry.TransactionType.CREDIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        Map secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"0.00\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // Make payment for installment #3\n        // Pay 2290 more than expected\n        fourMonthsfromNowCalendar.add(Calendar.MONTH, 1);\n\n        final String oneMonthfromNow = Utils.convertDateToURLFormat(fourMonthsfromNowCalendar);\n\n        this.loanTransactionHelper.makeRepayment(oneMonthfromNow, Float.parseFloat(\"4580\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, oneMonthfromNow,\n                new JournalEntry(Float.parseFloat(\"4580\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"4000\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, oneMonthfromNow,\n                new JournalEntry(Float.parseFloat(\"100\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"480\"), JournalEntry.TransactionType.CREDIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap thirdInstallment = loanSchedule.get(3);\n        validateNumberForEqual(\"0.00\", String.valueOf(thirdInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // Make refund of 20\n        // max 2290 to refund. Pay 20 means only principal\n        // Default style refund order(principal, interest, fees and penalties\n        // paid: principal 2000, interest 240, fees 50, penalty 0\n        // refund 20 means paid: principal 1980, interest 240, fees 50, penalty\n        // 0\n\n        // FINERACT-885: As loan may not have started exactly four months ago,\n        // make final payment today and not four months from start (as that may be in the future)\n        fourMonthsfromNowCalendar.setTime(Date.from(Utils.getLocalDateOfTenant().atStartOfDay(Utils.getZoneIdOfTenant()).toInstant()));\n        final String now = Utils.convertDateToURLFormat(fourMonthsfromNowCalendar);\n\n        this.loanTransactionHelper.makeRefundByCash(now, Float.parseFloat(\"20\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, now,\n                new JournalEntry(Float.parseFloat(\"20\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"20\"), JournalEntry.TransactionType.DEBIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"20.00\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n        validateNumberForEqual(\"20.00\", String.valueOf(fourthInstallment.get(\"principalOutstanding\")));\n        validateNumberForEqual(\"0.00\", String.valueOf(fourthInstallment.get(\"interestOutstanding\")));\n        validateNumberForEqual(\"0.00\", String.valueOf(fourthInstallment.get(\"feeChargesOutstanding\")));\n\n        // Make refund of 2000\n        // max 2270 to refund. Pay 2000 means only principal\n        // paid: principal 1980, interest 240, fees 50, penalty 0\n        // refund 2000 means paid: principal 0, interest 220, fees 50, penalty 0\n\n        this.loanTransactionHelper.makeRefundByCash(now, Float.parseFloat(\"2000\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, now,\n                new JournalEntry(Float.parseFloat(\"2000\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"1980\"), JournalEntry.TransactionType.DEBIT));\n\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, now,\n                new JournalEntry(Float.parseFloat(\"20\"), JournalEntry.TransactionType.DEBIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"2020.00\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n        validateNumberForEqual(\"2000.00\", String.valueOf(fourthInstallment.get(\"principalOutstanding\")));\n        validateNumberForEqual(\"20.00\", String.valueOf(fourthInstallment.get(\"interestOutstanding\")));\n        validateNumberForEqual(\"0.00\", String.valueOf(fourthInstallment.get(\"feeChargesOutstanding\")));\n\n    }"}
{"prompt": "Create a test that tests test Loan Refund By Cash Accrual Based Accounting", "completion": "    @Test\n    public void testLoanRefundByCashAccrualBasedAccounting() {\n        this.journalEntryHelper = new JournalEntryHelper(this.requestSpec, this.responseSpec);\n\n        Calendar fourMonthsfromNowCalendar = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        fourMonthsfromNowCalendar.add(Calendar.MONTH, -4);\n\n        // FINERACT-885: If the loan starts on day 27-31th of month and not all months have that\n        // many days, then loan payment will get reset to a day of month less than today's day\n        // and 4th payment will be in the past. In such case, start the loan a few days later,\n        // so that 4th payment is guaranteed to be in the future.\n        if (fourMonthsfromNowCalendar.get(Calendar.DAY_OF_MONTH) > 27) {\n            fourMonthsfromNowCalendar.add(Calendar.DAY_OF_MONTH, 4);\n        }\n\n        String fourMonthsfromNow = Utils.convertDateToURLFormat(fourMonthsfromNowCalendar);\n\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        /***\n         * Create loan product with Default STYLE strategy\n         */\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProduct(\"0\", \"0\", LoanProductTestBuilder.DEFAULT_STRATEGY, ACCRUAL_UPFRONT, assetAccount,\n                incomeAccount, expenseAccount, overpaymentAccount);// ,\n        // LoanProductTestBuilder.EQUAL_INSTALLMENTS,\n        // LoanProductTestBuilder.FLAT_BALANCE);\n        Assertions.assertNotNull(loanProductID);\n\n        /***\n         * Apply for loan application and verify loan status\n         */\n        final String savingsId = null;\n        final String principal = \"12,000.00\";\n\n        // Add charges with payment mode regular\n        List<HashMap> charges = new ArrayList<>();\n\n        Integer flatInstallmentFee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n        addCharges(charges, flatInstallmentFee, \"50\", null);\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplicationWithPaymentStrategyAndPastMonth(clientID, loanProductID, charges, savingsId,\n                principal, LoanApplicationTestBuilder.DEFAULT_STRATEGY, -4, collaterals);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(fourMonthsfromNow, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(fourMonthsfromNow, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(Float.parseFloat(\"1440\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"300.00\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, fourMonthsfromNow, assetAccountInitialEntry);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"2290\", String.valueOf(firstInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // Make payment for installment #1\n\n        fourMonthsfromNowCalendar.add(Calendar.MONTH, 1);\n\n        final String threeMonthsfromNow = Utils.convertDateToURLFormat(fourMonthsfromNowCalendar);\n\n        this.loanTransactionHelper.makeRepayment(threeMonthsfromNow, Float.parseFloat(\"2290\"), loanID);\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"0.00\", String.valueOf(firstInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // Make payment for installment #2\n        fourMonthsfromNowCalendar.add(Calendar.MONTH, 1);\n\n        final String twoMonthsfromNow = Utils.convertDateToURLFormat(fourMonthsfromNowCalendar);\n\n        this.loanTransactionHelper.makeRepayment(twoMonthsfromNow, Float.parseFloat(\"2290\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, twoMonthsfromNow,\n                new JournalEntry(Float.parseFloat(\"2290\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"2290\"), JournalEntry.TransactionType.CREDIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        Map secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"0.00\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // Make payment for installment #3\n        // Pay 2290 more than expected\n        fourMonthsfromNowCalendar.add(Calendar.MONTH, 1);\n\n        final String oneMonthfromNow = Utils.convertDateToURLFormat(fourMonthsfromNowCalendar);\n\n        this.loanTransactionHelper.makeRepayment(oneMonthfromNow, Float.parseFloat(\"4580\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, oneMonthfromNow,\n                new JournalEntry(Float.parseFloat(\"4580\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"4580\"), JournalEntry.TransactionType.CREDIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap thirdInstallment = loanSchedule.get(3);\n        validateNumberForEqual(\"0.00\", String.valueOf(thirdInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // Make refund of 20\n        // max 2290 to refund. Pay 20 means only principal\n        // Default style refund order(principal, interest, fees and penalties\n        // paid: principal 2000, interest 240, fees 50, penalty 0\n        // refund 20 means paid: principal 1980, interest 240, fees 50, penalty\n        // 0\n\n        // FINERACT-885: As loan may not have started exactly four months ago,\n        // make final payment today and not four months from start (as that may be in the future)\n        fourMonthsfromNowCalendar.setTime(Date.from(Utils.getLocalDateOfTenant().atStartOfDay(Utils.getZoneIdOfTenant()).toInstant()));\n        final String now = Utils.convertDateToURLFormat(fourMonthsfromNowCalendar);\n\n        this.loanTransactionHelper.makeRefundByCash(now, Float.parseFloat(\"20\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, now,\n                new JournalEntry(Float.parseFloat(\"20\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"20\"), JournalEntry.TransactionType.DEBIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"20.00\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n        validateNumberForEqual(\"20.00\", String.valueOf(fourthInstallment.get(\"principalOutstanding\")));\n        validateNumberForEqual(\"0.00\", String.valueOf(fourthInstallment.get(\"interestOutstanding\")));\n        validateNumberForEqual(\"0.00\", String.valueOf(fourthInstallment.get(\"feeChargesOutstanding\")));\n\n        // Make refund of 2000\n        // max 2270 to refund. Pay 2000 means only principal\n        // paid: principal 1980, interest 240, fees 50, penalty 0\n        // refund 2000 means paid: principal 0, interest 220, fees 50, penalty 0\n\n        this.loanTransactionHelper.makeRefundByCash(now, Float.parseFloat(\"2000\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, now,\n                new JournalEntry(Float.parseFloat(\"2000\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"1980\"), JournalEntry.TransactionType.DEBIT));\n\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, now,\n                new JournalEntry(Float.parseFloat(\"20\"), JournalEntry.TransactionType.DEBIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"2020.00\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n        validateNumberForEqual(\"2000.00\", String.valueOf(fourthInstallment.get(\"principalOutstanding\")));\n        validateNumberForEqual(\"20.00\", String.valueOf(fourthInstallment.get(\"interestOutstanding\")));\n        validateNumberForEqual(\"0.00\", String.valueOf(fourthInstallment.get(\"feeChargesOutstanding\")));\n\n    }"}
{"prompt": "Create a test that tests test Loan Refund By Transfer Cash Based Accounting", "completion": "    @Test\n    public void testLoanRefundByTransferCashBasedAccounting() {\n        this.journalEntryHelper = new JournalEntryHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.accountTransferHelper = new AccountTransferHelper(this.requestSpec, this.responseSpec);\n\n        Calendar fourMonthsfromNowCalendar = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        fourMonthsfromNowCalendar.add(Calendar.MONTH, -4);\n\n        // FINERACT-885: If the loan starts on day 27-31th of month and not all months have that\n        // many days, then loan payment will get reset to a day of month less than today's day\n        // and 4th payment will be in the past. In such case, start the loan a few days later,\n        // so that 4th payment is guaranteed to be in the future.\n        if (fourMonthsfromNowCalendar.get(Calendar.DAY_OF_MONTH) > 27) {\n            fourMonthsfromNowCalendar.add(Calendar.DAY_OF_MONTH, 4);\n        }\n\n        String fourMonthsfromNow = Utils.convertDateToURLFormat(fourMonthsfromNowCalendar);\n\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        /***\n         * Create loan product with Default STYLE strategy\n         */\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProduct(\"0\", \"0\", LoanProductTestBuilder.DEFAULT_STRATEGY, CASH_BASED, assetAccount,\n                incomeAccount, expenseAccount, overpaymentAccount);\n        Assertions.assertNotNull(loanProductID);\n\n        /***\n         * Apply for loan application and verify loan status\n         */\n\n        final String principal = \"12,000.00\";\n\n        // Add charges with payment mode regular\n        List<HashMap> charges = new ArrayList<>();\n\n        Integer flatInstallmentFee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n        addCharges(charges, flatInstallmentFee, \"50\", null);\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplicationWithPaymentStrategyAndPastMonth(clientID, loanProductID, charges, null, principal,\n                LoanApplicationTestBuilder.DEFAULT_STRATEGY, -4, collaterals);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(fourMonthsfromNow, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(fourMonthsfromNow, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final JournalEntry[] assetAccountInitialEntry = {\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"12000.00\"), JournalEntry.TransactionType.DEBIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, fourMonthsfromNow, assetAccountInitialEntry);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"2290\", String.valueOf(firstInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // Make payment for installment #1\n\n        fourMonthsfromNowCalendar.add(Calendar.MONTH, 1);\n\n        final String threeMonthsfromNow = Utils.convertDateToURLFormat(fourMonthsfromNowCalendar);\n\n        this.loanTransactionHelper.makeRepayment(threeMonthsfromNow, Float.parseFloat(\"2290\"), loanID);\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        firstInstallment = loanSchedule.get(1);\n        validateNumberForEqual(\"0.00\", String.valueOf(firstInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // Make payment for installment #2\n        fourMonthsfromNowCalendar.add(Calendar.MONTH, 1);\n\n        final String twoMonthsfromNow = Utils.convertDateToURLFormat(fourMonthsfromNowCalendar);\n\n        this.loanTransactionHelper.makeRepayment(twoMonthsfromNow, Float.parseFloat(\"2290\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, twoMonthsfromNow,\n                new JournalEntry(Float.parseFloat(\"2290\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"2000\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, twoMonthsfromNow,\n                new JournalEntry(Float.parseFloat(\"50\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"240\"), JournalEntry.TransactionType.CREDIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        Map secondInstallment = loanSchedule.get(2);\n        validateNumberForEqual(\"0.00\", String.valueOf(secondInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // Make payment for installment #3\n        // Pay 2290 more than expected\n        fourMonthsfromNowCalendar.add(Calendar.MONTH, 1);\n\n        final String oneMonthfromNow = Utils.convertDateToURLFormat(fourMonthsfromNowCalendar);\n\n        this.loanTransactionHelper.makeRepayment(oneMonthfromNow, Float.parseFloat(\"4580\"), loanID);\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, oneMonthfromNow,\n                new JournalEntry(Float.parseFloat(\"4580\"), JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(Float.parseFloat(\"4000\"), JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, oneMonthfromNow,\n                new JournalEntry(Float.parseFloat(\"100\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"480\"), JournalEntry.TransactionType.CREDIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap thirdInstallment = loanSchedule.get(3);\n        validateNumberForEqual(\"0.00\", String.valueOf(thirdInstallment.get(\"totalOutstandingForPeriod\")));\n\n        // Make refund of 20\n        // max 2290 to refund. Pay 20 means only principal\n        // Default style refund order(principal, interest, fees and penalties\n        // paid: principal 2000, interest 240, fees 50, penalty 0\n        // refund 20 means paid: principal 1980, interest 240, fees 50, penalty\n        // 0\n\n        Float transferAmountValue = 20f;\n\n        // FINERACT-885: As loan may not have started exactly four months ago,\n        // make final payment today and not four months from start (as that may be in the future)\n        fourMonthsfromNowCalendar.setTime(Date.from(Utils.getLocalDateOfTenant().atStartOfDay(Utils.getZoneIdOfTenant()).toInstant()));\n        final String now = Utils.convertDateToURLFormat(fourMonthsfromNowCalendar);\n\n        final String FROM_LOAN_ACCOUNT_TYPE = \"1\";\n        final String TO_SAVINGS_ACCOUNT_TYPE = \"2\";\n\n        this.accountTransferHelper.refundLoanByTransfer(now, clientID, loanID, clientID, savingsId, FROM_LOAN_ACCOUNT_TYPE,\n                TO_SAVINGS_ACCOUNT_TYPE, transferAmountValue.toString());\n\n        Float toSavingsBalance = Float.parseFloat(MINIMUM_OPENING_BALANCE);\n\n        HashMap toSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        toSavingsBalance += transferAmountValue;\n\n        // Verifying toSavings Account Balance after Account Transfer\n        assertEquals(toSavingsBalance, toSavingsSummaryAfter.get(\"accountBalance\"),\n                \"Verifying From Savings Account Balance after Account Transfer\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, now,\n                new JournalEntry(Float.parseFloat(\"20\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"20\"), JournalEntry.TransactionType.DEBIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        HashMap fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"20.00\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n        validateNumberForEqual(\"20.00\", String.valueOf(fourthInstallment.get(\"principalOutstanding\")));\n        validateNumberForEqual(\"0.00\", String.valueOf(fourthInstallment.get(\"interestOutstanding\")));\n        validateNumberForEqual(\"0.00\", String.valueOf(fourthInstallment.get(\"feeChargesOutstanding\")));\n\n        // Make refund of 2000\n        // max 2270 to refund. Pay 2000 means only principal\n        // paid: principal 1980, interest 240, fees 50, penalty 0\n        // refund 2000 means paid: principal 0, interest 220, fees 50, penalty 0\n        // final String now = Utils.convertDate(fourMonthsfromNowCalendar);\n\n        transferAmountValue = 2000f;\n\n        this.accountTransferHelper.refundLoanByTransfer(now, clientID, loanID, clientID, savingsId, FROM_LOAN_ACCOUNT_TYPE,\n                TO_SAVINGS_ACCOUNT_TYPE, transferAmountValue.toString());\n\n        toSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        toSavingsBalance += transferAmountValue;\n\n        // Verifying toSavings Account Balance after Account Transfer\n        assertEquals(toSavingsBalance, toSavingsSummaryAfter.get(\"accountBalance\"),\n                \"Verifying From Savings Account Balance after Account Transfer\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, now,\n                new JournalEntry(Float.parseFloat(\"2000\"), JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(Float.parseFloat(\"1980\"), JournalEntry.TransactionType.DEBIT));\n\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, now,\n                new JournalEntry(Float.parseFloat(\"20\"), JournalEntry.TransactionType.DEBIT));\n\n        loanSchedule.clear();\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        fourthInstallment = loanSchedule.get(4);\n        validateNumberForEqual(\"2020.00\", String.valueOf(fourthInstallment.get(\"totalOutstandingForPeriod\")));\n        validateNumberForEqual(\"2000.00\", String.valueOf(fourthInstallment.get(\"principalOutstanding\")));\n        validateNumberForEqual(\"20.00\", String.valueOf(fourthInstallment.get(\"interestOutstanding\")));\n        validateNumberForEqual(\"0.00\", String.valueOf(fourthInstallment.get(\"feeChargesOutstanding\")));\n\n    }"}
{"prompt": "Create a test that tests test Loan Product Configuration", "completion": "    @Test\n    public void testLoanProductConfiguration() {\n        final String proposedAmount = \"5000\";\n        JsonObject loanProductConfigurationAsTrue = new JsonObject();\n        loanProductConfigurationAsTrue = this.createLoanProductConfigurationDetail(loanProductConfigurationAsTrue, true);\n\n        JsonObject loanProductConfigurationAsFalse = new JsonObject();\n        loanProductConfigurationAsFalse = this.createLoanProductConfigurationDetail(loanProductConfigurationAsFalse, false);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        Integer loanProductID = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withAmortizationTypeAsEqualInstallments().withRepaymentTypeAsMonth()\n                        .withRepaymentAfterEvery(\"1\").withRepaymentStrategy(LoanProductTestBuilder.DEFAULT_STRATEGY)\n                        .withInterestTypeAsDecliningBalance().withInterestCalculationPeriodTypeAsDays().withInArrearsTolerance(\"10\")\n                        .withMoratorium(\"2\", \"3\").withLoanProductConfiguration(loanProductConfigurationAsTrue).build(null));\n        LOG.info(\"-----------------------LOAN PRODUCT CREATED WITH ATTRIBUTE CONFIGURATION AS TRUE-------------------------- {}\",\n                loanProductID);\n        Integer loanID = applyForLoanApplicationWithProductConfigurationAsTrue(clientID, loanProductID, proposedAmount);\n        LOG.info(\"------------------------LOAN CREATED WITH ID------------------------------{}\", loanID);\n\n        loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().withAmortizationTypeAsEqualInstallments()\n                .withRepaymentTypeAsMonth().withRepaymentAfterEvery(\"1\").withRepaymentStrategy(LoanProductTestBuilder.DEFAULT_STRATEGY)\n                .withInterestTypeAsDecliningBalance().withInterestCalculationPeriodTypeAsDays().withInArrearsTolerance(\"10\")\n                .withMoratorium(\"2\", \"3\").withLoanProductConfiguration(loanProductConfigurationAsFalse).build(null));\n        LOG.info(\"-------------------LOAN PRODUCT CREATED WITH ATTRIBUTE CONFIGURATION AS FALSE---------------------- {}\", loanProductID);\n        /*\n         * Try to override attribute values in loan account when attribute configurations are set to false at product\n         * level\n         */\n        loanID = applyForLoanApplicationWithProductConfigurationAsFalse(clientID, loanProductID, proposedAmount);\n        LOG.info(\"--------------------------LOAN CREATED WITH ID------------------------- {}\", loanID);\n        this.validateIfValuesAreNotOverridden(loanID, loanProductID);\n    }"}
{"prompt": "Create a test that tests test Loan Foreclosure", "completion": "    @Test\n    public void testLoanForeclosure() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(false, NONE);\n\n        List<HashMap> charges = new ArrayList<>();\n\n        Integer flatAmountChargeOne = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n        addCharges(charges, flatAmountChargeOne, \"50\", \"01 October 2011\");\n        Integer flatAmountChargeTwo = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"100\", true));\n        addCharges(charges, flatAmountChargeTwo, \"100\", \"15 December 2011\");\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges, null, \"10,000.00\", collaterals);\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"----------------------------------- APPROVE LOAN -----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"----------------------------------- DISBURSE LOAN ----------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID, \"10,000.00\",\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        LOG.info(\"---------------------------------- Make repayment 1 --------------------------------------\");\n        this.loanTransactionHelper.makeRepayment(\"20 October 2011\", Float.parseFloat(\"2676.24\"), loanID);\n\n        LOG.info(\"---------------------------------- FORECLOSE LOAN ----------------------------------------\");\n        this.loanTransactionHelper.forecloseLoan(\"08 November 2011\", loanID);\n\n        // retrieving the loan status\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        // verifying the loan status is closed\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n        // retrieving the loan sub-status\n        loanStatusHashMap = LoanStatusChecker.getSubStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        // verifying the loan sub-status is foreclosed\n        LoanStatusChecker.verifyLoanAccountForeclosed(loanStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation WITH INTEREST FIRST STRATEGY AND REST DAILY INTEREST COMPOUND INTEREST STRATEGY REDUCE NUMBER OF INSTALLMENTS", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_INTEREST_FIRST_STRATEGY_AND_REST_DAILY_INTEREST_COMPOUND_INTEREST_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Integer dayOfWeek = getDayOfWeek(todaysDate);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_INTEREST,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_WEEKLY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, null, dayOfWeek, null, dayOfWeek);\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE,\n                LoanApplicationTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY, new ArrayList<HashMap>(0));\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.54\", \"46.37\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        loanSchedule = this.loanTransactionHelper.getLoanFutureRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, 0, false, \"4965.3\", \"92.52\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues, 0);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        Float earlyPayment = Float.parseFloat(\"4000\");\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -5);\n        final String LOAN_SECOND_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(LOAN_SECOND_REPAYMENT_DATE, earlyPayment, loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        Calendar today = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        Map<String, Object> paymentday = new HashMap<>(3);\n        paymentday.put(\"dueDate\", getDateAsArray(today, -5, Calendar.DAY_OF_MONTH));\n        paymentday.put(\"principalDue\", \"3990.09\");\n        paymentday.put(\"interestDue\", \"9.91\");\n        paymentday.put(\"feeChargesDue\", \"0\");\n        paymentday.put(\"penaltyChargesDue\", \"0\");\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        expectedvalues.add(paymentday);\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.31\", \"11.6\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"1009.84\", \"4.66\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation WITH INTEREST FIRST STRATEGY AND REST DAILY INTEREST COMPOUND INTEREST STRATEGY REDUCE NUMBER OF INSTALLMENTS EARLY REPAYMENT", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculation_WITH_INTEREST_FIRST_STRATEGY_AND_REST_DAILY_INTEREST_COMPOUND_INTEREST_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS_EARLY_REPAYMENT() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        Calendar todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_DISBURSEMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Integer dayOfWeek = getDayOfWeek(todaysDate);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_INTEREST,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_WEEKLY, \"1\", LOAN_DISBURSEMENT_DATE,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, null, dayOfWeek, null, dayOfWeek);\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, LOAN_DISBURSEMENT_DATE,\n                LoanApplicationTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY, new ArrayList<HashMap>(0));\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        List<Map<String, Object>> expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(LOAN_DISBURSEMENT_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(LOAN_DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2482.54\", \"46.37\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        loanSchedule = this.loanTransactionHelper.getLoanFutureRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, 0, false, \"4965.3\", \"92.52\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.67\", \"23.24\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2529.03\", \"11.67\", \"0.0\", \"0.0\");\n\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues, 0);\n\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        final String LOAN_FIRST_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(LOAN_FIRST_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2494.22\", \"34.69\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2505.73\", \"23.18\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2517.29\", \"11.62\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        // early repayment - pay exact due amount 2 days before due date\n        Float earlyPayment = Float.parseFloat(\"2528.91\");\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysDate.add(Calendar.DAY_OF_MONTH, -2);\n        final String LOAN_SECOND_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(LOAN_SECOND_REPAYMENT_DATE, earlyPayment, loanID);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        expectedvalues = new ArrayList<>();\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        Calendar today = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        addRepaymentValues(expectedvalues, todaysDate, -1, false, \"2482.76\", \"46.15\", \"0.0\", \"0.0\");\n        // early-repayment\n        addRepaymentValues(expectedvalues, todaysDate, 5, true, \"2504.13\", \"24.78\", \"0.0\", \"0.0\");\n\n        addRepaymentValues(expectedvalues, todaysDate, 2, true, \"2522.33\", \"6.58\", \"0.0\", \"0.0\");\n        addRepaymentValues(expectedvalues, todaysDate, 1, false, \"2490.78\", \"11.5\", \"0.0\", \"0.0\");\n        verifyLoanRepaymentSchedule(loanSchedule, expectedvalues);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        todaysDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        final String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation Make Prepayment After Repayment", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculationMakePrepaymentAfterRepayment() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"42\", true);\n        Calendar startDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        Calendar currentDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        startDate.add(Calendar.MONTH, -8);\n\n        Calendar firstRepaymentDate = (Calendar) startDate.clone();\n        firstRepaymentDate.add(Calendar.MONTH, 1);\n        firstRepaymentDate.add(Calendar.DAY_OF_MONTH, firstRepaymentDate.getActualMaximum(Calendar.DAY_OF_MONTH) - Calendar.DAY_OF_MONTH);\n        String firstRepayment = dateFormat.format(firstRepaymentDate.getTime());\n\n        final String loanDisbursementDate = dateFormat.format(startDate.getTime());\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, \"12\");\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, loanDisbursementDate,\n                LoanApplicationTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY, firstRepayment);\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        Assertions.assertNotNull(loanSchedule);\n        startDate.add(Calendar.DAY_OF_MONTH, 2);\n        String loanFirstRepaymentDate = dateFormat.format(startDate.getTime());\n        //\n        Float earlyPayment = Float.parseFloat(\"3000\");\n        this.loanTransactionHelper.makeRepayment(loanFirstRepaymentDate, earlyPayment, loanID);\n\n        HashMap prepayDetail = this.loanTransactionHelper.getPrepayAmount(this.requestSpec, this.responseSpec, loanID);\n        String prepayAmount = String.valueOf(prepayDetail.get(\"amount\"));\n        String loanPrepaymentDate = dateFormat.format(currentDate.getTime());\n        this.loanTransactionHelper.makeRepayment(loanPrepaymentDate, Float.parseFloat(prepayAmount), loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"42\", false);\n    }"}
{"prompt": "Create a test that tests test Loan Schedule With Interest Recalculation Make Advance Payment Till Settlement", "completion": "    @Test\n    public void testLoanScheduleWithInterestRecalculationMakeAdvancePaymentTillSettlement() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final LoanTransactionHelper validationErrorHelper = new LoanTransactionHelper(this.requestSpec, errorResponse);\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"42\", true);\n        Calendar startDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        Calendar currentDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        startDate.add(Calendar.MONTH, -8);\n\n        Calendar firstRepaymentDate = (Calendar) startDate.clone();\n        firstRepaymentDate.add(Calendar.MONTH, 1);\n        firstRepaymentDate.add(Calendar.DAY_OF_MONTH, firstRepaymentDate.getActualMaximum(Calendar.DAY_OF_MONTH) - Calendar.DAY_OF_MONTH);\n        String firstRepayment = dateFormat.format(firstRepaymentDate.getTime());\n\n        final String loanDisbursementDate = dateFormat.format(startDate.getTime());\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithInterestRecalculationAndCompoundingDetails(\n                LoanProductTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_SAME_AS_REPAYMENT_PERIOD,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, \"12\");\n\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, loanDisbursementDate,\n                LoanApplicationTestBuilder.INTEREST_PRINCIPAL_PENALTIES_FEES_ORDER_STRATEGY, firstRepayment);\n\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        Assertions.assertNotNull(loanSchedule);\n        Calendar repaymentDate = (Calendar) firstRepaymentDate.clone();\n        startDate.add(Calendar.DAY_OF_MONTH, 2);\n        String loanFirstRepaymentDate = dateFormat.format(startDate.getTime());\n        //\n        Float earlyPayment = Float.parseFloat(\"3000\");\n        String retrieveDueDate = null;\n        Float amount = null;\n        this.loanTransactionHelper.makeRepayment(loanFirstRepaymentDate, earlyPayment, loanID);\n        for (int i = 1; i < loanSchedule.size(); i++) {\n\n            retrieveDueDate = dateFormat.format(repaymentDate.getTime());\n            amount = (Float) loanSchedule.get(i).get(\"principalOriginalDue\") + (Float) loanSchedule.get(i).get(\"interestOriginalDue\");\n            if (currentDate.after(repaymentDate)) {\n                this.loanTransactionHelper.makeRepayment(retrieveDueDate, amount, loanID);\n            } else {\n                break;\n            }\n            repaymentDate.add(Calendar.MONTH, 1);\n        }\n        HashMap savingsAccountErrorData = validationErrorHelper.makeRepayment(retrieveDueDate, amount, loanID);\n        ArrayList<HashMap> error = (ArrayList<HashMap>) savingsAccountErrorData.get(\"errors\");\n        assertEquals(\"error.msg.loan.transaction.cannot.be.a.future.date\", error.get(0).get(\"userMessageGlobalisationCode\"));\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"42\", false);\n    }"}
{"prompt": "Create a test that tests test Collateral Data Is Available When Requested", "completion": "    @Test\n    public void testCollateralDataIsAvailableWhenRequested() {\n        // given\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        List<HashMap> collaterals = new ArrayList<>();\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n\n        Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientId), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        Integer loanProductId = createLoanProduct(false, NONE);\n\n        // when\n        Integer loanId = applyForLoanApplication(clientId, loanProductId, null, null, \"12,000.00\", collaterals);\n\n        // then\n        List<Integer> clientCollateralIds = (List<Integer>) loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanId,\n                \"collateral.clientCollateralId\");\n        Integer clientCollateralIdResult = clientCollateralIds.get(0);\n        assertEquals(clientCollateralId, clientCollateralIdResult);\n    }"}
{"prompt": "Create a test that tests undo Waived Charge Transaction Does Not Exist", "completion": "    @Test\n    public void undoWaivedChargeTransactionDoesNotExist() {\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(404).build();\n        LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, responseSpec);\n        HashMap response = loanTransactionHelper.undoWaiveChargesForLoan(-1, -2, \"\");\n        assertEquals(\"error.msg.loan.transaction.id.invalid\",\n                ((Map) ((List) response.get(\"errors\")).get(0)).get(\"userMessageGlobalisationCode\"));\n        assertEquals(\"Transaction with identifier -2 does not exist for loan with identifier -1.\",\n                ((Map) ((List) response.get(\"errors\")).get(0)).get(\"defaultUserMessage\"));\n    }"}
{"prompt": "Create a test that tests charge Adjustment Charge Wrong Params", "completion": "    @Test\n    public void chargeAdjustmentChargeWrongParams() {\n        CallFailedRuntimeException exception = assertThrows(CallFailedRuntimeException.class,\n                () -> loanTransactionHelper.chargeAdjustment(0L, 0L, new PostLoansLoanIdChargesChargeIdRequest().amount(0.0)));\n        assertEquals(400, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"validation.msg.loan.charge.adjustment.request.amount.not.greater.than.zero\"));\n        assertTrue(exception.getMessage().contains(\"validation.msg.loan.charge.adjustment.request.loanId.not.greater.than.zero\"));\n        assertTrue(exception.getMessage().contains(\"validation.msg.loan.charge.adjustment.request.loanChargeId.not.greater.than.zero\"));\n        exception = assertThrows(CallFailedRuntimeException.class,\n                () -> loanTransactionHelper.chargeAdjustment(1L, 0L, new PostLoansLoanIdChargesChargeIdRequest().amount(0.0)));\n        assertEquals(400, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"validation.msg.loan.charge.adjustment.request.amount.not.greater.than.zero\"));\n        assertTrue(exception.getMessage().contains(\"validation.msg.loan.charge.adjustment.request.loanChargeId.not.greater.than.zero\"));\n        exception = assertThrows(CallFailedRuntimeException.class,\n                () -> loanTransactionHelper.chargeAdjustment(1L, 1L, new PostLoansLoanIdChargesChargeIdRequest().amount(0.0)));\n        assertEquals(400, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"validation.msg.loan.charge.adjustment.request.amount.not.greater.than.zero\"));\n    }"}
{"prompt": "Create a test that tests charge Adjustment Charge Does Not Exist", "completion": "    @Test\n    public void chargeAdjustmentChargeDoesNotExist() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        CallFailedRuntimeException exception = assertThrows(CallFailedRuntimeException.class,\n                () -> loanTransactionHelper.chargeAdjustment((long) loanID, 1L, new PostLoansLoanIdChargesChargeIdRequest().amount(1.0)));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loanCharge.id.invalid\"));\n    }"}
{"prompt": "Create a test that tests charge Adjustment Charge Does Not Exist For Loan", "completion": "    @Test\n    public void chargeAdjustmentChargeDoesNotExistForLoan() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n        LocalDate targetDate = LocalDate.of(2022, 9, 7);\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        final Integer loanID2 = applyForLoanApplication(clientID, loanProductID);\n\n        CallFailedRuntimeException exception = assertThrows(CallFailedRuntimeException.class, () -> loanTransactionHelper\n                .chargeAdjustment((long) loanID2, (long) penalty1LoanChargeId, new PostLoansLoanIdChargesChargeIdRequest().amount(1.0)));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loanCharge.id.invalid.for.given.loan\"));\n    }"}
{"prompt": "Create a test that tests charge Adjustment For Unpaid Charge", "completion": "    @Test\n    public void chargeAdjustmentForUnpaidCharge() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2022.11.01\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n            final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount,\n                    expenseAccount, overpaymentAccount);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n            assertEquals(2, loanSchedule.size());\n            assertEquals(0, loanSchedule.get(1).get(\"penaltyChargesDue\"));\n            assertEquals(0, loanSchedule.get(1).get(\"penaltyChargesOutstanding\"));\n            assertEquals(1000.0f, loanSchedule.get(1).get(\"totalDueForPeriod\"));\n            assertEquals(1000.0f, loanSchedule.get(1).get(\"totalOutstandingForPeriod\"));\n            LocalDate targetDate = LocalDate.of(2022, 9, 7);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n            Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n            this.loanTransactionHelper.noAccrualTransactionForRepayment(loanID);\n\n            loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n            assertEquals(2, loanSchedule.size());\n            assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesDue\"));\n            assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesOutstanding\"));\n            assertEquals(1010.0f, loanSchedule.get(1).get(\"totalDueForPeriod\"));\n            assertEquals(1010.0f, loanSchedule.get(1).get(\"totalOutstandingForPeriod\"));\n            assertEquals(0, loanSchedule.get(1).get(\"totalWaivedForPeriod\"));\n\n            HashMap loanSummary = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"summary\");\n            assertEquals(10.0f, loanSummary.get(\"penaltyChargesCharged\"));\n            assertEquals(10.0f, loanSummary.get(\"penaltyChargesOutstanding\"));\n            assertEquals(0.0f, loanSummary.get(\"penaltyChargesWaived\"));\n            assertEquals(1010.0f, loanSummary.get(\"totalOutstanding\"));\n            assertEquals(0.0f, loanSummary.get(\"totalWaived\"));\n\n            String externalId = UUID.randomUUID().toString();\n            PostLoansLoanIdChargesChargeIdResponse chargeAdjustmentResponse = this.loanTransactionHelper.chargeAdjustment((long) loanID,\n                    (long) penalty1LoanChargeId,\n                    new PostLoansLoanIdChargesChargeIdRequest().amount(10.0).externalId(externalId).paymentTypeId(1L));\n\n            loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n            assertEquals(2, loanSchedule.size());\n            assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesDue\"));\n            assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesPaid\"));\n            assertEquals(0.0f, loanSchedule.get(1).get(\"penaltyChargesOutstanding\"));\n            assertEquals(1010.0f, loanSchedule.get(1).get(\"totalDueForPeriod\"));\n            assertEquals(1000.0f, loanSchedule.get(1).get(\"totalOutstandingForPeriod\"));\n            assertEquals(10.0f, loanSchedule.get(1).get(\"totalPaidForPeriod\"));\n\n            loanSummary = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"summary\");\n            assertEquals(10.0f, loanSummary.get(\"penaltyChargesCharged\"));\n            assertEquals(0.0f, loanSummary.get(\"penaltyChargesOutstanding\"));\n            assertEquals(10.0f, loanSummary.get(\"penaltyChargesPaid\"));\n            assertEquals(1000.0f, loanSummary.get(\"totalOutstanding\"));\n\n            GetLoansLoanIdTransactionsTransactionIdResponse chargeAdjustmentTransaction = this.loanTransactionHelper\n                    .getLoanTransactionDetails((long) loanID, chargeAdjustmentResponse.getSubResourceId());\n            assertEquals(10.0, chargeAdjustmentTransaction.getAmount());\n            assertEquals(10.0, chargeAdjustmentTransaction.getPenaltyChargesPortion());\n            assertEquals(\"loanTransactionType.chargeAdjustment\", chargeAdjustmentTransaction.getType().getCode());\n            assertEquals(externalId, chargeAdjustmentTransaction.getExternalId());\n            GetLoanTransactionRelation transactionRelation = chargeAdjustmentTransaction.getTransactionRelations().iterator().next();\n            assertEquals(chargeAdjustmentResponse.getSubResourceId(), transactionRelation.getFromLoanTransaction());\n            assertEquals((long) penalty1LoanChargeId, transactionRelation.getToLoanCharge());\n            assertEquals(\"CHARGE_ADJUSTMENT\", transactionRelation.getRelationType());\n            assertEquals(1L, chargeAdjustmentTransaction.getPaymentDetailData().getPaymentType().getId());\n\n            PostLoansLoanIdTransactionsResponse repaymentResult = loanTransactionHelper.makeLoanRepayment((long) loanID,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"06 September 2022\").locale(\"en\")\n                            .transactionAmount(5.0));\n\n            loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n            assertEquals(2, loanSchedule.size());\n            assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesDue\"));\n            assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesPaid\"));\n            assertEquals(0.0f, loanSchedule.get(1).get(\"penaltyChargesOutstanding\"));\n            assertEquals(1000.0f, loanSchedule.get(1).get(\"principalDue\"));\n            assertEquals(5.0f, loanSchedule.get(1).get(\"principalPaid\"));\n            assertEquals(995.0f, loanSchedule.get(1).get(\"principalOutstanding\"));\n            assertEquals(1010.0f, loanSchedule.get(1).get(\"totalDueForPeriod\"));\n            assertEquals(995.0f, loanSchedule.get(1).get(\"totalOutstandingForPeriod\"));\n            assertEquals(15.0f, loanSchedule.get(1).get(\"totalPaidForPeriod\"));\n\n            loanSummary = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"summary\");\n            assertEquals(10.0f, loanSummary.get(\"penaltyChargesCharged\"));\n            assertEquals(0.0f, loanSummary.get(\"penaltyChargesOutstanding\"));\n            assertEquals(10.0f, loanSummary.get(\"penaltyChargesPaid\"));\n            assertEquals(1000.0f, loanSummary.get(\"principalDisbursed\"));\n            assertEquals(995.0f, loanSummary.get(\"principalOutstanding\"));\n            assertEquals(5.0f, loanSummary.get(\"principalPaid\"));\n            assertEquals(995.0f, loanSummary.get(\"totalOutstanding\"));\n\n            GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            GetLoansLoanIdTransactions replayedTransaction = loanDetails.getTransactions().stream()\n                    .filter(t -> externalId.equals(t.getExternalId())).findFirst().get();\n\n            assertEquals(10.0, replayedTransaction.getAmount());\n            assertEquals(5.0, replayedTransaction.getPenaltyChargesPortion());\n            assertEquals(5.0, replayedTransaction.getPrincipalPortion());\n            assertEquals(\"loanTransactionType.chargeAdjustment\", replayedTransaction.getType().getCode());\n            assertEquals(externalId, replayedTransaction.getExternalId());\n\n            Set<GetLoansLoanIdLoanTransactionRelation> transactionRelations = replayedTransaction.getTransactionRelations();\n            for (GetLoansLoanIdLoanTransactionRelation loanTransactionRelation : transactionRelations) {\n                if (\"CHARGE_ADJUSTMENT\".equals(loanTransactionRelation.getRelationType())) {\n                    assertEquals(replayedTransaction.getId(), loanTransactionRelation.getFromLoanTransaction());\n                    assertEquals((long) penalty1LoanChargeId, loanTransactionRelation.getToLoanCharge());\n                }\n            }\n\n            String uuid = UUID.randomUUID().toString();\n            this.loanTransactionHelper.reverseLoanTransaction((long) loanID, replayedTransaction.getId(),\n                    new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"08 September 2022\")\n                            .transactionAmount(0.0).locale(\"en\").reversalExternalId(uuid));\n\n            // Should fail due to external id collusion\n            assertThrows(CallFailedRuntimeException.class,\n                    () -> this.loanTransactionHelper.reverseLoanTransaction((long) loanID, repaymentResult.getResourceId(),\n                            new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\")\n                                    .transactionDate(\"08 September 2022\").transactionAmount(0.0).locale(\"en\").reversalExternalId(uuid)));\n\n            loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n            assertEquals(2, loanSchedule.size());\n            assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesDue\"));\n            assertEquals(5.0f, loanSchedule.get(1).get(\"penaltyChargesPaid\"));\n            assertEquals(5.0f, loanSchedule.get(1).get(\"penaltyChargesOutstanding\"));\n            assertEquals(1000.0f, loanSchedule.get(1).get(\"principalDue\"));\n            assertEquals(0, loanSchedule.get(1).get(\"principalPaid\"));\n            assertEquals(1000.0f, loanSchedule.get(1).get(\"principalOutstanding\"));\n            assertEquals(1010.0f, loanSchedule.get(1).get(\"totalDueForPeriod\"));\n            assertEquals(1005.0f, loanSchedule.get(1).get(\"totalOutstandingForPeriod\"));\n            assertEquals(5.0f, loanSchedule.get(1).get(\"totalPaidForPeriod\"));\n\n            loanSummary = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"summary\");\n            assertEquals(10.0f, loanSummary.get(\"penaltyChargesCharged\"));\n            assertEquals(5.0f, loanSummary.get(\"penaltyChargesOutstanding\"));\n            assertEquals(5.0f, loanSummary.get(\"penaltyChargesPaid\"));\n            assertEquals(1000.0f, loanSummary.get(\"principalDisbursed\"));\n            assertEquals(1000.0f, loanSummary.get(\"principalOutstanding\"));\n            assertEquals(0.0f, loanSummary.get(\"principalPaid\"));\n            assertEquals(1005.0f, loanSummary.get(\"totalOutstanding\"));\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests charge Adjustment Accounting Validation", "completion": "    @Test\n    public void chargeAdjustmentAccountingValidation() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2022.11.01\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account assetFeeAndPenaltyAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n            final PostGLAccountsResponse uniqueIncomeAccountForFee = this.accountHelper.createGLAccount(new PostGLAccountsRequest()\n                    .type(GLAccountType.INCOME.getValue())\n                    .glCode(Utils.uniqueRandomStringGenerator(\"UNIQUE_FEE_INCOME\" + Calendar.getInstance().getTimeInMillis(), 5))\n                    .manualEntriesAllowed(true)\n                    .name(Utils.uniqueRandomStringGenerator(\"UNIQUE_FEE_INCOME\" + Calendar.getInstance().getTimeInMillis(), 5)).usage(1));\n            final PostGLAccountsResponse uniqueIncomeAccountForPenalty = this.accountHelper.createGLAccount(new PostGLAccountsRequest()\n                    .type(GLAccountType.INCOME.getValue())\n                    .glCode(Utils.uniqueRandomStringGenerator(\"UNIQUE_PENALTY_INCOME\" + Calendar.getInstance().getTimeInMillis(), 5))\n                    .manualEntriesAllowed(true)\n                    .name(Utils.uniqueRandomStringGenerator(\"UNIQUE_PENALTY_INCOME\" + Calendar.getInstance().getTimeInMillis(), 5))\n                    .usage(1));\n\n            PostChargesResponse penaltyCharge = chargesHelper.createCharges(new PostChargesRequest().penalty(true).amount(10.0)\n                    .chargeCalculationType(ChargeCalculationType.FLAT.getValue())\n                    .chargeTimeType(ChargeTimeType.SPECIFIED_DUE_DATE.getValue()).chargePaymentMode(ChargePaymentMode.REGULAR.getValue())\n                    .currencyCode(\"USD\").name(Utils.randomStringGenerator(\"PENALTY_\" + Calendar.getInstance().getTimeInMillis(), 5))\n                    .chargeAppliesTo(1).locale(\"en\").active(true));\n\n            PostChargesResponse feeCharge = chargesHelper.createCharges(new PostChargesRequest().penalty(false).amount(9.0)\n                    .chargeCalculationType(ChargeCalculationType.FLAT.getValue())\n                    .chargeTimeType(ChargeTimeType.SPECIFIED_DUE_DATE.getValue()).chargePaymentMode(ChargePaymentMode.REGULAR.getValue())\n                    .currencyCode(\"USD\").name(Utils.randomStringGenerator(\"FEE_\" + Calendar.getInstance().getTimeInMillis(), 5))\n                    .chargeAppliesTo(1).locale(\"en\").active(true));\n\n            final String loanProductJSON = new LoanProductTestBuilder().withPrincipal(\"1000\").withRepaymentTypeAsMonth()\n                    .withRepaymentAfterEvery(\"1\").withNumberOfRepayments(\"1\").withRepaymentTypeAsMonth().withinterestRatePerPeriod(\"0\")\n                    .withInterestRateFrequencyTypeAsMonths().withAmortizationTypeAsEqualPrincipalPayment().withInterestTypeAsFlat()\n                    .withAccountingRulePeriodicAccrual(new Account[] { assetAccount, incomeAccount, expenseAccount, overpaymentAccount })\n                    .withDaysInMonth(\"30\").withDaysInYear(\"365\").withMoratorium(\"0\", \"0\")\n                    .withFeeToIncomeAccountMapping(feeCharge.getResourceId(), uniqueIncomeAccountForFee.getResourceId())\n                    .withPenaltyToIncomeAccountMapping(penaltyCharge.getResourceId(), uniqueIncomeAccountForPenalty.getResourceId())\n                    .withFeeAndPenaltyAssetAccount(assetFeeAndPenaltyAccount).build(null);\n            final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJSON);\n\n            final PostClientsResponse client = clientHelper.createClient(ClientHelper.defaultClientCreationRequest());\n\n            final Integer loanID = applyForLoanApplication(client.getClientId().intValue(), loanProductID);\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            List<GetLoansLoanIdRepaymentPeriod> loanSchedulePeriods = loanDetails.getRepaymentSchedule().getPeriods();\n            assertEquals(2, loanSchedulePeriods.size());\n            assertEquals(0.0, loanSchedulePeriods.get(1).getPenaltyChargesDue());\n            assertEquals(0.0, loanSchedulePeriods.get(1).getPenaltyChargesOutstanding());\n            assertEquals(1000.0, loanSchedulePeriods.get(1).getTotalDueForPeriod());\n            assertEquals(1000.0, loanSchedulePeriods.get(1).getTotalOutstandingForPeriod());\n\n            LocalDate targetDate = LocalDate.of(2022, 9, 7);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n            Integer penaltyLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                    .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penaltyCharge.getResourceId()), penaltyCharge1AddedDate, \"10\"));\n\n            final String penalty1LoanChargeDate = dateFormatter.format(targetDate);\n            this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(penalty1LoanChargeDate);\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            List<GetLoansLoanIdTransactions> transactions = loanDetails.getTransactions();\n            assertEquals(10.0, transactions.get(1).getAmount());\n            assertTrue(transactions.get(1).getType().getAccrual());\n            assertEquals(10.0, transactions.get(1).getPenaltyChargesPortion());\n            Long accrualTransactionId = transactions.get(1).getId();\n\n            List<HashMap> journalEntries = this.journalEntryHelper.getJournalEntriesByTransactionId(\"L\" + accrualTransactionId);\n            assertEquals(10.0f, (float) journalEntries.get(0).get(\"amount\"));\n            assertEquals(uniqueIncomeAccountForPenalty.getResourceId().intValue(), (int) journalEntries.get(0).get(\"glAccountId\"));\n            assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(0).get(\"entryType\")).get(\"value\"));\n            assertEquals(10.0f, (float) journalEntries.get(1).get(\"amount\"));\n            assertEquals(assetFeeAndPenaltyAccount.getAccountID(), (int) journalEntries.get(1).get(\"glAccountId\"));\n            assertEquals(\"DEBIT\", ((HashMap) journalEntries.get(1).get(\"entryType\")).get(\"value\"));\n\n            loanSchedulePeriods = loanDetails.getRepaymentSchedule().getPeriods();\n            assertEquals(2, loanSchedulePeriods.size());\n            assertEquals(10.0, loanSchedulePeriods.get(1).getPenaltyChargesDue());\n            assertEquals(10.0, loanSchedulePeriods.get(1).getPenaltyChargesOutstanding());\n            assertEquals(1010.0, loanSchedulePeriods.get(1).getTotalDueForPeriod());\n            assertEquals(1010.0, loanSchedulePeriods.get(1).getTotalOutstandingForPeriod());\n\n            GetLoansLoanIdSummary loanSummary = loanDetails.getSummary();\n            assertEquals(10.0, loanSummary.getPenaltyChargesCharged());\n            assertEquals(10.0, loanSummary.getPenaltyChargesOutstanding());\n            assertEquals(1010.0, loanSummary.getTotalOutstanding());\n\n            String externalId = UUID.randomUUID().toString();\n            PostLoansLoanIdChargesChargeIdResponse chargeAdjustmentResponse = this.loanTransactionHelper.chargeAdjustment((long) loanID,\n                    (long) penaltyLoanChargeId, new PostLoansLoanIdChargesChargeIdRequest().amount(10.0).externalId(externalId));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            loanSchedulePeriods = loanDetails.getRepaymentSchedule().getPeriods();\n            assertEquals(2, loanSchedulePeriods.size());\n            assertEquals(10.0, loanSchedulePeriods.get(1).getPenaltyChargesDue());\n            assertEquals(10.0, loanSchedulePeriods.get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, loanSchedulePeriods.get(1).getPenaltyChargesOutstanding());\n            assertEquals(1010.0, loanSchedulePeriods.get(1).getTotalDueForPeriod());\n            assertEquals(1000.0, loanSchedulePeriods.get(1).getTotalOutstandingForPeriod());\n            assertEquals(10.0, loanSchedulePeriods.get(1).getTotalPaidForPeriod());\n\n            loanSummary = loanDetails.getSummary();\n            assertEquals(10.0, loanSummary.getPenaltyChargesCharged());\n            assertEquals(0.0, loanSummary.getPenaltyChargesOutstanding());\n            assertEquals(10.0, loanSummary.getPenaltyChargesPaid());\n            assertEquals(1000.0, loanSummary.getTotalOutstanding());\n\n            transactions = loanDetails.getTransactions();\n            assertEquals(10.0, transactions.get(2).getAmount());\n            assertTrue(transactions.get(2).getType().getChargeAdjustment());\n            assertEquals(10.0, transactions.get(2).getPenaltyChargesPortion());\n            Long chargeAdjustmentTransactionId = transactions.get(2).getId();\n\n            journalEntries = this.journalEntryHelper.getJournalEntriesByTransactionId(\"L\" + chargeAdjustmentTransactionId);\n            assertEquals(10.0f, (float) journalEntries.get(0).get(\"amount\"));\n            assertEquals(uniqueIncomeAccountForPenalty.getResourceId().intValue(), (int) journalEntries.get(0).get(\"glAccountId\"));\n            assertEquals(\"DEBIT\", ((HashMap) journalEntries.get(0).get(\"entryType\")).get(\"value\"));\n            assertEquals(10.0f, (float) journalEntries.get(1).get(\"amount\"));\n            assertEquals(assetFeeAndPenaltyAccount.getAccountID(), (int) journalEntries.get(1).get(\"glAccountId\"));\n            assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(1).get(\"entryType\")).get(\"value\"));\n\n            String uuid = UUID.randomUUID().toString();\n            this.loanTransactionHelper.reverseLoanTransaction((long) loanID, chargeAdjustmentTransactionId,\n                    new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"08 September 2022\")\n                            .transactionAmount(0.0).locale(\"en\").reversalExternalId(uuid));\n\n            journalEntries = this.journalEntryHelper.getJournalEntriesByTransactionId(\"L\" + chargeAdjustmentTransactionId);\n            assertEquals(10.0f, (float) journalEntries.get(0).get(\"amount\"));\n            assertEquals(uniqueIncomeAccountForPenalty.getResourceId().intValue(), (int) journalEntries.get(0).get(\"glAccountId\"));\n            assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(0).get(\"entryType\")).get(\"value\"));\n            assertEquals(10.0f, (float) journalEntries.get(1).get(\"amount\"));\n            assertEquals(assetFeeAndPenaltyAccount.getAccountID(), (int) journalEntries.get(1).get(\"glAccountId\"));\n            assertEquals(\"DEBIT\", ((HashMap) journalEntries.get(1).get(\"entryType\")).get(\"value\"));\n            assertEquals(10.0f, (float) journalEntries.get(2).get(\"amount\"));\n            assertEquals(uniqueIncomeAccountForPenalty.getResourceId().intValue(), (int) journalEntries.get(2).get(\"glAccountId\"));\n            assertEquals(\"DEBIT\", ((HashMap) journalEntries.get(2).get(\"entryType\")).get(\"value\"));\n            assertEquals(10.0f, (float) journalEntries.get(3).get(\"amount\"));\n            assertEquals(assetFeeAndPenaltyAccount.getAccountID(), (int) journalEntries.get(3).get(\"glAccountId\"));\n            assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(3).get(\"entryType\")).get(\"value\"));\n\n            targetDate = LocalDate.of(2022, 9, 10);\n            final String feeCharge1AddedDate = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                    .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge.getResourceId()), feeCharge1AddedDate, \"3\"));\n\n            final String feeLoanChargeDate = dateFormatter.format(targetDate);\n            this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(feeLoanChargeDate);\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            transactions = loanDetails.getTransactions();\n            assertEquals(3.0, transactions.get(2).getAmount());\n            assertTrue(transactions.get(2).getType().getAccrual());\n            assertEquals(3.0, transactions.get(2).getFeeChargesPortion());\n            accrualTransactionId = transactions.get(2).getId();\n\n            journalEntries = this.journalEntryHelper.getJournalEntriesByTransactionId(\"L\" + accrualTransactionId);\n            assertEquals(3.0f, (float) journalEntries.get(0).get(\"amount\"));\n            assertEquals(uniqueIncomeAccountForFee.getResourceId().intValue(), (int) journalEntries.get(0).get(\"glAccountId\"));\n            assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(0).get(\"entryType\")).get(\"value\"));\n            assertEquals(3.0f, (float) journalEntries.get(1).get(\"amount\"));\n            assertEquals(assetFeeAndPenaltyAccount.getAccountID(), (int) journalEntries.get(1).get(\"glAccountId\"));\n            assertEquals(\"DEBIT\", ((HashMap) journalEntries.get(1).get(\"entryType\")).get(\"value\"));\n\n            loanSchedulePeriods = loanDetails.getRepaymentSchedule().getPeriods();\n            assertEquals(2, loanSchedulePeriods.size());\n            assertEquals(10.0, loanSchedulePeriods.get(1).getPenaltyChargesDue());\n            assertEquals(10.0, loanSchedulePeriods.get(1).getPenaltyChargesOutstanding());\n            assertEquals(3.0, loanSchedulePeriods.get(1).getFeeChargesDue());\n            assertEquals(3.0, loanSchedulePeriods.get(1).getFeeChargesOutstanding());\n            assertEquals(1013.0, loanSchedulePeriods.get(1).getTotalDueForPeriod());\n            assertEquals(1013.0, loanSchedulePeriods.get(1).getTotalOutstandingForPeriod());\n\n            loanSummary = loanDetails.getSummary();\n            assertEquals(10.0, loanSummary.getPenaltyChargesCharged());\n            assertEquals(10.0, loanSummary.getPenaltyChargesOutstanding());\n            assertEquals(3.0, loanSummary.getFeeChargesCharged());\n            assertEquals(3.0, loanSummary.getFeeChargesOutstanding());\n            assertEquals(1013.0, loanSummary.getTotalOutstanding());\n\n            loanTransactionHelper.makeLoanRepayment((long) loanID, new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\")\n                    .transactionDate(\"11 September 2022\").locale(\"en\").transactionAmount(5.0));\n\n            externalId = UUID.randomUUID().toString();\n            chargeAdjustmentResponse = this.loanTransactionHelper.chargeAdjustment((long) loanID, (long) feeLoanChargeId,\n                    new PostLoansLoanIdChargesChargeIdRequest().amount(2.0).externalId(externalId));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            loanSchedulePeriods = loanDetails.getRepaymentSchedule().getPeriods();\n            assertEquals(2, loanSchedulePeriods.size());\n            assertEquals(10.0, loanSchedulePeriods.get(1).getPenaltyChargesDue());\n            assertEquals(7.0, loanSchedulePeriods.get(1).getPenaltyChargesPaid());\n            assertEquals(3.0, loanSchedulePeriods.get(1).getPenaltyChargesOutstanding());\n            assertEquals(3.0, loanSchedulePeriods.get(1).getFeeChargesDue());\n            assertEquals(0.0, loanSchedulePeriods.get(1).getFeeChargesPaid());\n            assertEquals(3.0, loanSchedulePeriods.get(1).getFeeChargesOutstanding());\n            assertEquals(1000.0, loanSchedulePeriods.get(1).getPrincipalDue());\n            assertEquals(0.0, loanSchedulePeriods.get(1).getPrincipalPaid());\n            assertEquals(1000.0, loanSchedulePeriods.get(1).getPrincipalOutstanding());\n            assertEquals(1013.0, loanSchedulePeriods.get(1).getTotalDueForPeriod());\n            assertEquals(1006.0, loanSchedulePeriods.get(1).getTotalOutstandingForPeriod());\n            assertEquals(7.0, loanSchedulePeriods.get(1).getTotalPaidForPeriod());\n\n            loanSummary = loanDetails.getSummary();\n            assertEquals(10.0, loanSummary.getPenaltyChargesCharged());\n            assertEquals(3.0, loanSummary.getPenaltyChargesOutstanding());\n            assertEquals(7.0, loanSummary.getPenaltyChargesPaid());\n            assertEquals(3.0, loanSummary.getFeeChargesCharged());\n            assertEquals(3.0, loanSummary.getFeeChargesOutstanding());\n            assertEquals(0.0, loanSummary.getFeeChargesPaid());\n            assertEquals(1000.0, loanSummary.getPrincipalOutstanding());\n            assertEquals(0.0, loanSummary.getPrincipalPaid());\n            assertEquals(7.0, loanSummary.getTotalRepayment());\n            assertEquals(1006.0, loanSummary.getTotalOutstanding());\n\n            transactions = loanDetails.getTransactions();\n            assertEquals(2.0, transactions.get(5).getAmount());\n            assertTrue(transactions.get(4).getType().getChargeAdjustment());\n            assertEquals(2.0, transactions.get(5).getPenaltyChargesPortion());\n            assertEquals(0.0, transactions.get(5).getFeeChargesPortion());\n            assertEquals(0.0, transactions.get(5).getPrincipalPortion());\n            chargeAdjustmentTransactionId = transactions.get(5).getId();\n\n            journalEntries = this.journalEntryHelper.getJournalEntriesByTransactionId(\"L\" + chargeAdjustmentTransactionId);\n            assertEquals(2.0f, (float) journalEntries.get(0).get(\"amount\"));\n            assertEquals(uniqueIncomeAccountForFee.getResourceId().intValue(), (int) journalEntries.get(0).get(\"glAccountId\"));\n            assertEquals(\"DEBIT\", ((HashMap) journalEntries.get(0).get(\"entryType\")).get(\"value\"));\n            assertEquals(2.0f, (float) journalEntries.get(1).get(\"amount\"));\n            assertEquals(assetFeeAndPenaltyAccount.getAccountID(), (int) journalEntries.get(1).get(\"glAccountId\"));\n            assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(1).get(\"entryType\")).get(\"value\"));\n\n            externalId = UUID.randomUUID().toString();\n            chargeAdjustmentResponse = this.loanTransactionHelper.chargeAdjustment((long) loanID, (long) penaltyLoanChargeId,\n                    new PostLoansLoanIdChargesChargeIdRequest().amount(7.0).externalId(externalId));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            loanSchedulePeriods = loanDetails.getRepaymentSchedule().getPeriods();\n            assertEquals(2, loanSchedulePeriods.size());\n            assertEquals(10.0, loanSchedulePeriods.get(1).getPenaltyChargesDue());\n            assertEquals(10.0, loanSchedulePeriods.get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, loanSchedulePeriods.get(1).getPenaltyChargesOutstanding());\n            assertEquals(3.0, loanSchedulePeriods.get(1).getFeeChargesDue());\n            assertEquals(3.0, loanSchedulePeriods.get(1).getFeeChargesPaid());\n            assertEquals(0.0, loanSchedulePeriods.get(1).getFeeChargesOutstanding());\n            assertEquals(1000.0, loanSchedulePeriods.get(1).getPrincipalDue());\n            assertEquals(1.0, loanSchedulePeriods.get(1).getPrincipalPaid());\n            assertEquals(999.0, loanSchedulePeriods.get(1).getPrincipalOutstanding());\n            assertEquals(1013.0, loanSchedulePeriods.get(1).getTotalDueForPeriod());\n            assertEquals(999.0, loanSchedulePeriods.get(1).getTotalOutstandingForPeriod());\n            assertEquals(14.0, loanSchedulePeriods.get(1).getTotalPaidForPeriod());\n\n            loanSummary = loanDetails.getSummary();\n            assertEquals(10.0, loanSummary.getPenaltyChargesCharged());\n            assertEquals(0.0, loanSummary.getPenaltyChargesOutstanding());\n            assertEquals(10.0, loanSummary.getPenaltyChargesPaid());\n            assertEquals(3.0, loanSummary.getFeeChargesCharged());\n            assertEquals(0.0, loanSummary.getFeeChargesOutstanding());\n            assertEquals(3.0, loanSummary.getFeeChargesPaid());\n            assertEquals(999.0, loanSummary.getPrincipalOutstanding());\n            assertEquals(1.0, loanSummary.getPrincipalPaid());\n            assertEquals(14.0, loanSummary.getTotalRepayment());\n            assertEquals(999.0, loanSummary.getTotalOutstanding());\n\n            transactions = loanDetails.getTransactions();\n            assertEquals(7.0, transactions.get(6).getAmount());\n            assertTrue(transactions.get(6).getType().getChargeAdjustment());\n            assertEquals(3.0, transactions.get(6).getPenaltyChargesPortion());\n            assertEquals(3.0, transactions.get(6).getFeeChargesPortion());\n            assertEquals(1.0, transactions.get(6).getPrincipalPortion());\n            chargeAdjustmentTransactionId = transactions.get(6).getId();\n\n            journalEntries = this.journalEntryHelper.getJournalEntriesByTransactionId(\"L\" + chargeAdjustmentTransactionId);\n            assertEquals(7.0f, (float) journalEntries.get(0).get(\"amount\"));\n            assertEquals(uniqueIncomeAccountForPenalty.getResourceId().intValue(), (int) journalEntries.get(0).get(\"glAccountId\"));\n            assertEquals(\"DEBIT\", ((HashMap) journalEntries.get(0).get(\"entryType\")).get(\"value\"));\n            if (assetAccount.getAccountID() == (int) journalEntries.get(1).get(\"glAccountId\")) {\n                assertEquals(1.0f, (float) journalEntries.get(1).get(\"amount\"));\n                assertEquals(assetAccount.getAccountID(), (int) journalEntries.get(1).get(\"glAccountId\"));\n                assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(1).get(\"entryType\")).get(\"value\"));\n\n                assertEquals(6.0f, (float) journalEntries.get(2).get(\"amount\"));\n                assertEquals(assetFeeAndPenaltyAccount.getAccountID(), (int) journalEntries.get(2).get(\"glAccountId\"));\n                assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(2).get(\"entryType\")).get(\"value\"));\n            } else {\n                assertEquals(1.0f, (float) journalEntries.get(2).get(\"amount\"));\n                assertEquals(assetAccount.getAccountID(), (int) journalEntries.get(2).get(\"glAccountId\"));\n                assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(2).get(\"entryType\")).get(\"value\"));\n\n                assertEquals(6.0f, (float) journalEntries.get(1).get(\"amount\"));\n                assertEquals(assetFeeAndPenaltyAccount.getAccountID(), (int) journalEntries.get(1).get(\"glAccountId\"));\n                assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(1).get(\"entryType\")).get(\"value\"));\n            }\n\n            loanTransactionHelper.makeLoanRepayment((long) loanID, new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\")\n                    .transactionDate(\"13 September 2022\").locale(\"en\").transactionAmount(998.0));\n\n            externalId = UUID.randomUUID().toString();\n            chargeAdjustmentResponse = this.loanTransactionHelper.chargeAdjustment((long) loanID, (long) feeLoanChargeId,\n                    new PostLoansLoanIdChargesChargeIdRequest().amount(1.0).externalId(externalId));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            loanSchedulePeriods = loanDetails.getRepaymentSchedule().getPeriods();\n            assertEquals(2, loanSchedulePeriods.size());\n            assertEquals(10.0, loanSchedulePeriods.get(1).getPenaltyChargesDue());\n            assertEquals(10.0, loanSchedulePeriods.get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, loanSchedulePeriods.get(1).getPenaltyChargesOutstanding());\n            assertEquals(3.0, loanSchedulePeriods.get(1).getFeeChargesDue());\n            assertEquals(3.0, loanSchedulePeriods.get(1).getFeeChargesPaid());\n            assertEquals(0.0, loanSchedulePeriods.get(1).getFeeChargesOutstanding());\n            assertEquals(1000.0, loanSchedulePeriods.get(1).getPrincipalDue());\n            assertEquals(1000.0, loanSchedulePeriods.get(1).getPrincipalPaid());\n            assertEquals(0.0, loanSchedulePeriods.get(1).getPrincipalOutstanding());\n            assertEquals(1013.0, loanSchedulePeriods.get(1).getTotalDueForPeriod());\n            assertEquals(0.0, loanSchedulePeriods.get(1).getTotalOutstandingForPeriod());\n            assertEquals(1013.0, loanSchedulePeriods.get(1).getTotalPaidForPeriod());\n\n            loanSummary = loanDetails.getSummary();\n            assertEquals(10.0, loanSummary.getPenaltyChargesCharged());\n            assertEquals(0.0, loanSummary.getPenaltyChargesOutstanding());\n            assertEquals(10.0, loanSummary.getPenaltyChargesPaid());\n            assertEquals(3.0, loanSummary.getFeeChargesCharged());\n            assertEquals(0.0, loanSummary.getFeeChargesOutstanding());\n            assertEquals(3.0, loanSummary.getFeeChargesPaid());\n            assertEquals(0.0, loanSummary.getPrincipalOutstanding());\n            assertEquals(1000.0, loanSummary.getPrincipalPaid());\n            assertEquals(1013.0, loanSummary.getTotalRepayment());\n            assertEquals(0.0, loanSummary.getTotalOutstanding());\n\n            transactions = loanDetails.getTransactions();\n            assertEquals(1.0, transactions.get(8).getAmount());\n            assertTrue(transactions.get(8).getType().getChargeAdjustment());\n            assertEquals(0.0, transactions.get(8).getPenaltyChargesPortion());\n            assertEquals(0.0, transactions.get(8).getFeeChargesPortion());\n            assertEquals(1.0, transactions.get(8).getPrincipalPortion());\n            chargeAdjustmentTransactionId = transactions.get(8).getId();\n\n            journalEntries = this.journalEntryHelper.getJournalEntriesByTransactionId(\"L\" + chargeAdjustmentTransactionId);\n            assertEquals(1.0f, (float) journalEntries.get(0).get(\"amount\"));\n            assertEquals(uniqueIncomeAccountForFee.getResourceId().intValue(), (int) journalEntries.get(0).get(\"glAccountId\"));\n            assertEquals(\"DEBIT\", ((HashMap) journalEntries.get(0).get(\"entryType\")).get(\"value\"));\n            assertEquals(1.0f, (float) journalEntries.get(1).get(\"amount\"));\n            assertEquals(assetAccount.getAccountID(), (int) journalEntries.get(1).get(\"glAccountId\"));\n            assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(1).get(\"entryType\")).get(\"value\"));\n\n            assertTrue(loanDetails.getStatus().getClosedObligationsMet());\n\n            externalId = UUID.randomUUID().toString();\n            chargeAdjustmentResponse = this.loanTransactionHelper.chargeAdjustment((long) loanID, (long) penaltyLoanChargeId,\n                    new PostLoansLoanIdChargesChargeIdRequest().amount(1.0).externalId(externalId));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            transactions = loanDetails.getTransactions();\n            assertEquals(1.0, transactions.get(9).getAmount());\n            assertTrue(transactions.get(9).getType().getChargeAdjustment());\n            assertEquals(0.0, transactions.get(9).getPenaltyChargesPortion());\n            assertEquals(0.0, transactions.get(9).getFeeChargesPortion());\n            assertEquals(0.0, transactions.get(9).getPrincipalPortion());\n            assertEquals(1.0, transactions.get(9).getOverpaymentPortion());\n            chargeAdjustmentTransactionId = transactions.get(9).getId();\n\n            journalEntries = this.journalEntryHelper.getJournalEntriesByTransactionId(\"L\" + chargeAdjustmentTransactionId);\n            assertEquals(1.0f, (float) journalEntries.get(0).get(\"amount\"));\n            assertEquals(uniqueIncomeAccountForPenalty.getResourceId().intValue(), (int) journalEntries.get(0).get(\"glAccountId\"));\n            assertEquals(\"DEBIT\", ((HashMap) journalEntries.get(0).get(\"entryType\")).get(\"value\"));\n            assertEquals(1.0f, (float) journalEntries.get(1).get(\"amount\"));\n            assertEquals(overpaymentAccount.getAccountID(), (int) journalEntries.get(1).get(\"glAccountId\"));\n            assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(1).get(\"entryType\")).get(\"value\"));\n\n            assertTrue(loanDetails.getStatus().getOverpaid());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests undo Waived Charge Waive Transaction Does Not Exist", "completion": "    @Test\n    public void undoWaivedChargeWaiveTransactionDoesNotExist() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        final Integer loanTransactionId = (Integer) ((Map) ((List) JsonPath.from(loanDetails).get(\"transactions\")).get(0)).get(\"id\");\n\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(403).build();\n        LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, responseSpec);\n        HashMap response = loanTransactionHelper.undoWaiveChargesForLoan(loanID, loanTransactionId, \"\");\n        assertEquals(\"error.msg.loan.transaction.undo.waive.charge\",\n                ((Map) ((List) response.get(\"errors\")).get(0)).get(\"userMessageGlobalisationCode\"));\n        assertEquals(\"Transaction is not a waive charge type.\", ((Map) ((List) response.get(\"errors\")).get(0)).get(\"defaultUserMessage\"));\n    }"}
{"prompt": "Create a test that tests undo Waived Charge", "completion": "    @Test\n    public void undoWaivedCharge() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(2, loanSchedule.size());\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesDue\"));\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesOutstanding\"));\n        assertEquals(0, loanSchedule.get(1).get(\"penaltyChargesDue\"));\n        assertEquals(0, loanSchedule.get(1).get(\"penaltyChargesOutstanding\"));\n        assertEquals(1000.0f, loanSchedule.get(1).get(\"totalDueForPeriod\"));\n        assertEquals(1000.0f, loanSchedule.get(1).get(\"totalOutstandingForPeriod\"));\n        LocalDate targetDate = LocalDate.of(2022, 9, 7);\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        this.loanTransactionHelper.noAccrualTransactionForRepayment(loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(2, loanSchedule.size());\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesDue\"));\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesOutstanding\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesDue\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesOutstanding\"));\n        assertEquals(1010.0f, loanSchedule.get(1).get(\"totalDueForPeriod\"));\n        assertEquals(1010.0f, loanSchedule.get(1).get(\"totalOutstandingForPeriod\"));\n        assertEquals(0, loanSchedule.get(1).get(\"totalWaivedForPeriod\"));\n\n        HashMap loanSummary = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"summary\");\n        assertEquals(10.0f, loanSummary.get(\"penaltyChargesCharged\"));\n        assertEquals(10.0f, loanSummary.get(\"penaltyChargesOutstanding\"));\n        assertEquals(0.0f, loanSummary.get(\"penaltyChargesWaived\"));\n        assertEquals(0.0f, loanSummary.get(\"feeChargesCharged\"));\n        assertEquals(0.0f, loanSummary.get(\"feeChargesOutstanding\"));\n        assertEquals(0.0f, loanSummary.get(\"feeChargesWaived\"));\n        assertEquals(1010.0f, loanSummary.get(\"totalOutstanding\"));\n        assertEquals(0.0f, loanSummary.get(\"totalWaived\"));\n\n        this.loanTransactionHelper.waiveChargesForLoan(loanID, penalty1LoanChargeId, \"\");\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(2, loanSchedule.size());\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesDue\"));\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesOutstanding\"));\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesWaived\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesDue\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesWaived\"));\n        assertEquals(0.0f, loanSchedule.get(1).get(\"penaltyChargesOutstanding\"));\n        assertEquals(1010.0f, loanSchedule.get(1).get(\"totalDueForPeriod\"));\n        assertEquals(1000.0f, loanSchedule.get(1).get(\"totalOutstandingForPeriod\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"totalWaivedForPeriod\"));\n\n        loanSummary = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"summary\");\n        assertEquals(10.0f, loanSummary.get(\"penaltyChargesCharged\"));\n        assertEquals(0.0f, loanSummary.get(\"penaltyChargesOutstanding\"));\n        assertEquals(10.0f, loanSummary.get(\"penaltyChargesWaived\"));\n        assertEquals(0.0f, loanSummary.get(\"feeChargesCharged\"));\n        assertEquals(0.0f, loanSummary.get(\"feeChargesOutstanding\"));\n        assertEquals(0.0f, loanSummary.get(\"feeChargesWaived\"));\n        assertEquals(1000.0f, loanSummary.get(\"totalOutstanding\"));\n        assertEquals(10.0f, loanSummary.get(\"totalWaived\"));\n\n        List<HashMap> transactions = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"transactions\");\n        assertEquals(10.0f, (float) transactions.get(1).get(\"amount\"));\n        assertEquals(9, (int) ((HashMap) transactions.get(1).get(\"type\")).get(\"id\"));\n        Integer waiveTransactionId = (int) transactions.get(1).get(\"id\");\n\n        this.loanTransactionHelper.undoWaiveChargesForLoan(loanID, waiveTransactionId, \"\");\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(2, loanSchedule.size());\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesDue\"));\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesOutstanding\"));\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesWaived\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesDue\"));\n        assertEquals(0.0f, loanSchedule.get(1).get(\"penaltyChargesWaived\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesOutstanding\"));\n        assertEquals(1010.0f, loanSchedule.get(1).get(\"totalDueForPeriod\"));\n        assertEquals(1010.0f, loanSchedule.get(1).get(\"totalOutstandingForPeriod\"));\n        assertEquals(0.0f, loanSchedule.get(1).get(\"totalWaivedForPeriod\"));\n\n        loanSummary = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"summary\");\n        assertEquals(10.0f, loanSummary.get(\"penaltyChargesCharged\"));\n        assertEquals(10.0f, loanSummary.get(\"penaltyChargesOutstanding\"));\n        assertEquals(0.0f, loanSummary.get(\"penaltyChargesWaived\"));\n        assertEquals(0.0f, loanSummary.get(\"feeChargesCharged\"));\n        assertEquals(0.0f, loanSummary.get(\"feeChargesOutstanding\"));\n        assertEquals(0.0f, loanSummary.get(\"feeChargesWaived\"));\n        assertEquals(1010.0f, loanSummary.get(\"totalOutstanding\"));\n        assertEquals(0.0f, loanSummary.get(\"totalWaived\"));\n\n        transactions = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"transactions\");\n        assertEquals(10.0f, (float) transactions.get(1).get(\"amount\"));\n        assertEquals(9, (int) ((HashMap) transactions.get(1).get(\"type\")).get(\"id\"));\n        assertEquals(true, transactions.get(1).get(\"manuallyReversed\"));\n\n        Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n        final String feeCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer fee1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), feeCharge1AddedDate, \"10\"));\n\n        this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(feeCharge1AddedDate);\n\n        transactions = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"transactions\");\n        assertEquals(20.0f, (float) transactions.get(2).get(\"amount\"));\n        assertEquals(10, (int) ((HashMap) transactions.get(2).get(\"type\")).get(\"id\"));\n        Integer accrualTransactionId = (int) transactions.get(2).get(\"id\");\n\n        List<HashMap> journalEntries = this.journalEntryHelper.getJournalEntriesByTransactionId(\"L\" + accrualTransactionId);\n        assertEquals(10.0f, (float) journalEntries.get(0).get(\"amount\"));\n        assertEquals(incomeAccount.getAccountID(), (int) journalEntries.get(0).get(\"glAccountId\"));\n        assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(0).get(\"entryType\")).get(\"value\"));\n        assertEquals(10.0f, (float) journalEntries.get(1).get(\"amount\"));\n        assertEquals(assetAccount.getAccountID(), (int) journalEntries.get(1).get(\"glAccountId\"));\n        assertEquals(\"DEBIT\", ((HashMap) journalEntries.get(1).get(\"entryType\")).get(\"value\"));\n        assertEquals(10.0f, (float) journalEntries.get(2).get(\"amount\"));\n        assertEquals(incomeAccount.getAccountID(), (int) journalEntries.get(2).get(\"glAccountId\"));\n        assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(2).get(\"entryType\")).get(\"value\"));\n        assertEquals(10.0f, (float) journalEntries.get(3).get(\"amount\"));\n        assertEquals(assetAccount.getAccountID(), (int) journalEntries.get(3).get(\"glAccountId\"));\n        assertEquals(\"DEBIT\", ((HashMap) journalEntries.get(3).get(\"entryType\")).get(\"value\"));\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(2, loanSchedule.size());\n        assertEquals(10.0f, loanSchedule.get(1).get(\"feeChargesDue\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"feeChargesOutstanding\"));\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesWaived\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesDue\"));\n        assertEquals(0, loanSchedule.get(1).get(\"penaltyChargesWaived\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesOutstanding\"));\n        assertEquals(1020.0f, loanSchedule.get(1).get(\"totalDueForPeriod\"));\n        assertEquals(1020.0f, loanSchedule.get(1).get(\"totalOutstandingForPeriod\"));\n        assertEquals(0, loanSchedule.get(1).get(\"totalWaivedForPeriod\"));\n\n        loanSummary = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"summary\");\n        assertEquals(10.0f, loanSummary.get(\"penaltyChargesCharged\"));\n        assertEquals(10.0f, loanSummary.get(\"penaltyChargesOutstanding\"));\n        assertEquals(0.0f, loanSummary.get(\"penaltyChargesWaived\"));\n        assertEquals(10.0f, loanSummary.get(\"feeChargesCharged\"));\n        assertEquals(10.0f, loanSummary.get(\"feeChargesOutstanding\"));\n        assertEquals(0.0f, loanSummary.get(\"feeChargesWaived\"));\n        assertEquals(1020.0f, loanSummary.get(\"totalOutstanding\"));\n        assertEquals(0.0f, loanSummary.get(\"totalWaived\"));\n\n        this.loanTransactionHelper.waiveChargesForLoan(loanID, fee1LoanChargeId, \"\");\n\n        transactions = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"transactions\");\n        assertEquals(10.0f, (float) transactions.get(3).get(\"amount\"));\n        assertEquals(9, (int) ((HashMap) transactions.get(3).get(\"type\")).get(\"id\"));\n        Integer waive2TransactionId = (int) transactions.get(3).get(\"id\");\n\n        journalEntries = this.journalEntryHelper.getJournalEntriesByTransactionId(\"L\" + waive2TransactionId);\n        assertEquals(10.0f, (float) journalEntries.get(0).get(\"amount\"));\n        assertEquals(expenseAccount.getAccountID(), (int) journalEntries.get(0).get(\"glAccountId\"));\n        assertEquals(\"DEBIT\", ((HashMap) journalEntries.get(0).get(\"entryType\")).get(\"value\"));\n        assertEquals(10.0f, (float) journalEntries.get(1).get(\"amount\"));\n        assertEquals(assetAccount.getAccountID(), (int) journalEntries.get(1).get(\"glAccountId\"));\n        assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(1).get(\"entryType\")).get(\"value\"));\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(2, loanSchedule.size());\n        assertEquals(10.0f, loanSchedule.get(1).get(\"feeChargesDue\"));\n        assertEquals(0.0f, loanSchedule.get(1).get(\"feeChargesOutstanding\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"feeChargesWaived\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesDue\"));\n        assertEquals(0, loanSchedule.get(1).get(\"penaltyChargesWaived\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesOutstanding\"));\n        assertEquals(1020.0f, loanSchedule.get(1).get(\"totalDueForPeriod\"));\n        assertEquals(1010.0f, loanSchedule.get(1).get(\"totalOutstandingForPeriod\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"totalWaivedForPeriod\"));\n\n        loanSummary = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"summary\");\n        assertEquals(10.0f, loanSummary.get(\"penaltyChargesCharged\"));\n        assertEquals(10.0f, loanSummary.get(\"penaltyChargesOutstanding\"));\n        assertEquals(0.0f, loanSummary.get(\"penaltyChargesWaived\"));\n        assertEquals(10.0f, loanSummary.get(\"feeChargesCharged\"));\n        assertEquals(0.0f, loanSummary.get(\"feeChargesOutstanding\"));\n        assertEquals(10.0f, loanSummary.get(\"feeChargesWaived\"));\n        assertEquals(1010.0f, loanSummary.get(\"totalOutstanding\"));\n        assertEquals(10.0f, loanSummary.get(\"totalWaived\"));\n\n        this.loanTransactionHelper.undoWaiveChargesForLoan(loanID, waive2TransactionId, \"\");\n\n        transactions = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"transactions\");\n        assertEquals(10.0f, (float) transactions.get(3).get(\"amount\"));\n        assertEquals(9, (int) ((HashMap) transactions.get(3).get(\"type\")).get(\"id\"));\n        assertEquals(true, transactions.get(3).get(\"manuallyReversed\"));\n\n        journalEntries = this.journalEntryHelper.getJournalEntriesByTransactionId(\"L\" + waive2TransactionId);\n        assertEquals(10.0f, (float) journalEntries.get(0).get(\"amount\"));\n        assertEquals(expenseAccount.getAccountID(), (int) journalEntries.get(0).get(\"glAccountId\"));\n        assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(0).get(\"entryType\")).get(\"value\"));\n        assertEquals(10.0f, (float) journalEntries.get(1).get(\"amount\"));\n        assertEquals(assetAccount.getAccountID(), (int) journalEntries.get(1).get(\"glAccountId\"));\n        assertEquals(\"DEBIT\", ((HashMap) journalEntries.get(1).get(\"entryType\")).get(\"value\"));\n        assertEquals(10.0f, (float) journalEntries.get(2).get(\"amount\"));\n        assertEquals(expenseAccount.getAccountID(), (int) journalEntries.get(2).get(\"glAccountId\"));\n        assertEquals(\"DEBIT\", ((HashMap) journalEntries.get(2).get(\"entryType\")).get(\"value\"));\n        assertEquals(10.0f, (float) journalEntries.get(3).get(\"amount\"));\n        assertEquals(assetAccount.getAccountID(), (int) journalEntries.get(3).get(\"glAccountId\"));\n        assertEquals(\"CREDIT\", ((HashMap) journalEntries.get(3).get(\"entryType\")).get(\"value\"));\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(2, loanSchedule.size());\n        assertEquals(10.0f, loanSchedule.get(1).get(\"feeChargesDue\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"feeChargesOutstanding\"));\n        assertEquals(0.0f, loanSchedule.get(1).get(\"feeChargesWaived\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesDue\"));\n        assertEquals(0, loanSchedule.get(1).get(\"penaltyChargesWaived\"));\n        assertEquals(10.0f, loanSchedule.get(1).get(\"penaltyChargesOutstanding\"));\n        assertEquals(1020.0f, loanSchedule.get(1).get(\"totalDueForPeriod\"));\n        assertEquals(1020.0f, loanSchedule.get(1).get(\"totalOutstandingForPeriod\"));\n        assertEquals(0.0f, loanSchedule.get(1).get(\"totalWaivedForPeriod\"));\n\n        loanSummary = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"summary\");\n        assertEquals(10.0f, loanSummary.get(\"penaltyChargesCharged\"));\n        assertEquals(10.0f, loanSummary.get(\"penaltyChargesOutstanding\"));\n        assertEquals(0.0f, loanSummary.get(\"penaltyChargesWaived\"));\n        assertEquals(10.0f, loanSummary.get(\"feeChargesCharged\"));\n        assertEquals(10.0f, loanSummary.get(\"feeChargesOutstanding\"));\n        assertEquals(0.0f, loanSummary.get(\"feeChargesWaived\"));\n        assertEquals(1020.0f, loanSummary.get(\"totalOutstanding\"));\n        assertEquals(0.0f, loanSummary.get(\"totalWaived\"));\n    }"}
{"prompt": "Create a test that tests charge Off", "completion": "    @Test\n    public void chargeOff() {\n        try {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, true);\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(this.requestSpec, this.responseSpec, true);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2022.09.30\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n            String randomText = UUID.randomUUID().toString();\n            Integer chargeOffReasonId = CodeHelper.createChargeOffCodeValue(requestSpec, responseSpec, randomText, 1);\n            final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterestMultiDisbursement(assetAccount,\n                    incomeAccount, expenseAccount, overpaymentAccount);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            ResponseSpecification errorResponseSpec = new ResponseSpecBuilder().expectStatusCode(403).build();\n            LoanTransactionHelper errorLoanTransactionHelper = new LoanTransactionHelper(this.requestSpec, errorResponseSpec);\n\n            CallFailedRuntimeException exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.chargeOffLoan((long) loanID,\n                        new PostLoansLoanIdTransactionsRequest().transactionDate(\"4 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\")\n                                .externalId(UUID.randomUUID().toString()).chargeOffReasonId((long) chargeOffReasonId));\n            });\n\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.loan.is.not.active\"));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                this.loanTransactionHelper.undoChargeOffLoan((long) loanID, new PostLoansLoanIdTransactionsRequest());\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.loan.is.not.active\"));\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithTransactionAmount(\"02 September 2022\", loanID, \"1000\");\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithTransactionAmount(\"03 September 2022\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                this.loanTransactionHelper.chargeOffLoan((long) loanID,\n                        new PostLoansLoanIdTransactionsRequest().transactionDate(\"1 October 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\")\n                                .chargeOffReasonId((long) chargeOffReasonId));\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.loan.transaction.cannot.be.a.future.date\"));\n\n            GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            assertTrue(loanDetails.getStatus().getActive());\n            assertEquals(2000.0, loanDetails.getSummary().getTotalOutstanding());\n            assertFalse(loanDetails.getChargedOff());\n            assertNull(loanDetails.getSummary().getChargeOffReasonId());\n            assertNull(loanDetails.getSummary().getChargeOffReason());\n            assertNull(loanDetails.getTimeline().getChargedOffOnDate());\n            assertNull(loanDetails.getTimeline().getChargedOffByUsername());\n            assertNull(loanDetails.getTimeline().getChargedOffByFirstname());\n            assertNull(loanDetails.getTimeline().getChargedOffByLastname());\n\n            Integer flatPenaltySpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"3\", true));\n            this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                    .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatPenaltySpecifiedDueDate), \"04 September 2022\", \"3\"));\n            Integer chargeId = this.loanTransactionHelper.addChargesForLoan(loanID, LoanTransactionHelper\n                    .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatPenaltySpecifiedDueDate), \"04 September 2022\", \"5\"));\n\n            PostLoansLoanIdChargesChargeIdResponse waiveChargeResponse = this.loanTransactionHelper.waiveLoanCharge((long) loanID,\n                    (long) chargeId, new PostLoansLoanIdChargesChargeIdRequest());\n\n            String transactionExternalId = UUID.randomUUID().toString();\n            this.loanTransactionHelper.chargeOffLoan((long) loanID,\n                    new PostLoansLoanIdTransactionsRequest().transactionDate(\"4 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\")\n                            .externalId(transactionExternalId).chargeOffReasonId((long) chargeOffReasonId));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            assertTrue(loanDetails.getStatus().getActive());\n            assertEquals(2003.0, loanDetails.getSummary().getTotalOutstanding());\n            assertTrue(loanDetails.getChargedOff());\n            assertEquals((long) chargeOffReasonId, loanDetails.getSummary().getChargeOffReasonId());\n            assertEquals(randomText, loanDetails.getSummary().getChargeOffReason());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTimeline().getChargedOffOnDate());\n            assertEquals(\"mifos\", loanDetails.getTimeline().getChargedOffByUsername());\n            assertEquals(\"App\", loanDetails.getTimeline().getChargedOffByFirstname());\n            assertEquals(\"Administrator\", loanDetails.getTimeline().getChargedOffByLastname());\n\n            GetLoansLoanIdTransactions chargeOffTransaction = loanDetails.getTransactions().get(loanDetails.getTransactions().size() - 1);\n\n            assertEquals(2003.0, chargeOffTransaction.getAmount());\n            assertEquals(2000.0, chargeOffTransaction.getPrincipalPortion());\n            assertEquals(3.0, chargeOffTransaction.getPenaltyChargesPortion());\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.chargeOffLoan((long) loanID,\n                        new PostLoansLoanIdTransactionsRequest().transactionDate(\"4 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\")\n                                .externalId(UUID.randomUUID().toString()).chargeOffReasonId((long) chargeOffReasonId));\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.loan.is.already.charged.off\"));\n\n            HashMap chargeAddingError = errorLoanTransactionHelper.addChargesForLoanGetFullResponse(loanID, LoanTransactionHelper\n                    .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatPenaltySpecifiedDueDate), \"04 September 2022\", \"3\"));\n\n            assertEquals(\"error.msg.loan.is.charged.off\",\n                    ((Map) ((List) chargeAddingError.get(\"errors\")).get(0)).get(\"userMessageGlobalisationCode\"));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.undoWaiveLoanCharge((long) loanID, waiveChargeResponse.getSubResourceId(),\n                        new PutChargeTransactionChangesRequest());\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.transaction.date.cannot.be.earlier.than.charge.off.date\"));\n\n            this.loanTransactionHelper.undoChargeOffLoan((long) loanID, new PostLoansLoanIdTransactionsRequest());\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            assertFalse(loanDetails.getChargedOff());\n            assertNull(loanDetails.getSummary().getChargeOffReasonId());\n            assertNull(loanDetails.getSummary().getChargeOffReason());\n            assertNull(loanDetails.getTimeline().getChargedOffOnDate());\n\n            GetLoansLoanIdTransactions undoChargeOffTransaction = loanDetails.getTransactions()\n                    .get(loanDetails.getTransactions().size() - 1);\n            assertTrue(undoChargeOffTransaction.getType().getChargeoff());\n            assertTrue(undoChargeOffTransaction.getManuallyReversed());\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.undoChargeOffLoan((long) loanID, new PostLoansLoanIdTransactionsRequest());\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.loan.is.not.charged.off\"));\n\n            PostLoansLoanIdTransactionsResponse loanRepaymentResponse = this.loanTransactionHelper.makeLoanRepayment((long) loanID,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"05 September 2022\").locale(\"en\")\n                            .transactionAmount(5.0));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.chargeOffLoan((long) loanID,\n                        new PostLoansLoanIdTransactionsRequest().transactionDate(\"04 September 2022\").locale(\"en\")\n                                .dateFormat(\"dd MMMM yyyy\").externalId(UUID.randomUUID().toString())\n                                .chargeOffReasonId((long) chargeOffReasonId));\n            });\n\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.loan.charge.off.is.before.than.the.last.user.transaction\"));\n\n            this.loanTransactionHelper.chargeOffLoan((long) loanID,\n                    new PostLoansLoanIdTransactionsRequest().transactionDate(\"06 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\")\n                            .externalId(UUID.randomUUID().toString()).chargeOffReasonId((long) chargeOffReasonId));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            chargeOffTransaction = loanDetails.getTransactions().get(loanDetails.getTransactions().size() - 1);\n\n            assertEquals(1998.0, chargeOffTransaction.getAmount());\n            assertEquals(1998.0, chargeOffTransaction.getPrincipalPortion());\n\n            this.loanTransactionHelper.makeLoanRepayment((long) loanID, new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\")\n                    .transactionDate(\"07 September 2022\").locale(\"en\").transactionAmount(5.0));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.undoChargeOffLoan((long) loanID, new PostLoansLoanIdTransactionsRequest());\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.loan.charge.off.is.not.the.last.user.transaction\"));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.adjustLoanTransaction((long) loanID, loanRepaymentResponse.getResourceId(),\n                        new PostLoansLoanIdTransactionsTransactionIdRequest().transactionDate(\"06 September 2022\").locale(\"en\")\n                                .dateFormat(\"dd MMMM yyyy\").transactionAmount(0.0));\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.adjusted.transaction.date.cannot.be.earlier.than.charge.off.date\"));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.makeWriteoff((long) loanID, new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\")\n                        .transactionDate(\"05 September 2022\").locale(\"en\"));\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.transaction.date.cannot.be.earlier.than.charge.off.date\"));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.closeLoan((long) loanID, new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\")\n                        .transactionDate(\"05 September 2022\").locale(\"en\"));\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.transaction.date.cannot.be.earlier.than.charge.off.date\"));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.forecloseLoan((long) loanID, new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\")\n                        .transactionDate(\"05 September 2022\").locale(\"en\"));\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.transaction.date.cannot.be.earlier.than.charge.off.date\"));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.closeRescheduledLoan((long) loanID, new PostLoansLoanIdTransactionsRequest()\n                        .dateFormat(\"dd MMMM yyyy\").transactionDate(\"05 September 2022\").locale(\"en\"));\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.loan.is.charged.off\"));\n\n            HashMap disbursementDetailREsponse = (HashMap) errorLoanTransactionHelper.addAndDeleteDisbursementDetail(loanID, \"1000\",\n                    \"03 September 2022\", List.of(this.loanTransactionHelper.createTrancheDetail(null, \"05 September 2022\", \"200\")), \"\");\n\n            assertEquals(\"error.msg.loan.is.charged.off\",\n                    ((Map) ((List) disbursementDetailREsponse.get(\"errors\")).get(0)).get(\"userMessageGlobalisationCode\"));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.undoLastDisbursalLoan((long) loanID, new PostLoansLoanIdRequest());\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.loan.is.charged.off\"));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.undoDisbursalLoan((long) loanID, new PostLoansLoanIdRequest());\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.loan.is.charged.off\"));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.makeLoanRepayment((long) loanID, new PostLoansLoanIdTransactionsRequest()\n                        .dateFormat(\"dd MMMM yyyy\").transactionDate(\"05 September 2022\").locale(\"en\").transactionAmount(5.0));\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.transaction.date.cannot.be.earlier.than.charge.off.date\"));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.makeLoanRepayment((long) loanID, new PostLoansLoanIdTransactionsRequest()\n                        .dateFormat(\"dd MMMM yyyy\").transactionDate(\"05 September 2022\").locale(\"en\").transactionAmount(5.0));\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.transaction.date.cannot.be.earlier.than.charge.off.date\"));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.makeCreditBalanceRefund((long) loanID, new PostLoansLoanIdTransactionsRequest()\n                        .dateFormat(\"dd MMMM yyyy\").transactionDate(\"05 September 2022\").locale(\"en\").transactionAmount(5.0));\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.transaction.date.cannot.be.earlier.than.charge.off.date\"));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.disburseLoan((long) loanID,\n                        new PostLoansLoanIdRequest().actualDisbursementDate(\"4 September 2022\").transactionAmount(new BigDecimal(\"10\"))\n                                .locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.transaction.date.cannot.be.earlier.than.charge.off.date\"));\n\n            this.loanTransactionHelper.makeLoanRepayment((long) loanID, new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\")\n                    .transactionDate(\"07 September 2022\").locale(\"en\").transactionAmount(5000.0));\n\n            exception = assertThrows(CallFailedRuntimeException.class, () -> {\n                errorLoanTransactionHelper.makeRefundByCash((long) loanID, new PostLoansLoanIdTransactionsRequest()\n                        .dateFormat(\"dd MMMM yyyy\").transactionDate(\"05 September 2022\").locale(\"en\").transactionAmount(5.0));\n            });\n            assertEquals(403, exception.getResponse().code());\n            assertTrue(exception.getMessage().contains(\"error.msg.transaction.date.cannot.be.earlier.than.charge.off.date\"));\n\n            this.loanTransactionHelper.makeCreditBalanceRefund((long) loanID, new PostLoansLoanIdTransactionsRequest()\n                    .dateFormat(\"dd MMMM yyyy\").transactionDate(\"08 September 2022\").locale(\"en\").transactionAmount(3007.0));\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Close Open Maturity Date", "completion": "    @Test\n    public void testCloseOpenMaturityDate() {\n        GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, true);\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n        LocalDate expectedMaturityDate = loanDetails.getTimeline().getExpectedMaturityDate();\n        LocalDate actualMaturityDate = loanDetails.getTimeline().getActualMaturityDate();\n\n        assertTrue(expectedMaturityDate.isEqual(actualMaturityDate));\n\n        this.loanTransactionHelper.makeRepayment(\"04 September 2022\", Float.parseFloat(\"500\"), loanID);\n        this.loanTransactionHelper.makeRepayment(\"05 September 2022\", Float.parseFloat(\"700\"), loanID);\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n        expectedMaturityDate = loanDetails.getTimeline().getExpectedMaturityDate();\n        actualMaturityDate = loanDetails.getTimeline().getActualMaturityDate();\n\n        assertNotNull(expectedMaturityDate);\n        assertNull(actualMaturityDate);\n\n        this.loanTransactionHelper.reverseLoanTransaction((long) loanID, loanDetails.getTransactions().get(1).getId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"04 September 2022\")\n                        .transactionAmount(0.0).locale(\"en\"));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n        expectedMaturityDate = loanDetails.getTimeline().getExpectedMaturityDate();\n        actualMaturityDate = loanDetails.getTimeline().getActualMaturityDate();\n\n        assertNotNull(expectedMaturityDate);\n        assertNotNull(actualMaturityDate);\n\n        assertTrue(expectedMaturityDate.isEqual(actualMaturityDate));\n\n    }"}
{"prompt": "Create a test that tests test Reverse Replay", "completion": "    @Test\n    public void testReverseReplay() {\n        try {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, true);\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount,\n                    expenseAccount, overpaymentAccount);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            this.loanTransactionHelper.makeRepayment(\"04 September 2022\", Float.parseFloat(\"500\"), loanID);\n            this.loanTransactionHelper.makeRepayment(\"05 September 2022\", Float.parseFloat(\"10\"), loanID);\n            this.loanTransactionHelper.makeRepayment(\"06 September 2022\", Float.parseFloat(\"400\"), loanID);\n            this.loanTransactionHelper.makeRepayment(\"07 September 2022\", Float.parseFloat(\"390\"), loanID);\n\n            GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            assertEquals(300.0, loanDetails.getTotalOverpaid());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n\n            assertEquals(10.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(10.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(2).getDate());\n\n            assertEquals(400.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(400.0, loanDetails.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 6), loanDetails.getTransactions().get(3).getDate());\n\n            assertEquals(390.0, loanDetails.getTransactions().get(4).getAmount());\n            assertEquals(90.0, loanDetails.getTransactions().get(4).getPrincipalPortion());\n            assertEquals(300.0, loanDetails.getTransactions().get(4).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 7), loanDetails.getTransactions().get(4).getDate());\n\n            this.loanTransactionHelper.reverseLoanTransaction((long) loanID, loanDetails.getTransactions().get(2).getId(),\n                    new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"05 September 2022\")\n                            .transactionAmount(0.0).locale(\"en\"));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            assertEquals(290.0, loanDetails.getTotalOverpaid());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n\n            assertEquals(10.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(10.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(2).getDate());\n            assertTrue(loanDetails.getTransactions().get(2).getManuallyReversed());\n\n            assertEquals(400.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(400.0, loanDetails.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 6), loanDetails.getTransactions().get(3).getDate());\n\n            assertEquals(390.0, loanDetails.getTransactions().get(4).getAmount());\n            assertEquals(100.0, loanDetails.getTransactions().get(4).getPrincipalPortion());\n            assertEquals(290.0, loanDetails.getTransactions().get(4).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 7), loanDetails.getTransactions().get(4).getDate());\n\n            this.loanTransactionHelper.reverseLoanTransaction((long) loanID, loanDetails.getTransactions().get(1).getId(),\n                    new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"05 September 2022\")\n                            .transactionAmount(0.0).locale(\"en\"));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            assertEquals(210.0, loanDetails.getSummary().getTotalOutstanding());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n            assertTrue(loanDetails.getTransactions().get(2).getManuallyReversed());\n\n            assertEquals(10.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(10.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(2).getDate());\n            assertTrue(loanDetails.getTransactions().get(2).getManuallyReversed());\n\n            assertEquals(400.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(400.0, loanDetails.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 6), loanDetails.getTransactions().get(3).getDate());\n\n            assertEquals(390.0, loanDetails.getTransactions().get(4).getAmount());\n            assertEquals(390.0, loanDetails.getTransactions().get(4).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 7), loanDetails.getTransactions().get(4).getDate());\n\n            this.loanTransactionHelper.makeRepayment(\"04 September 2022\", Float.parseFloat(\"500\"), loanID);\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            assertEquals(290.0, loanDetails.getTotalOverpaid());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n            assertTrue(loanDetails.getTransactions().get(1).getManuallyReversed());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(2).getDate());\n\n            assertEquals(10.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(10.0, loanDetails.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(3).getDate());\n            assertTrue(loanDetails.getTransactions().get(3).getManuallyReversed());\n\n            assertEquals(400.0, loanDetails.getTransactions().get(4).getAmount());\n            assertEquals(400.0, loanDetails.getTransactions().get(4).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 6), loanDetails.getTransactions().get(4).getDate());\n\n            assertEquals(390.0, loanDetails.getTransactions().get(5).getAmount());\n            assertEquals(100.0, loanDetails.getTransactions().get(5).getPrincipalPortion());\n            assertEquals(290.0, loanDetails.getTransactions().get(5).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 7), loanDetails.getTransactions().get(5).getDate());\n        } finally {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, false);\n        }\n    }"}
{"prompt": "Create a test that tests test Credit Balance Refund After Maturity With Reverse Replay Of Repayments", "completion": "    @Test\n    public void testCreditBalanceRefundAfterMaturityWithReverseReplayOfRepayments() {\n        try {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, true);\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(this.requestSpec, this.responseSpec, true);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2022.10.10\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount,\n                    expenseAccount, overpaymentAccount);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            this.loanTransactionHelper.makeRepayment(\"04 September 2022\", Float.parseFloat(\"100\"), loanID);\n            this.loanTransactionHelper.makeRepayment(\"05 September 2022\", Float.parseFloat(\"1100\"), loanID);\n\n            GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(200.0, loanDetails.getTotalOverpaid());\n            assertTrue(loanDetails.getStatus().getOverpaid());\n\n            this.loanTransactionHelper.makeCreditBalanceRefund((long) loanID, new PostLoansLoanIdTransactionsRequest()\n                    .transactionAmount(200.0).transactionDate(\"10 October 2022\").dateFormat(\"dd MMMM yyyy\").locale(\"en\").paymentTypeId(1L));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            assertTrue(loanDetails.getStatus().getClosedObligationsMet());\n\n            assertEquals(2, loanDetails.getRepaymentSchedule().getPeriods().size());\n            assertEquals(1000, loanDetails.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n\n            assertEquals(100.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(100.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n            assertEquals(900.0, loanDetails.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(1100.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(900.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(200.0, loanDetails.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(2).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(2).getOutstandingLoanBalance());\n            assertEquals(200.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(200.0, loanDetails.getTransactions().get(3).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 10, 10), loanDetails.getTransactions().get(3).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(3).getOutstandingLoanBalance());\n            assertEquals(1L, loanDetails.getTransactions().get(3).getPaymentDetailData().getPaymentType().getId());\n            GetJournalEntriesTransactionIdResponse journalEntriesForTransaction = journalEntryHelper\n                    .getJournalEntries(\"L\" + loanDetails.getTransactions().get(3).getId());\n            List<JournalEntryTransactionItem> journalItems = journalEntriesForTransaction.getPageItems();\n            assertEquals(2, journalItems.size());\n            assertEquals(200.0,\n                    journalItems.stream()\n                            .filter(j -> \"DEBIT\".equalsIgnoreCase(j.getEntryType().getValue())\n                                    && j.getGlAccountId().equals(overpaymentAccount.getAccountID().longValue()))\n                            .findFirst().get().getAmount());\n            assertEquals(200.0, journalItems.stream().filter(j -> \"CREDIT\".equalsIgnoreCase(j.getEntryType().getValue())\n                    && j.getGlAccountId().equals(assetAccount.getAccountID().longValue())).findFirst().get().getAmount());\n\n            this.loanTransactionHelper.reverseLoanTransaction(loanDetails.getId(), loanDetails.getTransactions().get(1).getId(),\n                    new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\").transactionAmount(0.0)\n                            .transactionDate(\"10 October 2022\").locale(\"en\"));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            assertEquals(100.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(100.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n            assertTrue(loanDetails.getTransactions().get(1).getManuallyReversed());\n\n            assertEquals(1100.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(1000.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(100.0, loanDetails.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(2).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(2).getOutstandingLoanBalance());\n            assertEquals(1, loanDetails.getTransactions().get(2).getTransactionRelations().size());\n\n            assertEquals(200.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(100.0, loanDetails.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(100.0, loanDetails.getTransactions().get(3).getOverpaymentPortion());\n            assertEquals(100.0, loanDetails.getTransactions().get(3).getOutstandingLoanBalance());\n            assertEquals(LocalDate.of(2022, 10, 10), loanDetails.getTransactions().get(3).getDate());\n            assertEquals(1, loanDetails.getTransactions().get(3).getTransactionRelations().size());\n\n            assertTrue(loanDetails.getStatus().getActive());\n\n            assertEquals(3, loanDetails.getRepaymentSchedule().getPeriods().size());\n            assertEquals(1000, loanDetails.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertTrue(loanDetails.getRepaymentSchedule().getPeriods().get(1).getComplete());\n            assertEquals(200, loanDetails.getRepaymentSchedule().getPeriods().get(2).getPrincipalDue());\n            assertFalse(loanDetails.getRepaymentSchedule().getPeriods().get(2).getComplete());\n            assertEquals(100.0, loanDetails.getRepaymentSchedule().getPeriods().get(2).getPrincipalPaid());\n            assertEquals(100.0, loanDetails.getRepaymentSchedule().getPeriods().get(2).getPrincipalOutstanding());\n\n            journalEntriesForTransaction = journalEntryHelper.getJournalEntries(\"L\" + loanDetails.getTransactions().get(3).getId());\n            journalItems = journalEntriesForTransaction.getPageItems();\n            assertEquals(3, journalItems.size());\n            assertEquals(1,\n                    journalItems.stream().filter(item -> item.getAmount() == 200.0d)\n                            .filter(j -> \"CREDIT\".equalsIgnoreCase(j.getEntryType().getValue())\n                                    && j.getGlAccountId().equals(assetAccount.getAccountID().longValue()))\n                            .count());\n            assertEquals(1,\n                    journalItems.stream().filter(item -> item.getAmount() == 100.0d)\n                            .filter(j -> \"DEBIT\".equalsIgnoreCase(j.getEntryType().getValue())\n                                    && j.getGlAccountId().equals(overpaymentAccount.getAccountID().longValue()))\n                            .count());\n            assertEquals(1,\n                    journalItems.stream().filter(item -> item.getAmount() == 100.0d)\n                            .filter(j -> \"DEBIT\".equalsIgnoreCase(j.getEntryType().getValue())\n                                    && j.getGlAccountId().equals(assetAccount.getAccountID().longValue()))\n                            .count());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, false);\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(this.requestSpec, this.responseSpec, false);\n        }\n    }"}
{"prompt": "Create a test that tests test Credit Balance Refund Before Maturity With Reverse Replay Of Repayments And Refund", "completion": "    @Test\n    public void testCreditBalanceRefundBeforeMaturityWithReverseReplayOfRepaymentsAndRefund() {\n        try {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, true);\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(this.requestSpec, this.responseSpec, true);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2022.10.10\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount,\n                    expenseAccount, overpaymentAccount);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            this.loanTransactionHelper.makeRepayment(\"04 September 2022\", Float.parseFloat(\"500\"), loanID);\n            this.loanTransactionHelper.makeRepayment(\"05 September 2022\", Float.parseFloat(\"700\"), loanID);\n\n            GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(200.0, loanDetails.getTotalOverpaid());\n            assertTrue(loanDetails.getStatus().getOverpaid());\n\n            this.loanTransactionHelper.makeCreditBalanceRefund((long) loanID, new PostLoansLoanIdTransactionsRequest()\n                    .transactionAmount(200.0).transactionDate(\"06 September 2022\").dateFormat(\"dd MMMM yyyy\").locale(\"en\"));\n\n            this.loanTransactionHelper.makeMerchantIssuedRefund((long) loanID, new PostLoansLoanIdTransactionsRequest().locale(\"en\")\n                    .dateFormat(\"dd MMMM yyyy\").transactionDate(\"07 September 2022\").transactionAmount(500.0));\n\n            this.loanTransactionHelper.makeCreditBalanceRefund((long) loanID, new PostLoansLoanIdTransactionsRequest()\n                    .transactionAmount(500.0).transactionDate(\"08 September 2022\").dateFormat(\"dd MMMM yyyy\").locale(\"en\"));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n            assertTrue(loanDetails.getStatus().getClosedObligationsMet());\n\n            assertEquals(2, loanDetails.getRepaymentSchedule().getPeriods().size());\n            assertEquals(1000, loanDetails.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getOutstandingLoanBalance());\n\n            assertEquals(700.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(200.0, loanDetails.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(2).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(2).getOutstandingLoanBalance());\n\n            assertEquals(200.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(200.0, loanDetails.getTransactions().get(3).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 6), loanDetails.getTransactions().get(3).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(3).getOutstandingLoanBalance());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(4).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(4).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 7), loanDetails.getTransactions().get(4).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(4).getOutstandingLoanBalance());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(5).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(5).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 8), loanDetails.getTransactions().get(5).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(5).getOutstandingLoanBalance());\n\n            this.loanTransactionHelper.reverseLoanTransaction(loanDetails.getId(), loanDetails.getTransactions().get(2).getId(),\n                    new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\").transactionAmount(0.0)\n                            .transactionDate(\"07 September 2022\").locale(\"en\"));\n\n            loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 4), loanDetails.getTransactions().get(1).getDate());\n            assertEquals(500.0, loanDetails.getTransactions().get(1).getOutstandingLoanBalance());\n\n            assertEquals(700.0, loanDetails.getTransactions().get(2).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(200.0, loanDetails.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(2).getDate());\n            assertEquals(0.0, loanDetails.getTransactions().get(2).getOutstandingLoanBalance());\n            assertTrue(loanDetails.getTransactions().get(2).getManuallyReversed());\n\n            assertEquals(200.0, loanDetails.getTransactions().get(3).getAmount());\n            assertEquals(200.0, loanDetails.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 6), loanDetails.getTransactions().get(3).getDate());\n            assertEquals(700.0, loanDetails.getTransactions().get(3).getOutstandingLoanBalance());\n            assertEquals(1, loanDetails.getTransactions().get(3).getTransactionRelations().size());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(4).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(4).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 7), loanDetails.getTransactions().get(4).getDate());\n            assertEquals(200.0, loanDetails.getTransactions().get(4).getOutstandingLoanBalance());\n            assertEquals(1, loanDetails.getTransactions().get(4).getTransactionRelations().size());\n\n            assertEquals(500.0, loanDetails.getTransactions().get(5).getAmount());\n            assertEquals(500.0, loanDetails.getTransactions().get(5).getPrincipalPortion());\n            assertEquals(LocalDate.of(2022, 9, 8), loanDetails.getTransactions().get(5).getDate());\n            assertEquals(700.0, loanDetails.getTransactions().get(5).getOutstandingLoanBalance());\n            assertEquals(1, loanDetails.getTransactions().get(5).getTransactionRelations().size());\n\n            assertTrue(loanDetails.getStatus().getActive());\n\n            assertEquals(2, loanDetails.getRepaymentSchedule().getPeriods().size());\n            assertEquals(1700, loanDetails.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertFalse(loanDetails.getRepaymentSchedule().getPeriods().get(1).getComplete());\n            assertEquals(1000.0, loanDetails.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(700.0, loanDetails.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, false);\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(this.requestSpec, this.responseSpec, false);\n        }\n    }"}
{"prompt": "Create a test that tests accrual Is Calculated When The Loan Is Closed", "completion": "    @Test\n    public void accrualIsCalculatedWhenTheLoanIsClosed() {\n        try {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, true);\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(this.requestSpec, this.responseSpec, true);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2022.10.10\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount,\n                    expenseAccount, overpaymentAccount);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2011\");\n            List<HashMap> charges = new ArrayList<>();\n            Integer installmentFee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanInstallmentJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n            addCharges(charges, installmentFee, \"10\", null);\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, charges);\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"03 September 2022\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            this.loanTransactionHelper.makeRepayment(\"04 September 2022\", Float.parseFloat(\"5\"), loanID);\n\n            this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(\"04 September 2022\");\n\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"11\", true));\n            LocalDate targetDate = LocalDate.of(2022, 9, 6);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"11\"));\n\n            this.loanTransactionHelper.waiveLoanCharge((long) loanID, (long) penalty1LoanChargeId,\n                    new PostLoansLoanIdChargesChargeIdRequest());\n\n            this.loanTransactionHelper.makeRepayment(\"08 September 2022\", Float.parseFloat(\"1010\"), loanID);\n\n            GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanID);\n\n            GetLoansLoanIdTransactions lastAccrualTransaction = loanDetails.getTransactions().stream()\n                    .filter(t -> Boolean.TRUE.equals(t.getType().getAccrual())).findFirst().get();\n            assertEquals(15, lastAccrualTransaction.getAmount());\n            assertEquals(5, lastAccrualTransaction.getPenaltyChargesPortion());\n            assertEquals(10, lastAccrualTransaction.getFeeChargesPortion());\n\n            GetLoansLoanIdTransactionsTransactionIdResponse accrualTransactionDetails = this.loanTransactionHelper\n                    .getLoanTransactionDetails((long) loanID, lastAccrualTransaction.getId());\n\n            assertEquals(2, accrualTransactionDetails.getLoanChargePaidByList().size());\n            accrualTransactionDetails.getLoanChargePaidByList().forEach(loanCharge -> {\n                if (loanCharge.getChargeId().equals((long) penalty1LoanChargeId)) {\n                    assertEquals(5, loanCharge.getAmount());\n                } else {\n                    assertEquals(10, loanCharge.getAmount());\n                }\n            });\n\n        } finally {\n            GlobalConfigurationHelper.updateIsAutomaticExternalIdGenerationEnabled(this.requestSpec, this.responseSpec, false);\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(this.requestSpec, this.responseSpec, false);\n        }\n    }"}
{"prompt": "Create a test that tests check That All Multi Disbursals Appear On Loan Schedule And Out Standing Balance Is Zero Test", "completion": "    @Test\n    public void checkThatAllMultiDisbursalsAppearOnLoanScheduleAndOutStandingBalanceIsZeroTest() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        /***\n         * Create loan product with allowing multiple disbursals\n         */\n        boolean allowMultipleDisbursals = true;\n        final Integer loanProductID = createLoanProduct(allowMultipleDisbursals);\n        Assertions.assertNotNull(loanProductID);\n\n        /***\n         * Apply for loan application and verify loan status\n         */\n        final String savingsId = null;\n        final String principal = \"12,000.00\";\n\n        LOG.info(\"-----------------------------------10 Tranches--------------------------------------\");\n        List<HashMap> tranches = new ArrayList<>();\n        tranches.add(createTrancheDetail(\"01 January 2021\", \"1\"));\n        tranches.add(createTrancheDetail(\"02 January 2021\", \"2\"));\n        tranches.add(createTrancheDetail(\"03 January 2021\", \"4\"));\n        tranches.add(createTrancheDetail(\"04 January 2021\", \"8\"));\n        tranches.add(createTrancheDetail(\"05 January 2021\", \"16\"));\n        tranches.add(createTrancheDetail(\"06 January 2021\", \"32\"));\n        tranches.add(createTrancheDetail(\"07 January 2021\", \"64\"));\n        tranches.add(createTrancheDetail(\"08 January 2021\", \"128\"));\n        tranches.add(createTrancheDetail(\"09 January 2021\", \"256\"));\n        tranches.add(createTrancheDetail(\"10 January 2021\", \"512\"));\n        String submitDate = \"01 January 2021\";\n\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, savingsId, principal, tranches, submitDate);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 January 2021\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\"-------------------------------DISBURSE 8 LOANS -------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"12 January 2021\", loanID, \"1\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"12 January 2021\", loanID, \"2\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"12 January 2021\", loanID, \"4\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"13 January 2021\", loanID, \"8\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"14 January 2021\", loanID, \"16\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"14 January 2021\", loanID, \"32\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"15 January 2021\", loanID, \"64\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"15 January 2021\", loanID, \"128\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        final int loanScheduleLineCount = loanSchedule.size();\n        final int expectedLoanScheduleLineCount = 9;\n        final int expectedDisbursals = 8;\n        final BigDecimal val255 = BigDecimal.valueOf(255.0);\n        final BigDecimal expectedTotalPrincipalDisbursed = val255;\n        final BigDecimal expectedPrincipalDue = val255;\n        final BigDecimal expectedPrincipalLoanBalanceOutstanding = BigDecimal.valueOf(0.0);\n\n        assertEquals(expectedLoanScheduleLineCount, loanScheduleLineCount, \"Checking nine lines in schedule\");\n\n        int disbursalCount = 0;\n        BigDecimal totalPrincipalDisbursed = BigDecimal.ZERO;\n        // First 8 lines should be disbursals\n        for (int i = 0; i < loanScheduleLineCount - 1; i++) {\n            final Integer period = (Integer) loanSchedule.get(i).get(\"period\");\n            final BigDecimal principalDisbursed = BigDecimal\n                    .valueOf(Double.parseDouble(loanSchedule.get(i).get(\"principalDisbursed\").toString()));\n\n            if (period == null) {\n                disbursalCount += 1;\n                totalPrincipalDisbursed = totalPrincipalDisbursed.add(principalDisbursed);\n            }\n        }\n        assertEquals(expectedDisbursals, disbursalCount, \"Checking for eight disbursals\");\n        assertEquals(expectedTotalPrincipalDisbursed, totalPrincipalDisbursed, \"Checking Principal Disburse is 255\");\n\n        final BigDecimal principalDue = BigDecimal.valueOf(Double.parseDouble(loanSchedule.get(8).get(\"principalDue\").toString()));\n        assertEquals(expectedPrincipalDue, principalDue, \"Checking Principal Due is 255\");\n\n        final BigDecimal principalLoanBalanceOutstanding = BigDecimal\n                .valueOf(Double.parseDouble(loanSchedule.get(8).get(\"principalLoanBalanceOutstanding\").toString()));\n        assertEquals(expectedPrincipalLoanBalanceOutstanding, principalLoanBalanceOutstanding,\n                \"Checking Principal Loan Balance Outstanding is zero\");\n\n    }"}
{"prompt": "Create a test that tests check That All Multi Disbursals Appear On Loan Schedule And Out Standing Balance Is Zero But Loan Got Reopened Test", "completion": "    @Test\n    public void checkThatAllMultiDisbursalsAppearOnLoanScheduleAndOutStandingBalanceIsZeroButLoanGotReopenedTest() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        /***\n         * Create loan product with allowing multiple disbursals\n         */\n        boolean allowMultipleDisbursals = true;\n        final Integer loanProductID = createLoanProduct(allowMultipleDisbursals);\n        Assertions.assertNotNull(loanProductID);\n\n        /***\n         * Apply for loan application and verify loan status\n         */\n        final String savingsId = null;\n        final String principal = \"12,000.00\";\n\n        LOG.info(\"-----------------------------------2 Tranches--------------------------------------\");\n        List<HashMap> tranches = new ArrayList<>();\n        tranches.add(createTrancheDetail(\"01 January 2021\", \"1\"));\n        tranches.add(createTrancheDetail(\"02 January 2021\", \"2\"));\n        String submitDate = \"01 January 2021\";\n\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, savingsId, principal, tranches, submitDate);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 January 2021\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\n                \"-------------------------------DISBURSE 1, repay fully, disburse again LOANS -------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithTransactionAmount(\"12 January 2021\", loanID, \"1\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        HashMap repaymentDetails = this.loanTransactionHelper.makeRepayment(\"13 January 2021\", 1.0f, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"status\");\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithTransactionAmount(\"14 January 2021\", loanID, \"2\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        final int loanScheduleLineCount = loanSchedule.size();\n        final int expectedLoanScheduleLineCount = 3;\n        final int expectedDisbursals = 2;\n        final BigDecimal expectedTotalPrincipalDisbursed = BigDecimal.valueOf(3.0);\n        final BigDecimal expectedPrincipalDue = BigDecimal.valueOf(3.0);\n        final BigDecimal expectedPrincipalPaid = BigDecimal.valueOf(1.0);\n        final BigDecimal expectedPrincipalOutstanding = BigDecimal.valueOf(2.0);\n        final BigDecimal expectedPrincipalLoanBalanceOutstanding = BigDecimal.valueOf(0.0);\n\n        assertEquals(expectedLoanScheduleLineCount, loanScheduleLineCount, \"Checking 3 lines in schedule\");\n\n        int disbursalCount = 0;\n        BigDecimal totalPrincipalDisbursed = BigDecimal.ZERO;\n        // First 8 lines should be disbursals\n        for (int i = 0; i < loanScheduleLineCount - 1; i++) {\n            final Integer period = (Integer) loanSchedule.get(i).get(\"period\");\n            final BigDecimal principalDisbursed = BigDecimal\n                    .valueOf(Double.parseDouble(loanSchedule.get(i).get(\"principalDisbursed\").toString()));\n\n            if (period == null) {\n                disbursalCount += 1;\n                totalPrincipalDisbursed = totalPrincipalDisbursed.add(principalDisbursed);\n            }\n            // LOG.info(loanSchedule.get(i).toString());\n        }\n        assertEquals(expectedDisbursals, disbursalCount, \"Checking for 2 disbursals\");\n        assertEquals(expectedTotalPrincipalDisbursed, totalPrincipalDisbursed, \"Checking Principal Disburse is 3\");\n\n        final BigDecimal principalDue = BigDecimal.valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalDue\").toString()));\n        assertEquals(expectedPrincipalDue, principalDue, \"Checking Principal Due is 3\");\n        final BigDecimal principalPaid = BigDecimal.valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalPaid\").toString()));\n        assertEquals(expectedPrincipalPaid, principalPaid, \"Checking Principal Paid is 1\");\n        final BigDecimal principalOutstanding = BigDecimal\n                .valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalOutstanding\").toString()));\n        assertEquals(expectedPrincipalOutstanding, principalOutstanding, \"Checking Principal Due is 2\");\n\n        final BigDecimal principalLoanBalanceOutstanding = BigDecimal\n                .valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalLoanBalanceOutstanding\").toString()));\n        assertEquals(expectedPrincipalLoanBalanceOutstanding, principalLoanBalanceOutstanding,\n                \"Checking Principal Loan Balance Outstanding is zero\");\n\n    }"}
{"prompt": "Create a test that tests check That All Multi Disbursals Appear On Loan Schedule And Out Standing Balance Is Zero But Loan Got Reopened From Over Paid Test", "completion": "    @Test\n    public void checkThatAllMultiDisbursalsAppearOnLoanScheduleAndOutStandingBalanceIsZeroButLoanGotReopenedFromOverPaidTest() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        /***\n         * Create loan product with allowing multiple disbursals\n         */\n        boolean allowMultipleDisbursals = true;\n        final Integer loanProductID = createLoanProduct(allowMultipleDisbursals);\n        Assertions.assertNotNull(loanProductID);\n\n        /***\n         * Apply for loan application and verify loan status\n         */\n        final String savingsId = null;\n        final String principal = \"12,000.00\";\n\n        LOG.info(\"-----------------------------------2 Tranches--------------------------------------\");\n        List<HashMap> tranches = new ArrayList<>();\n        tranches.add(createTrancheDetail(\"01 January 2021\", \"1\"));\n        tranches.add(createTrancheDetail(\"02 January 2021\", \"2\"));\n        String submitDate = \"01 January 2021\";\n\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, savingsId, principal, tranches, submitDate);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 January 2021\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LOG.info(\n                \"-------------------------------DISBURSE 1, repay fully, disburse again LOANS -------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithTransactionAmount(\"12 January 2021\", loanID, \"1\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        HashMap repaymentDetails = this.loanTransactionHelper.makeRepayment(\"13 January 2021\", 2.0f, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanID, \"status\");\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithTransactionAmount(\"14 January 2021\", loanID, \"2\");\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        final int loanScheduleLineCount = loanSchedule.size();\n        final int expectedLoanScheduleLineCount = 3;\n        final int expectedDisbursals = 2;\n        final BigDecimal expectedTotalPrincipalDisbursed = BigDecimal.valueOf(3.0);\n        final BigDecimal expectedPrincipalDue = BigDecimal.valueOf(3.0);\n        final BigDecimal expectedPrincipalPaid = BigDecimal.valueOf(2.0);\n        final BigDecimal expectedPrincipalOutstanding = BigDecimal.valueOf(1.0);\n        final BigDecimal expectedPrincipalLoanBalanceOutstanding = BigDecimal.valueOf(0.0);\n\n        assertEquals(expectedLoanScheduleLineCount, loanScheduleLineCount, \"Checking nine lines in schedule\");\n\n        int disbursalCount = 0;\n        BigDecimal totalPrincipalDisbursed = BigDecimal.ZERO;\n        // First 8 lines should be disbursals\n        for (int i = 0; i < loanScheduleLineCount - 1; i++) {\n            final Integer period = (Integer) loanSchedule.get(i).get(\"period\");\n            final BigDecimal principalDisbursed = BigDecimal\n                    .valueOf(Double.parseDouble(loanSchedule.get(i).get(\"principalDisbursed\").toString()));\n\n            if (period == null) {\n                disbursalCount += 1;\n                totalPrincipalDisbursed = totalPrincipalDisbursed.add(principalDisbursed);\n            }\n            // LOG.info(loanSchedule.get(i).toString());\n        }\n        assertEquals(expectedDisbursals, disbursalCount, \"Checking for 2 disbursals\");\n        assertEquals(expectedTotalPrincipalDisbursed, totalPrincipalDisbursed, \"Checking Principal Disburse is 3\");\n\n        final BigDecimal principalDue = BigDecimal.valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalDue\").toString()));\n        assertEquals(expectedPrincipalDue, principalDue, \"Checking Principal Due is 3\");\n        final BigDecimal principalPaid = BigDecimal.valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalPaid\").toString()));\n        assertEquals(expectedPrincipalPaid, principalPaid, \"Checking Principal Paid is 1\");\n        final BigDecimal principalOutstanding = BigDecimal\n                .valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalOutstanding\").toString()));\n        assertEquals(expectedPrincipalOutstanding, principalOutstanding, \"Checking Principal Due is 2\");\n\n        final BigDecimal principalLoanBalanceOutstanding = BigDecimal\n                .valueOf(Double.parseDouble(loanSchedule.get(2).get(\"principalLoanBalanceOutstanding\").toString()));\n        assertEquals(expectedPrincipalLoanBalanceOutstanding, principalLoanBalanceOutstanding,\n                \"Checking Principal Loan Balance Outstanding is zero\");\n\n    }"}
{"prompt": "Create a test that tests check That Non Tranche Multi Disbursals Create ASchedule On First Disbursal Test", "completion": "    @Test\n    public void checkThatNonTrancheMultiDisbursalsCreateAScheduleOnFirstDisbursalTest() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        /***\n         * Create loan product allowing non-tranche multiple disbursals with interest recalculation\n         */\n        boolean isInterestRecalculationEnabled = true;\n        final Integer loanProductID = createLoanProduct(isInterestRecalculationEnabled);\n        Assertions.assertNotNull(loanProductID);\n\n        /***\n         * Apply for loan application and verify loan status\n         */\n        final String savingsId = null;\n        String submitDate = \"01 January 2021\";\n        Integer repaymentsNo = 3;\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, savingsId, APPLIED_FOR_PRINCIPAL, submitDate,\n                repaymentsNo.toString());\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        final Float approved = 9000.00f;\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(submitDate, null, approved.toString(), loanID, null);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n\n        LOG.info(\"-------------------------------DISBURSE non-tranch multi-disbursal loan       ----------\");\n        final String netDisbursedAmt = null;\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithTransactionAmount(submitDate, loanID, approved.toString());\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        Assertions.assertNotNull(getLoansLoanIdResponse);\n\n        this.loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        Integer loanScheduleLineCount = loanSchedule.size() - 1;\n        Assertions.assertEquals(repaymentsNo, loanScheduleLineCount);\n\n        HashMap loanSummary = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, loanID);\n        Assertions.assertEquals(approved, loanSummary.get(\"principalDisbursed\"));\n        Assertions.assertEquals(approved, loanSummary.get(\"principalOutstanding\"));\n\n        LOG.info(\"------------------------------- 2nd DISBURSE non-tranch multi-disbursal loan       ----------\");\n        final Float anotherDisbursalAmount = 900.00f;\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(submitDate, loanID,\n                anotherDisbursalAmount.toString(), netDisbursedAmt);\n\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanScheduleLineCount = loanSchedule.size() - 2;\n        Assertions.assertEquals(repaymentsNo, loanScheduleLineCount);\n\n        loanSummary = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, loanID);\n        Float disbursedSum = approved + anotherDisbursalAmount;\n        Assertions.assertEquals(disbursedSum, loanSummary.get(\"principalDisbursed\"));\n        Assertions.assertEquals(disbursedSum, loanSummary.get(\"principalOutstanding\"));\n\n        LOG.info(\"------------------------------- 3rd DISBURSE non-tranch multi-disbursal loan       ----------\");\n        final Float thirdDisbursalAmount = 500.00f;\n        String thirdDisbursalDate = \"03 February 2021\";\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(thirdDisbursalDate, loanID,\n                thirdDisbursalAmount.toString(), netDisbursedAmt);\n\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanScheduleLineCount = loanSchedule.size() - 3;\n        Assertions.assertEquals(repaymentsNo, loanScheduleLineCount);\n\n        loanSummary = this.loanTransactionHelper.getLoanSummary(this.requestSpec, this.responseSpec, loanID);\n        disbursedSum = disbursedSum + thirdDisbursalAmount;\n        Assertions.assertEquals(disbursedSum, loanSummary.get(\"principalDisbursed\"));\n        Assertions.assertEquals(disbursedSum, loanSummary.get(\"principalOutstanding\"));\n\n    }"}
{"prompt": "Create a test that tests check That Non Tranche Multi Disbursals Create ASchedule On Submit And Approval Test", "completion": "    @Test\n    public void checkThatNonTrancheMultiDisbursalsCreateAScheduleOnSubmitAndApprovalTest() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        /***\n         * Create loan product allowing non-tranche multiple disbursals with interest recalculation\n         */\n        boolean isInterestRecalculationEnabled = true;\n        final Integer loanProductID = createLoanProduct(isInterestRecalculationEnabled);\n        Assertions.assertNotNull(loanProductID);\n\n        /***\n         * Apply for loan application and verify loan status\n         */\n        final String savingsId = null;\n        String submitDate = \"01 January 2022\";\n        Integer repaymentsNo = 3;\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, savingsId, APPLIED_FOR_PRINCIPAL, submitDate,\n                repaymentsNo.toString());\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        Integer loanScheduleLineCount = loanSchedule.size() - 1; // exclude disbursement line\n        Assertions.assertEquals(repaymentsNo, loanScheduleLineCount);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        final Float approved = 9000.00f;\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(submitDate, null, approved.toString(), loanID, null);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        loanScheduleLineCount = loanSchedule.size() - 1;\n        Assertions.assertEquals(repaymentsNo, loanScheduleLineCount);\n\n    }"}
{"prompt": "Create a test that tests test Savings Account", "completion": "    @Test\n    public void testSavingsAccount() {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(groupID, savingsProductID, savingsId, ACCOUNT_TYPE_GROUP);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Assertions.assertFalse(summaryBefore.equals(summary));\n\n        final Object savingsInterest = this.savingsAccountHelper.getSavingsInterest(savingsId);\n\n    }"}
{"prompt": "Create a test that tests test Savings Last Transaction And Running Balance Update", "completion": "    @Test\n    public void testSavingsLastTransactionAndRunningBalanceUpdate() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n\n        HashMap summaryAfterPosting = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Assertions.assertNotNull(summaryAfterPosting.get(\"interestPostedTillDate\"));\n    }"}
{"prompt": "Create a test that tests test Savings Backed Dated Transactions Not Allowed", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsBackedDatedTransactionsNotAllowed() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n\n        HashMap summaryAfterPosting = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Assertions.assertNotNull(summaryAfterPosting.get(\"interestPostedTillDate\"));\n\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"38\", false);\n\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        SimpleDateFormat sdf = new SimpleDateFormat(CommonConstants.DATE_FORMAT, Locale.US);\n        Calendar cal = Calendar.getInstance();\n        List dates = (List) summaryAfterPosting.get(\"interestPostedTillDate\");\n        cal.set(Calendar.YEAR, (Integer) dates.get(0));\n        cal.set(Calendar.MONTH, (Integer) dates.get(1) - 1);\n        cal.set(Calendar.DAY_OF_MONTH, (Integer) dates.get(2) - 1);\n        final String depositDate = sdf.format(cal.getTime());\n        LOG.info(\"-------------------- BackDated Transaction -----------------------------\");\n        List<HashMap> error = (List<HashMap>) validationErrorHelper.depositToSavingsAccount(savingsId, \"3000\", depositDate,\n                CommonConstants.RESPONSE_ERROR);\n\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"38\", true);\n\n        // LOG.info(savingsAccountErrorData.get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE).toString());\n        assertEquals(\"error.msg.savings.transaction.is.not.allowed\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    }"}
{"prompt": "Create a test that tests test Savings Account With Min Balance For Interest Calculation", "completion": "    @Test\n    public void testSavingsAccountWithMinBalanceForInterestCalculation() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = \"5000\";\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        // These two fields are getting updated after an interest posting\n        summary.remove(\"interestPostedTillDate\");\n\n        assertEquals(summaryBefore, summary);\n\n        final Object savingsInterest = this.savingsAccountHelper.getSavingsInterest(savingsId);\n        Assertions.assertNull(savingsInterest);\n\n    }"}
{"prompt": "Create a test that tests test Savings Account CLOSE APPLICATION", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccount_CLOSE_APPLICATION() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"1000.0\";\n        final String enforceMinRequiredBalance = \"true\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        final String CLOSEDON_DATE = dateFormat.format(todaysDate.getTime());\n        String withdrawBalance = \"false\";\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper\n                .closeSavingsAccountAndGetBackRequiredField(savingsId, withdrawBalance, CommonConstants.RESPONSE_ERROR, CLOSEDON_DATE);\n        assertEquals(\"validation.msg.savingsaccount.close.results.in.balance.not.zero\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        withdrawBalance = \"true\";\n        savingsStatusHashMap = this.savingsAccountHelper.closeSavingsAccount(savingsId, withdrawBalance);\n        SavingsStatusChecker.verifySavingsAccountIsClosed(savingsStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Savings Account WITH ENFORCE MIN BALANCE", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccount_WITH_ENFORCE_MIN_BALANCE() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"1500.0\";\n        final String openningBalance = \"1600\";\n        final String enforceMinRequiredBalance = \"true\";\n        final boolean allowOverdraft = false;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, openningBalance,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        final Integer savingsActivationChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsActivationFeeJSON());\n        Assertions.assertNotNull(savingsActivationChargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, savingsActivationChargeId, true);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(openningBalance);\n        Float chargeAmt = 100f;\n        balance -= chargeAmt;\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate.getTime());\n        final String withdrawAmt = \"800\";\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper.withdrawalFromSavingsAccount(savingsId,\n                withdrawAmt, TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n        assertEquals(balance, depositTransaction.get(\"runningBalance\"), \"Verifying Balance after Deposit\");\n\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, withdrawAmt,\n                TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(withdrawAmt);\n        assertEquals(Float.parseFloat(withdrawAmt), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n        assertEquals(balance, withdrawTransaction.get(\"runningBalance\"), \"Verifying Balance after Withdrawal\");\n    }"}
{"prompt": "Create a test that tests test Savings Account DELETE APPLICATION", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccount_DELETE_APPLICATION() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        List<HashMap> error1 = (List<HashMap>) savingsAccountHelperValidationError.deleteSavingsApplication(savingsId,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"validation.msg.savingsaccount.delete.not.in.submittedandpendingapproval.state\",\n                error1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        savingsStatusHashMap = this.savingsAccountHelper.undoApproval(savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        this.savingsAccountHelper.deleteSavingsApplication(savingsId, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        List<HashMap> error = savingsAccountHelperValidationError.getSavingsCollectionAttribute(savingsId, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.saving.account.id.invalid\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    }"}
{"prompt": "Create a test that tests test Savings Account REJECT APPLICATION", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccount_REJECT_APPLICATION() {\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        List<HashMap> error1 = savingsAccountHelperValidationError.rejectApplicationWithErrorCode(savingsId,\n                SavingsAccountHelper.CREATED_DATE_PLUS_ONE);\n        assertEquals(\"validation.msg.savingsaccount.reject.not.in.submittedandpendingapproval.state\",\n                error1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        savingsStatusHashMap = this.savingsAccountHelper.undoApproval(savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        error1 = savingsAccountHelperValidationError.rejectApplicationWithErrorCode(savingsId, SavingsAccountHelper.getFutureDate());\n        assertEquals(\"validation.msg.savingsaccount.reject.cannot.be.a.future.date\",\n                error1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error1 = savingsAccountHelperValidationError.rejectApplicationWithErrorCode(savingsId, SavingsAccountHelper.CREATED_DATE_MINUS_ONE);\n        assertEquals(\"validation.msg.savingsaccount.reject.cannot.be.before.submittal.date\",\n                error1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        savingsStatusHashMap = this.savingsAccountHelper.rejectApplication(savingsId);\n        SavingsStatusChecker.verifySavingsIsRejected(savingsStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Savings Account WITHDRAW APPLICATION", "completion": "    @Test\n    public void testSavingsAccount_WITHDRAW_APPLICATION() {\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.withdrawApplication(savingsId);\n        SavingsStatusChecker.verifySavingsIsWithdrawn(savingsStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Savings Account Transactions", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountTransactions() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        List<HashMap> error = (List) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"100\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.account.is.not.active\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error = (List) savingsAccountHelperValidationError.depositToSavingsAccount(savingsId, \"100\", SavingsAccountHelper.TRANSACTION_DATE,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.account.is.not.active\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.valueOf(MINIMUM_OPENING_BALANCE);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.valueOf(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n        assertEquals(balance, depositTransaction.get(\"runningBalance\"), \"Verifying Balance after Deposit\");\n\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, WITHDRAW_AMOUNT,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(WITHDRAW_AMOUNT);\n        assertEquals(Float.valueOf(WITHDRAW_AMOUNT), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n        assertEquals(balance, withdrawTransaction.get(\"runningBalance\"), \"Verifying Balance after Withdrawal\");\n\n        Integer newWithdrawTransactionId = this.savingsAccountHelper.updateSavingsAccountTransaction(savingsId, withdrawTransactionId,\n                WITHDRAW_AMOUNT_ADJUSTED);\n        HashMap newWithdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, newWithdrawTransactionId);\n        balance = balance + Float.parseFloat(WITHDRAW_AMOUNT) - Float.parseFloat(WITHDRAW_AMOUNT_ADJUSTED);\n        assertEquals(Float.valueOf(WITHDRAW_AMOUNT_ADJUSTED), newWithdrawTransaction.get(\"amount\"), \"Verifying adjusted Amount\");\n        assertEquals(balance, newWithdrawTransaction.get(\"runningBalance\"), \"Verifying Balance after adjust\");\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Adjusted Balance\");\n        withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        Assertions.assertTrue((Boolean) withdrawTransaction.get(\"reversed\"));\n\n        this.savingsAccountHelper.undoSavingsAccountTransaction(savingsId, newWithdrawTransactionId);\n        newWithdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        Assertions.assertTrue((Boolean) newWithdrawTransaction.get(\"reversed\"));\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        balance += Float.parseFloat(WITHDRAW_AMOUNT_ADJUSTED);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance After Undo Transaction\");\n\n        error = (List) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"5000\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error = (List) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"5000\",\n                SavingsAccountHelper.getFutureDate(), CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.in.the.future\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error = (List) savingsAccountHelperValidationError.depositToSavingsAccount(savingsId, \"5000\", SavingsAccountHelper.getFutureDate(),\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.in.the.future\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error = (List) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"5000\",\n                SavingsAccountHelper.CREATED_DATE_MINUS_ONE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.before.activation.date\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error = (List) savingsAccountHelperValidationError.depositToSavingsAccount(savingsId, \"5000\",\n                SavingsAccountHelper.CREATED_DATE_MINUS_ONE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.before.activation.date\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    }"}
{"prompt": "Create a test that tests test Savings Account Charges", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountCharges() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        final Integer withdrawalChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsWithdrawalFeeJSON());\n        Assertions.assertNotNull(withdrawalChargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, withdrawalChargeId, false);\n        ArrayList<HashMap> chargesPendingState = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertEquals(1, chargesPendingState.size());\n\n        Integer savingsChargeId = (Integer) chargesPendingState.get(0).get(\"id\");\n        HashMap chargeChanges = this.savingsAccountHelper.updateCharges(savingsChargeId, savingsId);\n        Assertions.assertTrue(chargeChanges.containsKey(\"amount\"));\n\n        Integer deletedChargeId = this.savingsAccountHelper.deleteCharge(savingsChargeId, savingsId);\n        assertEquals(savingsChargeId, deletedChargeId);\n\n        chargesPendingState = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertTrue(chargesPendingState == null || chargesPendingState.size() == 0);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final Integer chargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec, ChargesHelper.getSavingsAnnualFeeJSON());\n        Assertions.assertNotNull(chargeId);\n\n        ArrayList<HashMap> charges = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertTrue(charges == null || charges.size() == 0);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, chargeId, true);\n        charges = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertEquals(1, charges.size());\n\n        HashMap savingsChargeForPay = charges.get(0);\n        SimpleDateFormat sdf = new SimpleDateFormat(CommonConstants.DATE_FORMAT, Locale.US);\n        Calendar cal = Calendar.getInstance();\n        List dates = (List) savingsChargeForPay.get(\"dueDate\");\n        cal.set(Calendar.YEAR, (Integer) dates.get(0));\n        cal.set(Calendar.MONTH, (Integer) dates.get(1) - 1);\n        cal.set(Calendar.DAY_OF_MONTH, (Integer) dates.get(2));\n\n        this.savingsAccountHelper.payCharge((Integer) savingsChargeForPay.get(\"id\"), savingsId,\n                ((Float) savingsChargeForPay.get(\"amount\")).toString(), sdf.format(cal.getTime()));\n        HashMap paidCharge = this.savingsAccountHelper.getSavingsCharge(savingsId, (Integer) savingsChargeForPay.get(\"id\"));\n        assertEquals(savingsChargeForPay.get(\"amount\"), paidCharge.get(\"amountPaid\"));\n\n        final Integer monthlyFeechargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsMonthlyFeeJSON());\n        Assertions.assertNotNull(monthlyFeechargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, monthlyFeechargeId, true);\n        charges = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertEquals(2, charges.size());\n\n        HashMap savingsChargeForWaive = charges.get(1);\n        this.savingsAccountHelper.waiveCharge((Integer) savingsChargeForWaive.get(\"id\"), savingsId);\n        HashMap waiveCharge = this.savingsAccountHelper.getSavingsCharge(savingsId, (Integer) savingsChargeForWaive.get(\"id\"));\n        assertEquals(savingsChargeForWaive.get(\"amount\"), waiveCharge.get(\"amountWaived\"));\n\n        this.savingsAccountHelper.waiveCharge((Integer) savingsChargeForWaive.get(\"id\"), savingsId);\n        waiveCharge = this.savingsAccountHelper.getSavingsCharge(savingsId, (Integer) savingsChargeForWaive.get(\"id\"));\n        BigDecimal totalWaiveAmount = BigDecimal.valueOf(Double.valueOf((Float) savingsChargeForWaive.get(\"amount\")));\n        totalWaiveAmount = totalWaiveAmount.add(totalWaiveAmount);\n        assertEquals(totalWaiveAmount.floatValue(), waiveCharge.get(\"amountWaived\"));\n\n        final Integer weeklyFeeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsWeeklyFeeJSON());\n        Assertions.assertNotNull(weeklyFeeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, weeklyFeeId, true);\n        charges = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertEquals(3, charges.size());\n\n        savingsChargeForPay = charges.get(2);\n        cal = Calendar.getInstance();\n        dates = (List) savingsChargeForPay.get(\"dueDate\");\n        cal.set(Calendar.YEAR, (Integer) dates.get(0));\n        cal.set(Calendar.MONTH, (Integer) dates.get(1) - 1);\n        cal.set(Calendar.DAY_OF_MONTH, (Integer) dates.get(2));\n\n        // Depositing huge amount as scheduler job deducts the fee amount\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"100000\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(depositTransactionId);\n\n        this.savingsAccountHelper.payCharge((Integer) savingsChargeForPay.get(\"id\"), savingsId,\n                ((Float) savingsChargeForPay.get(\"amount\")).toString(), sdf.format(cal.getTime()));\n        paidCharge = this.savingsAccountHelper.getSavingsCharge(savingsId, (Integer) savingsChargeForPay.get(\"id\"));\n        assertEquals(savingsChargeForPay.get(\"amount\"), paidCharge.get(\"amountPaid\"));\n        List nextDueDates = (List) paidCharge.get(\"dueDate\");\n        LocalDate nextDueDate = LocalDate.of((Integer) nextDueDates.get(0), (Integer) nextDueDates.get(1), (Integer) nextDueDates.get(2));\n        LocalDate expectedNextDueDate = LocalDate.of((Integer) dates.get(0), (Integer) dates.get(1), (Integer) dates.get(2))\n                .plusWeeks((Integer) paidCharge.get(\"feeInterval\"));\n        assertEquals(expectedNextDueDate, nextDueDate);\n\n        this.savingsAccountHelper.closeSavingsAccountAndGetBackRequiredField(savingsId, \"true\", null,\n                Utils.getLocalDateOfTenant().format(Utils.dateFormatter));\n\n    }"}
{"prompt": "Create a test that tests test Savings Account With Overdraft", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountWithOverdraft() {\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        /***\n         * Create a client to apply for savings account (overdraft account).\n         */\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n\n        /***\n         * Create savings product with zero opening balance and overdraft enabled\n         */\n        final String zeroOpeningBalance = \"0.0\";\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = true;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, zeroOpeningBalance,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        /***\n         * Apply for Savings account\n         */\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        /***\n         * Approve the savings account\n         */\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n        todaysDate = todaysDate.withDayOfMonth(1);\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n        final Integer lastDayOfMonth = todaysDate.lengthOfMonth();\n        todaysDate = todaysDate.withDayOfMonth(lastDayOfMonth);\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate);\n\n        /***\n         * Activate the application and verify account status\n         *\n         * @param activationDate\n         *            this value is every time first day of previous month\n         */\n        savingsStatusHashMap = activateSavingsAccount(savingsId, ACTIVATION_DATE);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        /***\n         * Verify the account summary\n         */\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        Float balance = Float.parseFloat(zeroOpeningBalance);\n\n        /***\n         * Perform withdraw transaction, verify account balance(account balance will go to negative as no deposits are\n         * there prior to this transaction)\n         */\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, WITHDRAW_AMOUNT,\n                ACTIVATION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(WITHDRAW_AMOUNT);\n        assertEquals(Float.parseFloat(WITHDRAW_AMOUNT), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n        assertEquals(balance, withdrawTransaction.get(\"runningBalance\"), \"Verifying Balance after Withdrawal\");\n\n        /***\n         * Perform Deposit transaction on last day of month and verify account balance.\n         *\n         * @param transactionDate\n         *            this value is every time last day of previous month\n         */\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n        assertEquals(balance, depositTransaction.get(\"runningBalance\"), \"Verifying Balance after Deposit\");\n\n        /***\n         * Perform Post interest transaction and verify the posted amount\n         */\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        HashMap accountDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountDetails.get(\"summary\");\n        Float actualInterestPosted = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        /***\n         * Calculate expected interest to be posted, interest should be posted for one day only because deposit\n         * transaction happened on last day of month before this account balance is negative.\n         */\n        final Float nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        final HashMap interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        final Integer daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        double interestRateInFraction = nominalAnnualInterest / 100;\n        double perDay = (double) 1 / daysInYear;\n        double interestPerDay = interestRateInFraction * perDay;\n        Float interestPosted = (float) (interestPerDay * balance * 1);\n\n        /***\n         * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n         */\n        DecimalFormat decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalFormat.applyPattern(\"#.###\");\n        interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n        actualInterestPosted = Float.parseFloat(decimalFormat.format(actualInterestPosted));\n        assertEquals(interestPosted, actualInterestPosted, \"Verifying interest posted\");\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        final String CLOSEDON_DATE = dateFormat.format(todaysDate);\n        String withdrawBalance = \"false\";\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper\n                .closeSavingsAccountAndGetBackRequiredField(savingsId, withdrawBalance, CommonConstants.RESPONSE_ERROR, CLOSEDON_DATE);\n        assertEquals(\"validation.msg.savingsaccount.close.results.in.balance.not.zero\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    }"}
{"prompt": "Create a test that tests test Savings Account Post Interest On Last Day With Overdraft", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountPostInterestOnLastDayWithOverdraft() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        /***\n         * Create a client to apply for savings account (overdraft account).\n         */\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n\n        /***\n         * Create savings product with zero opening balance and overdraft enabled\n         */\n        final String zeroOpeningBalance = \"0.0\";\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = true;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, zeroOpeningBalance,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        /***\n         * Apply for Savings account\n         */\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        /***\n         * Approve the savings account\n         */\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n\n        /***\n         * Activate the application and verify account status\n         *\n         * @param activationDate\n         *            this value is every time first day of previous month\n         */\n        savingsStatusHashMap = activateSavingsAccount(savingsId, ACTIVATION_DATE);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        /***\n         * Verify the account summary\n         */\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        final Integer lastDayOfMonth = todaysDate.lengthOfMonth();\n        todaysDate = todaysDate.withDayOfMonth(lastDayOfMonth);\n        final String WITHDRAWAL_DATE = dateFormat.format(todaysDate);\n        Float balance = Float.parseFloat(zeroOpeningBalance);\n\n        // DateFormat transactionDateFormat = new SimpleDateFormat(\"dd MMMM\n        // yyyy\",Locale.US);\n        LocalDate transactionDate = Utils.getLocalDateOfTenant();\n        transactionDate = transactionDate.withDayOfMonth(2);\n        String transactionDateValue = dateFormat.format(transactionDate);\n\n        /***\n         * Perform Deposit transaction on last day of month and verify account balance.\n         *\n         * @param transactionDate\n         *            this value is every time last day of previous month\n         */\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                WITHDRAWAL_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n        assertEquals(balance, depositTransaction.get(\"runningBalance\"), \"Verifying Balance after Deposit\");\n\n        /***\n         * Calculate expected interest to be posted, interest should be posted for one day only because deposit\n         * transaction happened on last day of month before this account balance is negative.\n         */\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        HashMap accountDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountDetails.get(\"summary\");\n        Float accountDetailsPostInterestPosted = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        Float nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        HashMap interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        double interestRateInFraction = nominalAnnualInterest / 100;\n        double perDay = (double) 1 / daysInYear;\n        double interestPerDay = interestRateInFraction * perDay;\n        Float interestPosted = (float) (interestPerDay * balance * 1);\n\n        /***\n         * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n         */\n        DecimalFormat decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalFormat.applyPattern(\"#.###\");\n        interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n        accountDetailsPostInterestPosted = Float.parseFloat(decimalFormat.format(accountDetailsPostInterestPosted));\n        assertEquals(interestPosted, accountDetailsPostInterestPosted, \"Verifying interest posted\");\n\n        this.savingsAccountHelper.postInterestAsOnSavings(savingsId, transactionDateValue);\n        HashMap accountTransactionDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountDetails.get(\"summary\");\n        Float accountDetailsPostInterest = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        interestRateInFraction = nominalAnnualInterest / 100;\n        perDay = (double) 1 / daysInYear;\n        interestPerDay = interestRateInFraction * perDay;\n        interestPosted = (float) (interestPerDay * balance * 1);\n\n        /***\n         * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n         */\n        decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalFormat.applyPattern(\"#.###\");\n        interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n        accountDetailsPostInterestPosted = Float.parseFloat(decimalFormat.format(accountDetailsPostInterestPosted));\n        assertEquals(interestPosted, accountDetailsPostInterestPosted, \"Verifying interest posted\");\n        LOG.info(\"-----Post Interest As on Successfully Worked----------\");\n\n        transactionDate = transactionDate.withDayOfMonth(3);\n        transactionDateValue = dateFormat.format(transactionDate);\n\n        this.savingsAccountHelper.postInterestAsOnSavings(savingsId, transactionDateValue);\n        accountTransactionDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountDetails.get(\"summary\");\n        accountDetailsPostInterest = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        interestRateInFraction = nominalAnnualInterest / 100;\n        perDay = (double) 1 / daysInYear;\n        interestPerDay = interestRateInFraction * perDay;\n        interestPosted = (float) (interestPerDay * balance * 1);\n\n        /***\n         * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n         */\n        decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalFormat.applyPattern(\"#.###\");\n        interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n        accountDetailsPostInterestPosted = Float.parseFloat(decimalFormat.format(accountDetailsPostInterestPosted));\n        assertEquals(interestPosted, accountDetailsPostInterestPosted, \"Verifying interest posted\");\n        LOG.info(\"-----Post Interest As on Successfully Worked-------\");\n\n        transactionDate = transactionDate.withDayOfMonth(22);\n        transactionDateValue = dateFormat.format(transactionDate);\n        if (Calendar.DAY_OF_MONTH >= 22) {\n            this.savingsAccountHelper.postInterestAsOnSavings(savingsId, transactionDateValue);\n            accountTransactionDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n            summary = (HashMap) accountTransactionDetails.get(\"summary\");\n            accountDetailsPostInterest = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n            nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n            interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n            daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n            interestRateInFraction = nominalAnnualInterest / 100;\n            perDay = (double) 1 / daysInYear;\n            interestPerDay = interestRateInFraction * perDay;\n            interestPosted = (float) (interestPerDay * balance * 19);\n\n            /***\n             * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n             */\n            decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n            decimalFormat.applyPattern(\"#.###\");\n            interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n            accountDetailsPostInterestPosted = Float.parseFloat(decimalFormat.format(accountDetailsPostInterestPosted));\n            assertEquals(interestPosted, accountDetailsPostInterestPosted, \"Verifying interest posted\");\n            LOG.info(\"-----Post Interest As on Successfully Worked----------\");\n        }\n\n        LocalDate postedLastDate = Utils.getLocalDateOfTenant();\n        int numberOfDateOfMonth = postedLastDate.lengthOfMonth();\n        transactionDateValue = dateFormat.format(transactionDate);\n\n        if (Calendar.DAY_OF_MONTH == numberOfDateOfMonth) {\n\n            this.savingsAccountHelper.postInterestAsOnSavings(savingsId, transactionDateValue);\n            accountTransactionDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n            summary = (HashMap) accountTransactionDetails.get(\"summary\");\n            accountDetailsPostInterest = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n            nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n            interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n            daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n            interestRateInFraction = nominalAnnualInterest / 100;\n            perDay = (double) 1 / daysInYear;\n            interestPerDay = interestRateInFraction * perDay;\n            interestPosted = (float) (interestPerDay * balance * 8);\n\n            /***\n             * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n             */\n            decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n            decimalFormat.applyPattern(\"#.###\");\n            interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n            accountDetailsPostInterestPosted = Float.parseFloat(decimalFormat.format(accountDetailsPostInterestPosted));\n            assertEquals(interestPosted, accountDetailsPostInterestPosted, \"Verifying interest posted\");\n            LOG.info(\"-----Post Interest As on Successfully Worked----------\");\n\n        }\n        transactionDate = transactionDate.withDayOfMonth(1);\n        transactionDateValue = dateFormat.format(transactionDate);\n        this.savingsAccountHelper.postInterestAsOnSavings(savingsId, transactionDateValue);\n        accountTransactionDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountTransactionDetails.get(\"summary\");\n        accountDetailsPostInterest = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        interestRateInFraction = nominalAnnualInterest / 100;\n        perDay = (double) 1 / daysInYear;\n        interestPerDay = interestRateInFraction * perDay;\n        interestPosted = (float) (interestPerDay * balance * 1);\n\n        /***\n         * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n         */\n        decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalFormat.applyPattern(\"#.###\");\n        interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n        accountDetailsPostInterestPosted = Float.parseFloat(decimalFormat.format(accountDetailsPostInterestPosted));\n        assertEquals(interestPosted, accountDetailsPostInterestPosted, \"Verifying interest posted\");\n        LOG.info(\"-----Post Interest As on Successfully Worked----------\");\n\n    }"}
{"prompt": "Create a test that tests test Savings Account Post Interest On Last Day Withdrawal With Overdraft", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountPostInterestOnLastDayWithdrawalWithOverdraft() {\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        /***\n         * Create a client to apply for savings account (overdraft account).\n         */\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n\n        /***\n         * Create savings product with zero opening balance and overdraft enabled\n         */\n        final String zeroOpeningBalance = \"0.0\";\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = true;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, zeroOpeningBalance,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        /***\n         * Apply for Savings account\n         */\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        /***\n         * Approve the savings account\n         */\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n\n        /***\n         * Activate the application and verify account status\n         *\n         * @param activationDate\n         *            this value is every time first day of previous month\n         */\n        savingsStatusHashMap = activateSavingsAccount(savingsId, ACTIVATION_DATE);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        /***\n         * Verify the account summary\n         */\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        final Integer lastDayOfMonth = todaysDate.lengthOfMonth();\n        todaysDate = todaysDate.withDayOfMonth(lastDayOfMonth);\n        final String WITHDRAWAL_DATE = dateFormat.format(todaysDate);\n        Float balance = Float.parseFloat(zeroOpeningBalance);\n\n        // DateFormat transactionDateFormat = new SimpleDateFormat(\"dd MMMM\n        // yyyy\", Locale.US);\n        LocalDate transactionDate = Utils.getLocalDateOfTenant();\n        transactionDate = transactionDate.withDayOfMonth(2);\n        String transactionDateValue = dateFormat.format(transactionDate);\n\n        /***\n         * Perform withdraw transaction, verify account balance(account balance will go to negative as no deposits are\n         * there prior to this transaction)\n         */\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, WITHDRAW_AMOUNT,\n                ACTIVATION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(WITHDRAW_AMOUNT);\n        assertEquals(Float.parseFloat(WITHDRAW_AMOUNT), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n        assertEquals(balance, withdrawTransaction.get(\"runningBalance\"), \"Verifying Balance after Withdrawal\");\n\n        /***\n         * Perform Deposit transaction on last day of month and verify account balance.\n         *\n         * @param transactionDate\n         *            this value is every time last day of previous month\n         */\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                WITHDRAWAL_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n        assertEquals(balance, depositTransaction.get(\"runningBalance\"), \"Verifying Balance after Deposit\");\n\n        /***\n         * Calculate expected interest to be posted, interest should be posted for one day only because deposit\n         * transaction happened on last day of month before this account balance is negative.\n         */\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        HashMap accountDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountDetails.get(\"summary\");\n        Float accountDetailsPostInterestPosted = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        Float nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        HashMap interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        double interestRateInFraction = nominalAnnualInterest / 100;\n        double perDay = (double) 1 / daysInYear;\n        double interestPerDay = interestRateInFraction * perDay;\n        Float interestPosted = (float) (interestPerDay * balance * 1);\n\n        /***\n         * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n         */\n        DecimalFormat decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalFormat.applyPattern(\"#.###\");\n        interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n        accountDetailsPostInterestPosted = Float.parseFloat(decimalFormat.format(accountDetailsPostInterestPosted));\n        assertEquals(interestPosted, accountDetailsPostInterestPosted, \"Verifying interest posted\");\n\n        this.savingsAccountHelper.postInterestAsOnSavings(savingsId, transactionDateValue);\n        HashMap accountTransactionDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountDetails.get(\"summary\");\n        Float accountDetailsPostInterest = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        interestRateInFraction = nominalAnnualInterest / 100;\n        perDay = (double) 1 / daysInYear;\n        interestPerDay = interestRateInFraction * perDay;\n        interestPosted = (float) (interestPerDay * balance * 1);\n\n        /***\n         * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n         */\n        decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalFormat.applyPattern(\"#.###\");\n        interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n        accountDetailsPostInterestPosted = Float.parseFloat(decimalFormat.format(accountDetailsPostInterestPosted));\n        assertEquals(interestPosted, accountDetailsPostInterestPosted, \"Verifying interest posted\");\n        LOG.info(\"-----Post Interest As on Successfully Worked----------\");\n\n        transactionDate = transactionDate.withDayOfMonth(3);\n        transactionDateValue = dateFormat.format(transactionDate);\n\n        this.savingsAccountHelper.postInterestAsOnSavings(savingsId, transactionDateValue);\n        accountTransactionDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountDetails.get(\"summary\");\n        accountDetailsPostInterest = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        interestRateInFraction = nominalAnnualInterest / 100;\n        perDay = (double) 1 / daysInYear;\n        interestPerDay = interestRateInFraction * perDay;\n        interestPosted = (float) (interestPerDay * balance * 1);\n\n        /***\n         * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n         */\n        decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalFormat.applyPattern(\"#.###\");\n        interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n        accountDetailsPostInterestPosted = Float.parseFloat(decimalFormat.format(accountDetailsPostInterestPosted));\n        assertEquals(interestPosted, accountDetailsPostInterestPosted, \"Verifying interest posted\");\n        LOG.info(\"-----Post Interest As on Successfully Worked-------\");\n\n        // DateFormat transactionFormat = new SimpleDateFormat(\"dd MMMM yyyy\",\n        // Locale.US);\n\n        transactionDate = transactionDate.withDayOfMonth(22);\n        transactionDateValue = dateFormat.format(transactionDate);\n        if (Calendar.DAY_OF_MONTH >= 22) {\n            this.savingsAccountHelper.postInterestAsOnSavings(savingsId, transactionDateValue);\n            accountTransactionDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n            summary = (HashMap) accountTransactionDetails.get(\"summary\");\n            accountDetailsPostInterest = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n            nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n            interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n            daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n            interestRateInFraction = nominalAnnualInterest / 100;\n            perDay = (double) 1 / daysInYear;\n            interestPerDay = interestRateInFraction * perDay;\n            interestPosted = (float) (interestPerDay * balance * 19);\n\n            /***\n             * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n             */\n            decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n            decimalFormat.applyPattern(\"#.###\");\n            interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n            accountDetailsPostInterestPosted = Float.parseFloat(decimalFormat.format(accountDetailsPostInterestPosted));\n            assertEquals(interestPosted, accountDetailsPostInterestPosted, \"Verifying interest posted\");\n            LOG.info(\"-----Post Interest As on Successfully Worked----------\");\n        }\n        LocalDate postedLastDate = Utils.getLocalDateOfTenant();\n        int numberOfDateOfMonth = postedLastDate.lengthOfMonth();\n        transactionDateValue = dateFormat.format(transactionDate);\n\n        if (Calendar.DAY_OF_MONTH == numberOfDateOfMonth) {\n\n            this.savingsAccountHelper.postInterestAsOnSavings(savingsId, transactionDateValue);\n            accountTransactionDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n            summary = (HashMap) accountTransactionDetails.get(\"summary\");\n            accountDetailsPostInterest = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n            nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n            interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n            daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n            interestRateInFraction = nominalAnnualInterest / 100;\n            perDay = (double) 1 / daysInYear;\n            interestPerDay = interestRateInFraction * perDay;\n            interestPosted = (float) (interestPerDay * balance * 8);\n\n            /***\n             * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n             */\n            decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n            decimalFormat.applyPattern(\"#.###\");\n            interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n            accountDetailsPostInterestPosted = Float.parseFloat(decimalFormat.format(accountDetailsPostInterestPosted));\n            assertEquals(interestPosted, accountDetailsPostInterestPosted, \"Verifying interest posted\");\n            LOG.info(\"-----Post Interest As on Successfully Worked----------\");\n\n        }\n        transactionDate = transactionDate.withDayOfMonth(1);\n        transactionDateValue = dateFormat.format(transactionDate);\n        this.savingsAccountHelper.postInterestAsOnSavings(savingsId, transactionDateValue);\n        accountTransactionDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountTransactionDetails.get(\"summary\");\n        accountDetailsPostInterest = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        interestRateInFraction = nominalAnnualInterest / 100;\n        perDay = (double) 1 / daysInYear;\n        interestPerDay = interestRateInFraction * perDay;\n        interestPosted = (float) (interestPerDay * balance * 1);\n\n        /***\n         * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n         */\n        decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalFormat.applyPattern(\"#.###\");\n        interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n        accountDetailsPostInterestPosted = Float.parseFloat(decimalFormat.format(accountDetailsPostInterestPosted));\n        assertEquals(interestPosted, accountDetailsPostInterestPosted, \"Verifying interest posted\");\n        LOG.info(\"-----Post Interest As on Successfully Worked----------\");\n\n    }"}
{"prompt": "Create a test that tests test Savings Account Post Interest With Overdraft", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountPostInterestWithOverdraft() {\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n\n        /***\n         * Create a client to apply for savings account (overdraft account).\n         */\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n\n        /***\n         * Create savings product with zero opening balance and overdraft enabled\n         */\n        final String zeroOpeningBalance = \"0.0\";\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = true;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, zeroOpeningBalance,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        /***\n         * Apply for Savings account\n         */\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        /***\n         * Approve the savings account\n         */\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n        todaysDate = todaysDate.withDayOfMonth(1);\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n        final Integer lastDayOfMonth = todaysDate.lengthOfMonth();\n        todaysDate = todaysDate.withDayOfMonth(lastDayOfMonth);\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate);\n\n        LocalDate postedDate = Utils.getLocalDateOfTenant();\n        postedDate = postedDate.withDayOfMonth(2);\n\n        final String POSTED_TRANSACTION_DATE = dateFormat.format(postedDate);\n\n        /***\n         * Activate the application and verify account status\n         *\n         * @param activationDate\n         *            this value is every time first day of previous month\n         */\n        savingsStatusHashMap = activateSavingsAccount(savingsId, ACTIVATION_DATE);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        /***\n         * Verify the account summary\n         */\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        Float balance = Float.parseFloat(zeroOpeningBalance);\n\n        /***\n         * Perform withdraw transaction, verify account balance(account balance will go to negative as no deposits are\n         * there prior to this transaction)\n         */\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, WITHDRAW_AMOUNT,\n                ACTIVATION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(WITHDRAW_AMOUNT);\n        assertEquals(Float.parseFloat(WITHDRAW_AMOUNT), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n        assertEquals(balance, withdrawTransaction.get(\"runningBalance\"), \"Verifying Balance after Withdrawal\");\n\n        /***\n         * Perform Deposit transaction on last day of month and verify account balance.\n         *\n         * @param transactionDate\n         *            this value is every time last day of previous month\n         */\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n        assertEquals(balance, depositTransaction.get(\"runningBalance\"), \"Verifying Balance after Deposit\");\n\n        /***\n         * Perform Post interest transaction and verify the posted amount\n         */\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        HashMap accountDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountDetails.get(\"summary\");\n        Float actualInterestPosted = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        /***\n         * Calculate expected interest to be posted, interest should be posted for one day only because deposit\n         * transaction happened on last day of month before this account balance is negative.\n         */\n        this.savingsAccountHelper.postInterestAsOnSavings(savingsId, POSTED_TRANSACTION_DATE);\n        HashMap accountDetailsPostInterest = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountDetails.get(\"summary\");\n        ArrayList interestPostingTransaction = (ArrayList) ((HashMap) ((ArrayList) accountDetails.get(\"transactions\")).get(0)).get(\"date\");\n        Float accountDetailsPostInterestPosted = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        /***\n         * Calculate expected interest to be posted, interest should be posted for one day only because deposit\n         * transaction happened on last day of month before this account balance is negative.\n         */\n        final Float nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        final HashMap interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        final Integer daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        double interestRateInFraction = nominalAnnualInterest / 100;\n        double perDay = (double) 1 / daysInYear;\n        double interestPerDay = interestRateInFraction * perDay;\n        Float interestPosted = (float) (interestPerDay * balance * 1);\n\n        /***\n         * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n         */\n        DecimalFormat decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalFormat.applyPattern(\"#.###\");\n        interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n        // actualInterestPosted =\n        // Float.parseFloat(decimalFormat.format(accountDetailsPostInterestPosted));\n        assertEquals(interestPosted, accountDetailsPostInterestPosted, \"Verifying interest posted\");\n        LOG.info(\"------Post Interest As On After doing a post interest Successfully worked--------\");\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        final String CLOSEDON_DATE = dateFormat.format(todaysDate);\n\n        LocalDate interestPostingDate = LocalDate.of((int) interestPostingTransaction.get(0), (int) interestPostingTransaction.get(1),\n                (int) interestPostingTransaction.get(2));\n        LocalDate todysDate = Utils.getLocalDateOfTenant();\n\n        final String INTEREST_POSTING_DATE = dateFormat.format(interestPostingDate);\n        final String TODYS_POSTING_DATE = dateFormat.format(todysDate);\n        String withdrawBalance = \"true\";\n\n        if (TODYS_POSTING_DATE.equalsIgnoreCase(INTEREST_POSTING_DATE)) {\n            final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, responseSpec);\n            validationErrorHelper.closeSavingsAccountPostInterestAndGetBackRequiredField(savingsId, withdrawBalance,\n                    CommonConstants.RESPONSE_ERROR, CLOSEDON_DATE);\n        } else {\n            final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n            ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper\n                    .closeSavingsAccountPostInterestAndGetBackRequiredField(savingsId, withdrawBalance, CommonConstants.RESPONSE_ERROR,\n                            CLOSEDON_DATE);\n            assertEquals(\"error.msg.postInterest.notDone\", savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n        }\n    }"}
{"prompt": "Create a test that tests test Post Interest As On Savings Account With Overdraft", "completion": "    @Test\n    public void testPostInterestAsOnSavingsAccountWithOverdraft() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        // final ResponseSpecification errorResponse = new\n        // ResponseSpecBuilder().expectStatusCode(400).build();\n        // final SavingsAccountHelper validationErrorHelper = new\n        // SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        /***\n         * Create a client to apply for savings account (overdraft account).\n         */\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n\n        /***\n         * Create savings product with zero opening balance and overdraft enabled\n         */\n        final String zeroOpeningBalance = \"0.0\";\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = true;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, zeroOpeningBalance,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        /***\n         * Apply for Savings account\n         */\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        /***\n         * Approve the savings account\n         */\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n        todaysDate = todaysDate.withDayOfMonth(1);\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n        final Integer lastDayOfMonth = todaysDate.lengthOfMonth();\n        todaysDate = todaysDate.withDayOfMonth(lastDayOfMonth);\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate);\n\n        LocalDate postedDate = Utils.getLocalDateOfTenant();\n        postedDate = postedDate.withDayOfMonth(1);\n\n        final String POSTED_TRANSACTION_DATE = dateFormat.format(postedDate);\n        LocalDate postedLastDate = Utils.getLocalDateOfTenant();\n        int countOfDate = postedDate.lengthOfMonth();\n        LOG.info(\"count Of Date---> {}\", countOfDate);\n        postedLastDate.withDayOfMonth(countOfDate);\n        final String POSTED_LAST_TRANSACTION_DATE = dateFormat.format(postedLastDate);\n\n        /***\n         * Activate the application and verify account status\n         *\n         * @param activationDate\n         *            this value is every time first day of previous month\n         */\n        savingsStatusHashMap = activateSavingsAccount(savingsId, ACTIVATION_DATE);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        /***\n         * Verify the account summary\n         */\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        Float balance = Float.parseFloat(zeroOpeningBalance);\n\n        /***\n         * Perform withdraw transaction, verify account balance(account balance will go to negative as no deposits are\n         * there prior to this transaction)\n         */\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, WITHDRAW_AMOUNT,\n                ACTIVATION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(WITHDRAW_AMOUNT);\n        assertEquals(Float.parseFloat(WITHDRAW_AMOUNT), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n        assertEquals(balance, withdrawTransaction.get(\"runningBalance\"), \"Verifying Balance after Withdrawal\");\n\n        /***\n         * Perform Deposit transaction on last day of month and verify account balance.\n         *\n         * @param transactionDate\n         *            this value is every time last day of previous month\n         */\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n        assertEquals(balance, depositTransaction.get(\"runningBalance\"), \"Verifying Balance after Deposit\");\n\n        /***\n         * Perform Post interest transaction and verify the posted amount\n         */\n        this.savingsAccountHelper.postInterestAsOnSavings(savingsId, POSTED_TRANSACTION_DATE);\n        HashMap accountDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountDetails.get(\"summary\");\n        Float actualInterestPosted = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        /***\n         * Calculate expected interest to be posted, interest should be posted for one day only because deposit\n         * transaction happened on last day of month before this account balance is negative.\n         */\n        final Float nominalAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        final HashMap interestCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        final Integer daysInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        double interestRateInFraction = nominalAnnualInterest / 100;\n        double perDay = (double) 1 / daysInYear;\n        double interestPerDay = interestRateInFraction * perDay;\n        Float interestPosted = (float) (interestPerDay * balance * 1);\n\n        /***\n         * Apply rounding on interestPosted, actualInterestPosted and verify both are same\n         */\n        DecimalFormat decimalFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalFormat.applyPattern(\"#.###\");\n        interestPosted = Float.parseFloat(decimalFormat.format(interestPosted));\n        actualInterestPosted = Float.parseFloat(decimalFormat.format(actualInterestPosted));\n        assertEquals(interestPosted, actualInterestPosted, \"Verifying interest posted\");\n        LOG.info(\"------Post Interest As On Successful Worked--------\");\n\n        this.savingsAccountHelper.postInterestAsOnSavings(savingsId, POSTED_LAST_TRANSACTION_DATE);\n        HashMap accountLastDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        summary = (HashMap) accountLastDetails.get(\"summary\");\n        Float actualLastInterestPosted = Float.parseFloat(summary.get(\"totalInterestPosted\").toString());\n\n        final Float nominalLastAnnualInterest = Float.parseFloat(accountDetails.get(\"nominalAnnualInterestRate\").toString());\n        final HashMap interestLastCalculationDaysInYearType = (HashMap) accountDetails.get(\"interestCalculationDaysInYearType\");\n        final Integer daysLastInYear = Integer.valueOf(interestCalculationDaysInYearType.get(\"id\").toString());\n        double interestLastRateInFraction = nominalAnnualInterest / 100;\n        double perLastDay = (double) 1 / daysInYear;\n        double interestLastPerDay = interestLastRateInFraction * perLastDay;\n        Float interestLastPosted = (float) (interestLastPerDay * balance * 1);\n\n        DecimalFormat decimalLastFormat = new DecimalFormat(\"\", new DecimalFormatSymbols(Locale.US));\n        decimalLastFormat.applyPattern(\"#.###\");\n        interestLastPosted = Float.parseFloat(decimalLastFormat.format(interestLastPosted));\n        actualInterestPosted = Float.parseFloat(decimalFormat.format(actualInterestPosted));\n        assertEquals(interestLastPosted, actualInterestPosted, \"Verifying interest posted\");\n        LOG.info(\"------Post Interest As On Successful Worked--------\");\n\n    }"}
{"prompt": "Create a test that tests test Savings Account WITH WITHHOLD TAX", "completion": "    @Test\n    public void testSavingsAccount_WITH_WITHHOLD_TAX() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final String percentage = \"10\";\n        final Integer taxGroupId = createTaxGroup(percentage);\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft, String.valueOf(taxGroupId),\n                false);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Assertions.assertFalse(summaryBefore.equals(summary));\n        Assertions.assertNotNull(summary.get(\"totalWithholdTax\"));\n        Float expected = (Float) summary.get(\"totalDeposits\") + (Float) summary.get(\"totalInterestPosted\")\n                - (Float) summary.get(\"totalWithholdTax\");\n        Float actual = (Float) summary.get(\"accountBalance\");\n        Assertions.assertEquals(expected, actual, 1);\n\n    }"}
{"prompt": "Create a test that tests test Savings Account WITH WITHHOLD TAX DISABLE AT ACCOUNT LEVEL", "completion": "    @Test\n    public void testSavingsAccount_WITH_WITHHOLD_TAX_DISABLE_AT_ACCOUNT_LEVEL() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final String percentage = \"10\";\n        final Integer taxGroupId = createTaxGroup(percentage);\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft, String.valueOf(taxGroupId),\n                false);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        this.savingsAccountHelper.calculateInterestForSavings(savingsId);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(summaryBefore, summary);\n\n        final HashMap changes = this.savingsAccountHelper.updateSavingsAccountWithHoldTaxStatus(savingsId, false);\n        Assertions.assertTrue(changes.containsKey(\"withHoldTax\"));\n\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Assertions.assertFalse(summaryBefore.equals(summary));\n        Assertions.assertNull(summary.get(\"totalWithholdTax\"));\n        Float expected = (Float) summary.get(\"totalDeposits\") + (Float) summary.get(\"totalInterestPosted\");\n        Float actual = (Float) summary.get(\"accountBalance\");\n        Assertions.assertEquals(expected, actual, 1);\n\n    }"}
{"prompt": "Create a test that tests test Savings Account Dormancy Tracking", "completion": "    @Test\n    public void testSavingsAccount_DormancyTracking() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final String percentage = \"10\";\n        final Integer taxGroupId = createTaxGroup(percentage);\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft, String.valueOf(taxGroupId),\n                true);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsNoActivityFeeJSON());\n        Assertions.assertNotNull(savingsChargeId);\n\n        ArrayList<Integer> savingsList = new ArrayList<>();\n\n        for (int i = 0; i < 5; i++) {\n            final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID,\n                    ACCOUNT_TYPE_INDIVIDUAL);\n            Assertions.assertNotNull(savingsProductID);\n\n            HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                    ACCOUNT_TYPE_INDIVIDUAL);\n            Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n            this.savingsAccountHelper.addChargesForSavings(savingsId, savingsChargeId, false);\n\n            HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n            SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n            savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n            SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n            savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n            SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n            savingsList.add(savingsId);\n        }\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsList.add(savingsId);\n\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant());\n        for (int i = 0; i < 4; i++) {\n            String transactionDateValue = formatter.format(transactionDate);\n            Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsList.get(i), DEPOSIT_AMOUNT,\n                    transactionDateValue, CommonConstants.RESPONSE_RESOURCE_ID);\n            transactionDate = transactionDate.minusDays(30);\n        }\n\n        LOG.info(\"Savings account IDs: {}\", savingsList);\n        SchedulerJobHelper jobHelper = new SchedulerJobHelper(this.requestSpec);\n        jobHelper.executeAndAwaitJob(\"Update Savings Dormant Accounts\");\n\n        // VERIFY WITHIN PROVIDED RANGE DOESN'T INACTIVATE\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(0));\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(0));\n        SavingsStatusChecker.verifySavingsSubStatusNone(savingsStatusHashMap);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsList.get(0));\n        Float balance = 3000f;\n        Float chargeAmt = 0f;\n        balance -= chargeAmt;\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account Balance\");\n\n        // VERIFY INACTIVE\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(1));\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(1));\n        SavingsStatusChecker.verifySavingsSubStatusInactive(savingsStatusHashMap);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsList.get(1));\n        balance = 3000f;\n        chargeAmt = 100f;\n        balance -= chargeAmt;\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account Balance\");\n\n        String transactionDateValue = formatter.format(LocalDate.now(Utils.getZoneIdOfTenant()));\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsList.get(1), DEPOSIT_AMOUNT,\n                transactionDateValue, CommonConstants.RESPONSE_RESOURCE_ID);\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(1));\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(1));\n        SavingsStatusChecker.verifySavingsSubStatusNone(savingsStatusHashMap);\n\n        // VERIFY DORMANT\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(2));\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(2));\n        SavingsStatusChecker.verifySavingsSubStatusDormant(savingsStatusHashMap);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsList.get(2));\n        balance = 3000f;\n        chargeAmt = 100f;\n        balance -= chargeAmt;\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account Balance\");\n\n        transactionDateValue = formatter.format(LocalDate.now(Utils.getZoneIdOfTenant()));\n        depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsList.get(2), DEPOSIT_AMOUNT,\n                transactionDateValue, CommonConstants.RESPONSE_RESOURCE_ID);\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(2));\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(2));\n        SavingsStatusChecker.verifySavingsSubStatusNone(savingsStatusHashMap);\n\n        // VERIFY ESCHEAT DUE TO OLD TRANSACTION\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(3));\n        SavingsStatusChecker.verifySavingsAccountIsClosed(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(3));\n        SavingsStatusChecker.verifySavingsSubStatusEscheat(savingsStatusHashMap);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsList.get(3));\n        assertEquals(2900f, summary.get(\"accountBalance\"), \"Verifying account Balance\");\n\n        // VERIFY ESCHEAT DUE NO TRANSACTION FROM ACTIVATION\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(4));\n        SavingsStatusChecker.verifySavingsAccountIsClosed(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(4));\n        SavingsStatusChecker.verifySavingsSubStatusEscheat(savingsStatusHashMap);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsList.get(4));\n        assertEquals(900f, summary.get(\"accountBalance\"), \"Verifying account Balance\");\n\n        // VERIFY NON ACTIVE ACCOUNTS ARE NOT AFFECTED\n        savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(5));\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n        savingsStatusHashMap = SavingsStatusChecker.getSubStatusOfSavings(this.requestSpec, this.responseSpec, savingsList.get(5));\n        SavingsStatusChecker.verifySavingsSubStatusNone(savingsStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Savings Account Block Status", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountBlockStatus() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(MINIMUM_OPENING_BALANCE);\n\n        savingsStatusHashMap = this.savingsAccountHelper.blockSavings(savingsId);\n        SavingsStatusChecker.verifySavingsSubStatusblock(savingsStatusHashMap);\n\n        List<HashMap> error = (List) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"100\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.saving.account.blocked.transaction.not.allowed\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error = (List) savingsAccountHelperValidationError.depositToSavingsAccount(savingsId, \"100\", SavingsAccountHelper.TRANSACTION_DATE,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.saving.account.blocked.transaction.not.allowed\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        savingsStatusHashMap = this.savingsAccountHelper.unblockSavings(savingsId);\n        SavingsStatusChecker.verifySavingsSubStatusIsNone(savingsStatusHashMap);\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n\n        savingsStatusHashMap = this.savingsAccountHelper.blockDebit(savingsId);\n        SavingsStatusChecker.verifySavingsSubStatusIsDebitBlocked(savingsStatusHashMap);\n        error = (List) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"100\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savings.account.debit.transaction.not.allowed\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n\n        savingsStatusHashMap = this.savingsAccountHelper.unblockDebit(savingsId);\n        SavingsStatusChecker.verifySavingsSubStatusIsNone(savingsStatusHashMap);\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, WITHDRAW_AMOUNT,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(WITHDRAW_AMOUNT);\n        assertEquals(Float.parseFloat(WITHDRAW_AMOUNT), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n\n        savingsStatusHashMap = this.savingsAccountHelper.blockCredit(savingsId);\n        SavingsStatusChecker.verifySavingsSubStatusIsCreditBlocked(savingsStatusHashMap);\n        error = (List) savingsAccountHelperValidationError.depositToSavingsAccount(savingsId, \"100\", SavingsAccountHelper.TRANSACTION_DATE,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savings.account.credit.transaction.not.allowed\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, WITHDRAW_AMOUNT,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(WITHDRAW_AMOUNT);\n        assertEquals(Float.parseFloat(WITHDRAW_AMOUNT), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n\n        savingsStatusHashMap = this.savingsAccountHelper.unblockCredit(savingsId);\n        SavingsStatusChecker.verifySavingsSubStatusIsNone(savingsStatusHashMap);\n        depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, DEPOSIT_AMOUNT,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        depositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        balance += Float.parseFloat(DEPOSIT_AMOUNT);\n        assertEquals(Float.parseFloat(DEPOSIT_AMOUNT), depositTransaction.get(\"amount\"), \"Verifying Deposit Amount\");\n\n        Integer holdTransactionId = (Integer) this.savingsAccountHelper.holdAmountInSavingsAccount(savingsId, String.valueOf(balance - 100),\n                false, SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        error = (List) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"300\",\n                SavingsAccountHelper.TRANSACTION_DATE_PLUS_ONE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer releaseTransactionId = this.savingsAccountHelper.releaseAmount(savingsId, holdTransactionId);\n        Date today = Date.from(Utils.getLocalDateOfTenant().atStartOfDay(Utils.getZoneIdOfTenant()).toInstant());\n        String todayDate = today.toString();\n        SimpleDateFormat dt1 = new SimpleDateFormat(\"dd MMM yyyy\");\n        todayDate = dt1.format(today).toString();\n        withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"300\", todayDate,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        withdrawTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawTransactionId);\n        balance -= Float.parseFloat(\"300\");\n        assertEquals(Float.parseFloat(\"300\"), withdrawTransaction.get(\"amount\"), \"Verifying Withdrawal Amount\");\n\n    }"}
{"prompt": "Create a test that tests test Savings Account Lien Allowed At Product Level With Enforce Balance", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountLienAllowedAtProductLevelWithEnforceBalance() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final boolean enforceMinRequiredBalance = true;\n        final boolean allowOverdraft = false;\n        final boolean lienAllowed = true;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, enforceMinRequiredBalance, allowOverdraft, lienAllowed);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        List<HashMap> error = (List) savingsAccountHelperValidationError.holdAmountInSavingsAccount(savingsId, \"2000\", false,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"validation.msg.savingsaccount.insufficient.balance\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer lienHoldTransactionId = (Integer) this.savingsAccountHelper.holdAmountInSavingsAccount(savingsId, \"2000\", true,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Float balance = Float.parseFloat(\"-1000\");\n\n        assertEquals(balance, summary.get(\"availableBalance\"), \"Verifying available Balance is -1000\");\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"1200\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate.getTime());\n\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper.withdrawalFromSavingsAccount(savingsId,\n                \"200\", TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", TRANSACTION_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Assertions.assertNotNull(withdrawTransactionId);\n    }"}
{"prompt": "Create a test that tests test Savings Account Lien Allowed At Product Level With Over Draft Limit", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountLienAllowedAtProductLevelWithOverDraftLimit() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final boolean enforceMinRequiredBalance = false;\n        final boolean allowOverdraft = true;\n        final boolean lienAllowed = true;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, enforceMinRequiredBalance, allowOverdraft, lienAllowed);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        List<HashMap> error = (List) savingsAccountHelperValidationError.holdAmountInSavingsAccount(savingsId, \"2000\", false,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"validation.msg.savingsaccount.insufficient.balance\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer lienHoldTransactionId = (Integer) this.savingsAccountHelper.holdAmountInSavingsAccount(savingsId, \"2000\", true,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Float balance = Float.parseFloat(\"-1000\");\n\n        assertEquals(balance, summary.get(\"availableBalance\"), \"Verifying available Balance is -1000\");\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"1200\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate.getTime());\n\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper.withdrawalFromSavingsAccount(savingsId,\n                \"300\", TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"200\", TRANSACTION_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Assertions.assertNotNull(withdrawTransactionId);\n    }"}
{"prompt": "Create a test that tests test Savings Account Lien Allowed At Product Level With No Config", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountLienAllowedAtProductLevelWithNoConfig() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final boolean enforceMinRequiredBalance = false;\n        final boolean allowOverdraft = false;\n        final boolean lienAllowed = true;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, enforceMinRequiredBalance, allowOverdraft, lienAllowed);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        List<HashMap> error = (List) savingsAccountHelperValidationError.holdAmountInSavingsAccount(savingsId, \"2000\", false,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"validation.msg.savingsaccount.insufficient.balance\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer lienHoldTransactionId = (Integer) this.savingsAccountHelper.holdAmountInSavingsAccount(savingsId, \"2000\", true,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Float balance = Float.parseFloat(\"-1000\");\n\n        assertEquals(balance, summary.get(\"availableBalance\"), \"Verifying available Balance is -1000\");\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"1100\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate.getTime());\n\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper.withdrawalFromSavingsAccount(savingsId,\n                \"200\", TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);// withdrawable amount = 200;\n\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", TRANSACTION_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Assertions.assertNotNull(withdrawTransactionId);\n\n    }"}
{"prompt": "Create a test that tests test Savings Account Without Lien Allowed", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountWithoutLienAllowed() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final boolean enforceMinRequiredBalance = false;\n        final boolean allowOverdraft = true;\n        final boolean lienAllowed = false;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, enforceMinRequiredBalance, allowOverdraft, lienAllowed);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        List<HashMap> error = (List) savingsAccountHelperValidationError.holdAmountInSavingsAccount(savingsId, \"2000\", true,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"validation.msg.savingsaccount.lien.is.not.allowed.in.product.level\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer lienHoldTransactionId = (Integer) this.savingsAccountHelper.holdAmountInSavingsAccount(savingsId, \"1500\", false,\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);// as per overdraft limit\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Float balance = Float.parseFloat(\"-500\"); // opening balance\n\n        assertEquals(balance, summary.get(\"availableBalance\"), \"Verifying available Balance is -500\");\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"2000\", // available\n                                                                                                                      // to\n                                                                                                                      // use\n                                                                                                                      // 1100\n                                                                                                                      // and\n                                                                                                                      // another\n                                                                                                                      // 1000\n                                                                                                                      // on\n                                                                                                                      // transactional\n                                                                                                                      // hold\n\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        final String TRANSACTION_DATE = dateFormat.format(todaysDate.getTime());\n\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper.withdrawalFromSavingsAccount(savingsId,\n                \"1600\", TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);// can not withdraw: amount on transactional\n                                                                          // hold\n\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        Integer withdrawTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"1500\",\n                TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Assertions.assertNotNull(withdrawTransactionId);\n\n    }"}
{"prompt": "Create a test that tests test Savings Account Lien Allowed At Product Level With Over Draft Limit Greater Than Lien Limit", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsAccountLienAllowedAtProductLevelWithOverDraftLimitGreaterThanLienLimit() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final boolean enforceMinRequiredBalance = false;\n        final boolean allowOverdraft = true;\n        final String overDraftLimit = \"2000.0\";\n        final boolean lienAllowed = true;\n        final String lineAllowedLimit = \"1000.0\";\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, errorResponse, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, enforceMinRequiredBalance, allowOverdraft, overDraftLimit, lienAllowed, lineAllowedLimit);\n        Assertions.assertNull(savingsProductID);\n\n    }"}
{"prompt": "Create a test that tests test Account Balance After Transaction Reversal", "completion": "    @Test\n    public void testAccountBalanceAfterTransactionReversal() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        // SavingsAccountHelper savingsAccountHelperValidationError = new\n        // SavingsAccountHelper(this.requestSpec,new\n        // ResponseSpecBuilder().build());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"500\";\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = true;\n        final String MINIMUM_OPENING_BALANCE = \"0\";\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"500\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        String chargeAmount = \"300\";\n        String chargeCurrency = \"USD\";\n\n        final Integer savingsChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsJSON(chargeAmount, chargeCurrency, ChargeTimeType.SPECIFIED_DUE_DATE));\n\n        Assertions.assertNotNull(savingsChargeId);\n\n        Integer amount = 300;\n\n        final Integer chargeId = this.savingsAccountHelper.addChargesForSavingsWithDueDate(savingsId, savingsChargeId,\n                SavingsAccountHelper.TRANSACTION_DATE, amount);\n\n        Assertions.assertNotNull(chargeId);\n\n        final Integer payChargeId = this.savingsAccountHelper.payCharge(chargeId, savingsId, chargeAmount,\n                SavingsAccountHelper.TRANSACTION_DATE);\n\n        final Integer undoSavingsTransaction = this.savingsAccountHelper.undoSavingsAccountTransaction(savingsId, depositTransactionId);\n        HashMap reversedDepositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        Assertions.assertTrue((Boolean) reversedDepositTransaction.get(\"reversed\"));\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Float balance = Float.parseFloat(\"-300\");\n\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance is -300\");\n\n    }"}
{"prompt": "Create a test that tests test Savings Account Withdrawal Charges On Payment Types", "completion": "    @Test\n    public void testSavingsAccountWithdrawalChargesOnPaymentTypes() {\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final String MINIMUM_OPENING_BALANCE = \"10000\";\n        final String withdrawalAmountOne = \"1000\";\n        final String withdrawalAmountTwo = \"2000\";\n        final Integer withdrawalChargeOne = 10;\n        final Integer withdrawalChargeTwo = 20;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        String name = PaymentTypeHelper.randomNameGenerator(\"P_T\", 5);\n        String description = PaymentTypeHelper.randomNameGenerator(\"PT_Desc\", 15);\n        Boolean isCashPayment = false;\n        Integer position = 1;\n\n        Integer paymentTypeIdOne = PaymentTypeHelper.createPaymentType(requestSpec, responseSpec, name, description, isCashPayment,\n                position);\n        Assertions.assertNotNull(paymentTypeIdOne);\n\n        final Integer chargeIdOne = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.paymentTypeCharge(withdrawalChargeOne, true, paymentTypeIdOne));\n        Assertions.assertNotNull(chargeIdOne);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, chargeIdOne, false, BigDecimal.valueOf(withdrawalChargeOne));\n\n        Integer withdrawTransactionIdOne = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccountWithPaymentType(savingsId,\n                withdrawalAmountOne, SavingsAccountHelper.TRANSACTION_DATE, paymentTypeIdOne.toString(),\n                CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Float balance = Float.parseFloat(\"8990\");\n        // Withdraw charge from paymentType 1 is 10 So balance should be 10,000(deposit)-1000(wd)-\"10(charge)\" = 8990\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance after withdrawal charge \");\n\n        String paymentTypeNameTwo = PaymentTypeHelper.randomNameGenerator(\"P_T\", 5);\n\n        Integer paymentTypeIdTwo = PaymentTypeHelper.createPaymentType(requestSpec, responseSpec, paymentTypeNameTwo, description,\n                isCashPayment, position);\n        Assertions.assertNotNull(paymentTypeIdTwo);\n\n        final Integer chargeIdTwo = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.paymentTypeCharge(withdrawalChargeTwo, true, paymentTypeIdTwo));\n        Assertions.assertNotNull(chargeIdTwo);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, chargeIdTwo, false, BigDecimal.valueOf(withdrawalChargeTwo));\n\n        Integer withdrawTransactionIdTwo = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccountWithPaymentType(savingsId,\n                withdrawalAmountTwo, SavingsAccountHelper.TRANSACTION_DATE, paymentTypeIdTwo.toString(),\n                CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Float balanceAfterChargeTwo = Float.parseFloat(\"6970\");\n        // Withdraw charge from paymentType 2 is 20 So balance should be 8990(balance)-2000(wd)-\"20(charge)\" = 6970\n\n        HashMap summaryTwo = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(balanceAfterChargeTwo, summaryTwo.get(\"accountBalance\"), \"Verifying Balance after withdrawal charge two \");\n    }"}
{"prompt": "Create a test that tests test Account Balance After Savings Transaction Reversal Posting", "completion": "    @Test\n    public void testAccountBalanceAfterSavingsTransactionReversalPosting() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"0\";\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = true;\n        final String MINIMUM_OPENING_BALANCE = \"0\";\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"500\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        this.savingsAccountHelper.reverseSavingsAccountTransaction(savingsId, depositTransactionId);\n\n        HashMap reversedDepositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n\n        Assertions.assertTrue((Boolean) reversedDepositTransaction.get(\"reversed\"));\n\n        List<HashMap> transactions = this.savingsAccountHelper.getSavingsTransactions(savingsId);\n\n        HashMap reversalDepositTransaction = transactions.get(0);\n\n        Assertions.assertTrue((Boolean) reversalDepositTransaction.get(\"isReversal\"));\n\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Float balance = Float.parseFloat(\"0.0\");\n\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance is 500\");\n\n    }"}
{"prompt": "Create a test that tests test Reversal When Is Bulk Is True", "completion": "    @Test\n    public void testReversalWhenIsBulkIsTrue() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"0\";\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final boolean isBulk = true;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsId);\n        final Integer withdrawalChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsWithdrawalFeeJSON());\n        Assertions.assertNotNull(withdrawalChargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, withdrawalChargeId, false);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        Integer withdrawalTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"500\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(\"400.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account balance is 400\");\n        LOG.info(\"------------------------When Bulk transaction is true------------------------\");\n        this.savingsAccountHelper.reverseSavingsAccountTransaction(savingsId, withdrawalTransactionId, isBulk);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(\"1000.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account balance is 1000\");\n    }"}
{"prompt": "Create a test that tests test Reversal When Is Bulk Is False", "completion": "    @Test\n    public void testReversalWhenIsBulkIsFalse() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"0\";\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final boolean isBulk = false;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsId);\n        final Integer withdrawalChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsWithdrawalFeeJSON());\n        Assertions.assertNotNull(withdrawalChargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, withdrawalChargeId, false);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        Integer withdrawalTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"500\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(\"400.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account balance is 400\");\n        LOG.info(\"------------------------When Bulk transaction is false------------------------\");\n        this.savingsAccountHelper.reverseSavingsAccountTransaction(savingsId, withdrawalTransactionId, isBulk);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(\"900.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account balance is 900\");\n    }"}
{"prompt": "Create a test that tests test Account Balance And Transaction Running Balance With Config On", "completion": "    @Test\n    public void testAccountBalanceAndTransactionRunningBalanceWithConfigOn() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        configurationForBackdatedTransaction();\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"0\";\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = true;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, \"0\", minBalanceForInterestCalculation,\n                minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(5);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n        // withdrawal transaction 1\n        Integer withdrawalTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"500\", startDate,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(\"-500.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account balance is -500\");\n\n        // withdrawal transaction 2\n        withdrawalTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"500\", startDate,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(\"-1000.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account balance is -1000\");\n\n        // Check for last transactions running balance\n        Object transactionObj = this.savingsAccountHelper.getSavingsDetails(savingsId, \"transactions\");\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) transactionObj;\n        HashMap<String, Object> requestedTransaction = transactions.get(transactions.size() - 2);\n        balance = Float.parseFloat(\"-1000.0\");\n        assertEquals(balance.toString(), requestedTransaction.get(\"runningBalance\").toString(), \"Equality check for Balance\");\n    }"}
{"prompt": "Create a test that tests test Savings Account Charges Back Date", "completion": "    @Test\n    public void testSavingsAccountChargesBackDate() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, \"0\", minBalanceForInterestCalculation,\n                minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap modifications = this.savingsAccountHelper.updateSavingsAccount(clientID, savingsProductID, savingsId,\n                ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertTrue(modifications.containsKey(\"submittedOnDate\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final Integer chargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getSavingsSpecifiedDueDateJSON());\n        Assertions.assertNotNull(chargeId);\n\n        ArrayList<HashMap> charges = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertTrue(charges == null || charges.size() == 0);\n\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"100\", \"05 March 2013\", CommonConstants.RESPONSE_RESOURCE_ID);\n\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"100\", \"07 March 2013\", CommonConstants.RESPONSE_RESOURCE_ID);\n\n        final Integer savingsChargeId = this.savingsAccountHelper.addChargesForSavingsWithDueDate(savingsId, chargeId, \"07 March 2013\",\n                200);\n\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) savingsAccountHelperValidationError\n                .payChargeToSavingsAccount(savingsId, savingsChargeId, \"200\", \"06 March 2013\", CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        final Integer payChargeId = this.savingsAccountHelper.payCharge(savingsChargeId, savingsId, \"200\", \"07 March 2013\");\n\n        Assertions.assertNotNull(payChargeId);\n    }"}
{"prompt": "Create a test that tests test Running Balance After Withdrawal With Backdate Configuration On", "completion": "    @Test\n    public void testRunningBalanceAfterWithdrawalWithBackdateConfigurationOn() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsProductHelper = new SavingsProductHelper();\n        this.scheduleJobHelper = new SchedulerJobHelper(requestSpec);\n        configurationForBackdatedTransaction();\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(5);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n        String secondTrx = formatter.format(transactionDate.plusDays(1));\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"100\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"200\", secondTrx, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap<String, Object> summaryObj = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        assertEquals(\"-100.0822\", summaryObj.get(\"availableBalance\").toString(), \"Equality check for Balance\");\n    }"}
{"prompt": "Create a test that tests test Running Balance After Deposit With Backdate Configuration On", "completion": "    @Test\n    public void testRunningBalanceAfterDepositWithBackdateConfigurationOn() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsProductHelper = new SavingsProductHelper();\n        this.scheduleJobHelper = new SchedulerJobHelper(requestSpec);\n        configurationForBackdatedTransaction();\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(5);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n        String secondTrx = formatter.format(transactionDate.plusDays(1));\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"200\", secondTrx, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap<String, Object> summaryObj = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(\"100.0822\", summaryObj.get(\"availableBalance\").toString(), \"Equality check for Balance\");\n    }"}
{"prompt": "Create a test that tests test Running Balance After Withdrawal Reversal With Backdate Configuration On", "completion": "    @Test\n    public void testRunningBalanceAfterWithdrawalReversalWithBackdateConfigurationOn() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsProductHelper = new SavingsProductHelper();\n        this.scheduleJobHelper = new SchedulerJobHelper(requestSpec);\n        configurationForBackdatedTransaction();\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(5);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n        String secondTrx = formatter.format(transactionDate.plusDays(1));\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"100\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n\n        Integer withdrawalToReverse = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"200\", secondTrx,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        this.savingsAccountHelper.reverseSavingsAccountTransaction(savingsId, withdrawalToReverse);\n        HashMap<String, Object> summaryObj = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        assertEquals(\"100.137\", summaryObj.get(\"availableBalance\").toString(), \"Equality check for Balance\");\n    }"}
{"prompt": "Create a test that tests test Running Balance After Deposit Reversal With Backdate Configuration On", "completion": "    @Test\n    public void testRunningBalanceAfterDepositReversalWithBackdateConfigurationOn() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsProductHelper = new SavingsProductHelper();\n        this.scheduleJobHelper = new SchedulerJobHelper(requestSpec);\n        configurationForBackdatedTransaction();\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(5);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n        String secondTrx = formatter.format(transactionDate.plusDays(1));\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        Integer depositToReverse = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"200\", secondTrx,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        this.savingsAccountHelper.reverseSavingsAccountTransaction(savingsId, depositToReverse);\n\n        HashMap<String, Object> summaryObj = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(\"-100.137\", summaryObj.get(\"availableBalance\").toString(), \"Equality check for Balance\");\n    }"}
{"prompt": "Create a test that tests test To Perform Transaction Before Pivot Date", "completion": "    @Test\n    public void testToPerformTransactionBeforePivotDate() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsProductHelper = new SavingsProductHelper();\n        this.scheduleJobHelper = new SchedulerJobHelper(requestSpec);\n\n        configurationForBackdatedTransaction();\n\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(10);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"200\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        final String jobName = \"Post Interest For Savings\";\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n        List<HashMap> error = (List<HashMap>) validationErrorHelper.depositToSavingsAccount(savingsId, \"300\", startDate,\n                CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.savings.transaction.is.not.allowed\", error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n    }"}
{"prompt": "Create a test that tests test Reversal Entries After System Reversing Transaction With Reversal Config On", "completion": "    @Test\n    public void testReversalEntriesAfterSystemReversingTransactionWithReversalConfigOn() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsProductHelper = new SavingsProductHelper();\n        this.scheduleJobHelper = new SchedulerJobHelper(requestSpec);\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"46\", true);\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(5);\n        LocalDate nextTransactionDate = transactionDate.plusDays(2);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n        String nxtTransaction = formatter.format(nextTransactionDate);\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", nxtTransaction, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        List<HashMap> transactions = this.savingsAccountHelper.getSavingsTransactions(savingsId);\n        boolean reversalFlag = false;\n        for (int i = 0; i < transactions.size(); i++) {\n            boolean isReversal = (boolean) transactions.get(i).get(\"isReversal\");\n            if (isReversal) {\n                reversalFlag = true;\n                break;\n            }\n        }\n        Assertions.assertTrue(reversalFlag);\n    }"}
{"prompt": "Create a test that tests test Reversal Entries After System Reversing Transaction With Reversal Config Off", "completion": "    @Test\n    public void testReversalEntriesAfterSystemReversingTransactionWithReversalConfigOff() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsProductHelper = new SavingsProductHelper();\n        this.scheduleJobHelper = new SchedulerJobHelper(requestSpec);\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec, \"46\", false);\n        LocalDate transactionDate = LocalDate.now(Utils.getZoneIdOfTenant()).minusDays(5);\n        LocalDate nextTransactionDate = transactionDate.plusDays(2);\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\");\n        String startDate = formatter.format(transactionDate);\n        String nxtTransaction = formatter.format(nextTransactionDate);\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", nxtTransaction, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        List<HashMap> transactions = this.savingsAccountHelper.getSavingsTransactions(savingsId);\n        boolean reversalFlag = false;\n        for (int i = 0; i < transactions.size(); i++) {\n            boolean isReversal = (boolean) transactions.get(i).get(\"isReversal\");\n            if (isReversal) {\n                reversalFlag = true;\n                break;\n            }\n        }\n        Assertions.assertFalse(reversalFlag);\n    }"}
{"prompt": "Create a test that tests test Savings Account Deposit After Hold Amount", "completion": "    @Test\n    public void testSavingsAccountDepositAfterHoldAmount() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final String minBalanceForInterestCalculation = null;\n        final boolean enforceMinRequiredBalance = false;\n        final boolean allowOverdraft = true;\n        final boolean lienAllowed = false;\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, \"0\", minBalanceForInterestCalculation,\n                enforceMinRequiredBalance, allowOverdraft, lienAllowed);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        this.savingsAccountHelper.holdAmountInSavingsAccount(savingsId, \"100\", lienAllowed, SavingsAccountHelper.TRANSACTION_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"200\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        Assertions.assertNotNull(depositTransactionId);\n        List<HashMap> error = (List) validationErrorHelper.withdrawalFromSavingsAccount(savingsId, \"200\",\n                SavingsAccountHelper.TRANSACTION_DATE, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    }"}
{"prompt": "Create a test that tests test Client Status", "completion": "    @Test\n    public void testClientStatus() {\n        final Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientId);\n\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientIsActive(status);\n\n        HashMap<String, Object> clientStatusHashMap = clientHelper.closeClient(clientId);\n        ClientStatusChecker.verifyClientClosed(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.reactivateClient(clientId);\n        ClientStatusChecker.verifyClientPending(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.rejectClient(clientId);\n        ClientStatusChecker.verifyClientRejected(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.activateClient(clientId);\n        ClientStatusChecker.verifyClientActiavted(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.closeClient(clientId);\n        ClientStatusChecker.verifyClientClosed(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.reactivateClient(clientId);\n        ClientStatusChecker.verifyClientPending(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(clientStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Client As Person Status", "completion": "    @Test\n    public void testClientAsPersonStatus() {\n        final Integer clientId = ClientHelper.createClientAsPerson(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientId);\n\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientIsActive(status);\n\n        HashMap<String, Object> clientStatusHashMap = clientHelper.closeClient(clientId);\n        ClientStatusChecker.verifyClientClosed(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.reactivateClient(clientId);\n        ClientStatusChecker.verifyClientPending(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.rejectClient(clientId);\n        ClientStatusChecker.verifyClientRejected(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.activateClient(clientId);\n        ClientStatusChecker.verifyClientActiavted(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.closeClient(clientId);\n        ClientStatusChecker.verifyClientClosed(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.reactivateClient(clientId);\n        ClientStatusChecker.verifyClientPending(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(clientStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Client As Entity Status", "completion": "    @Test\n    public void testClientAsEntityStatus() {\n        final Integer clientId = ClientHelper.createClientAsEntity(requestSpec, responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientId);\n\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientIsActive(status);\n\n        HashMap<String, Object> clientStatusHashMap = clientHelper.closeClient(clientId);\n        ClientStatusChecker.verifyClientClosed(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.reactivateClient(clientId);\n        ClientStatusChecker.verifyClientPending(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.rejectClient(clientId);\n        ClientStatusChecker.verifyClientRejected(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.activateClient(clientId);\n        ClientStatusChecker.verifyClientActiavted(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.closeClient(clientId);\n        ClientStatusChecker.verifyClientClosed(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.reactivateClient(clientId);\n        ClientStatusChecker.verifyClientPending(clientStatusHashMap);\n\n        clientStatusHashMap = clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(clientStatusHashMap);\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    @SuppressFBWarnings(value = {\n            \"DMI_RANDOM_USED_ONLY_ONCE\" }"}
{"prompt": "Create a test that tests test Client Address Creation Works", "completion": "    @Test\n    public void testClientAddressCreationWorks() {\n        // given\n        GlobalConfigurationPropertyData addressEnabledConfig = GlobalConfigurationHelper.getGlobalConfigurationByName(requestSpec,\n                responseSpec, \"Enable-Address\");\n        Long configId = addressEnabledConfig.getId();\n\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(requestSpec, responseSpec, configId, true);\n        GlobalConfigurationPropertyData updatedAddressEnabledConfig = GlobalConfigurationHelper.getGlobalConfigurationByName(requestSpec,\n                responseSpec, \"Enable-Address\");\n        boolean isAddressEnabled = BooleanUtils.toBoolean(updatedAddressEnabledConfig.getEnabled());\n        assertThat(isAddressEnabled).isTrue();\n\n        Integer addressTypeId = CodeHelper.createAddressTypeCodeValue(requestSpec, responseSpec,\n                Utils.randomStringGenerator(\"Residential address\", 4), 0);\n        Integer countryId = CodeHelper.createCountryCodeValue(requestSpec, responseSpec, Utils.randomStringGenerator(\"Hungary\", 4), 0);\n        Integer stateId = CodeHelper.createStateCodeValue(requestSpec, responseSpec, Utils.randomStringGenerator(\"Budapest\", 4), 0);\n        String city = \"Budapest\";\n        boolean addressIsActive = true;\n        long postalCode = 1000L;\n\n        // when\n        PostClientsAddressRequest addressRequest = new PostClientsAddressRequest().postalCode(postalCode).city(city).countryId(countryId)\n                .stateProvinceId(stateId).addressTypeId(addressTypeId.longValue()).isActive(addressIsActive);\n        PostClientsRequest request = ClientHelper.defaultClientCreationRequest().address(List.of(addressRequest));\n        final Integer clientId = ClientHelper.createClient(requestSpec, responseSpec, request);\n\n        // then\n        ClientHelper.verifyClientCreatedOnServer(requestSpec, responseSpec, clientId);\n        List<GetClientClientIdAddressesResponse> clientAddresses = ClientHelper.getClientAddresses(requestSpec, responseSpec, clientId);\n        GetClientClientIdAddressesResponse addressResponse = clientAddresses.get(0);\n        assertThat(addressResponse.getCity()).isEqualTo(city);\n        assertThat(addressResponse.getCountryId()).isEqualTo(countryId);\n        assertThat(addressResponse.getStateProvinceId()).isEqualTo(stateId);\n        assertThat(addressResponse.getAddressTypeId()).isEqualTo(addressTypeId);\n        assertThat(addressResponse.getIsActive()).isEqualTo(addressIsActive);\n        assertThat(addressResponse.getPostalCode()).isEqualTo(postalCode);\n    }"}
{"prompt": "Create a test that tests test Client Address Creation Works After Client Is Created", "completion": "    @Test\n    public void testClientAddressCreationWorksAfterClientIsCreated() {\n        // given\n        Integer addressTypeId = CodeHelper.createAddressTypeCodeValue(requestSpec, responseSpec,\n                Utils.randomStringGenerator(\"Residential address\", 4), 0);\n        Integer countryId = CodeHelper.createCountryCodeValue(requestSpec, responseSpec, Utils.randomStringGenerator(\"Hungary\", 4), 0);\n        Integer stateId = CodeHelper.createStateCodeValue(requestSpec, responseSpec, Utils.randomStringGenerator(\"Budapest\", 4), 0);\n        String city = \"Budapest\";\n        boolean addressIsActive = true;\n        long postalCode = 1000L;\n\n        PostClientsRequest clientRequest = ClientHelper.defaultClientCreationRequest();\n        final Integer clientId = ClientHelper.createClient(requestSpec, responseSpec, clientRequest);\n        // when\n        PostClientClientIdAddressesRequest request = new PostClientClientIdAddressesRequest().postalCode(postalCode).city(city)\n                .countryId(countryId).stateProvinceId(stateId).isActive(addressIsActive);\n        PostClientClientIdAddressesResponse response = ClientHelper.createClientAddress(requestSpec, responseSpec, clientId.longValue(),\n                addressTypeId, request);\n        // then\n        assertThat(response.getResourceId()).isNotNull();\n        List<GetClientClientIdAddressesResponse> clientAddresses = ClientHelper.getClientAddresses(requestSpec, responseSpec, clientId);\n        GetClientClientIdAddressesResponse addressResponse = clientAddresses.get(0);\n        assertThat(addressResponse.getCity()).isEqualTo(city);\n        assertThat(addressResponse.getCountryId()).isEqualTo(countryId);\n        assertThat(addressResponse.getStateProvinceId()).isEqualTo(stateId);\n        assertThat(addressResponse.getAddressTypeId()).isEqualTo(addressTypeId);\n        assertThat(addressResponse.getIsActive()).isEqualTo(addressIsActive);\n        assertThat(addressResponse.getPostalCode()).isEqualTo(postalCode);\n    }"}
{"prompt": "Create a test that tests client Undo Reject Integration Test", "completion": "    @Test\n    public void clientUndoRejectIntegrationTest() {\n\n        // CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientId);\n        // Assertions.assertNotNull(clientId);\n\n        // GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.rejectClient(clientId);\n        ClientStatusChecker.verifyClientRejected(status);\n\n        status = this.clientHelper.undoReject(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n\n    }"}
{"prompt": "Create a test that tests test Client Undo Reject With Date Before Reject Date", "completion": "    @Test\n    public void testClientUndoRejectWithDateBeforeRejectDate() {\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n\n        // CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        // GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.rejectClient(clientId);\n        ClientStatusChecker.verifyClientRejected(status);\n\n        ArrayList<HashMap<String, Object>> clientErrorData = validationErrorHelper.undoRejectedclient(clientId,\n                CommonConstants.RESPONSE_ERROR, ClientHelper.CREATED_DATE);\n        assertEquals(\"error.msg.client.reopened.date.cannot.before.client.rejected.date\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        status = this.clientHelper.undoReject(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }"}
{"prompt": "Create a test that tests test Client Undo Reject Without Reject", "completion": "    @Test\n    public void testClientUndoRejectWithoutReject() {\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n\n        // CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        // GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientPending(status);\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        final String undoRejectDate = todaysDate.format(Utils.dateFormatter);\n\n        ArrayList<HashMap<String, Object>> clientErrorData = validationErrorHelper.undoRejectedclient(clientId,\n                CommonConstants.RESPONSE_ERROR, undoRejectDate);\n        assertEquals(\"error.msg.client.undorejection.on.nonrejected.account\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientPending(status);\n\n    }"}
{"prompt": "Create a test that tests test Client Undo Reject With Future Date", "completion": "    @Test\n    public void testClientUndoRejectWithFutureDate() {\n\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n\n        // CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        // GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.rejectClient(clientId);\n        ClientStatusChecker.verifyClientRejected(status);\n        LocalDate tomorrowsDate = Utils.getLocalDateOfTenant().plusDays(1);\n        final String undoRejectDate = tomorrowsDate.format(Utils.dateFormatter);\n        ArrayList<HashMap<String, Object>> clientErrorData = validationErrorHelper.undoRejectedclient(clientId,\n                CommonConstants.RESPONSE_ERROR, undoRejectDate);\n        assertEquals(\"validation.msg.client.reopenedDate.is.greater.than.date\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        status = this.clientHelper.undoReject(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n\n    }"}
{"prompt": "Create a test that tests client Undo With Drawn Integration Test", "completion": "    @Test\n    public void clientUndoWithDrawnIntegrationTest() {\n\n        // CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        // GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(status);\n\n        status = this.clientHelper.undoWithdrawn(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n\n    }"}
{"prompt": "Create a test that tests test Client Undo With Drawn With Date Before Withdrawal", "completion": "    @Test\n    public void testClientUndoWithDrawnWithDateBeforeWithdrawal() {\n\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n\n        // CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        // GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(status);\n\n        ArrayList<HashMap<String, Object>> clientErrorData = validationErrorHelper.undoWithdrawclient(clientId,\n                CommonConstants.RESPONSE_ERROR, ClientHelper.CREATED_DATE);\n        assertEquals(\"error.msg.client.reopened.date.cannot.before.client.withdrawal.date\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        status = this.clientHelper.undoWithdrawn(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }"}
{"prompt": "Create a test that tests test Client Undo With Drawn Without Withdrawal", "completion": "    @Test\n    public void testClientUndoWithDrawnWithoutWithdrawal() {\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n        // CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        // GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        final String undoWithdrawDate = todaysDate.format(Utils.dateFormatter);\n\n        ArrayList<HashMap<String, Object>> clientErrorData = validationErrorHelper.undoWithdrawclient(clientId,\n                CommonConstants.RESPONSE_ERROR, undoWithdrawDate);\n        assertEquals(\"error.msg.client.undoWithdrawal.on.nonwithdrawal.account\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientPending(status);\n\n    }"}
{"prompt": "Create a test that tests test Client Undo With Drawn With Future Date", "completion": "    @Test\n    public void testClientUndoWithDrawnWithFutureDate() {\n\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n\n        // CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        // GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(status);\n        LocalDate tomorrowsDate = Utils.getLocalDateOfTenant().plusDays(1);\n        final String undoWithdrawDate = tomorrowsDate.format(Utils.dateFormatter);\n        ArrayList<HashMap<String, Object>> clientErrorData = validationErrorHelper.undoWithdrawclient(clientId,\n                CommonConstants.RESPONSE_ERROR, undoWithdrawDate);\n        assertEquals(\"validation.msg.client.reopenedDate.is.greater.than.date\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        status = this.clientHelper.undoWithdrawn(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }"}
{"prompt": "Create a test that tests test Validate Reopened Date", "completion": "    @Test\n    public void testValidateReopenedDate() {\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n\n        // CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n        // GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(status);\n        status = this.clientHelper.undoWithdrawn(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n        ArrayList<HashMap<String, Object>> clientErrorData = validationErrorHelper.activateClient(clientId, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.clients.submittedOnDate.after.reopened.date\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    }"}
{"prompt": "Create a test that tests test Reopened Date", "completion": "    @Test\n    public void testReopenedDate() {\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n        // final ClientHelper validationErrorHelper = new\n        // ClientHelper(this.requestSpec, errorResponse);\n\n        // CREATE CLIENT\n        this.clientHelper = new ClientHelper(this.requestSpec, this.responseSpec);\n        final Integer clientId = ClientHelper.createClientPending(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n        // GET CLIENT STATUS\n        HashMap<String, Object> status = ClientHelper.getClientStatus(requestSpec, responseSpec, String.valueOf(clientId));\n        ClientStatusChecker.verifyClientPending(status);\n\n        status = this.clientHelper.withdrawClient(clientId);\n        ClientStatusChecker.verifyClientWithdrawn(status);\n        status = this.clientHelper.undoWithdrawn(clientId);\n        ClientStatusChecker.verifyClientPending(status);\n        status = this.clientHelper.activateClientWithDiffDateOption(clientId, ClientHelper.CREATED_DATE_PLUS_TWO);\n\n    }"}
{"prompt": "Create a test that tests create Collateral Product Test", "completion": "    @Test\n    public void createCollateralProductTest() {\n        LOG.info(\"-------------------------Creating Collateral Product---------------------------\");\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n    }"}
{"prompt": "Create a test that tests update Collateral Product Test", "completion": "    @Test\n    public void updateCollateralProductTest() {\n        LOG.info(\"-------------------------Updating Collateral Product---------------------------\");\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer resourceId = CollateralManagementHelper.updateCollateralProduct(this.requestSpec, this.responseSpec, collateralId);\n\n        Assertions.assertEquals(collateralId, resourceId);\n    }"}
{"prompt": "Create a test that tests verify Concurrent Loan Repayments", "completion": "    @Test\n    public void verifyConcurrentLoanRepayments() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(false, NO_ACCOUNTING);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"12,000.00\");\n        this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID, \"12,000.00\",\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        ExecutorService executor = Executors.newFixedThreadPool(MYTHREADS);\n        Calendar date = Calendar.getInstance();\n        date.set(2011, 9, 20);\n        Float repaymentAmount = 100.0f;\n        for (int i = 0; i < 10; i++) {\n            LOG.info(\"Starting concurrent transaction number {}\", i);\n            date.add(Calendar.DAY_OF_MONTH, 1);\n            repaymentAmount = repaymentAmount + 100;\n            Runnable worker = new LoanRepaymentExecutor(loanTransactionHelper, loanID, repaymentAmount, date);\n            executor.execute(worker);\n        }\n\n        executor.shutdown();\n        // Wait until all threads are finish\n        while (!executor.isTerminated()) {\n\n        }\n        LOG.info(\"\\nFinished all threads\");\n\n    }"}
{"prompt": "Create a test that tests credit Bureau Configuration Test", "completion": "    @Test\n    public void creditBureauConfigurationTest() {\n\n        // create creditBureauConfiguration\n        final Integer configurationId = CreditBureauConfigurationHelper.createCreditBureauConfiguration(this.requestSpec, this.responseSpec,\n                Utils.randomStringGenerator(\"testConfigKey_\", 5));\n        Assertions.assertNotNull(configurationId);\n\n        // update creditBureauConfiguration\n        final String updateconfiguration = CreditBureauConfigurationHelper.updateCreditBureauConfiguration(this.requestSpec,\n                this.responseSpec, configurationId);\n\n        Assertions.assertEquals(\"updateConfigKeyValue\", updateconfiguration);\n    }"}
{"prompt": "Create a test that tests credit Bureau Integration Test", "completion": "    @Test\n    public void creditBureauIntegrationTest() throws JsonProcessingException {\n        ObjectNode jsonResponse = MAPPER.createObjectNode();\n        jsonResponse.put(\"access_token\", \"AccessToken\");\n        jsonResponse.put(\"expires_in\", 3600);\n        jsonResponse.put(\"token_type\", \"Bearer\");\n        jsonResponse.put(\"userName\", \"testUser\");\n        jsonResponse.put(\".issued\", \"sample\");\n        jsonResponse.put(\".expires\", ZonedDateTime.now(ZoneId.systemDefault()).plusSeconds(3600)\n                .format(new DateTimeFormatterBuilder().appendPattern(\"EEE, dd MMM yyyy kk:mm:ss zzz\").toFormatter()));\n        wm.stubFor(WireMock.post(\"/token/\").willReturn(WireMock.jsonResponse(MAPPER.writeValueAsString(jsonResponse), 200)));\n        wm.stubFor(WireMock.post(\"/search/NRC213\")\n                .willReturn(WireMock.jsonResponse(\"{\\\"ResponseMessage\\\":\\\"OK\\\",\\\"Data\\\":[{\\\"UniqueID\\\":\\\"123456\\\"}]}\", 200)));\n        wm.stubFor(WireMock.get(\"/report/123456\").willReturn(\n                WireMock.jsonResponse(\"{\\\"ResponseMessage\\\":\\\"OK\\\",\\\"Data\\\":{\" + \"\\\"BorrowerInfo\\\":{\" + \"\\\"Name\\\":\\\"Test Name\\\",\"\n                        + \"\\\"Gender\\\":\\\"male\\\",\" + \"\\\"Address\\\":\\\"Test Address\\\"\" + \"},\" + \"\\\"CreditScore\\\": {\\\"Score\\\":  \\\"500\\\"},\"\n                        + \"\\\"ActiveLoans\\\": [\\\"Loan1\\\", \\\"Loan2\\\"],\" + \"\\\"WriteOffLoans\\\": [\\\"Loan3\\\", \\\"Loan4\\\"]\" + \"}}\", 200)));\n\n        Object serviceResult = CreditBureauIntegrationHelper.getCreditReport(this.requestSpec, this.responseSpec, \"1\", \"NRC213\");\n        Assertions.assertNotNull(serviceResult);\n        Gson gson = new Gson();\n        CreditBureauReportData responseData = gson.fromJson(\n                gson.toJson(JsonParser.parseString(String.valueOf(serviceResult)).getAsJsonObject().get(\"creditBureauReportData\")),\n                CreditBureauReportData.class);\n        Assertions.assertEquals(\"\\\"Test Name\\\"\", responseData.getName());\n        Assertions.assertEquals(\"{\\\"Score\\\":\\\"500\\\"}\", responseData.getCreditScore());\n\n        Assertions.assertEquals(\"\\\"male\\\"\", responseData.getGender());\n        Assertions.assertEquals(\"\\\"Test Address\\\"\", responseData.getAddress());\n\n        Assertions.assertEquals(2, responseData.getClosedAccounts().length);\n        Assertions.assertEquals(2, responseData.getOpenAccounts().length);\n        Assertions.assertEquals(\"\\\"Loan3\\\"\", responseData.getClosedAccounts()[0]);\n        Assertions.assertEquals(\"\\\"Loan4\\\"\", responseData.getClosedAccounts()[1]);\n        Assertions.assertEquals(\"\\\"Loan1\\\"\", responseData.getOpenAccounts()[0]);\n        Assertions.assertEquals(\"\\\"Loan2\\\"\", responseData.getOpenAccounts()[1]);\n    }"}
{"prompt": "Create a test that tests credit Bureau No Loan Test", "completion": "    @Test\n    public void creditBureauNoLoanTest() throws JsonProcessingException {\n        ObjectNode jsonResponse = MAPPER.createObjectNode();\n        jsonResponse.put(\"access_token\", \"AccessToken\");\n        jsonResponse.put(\"expires_in\", 3600);\n        jsonResponse.put(\"token_type\", \"Bearer\");\n        jsonResponse.put(\"userName\", \"testUser\");\n        jsonResponse.put(\".issued\", \"sample\");\n        jsonResponse.put(\".expires\", ZonedDateTime.now(ZoneId.systemDefault()).plusSeconds(3600)\n                .format(new DateTimeFormatterBuilder().appendPattern(\"EEE, dd MMM yyyy kk:mm:ss zzz\").toFormatter()));\n        wm.stubFor(WireMock.post(\"/token/\").willReturn(WireMock.jsonResponse(MAPPER.writeValueAsString(jsonResponse), 200)));\n        wm.stubFor(WireMock.post(\"/search/NRC213\")\n                .willReturn(WireMock.jsonResponse(\"{\\\"ResponseMessage\\\":\\\"OK\\\",\\\"Data\\\":[{\\\"UniqueID\\\":\\\"123456\\\"}]}\", 200)));\n        wm.stubFor(WireMock.get(\"/report/123456\")\n                .willReturn(WireMock.jsonResponse(\"{\\\"ResponseMessage\\\":\\\"OK\\\",\\\"Data\\\":{\" + \"\\\"BorrowerInfo\\\":{\"\n                        + \"\\\"Name\\\":\\\"Test Name\\\",\" + \"\\\"Gender\\\":\\\"male\\\",\" + \"\\\"Address\\\":\\\"Test Address\\\"\" + \"},\"\n                        + \"\\\"CreditScore\\\": {\\\"Score\\\":  \\\"500\\\"},\" + \"\\\"ActiveLoans\\\": [],\" + \"\\\"WriteOffLoans\\\": []\" + \"}}\", 200)));\n\n        Object serviceResult = CreditBureauIntegrationHelper.getCreditReport(this.requestSpec, this.responseSpec, \"1\", \"NRC213\");\n        Assertions.assertNotNull(serviceResult);\n        Gson gson = new Gson();\n        CreditBureauReportData responseData = gson.fromJson(\n                gson.toJson(JsonParser.parseString(String.valueOf(serviceResult)).getAsJsonObject().get(\"creditBureauReportData\")),\n                CreditBureauReportData.class);\n        Assertions.assertEquals(\"\\\"Test Name\\\"\", responseData.getName());\n        Assertions.assertEquals(\"{\\\"Score\\\":\\\"500\\\"}\", responseData.getCreditScore());\n\n        Assertions.assertEquals(\"\\\"male\\\"\", responseData.getGender());\n        Assertions.assertEquals(\"\\\"Test Address\\\"\", responseData.getAddress());\n\n        Assertions.assertEquals(0, responseData.getClosedAccounts().length);\n        Assertions.assertEquals(0, responseData.getOpenAccounts().length);\n    }"}
{"prompt": "Create a test that tests test Currency Elements", "completion": "    @Test\n    public void testCurrencyElements() {\n\n        CurrencyDomain currency = CurrenciesHelper.getCurrencybyCode(requestSpec, responseSpec, \"USD\");\n        CurrencyDomain usd = CurrencyDomain.create(\"USD\", \"US Dollar\", 2, \"$\", \"currency.USD\", \"US Dollar ($)\").build();\n\n        Assertions.assertTrue(currency.getDecimalPlaces() >= 0);\n        Assertions.assertNotNull(currency.getName());\n        Assertions.assertNotNull(currency.getDisplaySymbol());\n        Assertions.assertNotNull(currency.getDisplayLabel());\n        Assertions.assertNotNull(currency.getNameCode());\n\n        Assertions.assertEquals(usd, currency);\n    }"}
{"prompt": "Create a test that tests test Update Currency Selection", "completion": "    @Test\n    public void testUpdateCurrencySelection() {\n\n        // Test updation\n        ArrayList<String> currenciestoUpdate = new ArrayList<String>();\n        currenciestoUpdate.add(\"KES\");\n        currenciestoUpdate.add(\"BND\");\n        currenciestoUpdate.add(\"LBP\");\n        currenciestoUpdate.add(\"GHC\");\n        currenciestoUpdate.add(\"USD\");\n        currenciestoUpdate.add(\"INR\");\n\n        ArrayList<String> currenciesOutput = CurrenciesHelper.updateSelectedCurrencies(this.requestSpec, this.responseSpec,\n                currenciestoUpdate);\n        Assertions.assertNotNull(currenciesOutput);\n\n        Assertions.assertEquals(currenciestoUpdate, currenciesOutput, \"Verifying Do Outputed Currencies Match after Updation\");\n\n        // Test that output matches updation\n        ArrayList<CurrencyDomain> currenciesBeforeUpdate = new ArrayList<CurrencyDomain>();\n        for (String e : currenciestoUpdate) {\n            currenciesBeforeUpdate.add(CurrenciesHelper.getCurrencybyCode(requestSpec, responseSpec, e));\n        }\n        Collections.sort(currenciesBeforeUpdate);\n\n        ArrayList<CurrencyDomain> currenciesAfterUpdate = CurrenciesHelper.getSelectedCurrencies(requestSpec, responseSpec);\n        Assertions.assertNotNull(currenciesAfterUpdate);\n\n        Assertions.assertEquals(currenciesBeforeUpdate, currenciesAfterUpdate, \"Verifying Do Selected Currencies Match after Updation\");\n    }"}
{"prompt": "Create a test that tests test Loan Classification Step As Part Of COB", "completion": "    @Test\n    public void testLoanClassificationStepAsPartOfCOB() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            LocalDate bussinesLocalDate = Utils.getDateAsLocalDate(\"01 April 2012\");\n            log.info(\"Current date {}\", bussinesLocalDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, bussinesLocalDate);\n\n            // Given\n            final LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n\n            ArrayList<Integer> rangeIds = new ArrayList<>();\n            String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n            PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec,\n                    responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n            final GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                    delinquencyRangeResponse.getResourceId());\n            final String classificationExpected = range.getClassification();\n            log.info(\"Expected Delinquency Range classification {}\", classificationExpected);\n\n            jsonRange = DelinquencyRangesHelper.getAsJSON(4, 60);\n            delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n\n            String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n            PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                    responseSpec, jsonBucket);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketResponse.getResourceId());\n\n            // Client and Loan account creation\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                    delinquencyBucket.getId());\n            assertNotNull(getLoanProductsProductResponse);\n            log.info(\"Loan Product Bucket Name: {}\", getLoanProductsProductResponse.getDelinquencyBucket().getName());\n            assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n\n            // Older date to have more than one overdue installment\n            final LocalDate transactionDate = bussinesLocalDate.minusDays(31);\n            String operationDate = Utils.dateFormatter.format(transactionDate);\n\n            // Create Loan Account\n            final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                    getLoanProductsProductResponse.getId().toString(), operationDate);\n\n            // COB Step Validation\n            final JobBusinessStepConfigData jobBusinessStepConfigData = BusinessStepConfigurationHelper\n                    .getConfiguredBusinessStepsByJobName(requestSpec, responseSpec, BusinessConfigurationApiTest.LOAN_JOB_NAME);\n            assertNotNull(jobBusinessStepConfigData);\n            assertEquals(BusinessConfigurationApiTest.LOAN_JOB_NAME, jobBusinessStepConfigData.getJobName());\n            assertTrue(jobBusinessStepConfigData.getBusinessSteps().size() > 0);\n            assertTrue(jobBusinessStepConfigData.getBusinessSteps().stream().anyMatch(\n                    businessStep -> BusinessConfigurationApiTest.LOAN_DELINQUENCY_CLASSIFICATION.equals(businessStep.getStepName())));\n\n            // Run first time the Loan COB Job\n            final String jobName = \"Loan COB\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            // Get loan details expecting to have not a delinquency classification\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            final GetDelinquencyRangesResponse firstTestCase = getLoansLoanIdResponse.getDelinquencyRange();\n            log.info(\"Loan Delinquency Range is null {}\", (firstTestCase == null));\n            GetLoansLoanIdRepaymentSchedule getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n            if (getLoanRepaymentSchedule != null) {\n                log.info(\"Loan with {} periods\", getLoanRepaymentSchedule.getPeriods().size());\n                for (GetLoansLoanIdRepaymentPeriod period : getLoanRepaymentSchedule.getPeriods()) {\n                    log.info(\"Period number {} for due date {} and outstanding {}\", period.getPeriod(), period.getDueDate(),\n                            period.getTotalOutstandingForPeriod());\n                }\n            }\n\n            // Move the Business date to get older the loan and to have an overdue loan\n            LocalDate lastLoanCOBBusinessDate = bussinesLocalDate;\n            bussinesLocalDate = bussinesLocalDate.plusDays(3);\n            schedulerJobHelper.fastForwardTime(lastLoanCOBBusinessDate, bussinesLocalDate, jobName, responseSpec);\n            log.info(\"Current date {}\", bussinesLocalDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, bussinesLocalDate);\n            // Run Second time the Job\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            // Get loan details expecting to have a delinquency classification\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n            final GetDelinquencyRangesResponse secondTestCase = getLoansLoanIdResponse.getDelinquencyRange();\n            assertNotNull(secondTestCase);\n            log.info(\"Loan Delinquency Range is {}\", secondTestCase.getClassification());\n\n            // Then\n            assertNotNull(delinquencyBucketResponse);\n            assertNotNull(getLoanProductsProductResponse);\n            assertNull(firstTestCase);\n            assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n            assertEquals(secondTestCase.getClassification(), classificationExpected);\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Loan Classification Step As Part Of COBRepeated", "completion": "    @Test\n    public void testLoanClassificationStepAsPartOfCOBRepeated() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            List<LocalDate> expectedDates = new ArrayList();\n\n            LocalDate businessDate = LocalDate.parse(\"2022-01-01\", DateUtils.DEFAULT_DATE_FORMATTER);\n            log.info(\"Current Business date {}\", businessDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n            // Delinquency Bucket\n            final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketId);\n\n            // Client and Loan account creation\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                    delinquencyBucket.getId());\n            assertNotNull(getLoanProductsProductResponse);\n\n            // Older date to have more than one overdue installment\n            String operationDate = Utils.dateFormatter.format(businessDate);\n            log.info(\"Operation date  {}\", businessDate);\n\n            // Create Loan Account\n            final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                    getLoanProductsProductResponse.getId().toString(), operationDate, \"3\");\n\n            // Move the Business date 1 month to apply the first repayment\n            businessDate = businessDate.plusMonths(1);\n            expectedDates.add(businessDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n            log.info(\"Current Business date {}\", businessDate);\n\n            String amountVal = \"400.00\";\n            Float transactionAmount = Float.valueOf(amountVal);\n            operationDate = Utils.dateFormatter.format(businessDate);\n            PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate,\n                    transactionAmount, loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            Long transactionId = loanIdTransactionsResponse.getResourceId();\n            loanTransactionHelper.reviewLoanTransactionRelations(loanId, transactionId, 0);\n\n            // Move the Business date 1 month more to apply the second repayment\n            businessDate = businessDate.plusMonths(1);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n            log.info(\"Current Business date {}\", businessDate);\n\n            operationDate = Utils.dateFormatter.format(businessDate);\n            expectedDates.add(businessDate);\n            loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, transactionAmount, loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            transactionId = loanIdTransactionsResponse.getResourceId();\n            loanTransactionHelper.reviewLoanTransactionRelations(loanId, transactionId, 0);\n\n            // Get loan details expecting to have not a delinquency classification and 1,000 as Outstanding\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            validateLoanAccount(getLoansLoanIdResponse, \"0.00\", \"400.00\", 0, doubleZERO);\n\n            // Move the Business date n days to apply the chargeback for the previous repayment\n            businessDate = businessDate.plusDays(15);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n            log.info(\"Current Business date {}\", businessDate);\n\n            // Apply the Chargeback transaction\n            final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, amountVal, 0,\n                    responseSpec);\n            loanTransactionHelper.reviewLoanTransactionRelations(loanId, transactionId, 1);\n\n            // Validate the account expecting to have an adjustment for 100.00 and Outstanding 1,100\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            // Past Due Days in Zero because the Charge back transaction exists and It was done with the current date\n            validateLoanAccount(getLoansLoanIdResponse, amountVal, \"800.00\", 0, Double.valueOf(\"0.00\"));\n\n            // Move the Business date n days to run the COB\n            businessDate = businessDate.plusDays(23);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n            log.info(\"Current Business date {}\", businessDate);\n\n            // Run the Loan COB Job\n            final String jobName = \"Loan COB\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            // Get loan details expecting to have a delinquency classification\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            validateLoanAccount(getLoansLoanIdResponse, amountVal, \"800.00\", 23, Double.valueOf(\"800.00\"));\n\n            // Move the Business date few days to apply the repayment for Chargeback\n            businessDate = LocalDate.parse(\"2022-03-20\", DateUtils.DEFAULT_DATE_FORMATTER);\n            expectedDates.add(businessDate);\n            operationDate = Utils.dateFormatter.format(businessDate);\n            loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, transactionAmount, loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            transactionId = loanIdTransactionsResponse.getResourceId();\n            loanTransactionHelper.reviewLoanTransactionRelations(loanId, transactionId, 0);\n\n            // Get loan details expecting to have a delinquency classification\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            validateLoanAccount(getLoansLoanIdResponse, amountVal, \"400.00\", 7, Double.valueOf(\"400.00\"));\n\n            // Pay the Loan to get this as Closed\n            loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, transactionAmount, loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertEquals(LoanStatus.CLOSED_OBLIGATIONS_MET.getValue(), getLoansLoanIdResponse.getStatus().getId());\n            log.info(\"Loan id {} with status {}\", loanId, getLoansLoanIdResponse.getStatus().getCode());\n\n            // Evaluate Installments\n            GetLoansLoanIdRepaymentSchedule getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n            assertNotNull(getLoanRepaymentSchedule);\n            log.info(\"Loan with {} periods\", getLoanRepaymentSchedule.getPeriods().size());\n\n            for (GetLoansLoanIdRepaymentPeriod period : getLoanRepaymentSchedule.getPeriods()) {\n                if (period.getPeriod() != null) {\n                    log.info(\"Period number {} completed on date {}\", period.getPeriod(), period.getObligationsMetOnDate());\n                    assertNotNull(period.getObligationsMetOnDate());\n                    assertEquals(expectedDates.get(period.getPeriod() - 1), period.getObligationsMetOnDate());\n                    assertTrue(period.getComplete());\n                }\n            }\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Create Delinquency Ranges", "completion": "    @Test\n    public void testCreateDelinquencyRanges() {\n        // given\n        final String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n\n        // when\n        final PostDelinquencyRangeResponse delinquencyRangeResponse01 = DelinquencyRangesHelper.createDelinquencyRange(requestSpec,\n                responseSpec, jsonRange);\n        final ArrayList<GetDelinquencyRangesResponse> ranges = DelinquencyRangesHelper.getDelinquencyRanges(requestSpec, responseSpec);\n\n        // then\n        assertNotNull(delinquencyRangeResponse01);\n        assertNotNull(ranges);\n        assertEquals(1, ranges.get(0).getMinimumAgeDays(), \"Expected Min Age Days to 1\");\n        assertEquals(3, ranges.get(0).getMaximumAgeDays(), \"Expected Max Age Days to 3\");\n    }"}
{"prompt": "Create a test that tests test Update Delinquency Ranges", "completion": "    @Test\n    public void testUpdateDelinquencyRanges() {\n        // given\n        String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n        final PostDelinquencyRangeResponse delinquencyRangeResponse01 = DelinquencyRangesHelper.createDelinquencyRange(requestSpec,\n                responseSpec, jsonRange);\n        jsonRange = DelinquencyRangesHelper.getAsJSON(1, 7);\n        assertNotNull(delinquencyRangeResponse01);\n\n        // when\n        final PutDelinquencyRangeResponse delinquencyRangeResponse02 = DelinquencyRangesHelper.updateDelinquencyRange(requestSpec,\n                responseSpec, delinquencyRangeResponse01.getResourceId(), jsonRange);\n        final GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                delinquencyRangeResponse01.getResourceId());\n        final DeleteDelinquencyRangeResponse deleteDelinquencyRangeResponse = DelinquencyRangesHelper.deleteDelinquencyRange(requestSpec,\n                responseSpec, delinquencyRangeResponse01.getResourceId());\n\n        // then\n        assertNotNull(delinquencyRangeResponse02);\n        assertNotNull(deleteDelinquencyRangeResponse);\n        assertNotNull(range);\n        assertNotEquals(3, range.getMaximumAgeDays());\n        assertEquals(1, range.getMinimumAgeDays());\n        assertEquals(7, range.getMaximumAgeDays());\n    }"}
{"prompt": "Create a test that tests test Delinquency Buckets", "completion": "    @Test\n    public void testDelinquencyBuckets() {\n        // given\n        ArrayList<Integer> rangeIds = new ArrayList<>();\n        String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n        PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec,\n                jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        jsonRange = DelinquencyRangesHelper.getAsJSON(4, 30);\n        // Create\n        delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n        PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                responseSpec, jsonBucket);\n        // Update\n        jsonRange = DelinquencyRangesHelper.getAsJSON(31, 60);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n        PutDelinquencyBucketResponse updateDelinquencyBucketResponse = DelinquencyBucketsHelper.updateDelinquencyBucket(requestSpec,\n                responseSpec, delinquencyBucketResponse.getResourceId(), jsonBucket);\n        delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        // Read\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketResponse.getResourceId());\n\n        // when\n        final ArrayList<GetDelinquencyBucketsResponse> bucketList = DelinquencyBucketsHelper.getDelinquencyBuckets(requestSpec,\n                responseSpec);\n\n        // then\n        assertNotNull(bucketList);\n        assertNotNull(delinquencyBucket);\n        assertEquals(2, delinquencyBucket.getRanges().size());\n        assertNotNull(delinquencyBucketResponse);\n        assertNotNull(updateDelinquencyBucketResponse);\n    }"}
{"prompt": "Create a test that tests test Delinquency Bucket Delete", "completion": "    @Test\n    public void testDelinquencyBucketDelete() {\n        // given\n        ArrayList<Integer> rangeIds = new ArrayList<>();\n        String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n        PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec,\n                jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        jsonRange = DelinquencyRangesHelper.getAsJSON(4, 30);\n        // Create\n        delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n        PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                responseSpec, jsonBucket);\n        // Delete\n        DeleteDelinquencyBucketResponse deleteDelinquencyBucketResponse = DelinquencyBucketsHelper.deleteDelinquencyBucket(requestSpec,\n                responseSpec, delinquencyBucketResponse.getResourceId());\n\n        // when\n        final ArrayList<GetDelinquencyBucketsResponse> bucketList = DelinquencyBucketsHelper.getDelinquencyBuckets(requestSpec,\n                responseSpec);\n\n        // then\n        assertNotNull(bucketList);\n        assertNotNull(delinquencyBucketResponse);\n        assertNotNull(deleteDelinquencyBucketResponse);\n    }"}
{"prompt": "Create a test that tests test Delinquency Buckets Range Age Overlaped", "completion": "    @Test\n    public void testDelinquencyBucketsRangeAgeOverlaped() {\n        // Given\n        ArrayList<Integer> rangeIds = new ArrayList<>();\n        String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n        PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec,\n                jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        jsonRange = DelinquencyRangesHelper.getAsJSON(3, 30);\n        // Create\n        delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n        final ResponseSpecification response403Spec = new ResponseSpecBuilder().expectStatusCode(403).build();\n\n        // When\n        DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, response403Spec, jsonBucket);\n    }"}
{"prompt": "Create a test that tests test Delinquency Buckets Name Duplication", "completion": "    @Test\n    public void testDelinquencyBucketsNameDuplication() {\n        // Given\n        ArrayList<Integer> rangeIds = new ArrayList<>();\n        String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n        PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec,\n                jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        jsonRange = DelinquencyRangesHelper.getAsJSON(4, 30);\n        // Create\n        delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n        final ResponseSpecification response403Spec = new ResponseSpecBuilder().expectStatusCode(403).build();\n\n        // When\n        DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec, jsonBucket);\n\n        // Then\n        DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, response403Spec, jsonBucket);\n    }"}
{"prompt": "Create a test that tests test Loan Classification Realtime", "completion": "    @Test\n    public void testLoanClassificationRealtime() {\n        try {\n            // Given\n            final LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            final LocalDate bussinesLocalDate = Utils.getDateAsLocalDate(\"01 March 2012\");\n            log.info(\"Current date {}\", bussinesLocalDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, bussinesLocalDate);\n            final BusinessDateResponse businessDateResponse = this.businessDateHelper.getBusinessDateByType(requestSpec, responseSpec,\n                    BusinessDateType.BUSINESS_DATE);\n\n            ArrayList<Integer> rangeIds = new ArrayList<>();\n            // First Range\n            String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n            PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec,\n                    responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n            jsonRange = DelinquencyRangesHelper.getAsJSON(4, 60);\n\n            GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                    delinquencyRangeResponse.getResourceId());\n\n            // Second Range\n            delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n\n            range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec, delinquencyRangeResponse.getResourceId());\n            final String classificationExpected = range.getClassification();\n            log.info(\"Expected Delinquency Range classification after Disbursement {}\", classificationExpected);\n\n            String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n            PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                    responseSpec, jsonBucket);\n            assertNotNull(delinquencyBucketResponse);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketResponse.getResourceId());\n\n            // Client and Loan account creation\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                    delinquencyBucket.getId());\n            assertNotNull(getLoanProductsProductResponse);\n            log.info(\"Loan Product Bucket Name: {}\", getLoanProductsProductResponse.getDelinquencyBucket().getName());\n            assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n\n            // Older date to have more than one overdue installment\n            final LocalDate transactionDate = bussinesLocalDate.minusDays(50);\n            String operationDate = Utils.dateFormatter.format(transactionDate);\n\n            // Create Loan Account\n            final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                    getLoanProductsProductResponse.getId().toString(), operationDate);\n\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            assertNotNull(getLoansLoanIdResponse.getDelinquencyRange());\n            log.info(\"Loan Delinquency Range after Disbursement {}\", getLoansLoanIdResponse.getDelinquencyRange().getClassification());\n            // First Loan Delinquency Classification after Disbursement command\n            assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected);\n\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            // Apply a partial repayment\n            operationDate = Utils.dateFormatter.format(bussinesLocalDate);\n            loanTransactionHelper.makeLoanRepayment(operationDate, 100.0f, loanId);\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            log.info(\"Loan Delinquency Range after Repayment {}\", getLoansLoanIdResponse.getDelinquencyRange());\n            assertNotNull(getLoansLoanIdResponse.getDelinquencyRange());\n            // First Loan Delinquency Classification remains after Repayment because the installment is not fully paid\n            assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected);\n\n            // Apply a repayment to get a full paid installment\n            loanTransactionHelper.makeLoanRepayment(operationDate, 1000.0f, loanId);\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            log.info(\"Loan Delinquency Range after Repayment {}\", getLoansLoanIdResponse.getDelinquencyRange());\n            assertNotNull(getLoansLoanIdResponse);\n            // The Loan Delinquency Classification after Repayment command must be null\n            assertNull(getLoansLoanIdResponse.getDelinquencyRange());\n            // Get the Delinquency Tags\n            ArrayList<GetDelinquencyTagHistoryResponse> getDelinquencyTagsHistory = loanTransactionHelper\n                    .getLoanDelinquencyTags(requestSpec, responseSpec, loanId);\n            assertNotNull(getDelinquencyTagsHistory);\n            log.info(\"Delinquency Tag History items {}\", getDelinquencyTagsHistory.size());\n            assertEquals(1, getDelinquencyTagsHistory.size());\n            assertNotNull(getDelinquencyTagsHistory.get(0).getLiftedOnDate());\n            assertEquals(getDelinquencyTagsHistory.get(0).getAddedOnDate(), businessDateResponse.getDate());\n            assertEquals(getDelinquencyTagsHistory.get(0).getLiftedOnDate(), businessDateResponse.getDate());\n            assertEquals(getDelinquencyTagsHistory.get(0).getDelinquencyRange().getClassification(), classificationExpected);\n            log.info(\"Delinquency Tag Item with Lifted On {}\", getDelinquencyTagsHistory.get(0).getLiftedOnDate());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Loan Classification Realtime With Charges", "completion": "    @Test\n    public void testLoanClassificationRealtimeWithCharges() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            final LocalDate bussinesLocalDate = Utils.getDateAsLocalDate(\"01 April 2012\");\n            log.info(\"Current date {}\", bussinesLocalDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, bussinesLocalDate);\n\n            // Given\n            final LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n            ArrayList<Integer> rangeIds = new ArrayList<>();\n            // First Range\n            String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n            PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec,\n                    responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n            jsonRange = DelinquencyRangesHelper.getAsJSON(4, 60);\n\n            GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                    delinquencyRangeResponse.getResourceId());\n\n            // Second Range\n            delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n\n            range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec, delinquencyRangeResponse.getResourceId());\n            final String classificationExpected = range.getClassification();\n            log.info(\"Expected Delinquency Range classification after Disbursement {}\", classificationExpected);\n\n            String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n            PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                    responseSpec, jsonBucket);\n            assertNotNull(delinquencyBucketResponse);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketResponse.getResourceId());\n\n            // Client and Loan account creation\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                    delinquencyBucket.getId());\n            assertNotNull(getLoanProductsProductResponse);\n            log.info(\"Loan Product Bucket Name: {}\", getLoanProductsProductResponse.getDelinquencyBucket().getName());\n            assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n\n            // Older date to have more than one overdue installment\n            LocalDate transactionDate = bussinesLocalDate.minusMonths(2).minusDays(5);\n            String operationDate = Utils.dateFormatter.format(transactionDate);\n\n            // Create Loan Account\n            final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                    getLoanProductsProductResponse.getId().toString(), operationDate);\n\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            log.info(\"Loan Delinquency Range after Disbursement {}\", getLoansLoanIdResponse.getDelinquencyRange().getClassification());\n            assertNotNull(getLoansLoanIdResponse);\n            // First Loan Delinquency Classification after Disbursement command\n            assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected);\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            // Apply a repayment to get a full paid installment\n            operationDate = Utils.dateFormatter.format(bussinesLocalDate);\n            loanTransactionHelper.makeLoanRepayment(operationDate, 2049.99f, loanId);\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            // The Loan Delinquency Classification after Repayment command must be null\n            log.info(\"Loan Delinquency Range after Repayment {}\", getLoansLoanIdResponse.getDelinquencyRange());\n            assertNull(getLoansLoanIdResponse.getDelinquencyRange());\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            transactionDate = bussinesLocalDate.minusDays(18);\n            operationDate = Utils.dateFormatter.format(transactionDate);\n\n            // Create and apply Charge for Specific Due Date\n            final Integer chargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(1, \"30\", false));\n            assertNotNull(chargeId);\n            final Integer loanChargeId = loanTransactionHelper.addChargesForLoan(loanId, getChargeApplyJSON(chargeId, operationDate),\n                    responseSpec);\n            assertNotNull(loanChargeId);\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            log.info(\"Loan Delinquency Range after add Loan Charge {}\", getLoansLoanIdResponse.getDelinquencyRange());\n            assertNotNull(getLoansLoanIdResponse.getDelinquencyRange());\n            // Evaluate a Delinquency Tag set after add charge to the Loan\n            assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected);\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Loan Classification Realtime Older Loan", "completion": "    @Test\n    public void testLoanClassificationRealtimeOlderLoan() {\n\n        // Given\n        final LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        ArrayList<Integer> rangeIds = new ArrayList<>();\n        // First Range\n        String jsonRange = DelinquencyRangesHelper.getAsJSON(4, 30);\n        PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec,\n                jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                delinquencyRangeResponse.getResourceId());\n        final String classificationExpected02 = range.getClassification();\n        log.info(\"Expected Delinquency Range classification after first repayment {}\", classificationExpected02);\n\n        // Second Range\n        jsonRange = DelinquencyRangesHelper.getAsJSON(31, 60);\n        delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n\n        range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec, delinquencyRangeResponse.getResourceId());\n        final String classificationExpected01 = range.getClassification();\n        log.info(\"Expected Delinquency Range classification after Disbursement {}\", classificationExpected01);\n\n        // Third Range\n        jsonRange = DelinquencyRangesHelper.getAsJSON(61, 90);\n        delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n\n        range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec, delinquencyRangeResponse.getResourceId());\n\n        String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n        PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                responseSpec, jsonBucket);\n        assertNotNull(delinquencyBucketResponse);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketResponse.getResourceId());\n\n        // Client and Loan account creation\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucket.getId());\n        assertNotNull(getLoanProductsProductResponse);\n        log.info(\"Loan Product Bucket Name: {}\", getLoanProductsProductResponse.getDelinquencyBucket().getName());\n        assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        // Older date to have more than one overdue installment\n        LocalDate transactionDate = todaysDate.minusDays(85);\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n\n        // Create Loan Account\n        final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                getLoanProductsProductResponse.getId().toString(), operationDate);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Delinquency Range after Disbursement in null? {}\", (getLoansLoanIdResponse.getDelinquencyRange() == null));\n        assertNotNull(getLoansLoanIdResponse.getDelinquencyRange());\n        log.info(\"Loan Delinquency Range after Disbursement {}\", getLoansLoanIdResponse.getDelinquencyRange());\n        // First Loan Delinquency Classification after Disbursement command\n        assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected01);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        // Apply a repayment to get a first full paid installment\n        transactionDate = todaysDate.minusDays(1);\n        operationDate = Utils.dateFormatter.format(transactionDate);\n        PostLoansLoanIdTransactionsResponse loansLoanIdTransactions = loanTransactionHelper.makeLoanRepayment(operationDate, 1050.0f,\n                loanId);\n        assertNotNull(loansLoanIdTransactions);\n        log.info(\"Loan repayment transaction id {}\", loansLoanIdTransactions.getResourceId());\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        log.info(\"Loan Delinquency Range after first Repayment {}\", getLoansLoanIdResponse.getDelinquencyRange());\n        assertNotNull(getLoansLoanIdResponse.getDelinquencyRange());\n        // First Loan Delinquency Classification remains after Repayment because the installment is not fully paid\n        assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected02);\n\n        ArrayList<GetDelinquencyTagHistoryResponse> getDelinquencyTagsHistory = loanTransactionHelper.getLoanDelinquencyTags(requestSpec,\n                responseSpec, loanId);\n        assertNotNull(getDelinquencyTagsHistory);\n        log.info(\"Delinquency Tag History items {}\", getDelinquencyTagsHistory.size());\n        log.info(\"Delinquency Tag Item with Lifted On {}\", getDelinquencyTagsHistory.get(0).getLiftedOnDate());\n        assertEquals(getDelinquencyTagsHistory.get(0).getAddedOnDate(), Utils.getLocalDateOfTenant());\n        assertEquals(getDelinquencyTagsHistory.get(0).getLiftedOnDate(), Utils.getLocalDateOfTenant());\n        assertEquals(getDelinquencyTagsHistory.get(0).getDelinquencyRange().getClassification(), classificationExpected01);\n        log.info(\"Loan Id {} with Loan status {}\", getLoansLoanIdResponse.getId(), getLoansLoanIdResponse.getStatus().getCode());\n\n        // Apply a repayment to get a second full paid installment\n        loansLoanIdTransactions = loanTransactionHelper.makeLoanRepayment(operationDate, 1020.0f, loanId);\n        assertNotNull(loansLoanIdTransactions);\n        log.info(\"Loan repayment transaction id {}\", loansLoanIdTransactions.getResourceId());\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        log.info(\"Loan Delinquency Range after second Repayment {}\", getLoansLoanIdResponse.getDelinquencyRange());\n        assertNotNull(getLoansLoanIdResponse);\n        // The Loan Delinquency Classification after Repayment command must be null\n        assertNull(getLoansLoanIdResponse.getDelinquencyRange());\n\n        getDelinquencyTagsHistory = loanTransactionHelper.getLoanDelinquencyTags(requestSpec, responseSpec, loanId);\n        assertNotNull(getDelinquencyTagsHistory);\n        log.info(\"Delinquency Tag History items {}\", getDelinquencyTagsHistory.size());\n        log.info(\"Delinquency Tag Item with Lifted On {}\", getDelinquencyTagsHistory.get(1).getLiftedOnDate());\n        assertEquals(getDelinquencyTagsHistory.get(1).getAddedOnDate(), Utils.getLocalDateOfTenant());\n        assertEquals(getDelinquencyTagsHistory.get(1).getLiftedOnDate(), Utils.getLocalDateOfTenant());\n        assertEquals(getDelinquencyTagsHistory.get(1).getDelinquencyRange().getClassification(), classificationExpected02);\n        log.info(\"Loan Id {} with final Loan status {}\", getLoansLoanIdResponse.getId(), getLoansLoanIdResponse.getStatus().getCode());\n    }"}
{"prompt": "Create a test that tests test Loan Classification Realtime With Reversed Repayment", "completion": "    @Test\n    public void testLoanClassificationRealtimeWithReversedRepayment() {\n        // Given\n        final LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        ArrayList<Integer> rangeIds = new ArrayList<>();\n        // First Range\n        String jsonRange = DelinquencyRangesHelper.getAsJSON(4, 30);\n        PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec,\n                jsonRange);\n        rangeIds.add(delinquencyRangeResponse.getResourceId());\n        GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                delinquencyRangeResponse.getResourceId());\n        final String classificationExpected = range.getClassification();\n        log.info(\"Expected Delinquency Range classification after first repayment {}\", classificationExpected);\n\n        String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n        PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                responseSpec, jsonBucket);\n        assertNotNull(delinquencyBucketResponse);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketResponse.getResourceId());\n\n        // Client and Loan account creation\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucket.getId());\n        assertNotNull(getLoanProductsProductResponse);\n        log.info(\"Loan Product Bucket Name: {}\", getLoanProductsProductResponse.getDelinquencyBucket().getName());\n        assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        log.info(\"Local date of Tenant: {}\", todaysDate);\n\n        // Older date to have more than one overdue installment\n        final LocalDate transactionDate = todaysDate.minusDays(50);\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n\n        // Create Loan Account\n        final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                getLoanProductsProductResponse.getId().toString(), operationDate);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n        loanTransactionHelper.printDelinquencyData(getLoansLoanIdResponse);\n\n        log.info(\"Loan Delinquency Range after Disbursement in null? {}\", (getLoansLoanIdResponse.getDelinquencyRange() == null));\n        assertNotNull(getLoansLoanIdResponse);\n        assertNotNull(getLoansLoanIdResponse.getDelinquencyRange());\n        log.info(\"Loan Delinquency Range after Disbursement {}\", getLoansLoanIdResponse.getDelinquencyRange());\n        // First Loan Delinquency Classification after Disbursement command\n        assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        // Apply a repayment to get a full paid installment\n        operationDate = Utils.dateFormatter.format(todaysDate);\n        PostLoansLoanIdTransactionsResponse loansLoanIdTransactions = loanTransactionHelper.makeLoanRepayment(operationDate, 1050.0f,\n                loanId);\n        assertNotNull(loansLoanIdTransactions);\n        log.info(\"Loan repayment transaction id {}\", loansLoanIdTransactions.getResourceId());\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        log.info(\"Loan Delinquency Range after Repayment {}\", getLoansLoanIdResponse.getDelinquencyRange());\n        // Loan Delinquency Classification removed after Repayment because the installment is fully paid\n        assertNull(getLoansLoanIdResponse.getDelinquencyRange());\n\n        ArrayList<GetDelinquencyTagHistoryResponse> getDelinquencyTagsHistory = loanTransactionHelper.getLoanDelinquencyTags(requestSpec,\n                responseSpec, loanId);\n        assertNotNull(getDelinquencyTagsHistory);\n        log.info(\"Delinquency Tag History items {}\", getDelinquencyTagsHistory.size());\n        log.info(\"Delinquency Tag Item with Lifted On {}\", getDelinquencyTagsHistory.get(0).getLiftedOnDate());\n        assertEquals(getDelinquencyTagsHistory.get(0).getAddedOnDate(), Utils.getLocalDateOfTenant());\n        assertEquals(getDelinquencyTagsHistory.get(0).getLiftedOnDate(), Utils.getLocalDateOfTenant());\n        assertEquals(getDelinquencyTagsHistory.get(0).getDelinquencyRange().getClassification(), classificationExpected);\n        log.info(\"Loan Id {} with Loan status {}\", getLoansLoanIdResponse.getId(), getLoansLoanIdResponse.getStatus().getCode());\n\n        // Reverse the Previous Loan Repayment\n        PostLoansLoanIdTransactionsResponse loansLoanIdReverseTransactions = loanTransactionHelper.reverseLoanTransaction(loanId,\n                loansLoanIdTransactions.getResourceId(), operationDate, responseSpec);\n        assertNotNull(loansLoanIdReverseTransactions);\n        log.info(\"Loan repayment reverse transaction id {}\", loansLoanIdReverseTransactions.getResourceId());\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        log.info(\"Loan Delinquency Range after Reverse Repayment {}\", getLoansLoanIdResponse.getDelinquencyRange());\n        // Loan Delinquency Classification goes back after Repayment because the installment is not paid\n        assertEquals(getLoansLoanIdResponse.getDelinquencyRange().getClassification(), classificationExpected);\n\n        getDelinquencyTagsHistory = loanTransactionHelper.getLoanDelinquencyTags(requestSpec, responseSpec, loanId);\n        assertNotNull(getDelinquencyTagsHistory);\n        log.info(\"Delinquency Tag History items {}\", getDelinquencyTagsHistory.size());\n        log.info(\"Delinquency Tag Item with Lifted On {}\", getDelinquencyTagsHistory.get(1).getLiftedOnDate());\n        assertEquals(getDelinquencyTagsHistory.get(1).getAddedOnDate(), Utils.getLocalDateOfTenant());\n        // Second record is open with liftedOn in null\n        assertNull(getDelinquencyTagsHistory.get(1).getLiftedOnDate());\n        assertEquals(getDelinquencyTagsHistory.get(1).getDelinquencyRange().getClassification(), classificationExpected);\n        log.info(\"Loan Id {} with final Loan status {}\", getLoansLoanIdResponse.getId(), getLoansLoanIdResponse.getStatus().getCode());\n    }"}
{"prompt": "Create a test that tests test Loan Classification Job", "completion": "    @Test\n    public void testLoanClassificationJob() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            LocalDate businessDate = Utils.getLocalDateOfTenant();\n            businessDate = businessDate.minusDays(37);\n            log.info(\"Current date {}\", businessDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n\n            final LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n\n            ArrayList<Integer> rangeIds = new ArrayList<>();\n            String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n            PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec,\n                    responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n            jsonRange = DelinquencyRangesHelper.getAsJSON(4, 60);\n            // Create\n            delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n\n            final GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                    delinquencyRangeResponse.getResourceId());\n            final String classificationExpected = range.getClassification();\n            log.info(\"Expected Delinquency Range classification {}\", classificationExpected);\n\n            String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n            PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                    responseSpec, jsonBucket);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketResponse.getResourceId());\n\n            // Client and Loan account creation\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                    delinquencyBucket.getId());\n            assertNotNull(getLoanProductsProductResponse);\n            log.info(\"Loan Product Bucket Name: {}\", getLoanProductsProductResponse.getDelinquencyBucket().getName());\n            assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n\n            final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n            // Older date to have more than one overdue installment\n            final LocalDate transactionDate = todaysDate.minusDays(57);\n            String operationDate = Utils.dateFormatter.format(transactionDate);\n\n            // Create Loan Account\n            final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                    getLoanProductsProductResponse.getId().toString(), operationDate);\n\n            // Run first time the Job\n            final String jobName = \"Loan Delinquency Classification\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            // Get loan details expecting to have not a delinquency classification\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.printDelinquencyData(getLoansLoanIdResponse);\n            final GetDelinquencyRangesResponse firstTestCase = getLoansLoanIdResponse.getDelinquencyRange();\n            log.info(\"Loan Delinquency Range is null {}\", (firstTestCase == null));\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            // Move the Business date to get older the loan and to have an overdue loan\n            businessDate = businessDate.plusMonths(1);\n            log.info(\"Current date {}\", businessDate);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n            // Run Second time the Job\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            // Get loan details expecting to have a delinquency classification\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n            loanTransactionHelper.printDelinquencyData(getLoansLoanIdResponse);\n\n            final GetDelinquencyRangesResponse secondTestCase = getLoansLoanIdResponse.getDelinquencyRange();\n            assertNotNull(secondTestCase);\n            log.info(\"Loan Delinquency Range is {}\", secondTestCase.getClassification());\n\n            // Then\n            assertNotNull(delinquencyBucketResponse);\n            assertNotNull(getLoanProductsProductResponse);\n            assertNull(firstTestCase);\n            assertEquals(getLoanProductsProductResponse.getDelinquencyBucket().getName(), delinquencyBucket.getName());\n            assertEquals(secondTestCase.getClassification(), classificationExpected);\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Reschedule JLGLoan Synk", "completion": "    @Test\n    public void testRescheduleJLGLoanSynk() {\n        // system.out.println(\"---------------------------------STARTING\n        // RESCHEDULE JLG\n        // LOAN TEST ------------------------------------------\");\n\n        Calendar meetingCalendar = Calendar.getInstance();\n        meetingCalendar.setFirstDayOfWeek(Calendar.MONDAY);\n        meetingCalendar.setTime(new java.util.Date());\n\n        int today = meetingCalendar.get(Calendar.DAY_OF_WEEK);\n        // making sure that the meeting calendar is set for the coming monday.\n        if (today >= Calendar.MONDAY) {\n            meetingCalendar.add(Calendar.DAY_OF_YEAR, +(Calendar.MONDAY - today + 7));\n        } else {\n            meetingCalendar.add(Calendar.DAY_OF_YEAR, +(Calendar.MONDAY - today));\n        }\n\n        Calendar groupMeetingChangeCalendar = (Calendar) meetingCalendar.clone();\n\n        meetingCalendar.add(Calendar.WEEK_OF_YEAR, -3);\n\n        final String groupMeetingDate = this.dateFormatterStandard.format(meetingCalendar.getTime());\n\n        final String disbursalDate = groupMeetingDate; // first meeting date\n        // after group creation\n\n        final String rescheduleSubmittedDate = this.dateFormatterStandard.format(new java.util.Date());\n\n        final String loanType = \"jlg\";\n        final String rescheduleInterestRate = \"28.0\";\n        groupMeetingChangeCalendar.add(Calendar.DAY_OF_YEAR, 1);\n        final String groupMeetingNewStartDate = this.dateFormatterStandard.format(groupMeetingChangeCalendar.getTime());\n        // The date\n        // from\n        // which we\n        // start the\n        // new group\n        // meeting\n        // occasion,\n        // this is a\n        // tuesday.\n        groupMeetingChangeCalendar.add(Calendar.WEEK_OF_YEAR, 2);\n        final String rescheduleDate = this.dateFormatterStandard.format(groupMeetingChangeCalendar.getTime());\n\n        this.requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n        this.requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n        this.requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n        this.responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n        this.generalResponseSpec = new ResponseSpecBuilder().build();\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        this.loanRescheduleRequestHelper = new LoanRescheduleRequestHelper(this.requestSpec, this.responseSpec);\n        // system.out.println(\"---------------------------------CREATING\n        // ENTITIES AND\n        // JLG LOAN ------------------------------------------\");\n        // create all required entities\n        this.createRequiredEntitiesForJLGLoanSync(groupMeetingDate);\n\n        final String loanApplicationJSON = new LoanApplicationTestBuilder().withPrincipal(loanPrincipalAmount).withLoanTermFrequency(\"24\")\n                .withLoanTermFrequencyAsWeeks().withNumberOfRepayments(\"12\").withRepaymentEveryAfter(\"2\")\n                .withRepaymentFrequencyTypeAsMonths().withAmortizationTypeAsEqualInstallments().withInterestCalculationPeriodTypeAsDays()\n                .withInterestRatePerPeriod(interestRatePerPeriod).withRepaymentFrequencyTypeAsWeeks().withSubmittedOnDate(disbursalDate)\n                .withExpectedDisbursementDate(disbursalDate).withLoanType(loanType).withSyncDisbursementWithMeetin()\n                .withCalendarID(this.groupCalendarId.toString())\n                .build(this.clientId.toString(), this.groupId.toString(), this.loanProductId.toString(), null);\n\n        this.loanId = this.loanTransactionHelper.getLoanId(loanApplicationJSON);\n\n        // Test for loan account is created\n        Assertions.assertNotNull(this.loanId);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        // Test for loan account is created, can be approved\n        this.loanTransactionHelper.approveLoan(disbursalDate, this.loanId);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        // Test for loan account approved can be disbursed\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, this.loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(disbursalDate, this.loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // system.out.println(\"---------------------------------CHANGING GROUP\n        // MEETING\n        // DATE ------------------------------------------\");\n        CalendarHelper.updateMeetingCalendarForGroup(this.requestSpec, this.responseSpec, this.groupId, this.groupCalendarId.toString(),\n                groupMeetingNewStartDate, \"2\", \"2\", \"2\"); // New\n                                                          // meeting\n                                                          // dates\n                                                          // will be\n                                                          // the\n                                                          // tuesday\n                                                          // after the\n        // coming\n        // monday\n\n        ArrayList loanRepaymnetSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, generalResponseSpec,\n                this.loanId);\n\n        ArrayList dueDateLoanSchedule = (ArrayList) ((HashMap) loanRepaymnetSchedule.get(2)).get(\"dueDate\");\n        Calendar dueDateCalendar = Calendar.getInstance();\n        dueDateCalendar.setFirstDayOfWeek(Calendar.MONDAY);\n        dueDateCalendar.set((Integer) dueDateLoanSchedule.get(0), (Integer) dueDateLoanSchedule.get(1) - 1,\n                (Integer) dueDateLoanSchedule.get(2));\n        assertEquals(3, dueDateCalendar.get(Calendar.DAY_OF_WEEK), \"AFTER MEETING CHANGE DATE THE NEXT REPAYMENT SHOULD BE ON TUESDAY\");\n\n        // system.out.println(\"---------------------------------CREATING LOAN\n        // RESCHEDULE\n        // REQUEST------------------------------------------\");\n\n        String requestJSON = new LoanRescheduleRequestTestBuilder().updateGraceOnInterest(\"2\").updateGraceOnPrincipal(\"2\")\n                .updateNewInterestRate(rescheduleInterestRate).updateRescheduleFromDate(rescheduleDate)\n                .updateSubmittedOnDate(rescheduleSubmittedDate).build(this.loanId.toString());\n\n        this.loanRescheduleRequestId = this.loanRescheduleRequestHelper.createLoanRescheduleRequest(requestJSON);\n        this.loanRescheduleRequestHelper.verifyCreationOfLoanRescheduleRequest(this.loanRescheduleRequestId);\n\n        loanRepaymnetSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, generalResponseSpec, this.loanId);\n        dueDateLoanSchedule = (ArrayList) ((HashMap) loanRepaymnetSchedule.get(2)).get(\"dueDate\");\n        dueDateCalendar.set((Integer) dueDateLoanSchedule.get(0), (Integer) dueDateLoanSchedule.get(1) - 1,\n                (Integer) dueDateLoanSchedule.get(2));\n        assertEquals(3, dueDateCalendar.get(Calendar.DAY_OF_WEEK),\n                \"AFTER MEETING CHANGE DATE THE NEXT REPAYMENT SHOULD BE ON TUESDAY, EVEN AFTER LOAN RESCHEDULE REQUEST WAS SENT\");\n\n        // system.out.println(\"Successfully created loan reschedule request (ID:\n        // \" +\n        // this.loanRescheduleRequestId + \")\");\n\n        // system.out.println(\"-----------------------------APPROVING LOAN\n        // RESCHEDULE\n        // REQUEST--------------------------\");\n\n        requestJSON = new LoanRescheduleRequestTestBuilder().updateSubmittedOnDate(rescheduleSubmittedDate)\n                .getApproveLoanRescheduleRequestJSON();\n        this.loanRescheduleRequestHelper.approveLoanRescheduleRequest(this.loanRescheduleRequestId, requestJSON);\n\n        final HashMap response = (HashMap) this.loanRescheduleRequestHelper.getLoanRescheduleRequest(loanRescheduleRequestId, \"statusEnum\");\n        assertTrue((Boolean) response.get(\"approved\"));\n\n        loanRepaymnetSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, generalResponseSpec, this.loanId);\n\n        dueDateLoanSchedule = (ArrayList) ((HashMap) loanRepaymnetSchedule.get(2)).get(\"dueDate\");\n        dueDateCalendar.set((Integer) dueDateLoanSchedule.get(0), (Integer) dueDateLoanSchedule.get(1) - 1,\n                (Integer) dueDateLoanSchedule.get(2));\n        assertEquals(3, dueDateCalendar.get(Calendar.DAY_OF_WEEK),\n                \"AFTER MEETING CHANGE DATE THE NEXT REPAYMENT SHOULD BE ON TUESDAY, EVEN AFTER RESCHEDULE\");\n        // system.out.println(\"Successfully changed group meeting date (CAELNDAR\n        // ID: \" +\n        // this.groupCalendarId\n        // + \") and rescheduled loan (RESCHEDULE ID: \" +\n        // this.loanRescheduleRequestId +\n        // \")\");\n\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpecForStatusCode403);\n    }"}
{"prompt": "Create a test that tests test Change Group Meeting Matured On Date", "completion": "    @Test\n    public void testChangeGroupMeetingMaturedOnDate() {\n        // system.out\n        // .println(\"---------------------------------STARTING GROUP LOAN\n        // MEETING CHANGE\n        // DATE EXPECTED MATURED\n        // CHANGE------------------------------------------\");\n\n        Calendar meetingCalendar = Calendar.getInstance();\n        meetingCalendar.setFirstDayOfWeek(Calendar.MONDAY);\n        meetingCalendar.setTime(new java.util.Date());\n\n        int today = meetingCalendar.get(Calendar.DAY_OF_WEEK);\n        // making sure that the meeting calendar is set for the coming monday.\n        if (today >= Calendar.MONDAY) {\n            meetingCalendar.add(Calendar.DAY_OF_YEAR, +(Calendar.MONDAY - today + 7));\n        } else {\n            meetingCalendar.add(Calendar.DAY_OF_YEAR, +(Calendar.MONDAY - today));\n        }\n\n        Calendar groupMeetingChangeCalendar = (Calendar) meetingCalendar.clone();\n\n        meetingCalendar.add(Calendar.WEEK_OF_YEAR, -3);\n\n        final String groupMeetingDate = this.dateFormatterStandard.format(meetingCalendar.getTime());\n\n        final String disbursalDate = groupMeetingDate; // first meeting date\n                                                       // after group creation\n\n        final String loanType = \"jlg\";\n        groupMeetingChangeCalendar.add(Calendar.DAY_OF_YEAR, 1);\n        final String groupMeetingNewStartDate = this.dateFormatterStandard.format(groupMeetingChangeCalendar.getTime());\n        // The date\n        // from\n        // which we\n        // start the\n        // new group\n        // meeting\n        // occasion,\n        // this is a\n        // tuesday.\n\n        this.requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n        this.requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n        this.requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n        this.responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n        this.generalResponseSpec = new ResponseSpecBuilder().build();\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        this.loanRescheduleRequestHelper = new LoanRescheduleRequestHelper(this.requestSpec, this.responseSpec);\n        // system.out.println(\"---------------------------------CREATING\n        // ENTITIES AND\n        // JLG LOAN ------------------------------------------\");\n        // create all required entities\n        this.createRequiredEntitiesForJLGLoanSync(groupMeetingDate);\n\n        final String loanApplicationJSON = new LoanApplicationTestBuilder().withPrincipal(loanPrincipalAmount).withLoanTermFrequency(\"24\")\n                .withLoanTermFrequencyAsWeeks().withNumberOfRepayments(\"12\").withRepaymentEveryAfter(\"2\")\n                .withRepaymentFrequencyTypeAsMonths().withAmortizationTypeAsEqualInstallments().withInterestCalculationPeriodTypeAsDays()\n                .withInterestRatePerPeriod(interestRatePerPeriod).withRepaymentFrequencyTypeAsWeeks().withSubmittedOnDate(disbursalDate)\n                .withExpectedDisbursementDate(disbursalDate).withLoanType(loanType).withSyncDisbursementWithMeetin()\n                .withCalendarID(this.groupCalendarId.toString())\n                .build(this.clientId.toString(), this.groupId.toString(), this.loanProductId.toString(), null);\n\n        this.loanId = this.loanTransactionHelper.getLoanId(loanApplicationJSON);\n\n        // Test for loan account is created\n        Assertions.assertNotNull(this.loanId);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        // Test for loan account is created, can be approved\n        this.loanTransactionHelper.approveLoan(disbursalDate, this.loanId);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        // Test for loan account approved can be disbursed\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, this.loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(disbursalDate, this.loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // system.out.println(\"---------------------------------CHANGING GROUP\n        // MEETING\n        // DATE ------------------------------------------\");\n        CalendarHelper.updateMeetingCalendarForGroup(this.requestSpec, this.responseSpec, this.groupId, this.groupCalendarId.toString(),\n                groupMeetingNewStartDate, \"2\", \"2\", \"2\"); // New\n                                                          // meeting\n                                                          // dates\n                                                          // will be\n                                                          // the\n                                                          // tuesday\n                                                          // after the\n                                                          // coming\n                                                          // monday\n\n        Calendar expectedMaturityCalendar = Calendar.getInstance();\n        expectedMaturityCalendar.setFirstDayOfWeek(Calendar.MONDAY);\n        ArrayList expectedMaturityDate = ((ArrayList) ((HashMap) this.loanTransactionHelper.getLoanDetail(requestSpec, generalResponseSpec,\n                this.loanId, \"timeline\")).get(\"expectedMaturityDate\"));\n\n        expectedMaturityCalendar.set((Integer) expectedMaturityDate.get(0), (Integer) expectedMaturityDate.get(1) - 1,\n                (Integer) expectedMaturityDate.get(2));\n\n        assertEquals(3, expectedMaturityCalendar.get(Calendar.DAY_OF_WEEK),\n                \"AFTER MEETING CHANGE DATE THE EXPECTED MATURITY SHOULD BE ON TUESDAY\");\n\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpecForStatusCode403);\n    }"}
{"prompt": "Create a test that tests scenario1", "completion": "    @Test\n    public void scenario1() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.02.01\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", true));\n            final Integer loanProductID = createLoanProductWithNoAccountingNoInterest(\"1000\", \"1\", \"1\", \"0\",\n                    LoanProductTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2023\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"1000\", \"1\", \"1\", \"1\", \"0\",\n                    LoanApplicationTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    \"01 January 2023\", \"01 January 2023\");\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 January 2023\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithTransactionAmount(\"01 January 2023\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            Integer firstRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"10 January 2023\", Float.parseFloat(\"500.00\"), loanID)\n                    .get(\"resourceId\");\n            Integer firstChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), \"20 January 2023\", \"50\"));\n            Integer secondRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"17 January 2023\", Float.parseFloat(\"450.00\"), loanID)\n                    .get(\"resourceId\");\n\n            Integer thirdRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"21 January 2023\", Float.parseFloat(\"50.00\"), loanID)\n                    .get(\"resourceId\");\n\n            GetLoansLoanIdResponse response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(50.0, response.getSummary().getTotalOutstanding());\n            assertEquals(50.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(950.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertNull(response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(500.0, response.getTransactions().get(1).getAmount());\n            assertEquals(500.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(500.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(secondRepaymentId, response.getTransactions().get(2).getId().intValue());\n            assertNull(response.getTransactions().get(2).getReversedOnDate());\n            assertTrue(response.getTransactions().get(2).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(2).getType().getRepayment());\n            assertEquals(450.0, response.getTransactions().get(2).getAmount());\n            assertEquals(450.0, response.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getFeeChargesPortion());\n            assertEquals(50.0, response.getTransactions().get(2).getOutstandingLoanBalance());\n            assertEquals(thirdRepaymentId, response.getTransactions().get(3).getId().intValue());\n            assertNull(response.getTransactions().get(3).getReversedOnDate());\n            assertTrue(response.getTransactions().get(3).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(3).getType().getRepayment());\n            assertEquals(50.0, response.getTransactions().get(3).getAmount());\n            assertEquals(0.0, response.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(50.0, response.getTransactions().get(3).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getFeeChargesPortion());\n            assertEquals(50.0, response.getTransactions().get(3).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(3).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(3).getLoanChargePaidByList().size());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests scenario2", "completion": "    @Test\n    public void scenario2() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.02.01\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", true));\n\n            Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n            final Integer loanProductID = createLoanProductWithNoAccountingNoInterest(\"1000\", \"1\", \"1\", \"0\",\n                    LoanProductTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2023\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"1000\", \"1\", \"1\", \"1\", \"0\",\n                    LoanApplicationTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    \"01 January 2023\", \"01 January 2023\");\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 January 2023\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithTransactionAmount(\"01 January 2023\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            Integer firstRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"10 January 2023\", Float.parseFloat(\"500.00\"), loanID)\n                    .get(\"resourceId\");\n            Integer firstChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), \"20 January 2023\", \"50\"));\n            Integer secondRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"17 January 2023\", Float.parseFloat(\"100.00\"), loanID)\n                    .get(\"resourceId\");\n\n            Integer secondChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), \"23 January 2023\", \"10\"));\n\n            Integer thirdRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"20 January 2023\", Float.parseFloat(\"100.00\"), loanID)\n                    .get(\"resourceId\");\n\n            GetLoansLoanIdResponse response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(360.0, response.getSummary().getTotalOutstanding());\n            assertEquals(360.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(10.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(10.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(650.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(350.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertNull(response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(500.0, response.getTransactions().get(1).getAmount());\n            assertEquals(500.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(500.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(secondRepaymentId, response.getTransactions().get(2).getId().intValue());\n            assertNull(response.getTransactions().get(2).getReversedOnDate());\n            assertTrue(response.getTransactions().get(2).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(2).getType().getRepayment());\n            assertEquals(100.0, response.getTransactions().get(2).getAmount());\n            assertEquals(100.0, response.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getFeeChargesPortion());\n            assertEquals(400.0, response.getTransactions().get(2).getOutstandingLoanBalance());\n            assertEquals(thirdRepaymentId, response.getTransactions().get(3).getId().intValue());\n            assertNull(response.getTransactions().get(3).getReversedOnDate());\n            assertTrue(response.getTransactions().get(3).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(3).getType().getRepayment());\n            assertEquals(100.0, response.getTransactions().get(3).getAmount());\n            assertEquals(50.0, response.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(50.0, response.getTransactions().get(3).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getPenaltyChargesPortion());\n            assertEquals(350.0, response.getTransactions().get(3).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(3).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(3).getLoanChargePaidByList().size());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests scenario3", "completion": "    @Test\n    public void scenario3() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.02.01\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n            final Integer loanProductID = createLoanProductWithNoAccountingNoInterest(\"1000\", \"1\", \"1\", \"0\",\n                    LoanProductTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2023\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"1000\", \"1\", \"1\", \"1\", \"0\",\n                    LoanApplicationTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    \"01 January 2023\", \"01 January 2023\");\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 January 2023\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithTransactionAmount(\"01 January 2023\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            Integer firstRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"10 January 2023\", Float.parseFloat(\"500.00\"), loanID)\n                    .get(\"resourceId\");\n            Integer firstChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), \"20 January 2023\", \"50\"));\n            Integer secondRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"17 January 2023\", Float.parseFloat(\"550.00\"), loanID)\n                    .get(\"resourceId\");\n\n            GetLoansLoanIdResponse response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(0.0, response.getSummary().getTotalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getClosedObligationsMet());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertNull(response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(500.0, response.getTransactions().get(1).getAmount());\n            assertEquals(500.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(500.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n\n            int repaymentOrderNo;\n            int accrualOrderNo;\n\n            if (response.getTransactions().get(2).getType().getAccrual()) {\n                accrualOrderNo = 2;\n                repaymentOrderNo = 3;\n            } else {\n                accrualOrderNo = 3;\n                repaymentOrderNo = 2;\n            }\n\n            assertNull(response.getTransactions().get(accrualOrderNo).getReversedOnDate());\n            assertTrue(response.getTransactions().get(accrualOrderNo).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(accrualOrderNo).getType().getAccrual());\n            assertEquals(50.0, response.getTransactions().get(accrualOrderNo).getAmount());\n            assertEquals(0.0, response.getTransactions().get(accrualOrderNo).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(accrualOrderNo).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(accrualOrderNo).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(accrualOrderNo).getInterestPortion());\n            assertEquals(50.0, response.getTransactions().get(accrualOrderNo).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(accrualOrderNo).getOutstandingLoanBalance());\n            assertEquals(firstChargeId,\n                    response.getTransactions().get(accrualOrderNo).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(accrualOrderNo).getLoanChargePaidByList().size());\n\n            assertEquals(secondRepaymentId, response.getTransactions().get(repaymentOrderNo).getId().intValue());\n            assertNull(response.getTransactions().get(repaymentOrderNo).getReversedOnDate());\n            assertTrue(response.getTransactions().get(repaymentOrderNo).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(repaymentOrderNo).getType().getRepayment());\n            assertEquals(550.0, response.getTransactions().get(repaymentOrderNo).getAmount());\n            assertEquals(500.0, response.getTransactions().get(repaymentOrderNo).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(repaymentOrderNo).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(repaymentOrderNo).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(repaymentOrderNo).getInterestPortion());\n            assertEquals(50.0, response.getTransactions().get(repaymentOrderNo).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(repaymentOrderNo).getOutstandingLoanBalance());\n            assertEquals(firstChargeId,\n                    response.getTransactions().get(repaymentOrderNo).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(repaymentOrderNo).getLoanChargePaidByList().size());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests scenario4", "completion": "    @Test\n    public void scenario4() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.02.01\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n            final Integer loanProductID = createLoanProductWithNoAccountingNoInterest(\"1000\", \"1\", \"3\", \"0\",\n                    LoanProductTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2023\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"1000\", \"3\", \"1\", \"3\", \"0\",\n                    LoanApplicationTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    \"01 January 2023\", \"01 January 2023\");\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 January 2023\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithTransactionAmount(\"01 January 2023\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            Integer firstChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), \"20 January 2023\", \"50\"));\n\n            Integer firstRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"10 January 2023\", Float.parseFloat(\"500.00\"), loanID)\n                    .get(\"resourceId\");\n\n            GetLoansLoanIdResponse response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(550.0, response.getSummary().getTotalOutstanding());\n            assertEquals(550.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(333.33, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(333.33, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesOutstanding());\n            assertEquals(333.33, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalDue());\n            assertEquals(116.67, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalPaid());\n            assertEquals(216.66, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertNull(response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(500.0, response.getTransactions().get(1).getAmount());\n            assertEquals(450.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(50.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(550.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(1).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(1).getLoanChargePaidByList().size());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests scenario5", "completion": "    @Test\n    public void scenario5() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.02.01\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"50\", false));\n            final Integer loanProductID = createLoanProductWithNoAccountingNoInterest(\"1000\", \"1\", \"3\", \"0\",\n                    LoanProductTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2023\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"1000\", \"3\", \"1\", \"3\", \"0\",\n                    LoanApplicationTestBuilder.DUE_PENALTY_FEE_INTEREST_PRINCIPAL_IN_ADVANCE_PRINCIPAL_PENALTY_FEE_INTEREST_STRATEGY,\n                    \"01 January 2023\", \"01 January 2023\");\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 January 2023\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithTransactionAmount(\"01 January 2023\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            Integer firstChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), \"20 January 2023\", \"50\"));\n\n            Integer firstRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"10 January 2023\", Float.parseFloat(\"500.00\"), loanID)\n                    .get(\"resourceId\");\n\n            GetLoansLoanIdResponse response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(550.0, response.getSummary().getTotalOutstanding());\n            assertEquals(550.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(333.33, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(333.33, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesOutstanding());\n            assertEquals(333.33, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalDue());\n            assertEquals(116.67, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalPaid());\n            assertEquals(216.66, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertNull(response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(500.0, response.getTransactions().get(1).getAmount());\n            assertEquals(450.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(50.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(550.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(1).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(1).getLoanChargePaidByList().size());\n\n            Integer secondRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"17 January 2023\", Float.parseFloat(\"650.00\"), loanID)\n                    .get(\"resourceId\");\n\n            response = loanTransactionHelper.getLoanDetails((long) loanID);\n\n            int repaymentOrderNo;\n            int accrualOrderNo;\n\n            assertEquals(0.0, response.getSummary().getTotalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(50.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(333.33, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(333.33, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesOutstanding());\n            assertEquals(333.33, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalDue());\n            assertEquals(333.33, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(3).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(3).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(3).getPenaltyChargesOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(3).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(3).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(3).getFeeChargesOutstanding());\n            assertEquals(333.34, response.getRepaymentSchedule().getPeriods().get(3).getPrincipalDue());\n            assertEquals(333.34, response.getRepaymentSchedule().getPeriods().get(3).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(3).getPrincipalOutstanding());\n            assertEquals(100.0, response.getTotalOverpaid());\n            assertTrue(response.getStatus().getOverpaid());\n\n            int secondRepaymentIndex;\n            // The repayment and accrual order is not consistent\n            if (response.getTransactions().get(2).getType().getRepayment()) {\n                secondRepaymentIndex = 2;\n            } else {\n                secondRepaymentIndex = 3;\n            }\n\n            assertEquals(secondRepaymentId, response.getTransactions().get(secondRepaymentIndex).getId().intValue());\n            assertNull(response.getTransactions().get(secondRepaymentIndex).getReversedOnDate());\n            assertTrue(response.getTransactions().get(secondRepaymentIndex).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(secondRepaymentIndex).getType().getRepayment());\n            assertEquals(650.0, response.getTransactions().get(secondRepaymentIndex).getAmount());\n            assertEquals(550.0, response.getTransactions().get(secondRepaymentIndex).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(secondRepaymentIndex).getPenaltyChargesPortion());\n            assertEquals(100.0, response.getTransactions().get(secondRepaymentIndex).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(secondRepaymentIndex).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(secondRepaymentIndex).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(secondRepaymentIndex).getOutstandingLoanBalance());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests scenario6", "completion": "    @Test\n    public void scenario6() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.03.01\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"20\", false));\n            final Integer loanProductID = createLoanProductWithNoAccountingNoInterest(\"1000\", \"1\", \"1\", \"0\",\n                    LoanProductTestBuilder.DUE_PENALTY_INTEREST_PRINCIPAL_FEE_IN_ADVANCE_PENALTY_INTEREST_PRINCIPAL_FEE_STRATEGY,\n                    assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2023\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"1000\", \"1\", \"1\", \"1\", \"0\",\n                    LoanApplicationTestBuilder.DUE_PENALTY_INTEREST_PRINCIPAL_FEE_IN_ADVANCE_PENALTY_INTEREST_PRINCIPAL_FEE_STRATEGY,\n                    \"01 January 2023\", \"01 January 2023\");\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 January 2023\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithTransactionAmount(\"01 January 2023\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            Integer firstChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), \"25 January 2023\", \"20\"));\n            Integer firstRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"01 March 2023\", Float.parseFloat(\"1010.00\"), loanID)\n                    .get(\"resourceId\");\n\n            GetLoansLoanIdResponse response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(10.0, response.getSummary().getTotalOutstanding());\n            assertEquals(10.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(10.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(10.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertNull(response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(1010.0, response.getTransactions().get(1).getAmount());\n            assertEquals(1000.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(10.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(1).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(1).getLoanChargePaidByList().size());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests scenario7", "completion": "    @Test\n    public void scenario7() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.01.28\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"15\", true));\n            final Integer loanProductID = createLoanProductWithNoAccountingNoInterest(\"1000\", \"1\", \"1\", \"0\",\n                    LoanProductTestBuilder.DUE_PENALTY_INTEREST_PRINCIPAL_FEE_IN_ADVANCE_PENALTY_INTEREST_PRINCIPAL_FEE_STRATEGY,\n                    assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2023\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"1000\", \"1\", \"1\", \"1\", \"0\",\n                    LoanApplicationTestBuilder.DUE_PENALTY_INTEREST_PRINCIPAL_FEE_IN_ADVANCE_PENALTY_INTEREST_PRINCIPAL_FEE_STRATEGY,\n                    \"01 January 2023\", \"01 January 2023\");\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 January 2023\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithTransactionAmount(\"01 January 2023\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            Integer firstRepaymentId = (Integer) loanTransactionHelper.makeRepayment(\"25 January 2023\", Float.parseFloat(\"1000.00\"), loanID)\n                    .get(\"resourceId\");\n\n            GetLoansLoanIdResponse response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(0.0, response.getSummary().getTotalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getClosedObligationsMet());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertNull(response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(1000.0, response.getTransactions().get(1).getAmount());\n            assertEquals(1000.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(0, response.getTransactions().get(1).getLoanChargePaidByList().size());\n\n            PostLoansLoanIdTransactionsResponse reverseRepayment = loanTransactionHelper.reverseLoanTransaction((long) loanID,\n                    (long) firstRepaymentId, new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\")\n                            .transactionDate(\"28 January 2023\").transactionAmount(0.0).locale(\"en\"));\n\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.01.31\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(1000.0, response.getSummary().getTotalOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertEquals(LocalDate.of(2023, 1, 28), response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getManuallyReversed());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(1000.0, response.getTransactions().get(1).getAmount());\n            assertEquals(1000.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(0, response.getTransactions().get(1).getLoanChargePaidByList().size());\n\n            Integer firstChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), \"28 January 2023\", \"15\"));\n            Integer secondRepayment = (Integer) loanTransactionHelper.makeRepayment(\"31 January 2023\", Float.parseFloat(\"1010.00\"), loanID)\n                    .get(\"resourceId\");\n\n            response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(5.0, response.getSummary().getTotalOutstanding());\n            assertEquals(5.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(995.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(5.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(secondRepayment, response.getTransactions().get(2).getId().intValue());\n            assertNull(response.getTransactions().get(2).getReversedOnDate());\n            assertTrue(response.getTransactions().get(2).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(2).getType().getRepayment());\n            assertEquals(1010.0, response.getTransactions().get(2).getAmount());\n            assertEquals(995.0, response.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(15.0, response.getTransactions().get(2).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getFeeChargesPortion());\n            assertEquals(5.0, response.getTransactions().get(2).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(2).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(2).getLoanChargePaidByList().size());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests scenario8", "completion": "    @Test\n    public void scenario8() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.02.15\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"20\", false));\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"15\", true));\n            final Integer loanProductID = createLoanProductWithNoAccountingNoInterest(\"1000\", \"1\", \"1\", \"0\",\n                    LoanProductTestBuilder.DUE_PENALTY_INTEREST_PRINCIPAL_FEE_IN_ADVANCE_PENALTY_INTEREST_PRINCIPAL_FEE_STRATEGY,\n                    assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2023\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"1000\", \"1\", \"1\", \"1\", \"0\",\n                    LoanApplicationTestBuilder.DUE_PENALTY_INTEREST_PRINCIPAL_FEE_IN_ADVANCE_PENALTY_INTEREST_PRINCIPAL_FEE_STRATEGY,\n                    \"01 January 2023\", \"01 January 2023\");\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 January 2023\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithTransactionAmount(\"01 January 2023\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            final String requestJSON = new LoanRescheduleRequestTestBuilder().updateRescheduleFromDate(\"1 February 2023\")\n                    .updateAdjustedDueDate(\"01 March 2023\").updateSubmittedOnDate(\"25 January 2023\").updateGraceOnPrincipal(null)\n                    .updateGraceOnInterest(null).updateExtraTerms(null).build(loanID.toString());\n            final HashMap<String, String> map = new HashMap<>();\n            map.put(\"locale\", \"en\");\n            map.put(\"dateFormat\", \"dd MMMM yyyy\");\n            map.put(\"approvedOnDate\", \"25 January 2023\");\n            final String aproveRequestJSON = new Gson().toJson(map);\n\n            Integer loanRescheduleRequestId = this.loanRescheduleRequestHelper.createLoanRescheduleRequest(requestJSON);\n            this.loanRescheduleRequestHelper.approveLoanRescheduleRequest(loanRescheduleRequestId, aproveRequestJSON);\n\n            Integer firstChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), \"01 March 2023\", \"20\"));\n            Integer firstRepaymentId = (Integer) loanTransactionHelper\n                    .makeRepayment(\"10 February 2023\", Float.parseFloat(\"1010.00\"), loanID).get(\"resourceId\");\n\n            GetLoansLoanIdResponse response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(10.0, response.getSummary().getTotalOutstanding());\n            assertEquals(10.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(10.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(10.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertNull(response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(1010.0, response.getTransactions().get(1).getAmount());\n            assertEquals(1000.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(10.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(1).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(1).getLoanChargePaidByList().size());\n\n            PostLoansLoanIdTransactionsResponse reverseRepayment = loanTransactionHelper.reverseLoanTransaction((long) loanID,\n                    (long) firstRepaymentId, new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\")\n                            .transactionDate(\"15 February 2023\").transactionAmount(0.0).locale(\"en\"));\n\n            Integer secondChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), \"15 February 2023\", \"15\"));\n\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.03.01\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(1035.0, response.getSummary().getTotalOutstanding());\n            assertEquals(1035.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(15, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertEquals(LocalDate.of(2023, 2, 15), response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getManuallyReversed());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(1010.0, response.getTransactions().get(1).getAmount());\n            assertEquals(1000.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(10.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(1).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(1).getLoanChargePaidByList().size());\n\n            Integer secondRepayment = (Integer) loanTransactionHelper.makeRepayment(\"01 March 2023\", Float.parseFloat(\"15.00\"), loanID)\n                    .get(\"resourceId\");\n\n            response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(1020.0, response.getSummary().getTotalOutstanding());\n            assertEquals(1020.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(15, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(secondRepayment, response.getTransactions().get(2).getId().intValue());\n            assertNull(response.getTransactions().get(2).getReversedOnDate());\n            assertTrue(response.getTransactions().get(2).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(2).getType().getRepayment());\n            assertEquals(15.0, response.getTransactions().get(2).getAmount());\n            assertEquals(0.0, response.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(15.0, response.getTransactions().get(2).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getFeeChargesPortion());\n            assertEquals(1000.0, response.getTransactions().get(2).getOutstandingLoanBalance());\n            assertEquals(secondChargeId, response.getTransactions().get(2).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(2).getLoanChargePaidByList().size());\n\n            Integer thirdRepayment = (Integer) loanTransactionHelper.makeRepayment(\"01 March 2023\", Float.parseFloat(\"1000.00\"), loanID)\n                    .get(\"resourceId\");\n\n            response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(20.0, response.getSummary().getTotalOutstanding());\n            assertEquals(20.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(thirdRepayment, response.getTransactions().get(3).getId().intValue());\n            assertNull(response.getTransactions().get(3).getReversedOnDate());\n            assertTrue(response.getTransactions().get(3).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(3).getType().getRepayment());\n            assertEquals(1000.0, response.getTransactions().get(3).getAmount());\n            assertEquals(1000.0, response.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getOutstandingLoanBalance());\n            assertEquals(0, response.getTransactions().get(3).getLoanChargePaidByList().size());\n\n            Integer forthRepayment = (Integer) loanTransactionHelper.makeRepayment(\"01 March 2023\", Float.parseFloat(\"10.00\"), loanID)\n                    .get(\"resourceId\");\n\n            response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(10.0, response.getSummary().getTotalOutstanding());\n            assertEquals(10.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(10.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(10.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(forthRepayment, response.getTransactions().get(4).getId().intValue());\n            assertNull(response.getTransactions().get(4).getReversedOnDate());\n            assertTrue(response.getTransactions().get(4).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(4).getType().getRepayment());\n            assertEquals(10.0, response.getTransactions().get(4).getAmount());\n            assertEquals(0.0, response.getTransactions().get(4).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(4).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(4).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(4).getInterestPortion());\n            assertEquals(10.0, response.getTransactions().get(4).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(4).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(4).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(4).getLoanChargePaidByList().size());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests scenario9", "completion": "    @Test\n    public void scenario9() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.02.15\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"20\", false));\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"15\", true));\n            final Integer loanProductID = createLoanProductWithNoAccountingNoInterest(\"1000\", \"1\", \"1\", \"0\",\n                    LoanProductTestBuilder.DUE_PENALTY_INTEREST_PRINCIPAL_FEE_IN_ADVANCE_PENALTY_INTEREST_PRINCIPAL_FEE_STRATEGY,\n                    assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, \"01 January 2023\");\n\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"1000\", \"1\", \"1\", \"1\", \"0\",\n                    LoanApplicationTestBuilder.DUE_PENALTY_INTEREST_PRINCIPAL_FEE_IN_ADVANCE_PENALTY_INTEREST_PRINCIPAL_FEE_STRATEGY,\n                    \"01 January 2023\", \"01 January 2023\");\n\n            HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 January 2023\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithTransactionAmount(\"01 January 2023\", loanID, \"1000\");\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            final String requestJSON = new LoanRescheduleRequestTestBuilder().updateRescheduleFromDate(\"1 February 2023\")\n                    .updateAdjustedDueDate(\"01 March 2023\").updateSubmittedOnDate(\"25 January 2023\").updateGraceOnPrincipal(null)\n                    .updateGraceOnInterest(null).updateExtraTerms(null).build(loanID.toString());\n            final HashMap<String, String> map = new HashMap<>();\n            map.put(\"locale\", \"en\");\n            map.put(\"dateFormat\", \"dd MMMM yyyy\");\n            map.put(\"approvedOnDate\", \"25 January 2023\");\n            final String aproveRequestJSON = new Gson().toJson(map);\n\n            Integer loanRescheduleRequestId = this.loanRescheduleRequestHelper.createLoanRescheduleRequest(requestJSON);\n            this.loanRescheduleRequestHelper.approveLoanRescheduleRequest(loanRescheduleRequestId, aproveRequestJSON);\n\n            Integer firstChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), \"01 March 2023\", \"20\"));\n            Integer firstRepaymentId = (Integer) loanTransactionHelper\n                    .makeRepayment(\"10 February 2023\", Float.parseFloat(\"1010.00\"), loanID).get(\"resourceId\");\n\n            GetLoansLoanIdResponse response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(10.0, response.getSummary().getTotalOutstanding());\n            assertEquals(10.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(10.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(10.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertNull(response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(1010.0, response.getTransactions().get(1).getAmount());\n            assertEquals(1000.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(10.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(1).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(1).getLoanChargePaidByList().size());\n\n            PostLoansLoanIdTransactionsResponse reverseRepayment = loanTransactionHelper.reverseLoanTransaction((long) loanID,\n                    (long) firstRepaymentId, new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\")\n                            .transactionDate(\"15 February 2023\").transactionAmount(0.0).locale(\"en\"));\n\n            Integer secondChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), \"15 February 2023\", \"15\"));\n\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.03.01\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(1035.0, response.getSummary().getTotalOutstanding());\n            assertEquals(1035.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(firstRepaymentId, response.getTransactions().get(1).getId().intValue());\n            assertEquals(LocalDate.of(2023, 2, 15), response.getTransactions().get(1).getReversedOnDate());\n            assertTrue(response.getTransactions().get(1).getManuallyReversed());\n            assertTrue(response.getTransactions().get(1).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(1).getType().getRepayment());\n            assertEquals(1010.0, response.getTransactions().get(1).getAmount());\n            assertEquals(1000.0, response.getTransactions().get(1).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getInterestPortion());\n            assertEquals(10.0, response.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(1).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(1).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(1).getLoanChargePaidByList().size());\n\n            Integer secondRepayment = (Integer) loanTransactionHelper.makeRepayment(\"01 March 2023\", Float.parseFloat(\"1030.00\"), loanID)\n                    .get(\"resourceId\");\n\n            response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(5.0, response.getSummary().getTotalOutstanding());\n            assertEquals(5.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(5.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(secondRepayment, response.getTransactions().get(2).getId().intValue());\n            assertNull(response.getTransactions().get(2).getReversedOnDate());\n            assertTrue(response.getTransactions().get(2).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(2).getType().getRepayment());\n            assertEquals(1030.0, response.getTransactions().get(2).getAmount());\n            assertEquals(1000.0, response.getTransactions().get(2).getPrincipalPortion());\n            assertEquals(15.0, response.getTransactions().get(2).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getInterestPortion());\n            assertEquals(15.0, response.getTransactions().get(2).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(2).getOutstandingLoanBalance());\n            if (secondChargeId.equals(response.getTransactions().get(2).getLoanChargePaidByList().get(0).getChargeId().intValue())) {\n                assertEquals(secondChargeId, response.getTransactions().get(2).getLoanChargePaidByList().get(0).getChargeId().intValue());\n                assertEquals(firstChargeId, response.getTransactions().get(2).getLoanChargePaidByList().get(1).getChargeId().intValue());\n            } else {\n                assertEquals(secondChargeId, response.getTransactions().get(2).getLoanChargePaidByList().get(1).getChargeId().intValue());\n                assertEquals(firstChargeId, response.getTransactions().get(2).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            }\n            assertEquals(2, response.getTransactions().get(2).getLoanChargePaidByList().size());\n\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.03.07\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            PostLoansLoanIdTransactionsResponse secondReverseRepayment = loanTransactionHelper.reverseLoanTransaction((long) loanID,\n                    (long) secondRepayment, new PostLoansLoanIdTransactionsTransactionIdRequest().dateFormat(\"dd MMMM yyyy\")\n                            .transactionDate(\"07 March 2023\").transactionAmount(0.0).locale(\"en\"));\n\n            Integer thirdChargeId = loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), \"07 March 2023\", \"15\"));\n\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2023.03.08\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            Integer thirdRepayment = (Integer) loanTransactionHelper.makeRepayment(\"08 March 2023\", Float.parseFloat(\"15.00\"), loanID)\n                    .get(\"resourceId\");\n\n            response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(1035.0, response.getSummary().getTotalOutstanding());\n            assertEquals(1035.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesOutstanding());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesPaid());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalOutstanding());\n\n            assertEquals(thirdRepayment, response.getTransactions().get(3).getId().intValue());\n            assertNull(response.getTransactions().get(3).getReversedOnDate());\n            assertTrue(response.getTransactions().get(3).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(3).getType().getRepayment());\n            assertEquals(15.0, response.getTransactions().get(3).getAmount());\n            assertEquals(0.0, response.getTransactions().get(3).getPrincipalPortion());\n            assertEquals(15.0, response.getTransactions().get(3).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getInterestPortion());\n            assertEquals(0.0, response.getTransactions().get(3).getFeeChargesPortion());\n            assertEquals(1000.0, response.getTransactions().get(3).getOutstandingLoanBalance());\n            assertEquals(secondChargeId, response.getTransactions().get(3).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(3).getLoanChargePaidByList().size());\n\n            Integer forthRepayment = (Integer) loanTransactionHelper.makeRepayment(\"08 March 2023\", Float.parseFloat(\"1015.00\"), loanID)\n                    .get(\"resourceId\");\n\n            response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(20.0, response.getSummary().getTotalOutstanding());\n            assertEquals(20.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(5.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesOutstanding());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesPaid());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalOutstanding());\n\n            assertEquals(forthRepayment, response.getTransactions().get(4).getId().intValue());\n            assertNull(response.getTransactions().get(4).getReversedOnDate());\n            assertTrue(response.getTransactions().get(4).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(4).getType().getRepayment());\n            assertEquals(1015.0, response.getTransactions().get(4).getAmount());\n            assertEquals(1000.0, response.getTransactions().get(4).getPrincipalPortion());\n            assertEquals(0.0, response.getTransactions().get(4).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(4).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(4).getInterestPortion());\n            assertEquals(15.0, response.getTransactions().get(4).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(4).getOutstandingLoanBalance());\n            assertEquals(firstChargeId, response.getTransactions().get(4).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            assertEquals(1, response.getTransactions().get(4).getLoanChargePaidByList().size());\n\n            Integer fifthRepayment = (Integer) loanTransactionHelper.makeRepayment(\"08 March 2023\", Float.parseFloat(\"10.00\"), loanID)\n                    .get(\"resourceId\");\n\n            response = loanTransactionHelper.getLoanDetails((long) loanID);\n            assertEquals(10.0, response.getSummary().getTotalOutstanding());\n            assertEquals(10.0, response.getRepaymentSchedule().getTotalOutstanding());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesDue());\n            assertEquals(20.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getFeeChargesOutstanding());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesDue());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPenaltyChargesOutstanding());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalDue());\n            assertEquals(1000.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(1).getPrincipalOutstanding());\n            assertTrue(response.getStatus().getActive());\n\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getFeeChargesOutstanding());\n            assertEquals(15.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesDue());\n            assertEquals(5.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesPaid());\n            assertEquals(10.0, response.getRepaymentSchedule().getPeriods().get(2).getPenaltyChargesOutstanding());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalDue());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalPaid());\n            assertEquals(0.0, response.getRepaymentSchedule().getPeriods().get(2).getPrincipalOutstanding());\n\n            assertEquals(fifthRepayment, response.getTransactions().get(5).getId().intValue());\n            assertNull(response.getTransactions().get(5).getReversedOnDate());\n            assertTrue(response.getTransactions().get(5).getTransactionRelations().isEmpty());\n            assertTrue(response.getTransactions().get(5).getType().getRepayment());\n            assertEquals(10.0, response.getTransactions().get(5).getAmount());\n            assertEquals(0.0, response.getTransactions().get(5).getPrincipalPortion());\n            assertEquals(5.0, response.getTransactions().get(5).getPenaltyChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(5).getOverpaymentPortion());\n            assertEquals(0.0, response.getTransactions().get(5).getInterestPortion());\n            assertEquals(5.0, response.getTransactions().get(5).getFeeChargesPortion());\n            assertEquals(0.0, response.getTransactions().get(5).getOutstandingLoanBalance());\n            if (firstChargeId.equals(response.getTransactions().get(5).getLoanChargePaidByList().get(0).getChargeId().intValue())) {\n                assertEquals(thirdChargeId, response.getTransactions().get(5).getLoanChargePaidByList().get(1).getChargeId().intValue());\n            } else {\n                assertEquals(firstChargeId, response.getTransactions().get(5).getLoanChargePaidByList().get(1).getChargeId().intValue());\n                assertEquals(thirdChargeId, response.getTransactions().get(5).getLoanChargePaidByList().get(0).getChargeId().intValue());\n            }\n            assertEquals(2, response.getTransactions().get(5).getLoanChargePaidByList().size());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests get External Event Configurations", "completion": "    @Test\n    public void getExternalEventConfigurations() {\n        final ArrayList<Map<String, Object>> externalEventConfigurations = ExternalEventConfigurationHelper\n                .getAllExternalEventConfigurations(requestSpec, responseSpec);\n        Assertions.assertNotNull(externalEventConfigurations);\n        final ArrayList<Map<String, Object>> defaultConfigurations = ExternalEventConfigurationHelper\n                .getDefaultExternalEventConfigurations();\n        Assertions.assertEquals(defaultConfigurations.size(), externalEventConfigurations.size());\n        verifyAllEventConfigurations(externalEventConfigurations, defaultConfigurations);\n\n    }"}
{"prompt": "Create a test that tests update External Event Configurations", "completion": "    @Test\n    public void updateExternalEventConfigurations() {\n        String updateRequestJson = ExternalEventConfigurationHelper.getExternalEventConfigurationsForUpdateJSON();\n        final Map<String, Boolean> updatedConfigurations = ExternalEventConfigurationHelper.updateExternalEventConfigurations(requestSpec,\n                responseSpec, updateRequestJson);\n        Assertions.assertEquals(updatedConfigurations.size(), 2);\n        Assertions.assertTrue(updatedConfigurations.containsKey(\"CentersCreateBusinessEvent\"));\n        Assertions.assertTrue(updatedConfigurations.containsKey(\"ClientActivateBusinessEvent\"));\n        Assertions.assertTrue(updatedConfigurations.get(\"CentersCreateBusinessEvent\"));\n        Assertions.assertTrue(updatedConfigurations.get(\"ClientActivateBusinessEvent\"));\n\n    }"}
{"prompt": "Create a test that tests test", "completion": "    @Disabled\n    @Test\n    public void test() {\n\n        final HashMap<String, String> metadata = new HashMap<>();\n        metadata.put(\"user\", \"resource_url\");\n        final HashMap<String, Object> map = new HashMap<>();\n        map.put(\"name\", \"foo\");\n        map.put(\"text\", \"Hello {{template}}\");\n        map.put(\"mappers\", metadata);\n\n        ArrayList<?> get = Utils.performServerGet(this.requestSpec, this.responseSpec, GET_TEMPLATES_URL, \"\");\n        final int entriesBeforeTest = get.size();\n\n        final Integer id = Utils.performServerPost(this.requestSpec, this.responseSpec, GET_TEMPLATES_URL, new Gson().toJson(map),\n                \"resourceId\");\n\n        final String templateUrlForId = String.format(\"/fineract-provider/api/v1/templates/%s?tenantIdentifier=default\", id);\n\n        final String getrequest2 = Utils.performServerGet(this.requestSpec, this.responseSpec, templateUrlForId, RESPONSE_ATTRIBUTE_NAME);\n\n        Assertions.assertTrue(getrequest2.equals(\"foo\"));\n\n        Utils.performServerDelete(this.requestSpec, this.responseSpec, templateUrlForId, \"\");\n\n        get = Utils.performServerGet(this.requestSpec, this.responseSpec, GET_TEMPLATES_URL, \"\");\n        final int entriesAfterTest = get.size();\n\n        Assertions.assertEquals(entriesBeforeTest, entriesAfterTest);\n    }"}
{"prompt": "Create a test that tests negative Test", "completion": "    @Test\n    public void negativeTest() {\n        // INIT\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account assetFeeAndPenaltyAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final String loanProductJSON = new LoanProductTestBuilder().withPrincipal(\"1000\").withRepaymentTypeAsMonth()\n                .withRepaymentAfterEvery(\"1\").withNumberOfRepayments(\"1\").withRepaymentTypeAsMonth().withinterestRatePerPeriod(\"0\")\n                .withInterestRateFrequencyTypeAsMonths().withAmortizationTypeAsEqualPrincipalPayment().withInterestTypeAsFlat()\n                .withAccountingRulePeriodicAccrual(new Account[] { assetAccount, incomeAccount, expenseAccount, overpaymentAccount })\n                .withDaysInMonth(\"30\").withDaysInYear(\"365\").withMoratorium(\"0\", \"0\")\n                .withFeeAndPenaltyAssetAccount(assetFeeAndPenaltyAccount).build(null);\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJSON);\n\n        final PostClientsResponse client = clientHelper.createClient(ClientHelper.defaultClientCreationRequest());\n\n        String loanExternalIdStr = UUID.randomUUID().toString();\n        final HashMap loan = applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr);\n        Integer loanId = (Integer) loan.get(\"resourceId\");\n\n        this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanId);\n        String txnExternalIdStr = UUID.randomUUID().toString();\n        final HashMap disbursedLoanResult = this.loanTransactionHelper.disburseLoan(\"03 September 2022\", loanId, \"1000\", txnExternalIdStr);\n\n        // Check whether the provided external id was retrieved\n        assertEquals(txnExternalIdStr, disbursedLoanResult.get(\"subResourceExternalId\"));\n\n        // Second loan\n        final HashMap loan2 = applyForLoanApplication(client.getClientId().intValue(), loanProductID, null);\n        Integer loan2Id = (Integer) loan2.get(\"resourceId\");\n        this.loanTransactionHelper.approveLoan(\"02 September 2022\", loan2Id);\n        final HashMap disbursedLoan2Result = this.loanTransactionHelper.disburseLoan(\"03 September 2022\", loan2Id, \"1000\", null);\n\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 7);\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        String penalty1LoanChargeExternalId = UUID.randomUUID().toString();\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loan2Id,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\",\n                        penalty1LoanChargeExternalId));\n\n        // NEGATIVE SCENARIOS\n\n        // GET\n        CallFailedRuntimeException exception = assertThrows(CallFailedRuntimeException.class, () -> this.loanTransactionHelper\n                .retrieveTransactionTemplate(\"randomNonExistingLoanExternalId\", \"disburse\", null, null, null));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loan.external.id.invalid\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class, () -> this.loanTransactionHelper\n                .getLoanTransactionDetails(\"randomNonExistingLoanExternalId\", \"randomNonExistingLoanTransactionExternalId\"));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loan.external.id.invalid\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class, () -> this.loanTransactionHelper\n                .getLoanTransactionDetails(loanExternalIdStr, \"randomNonExistingLoanTransactionExternalId\"));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loan.transaction.external.id.invalid\"));\n\n        // POST\n        exception = assertThrows(CallFailedRuntimeException.class, () -> this.loanTransactionHelper\n                .makeChargeRefund(\"randomNonExistingLoanExternalId\", new PostLoansLoanIdTransactionsRequest()));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loan.external.id.invalid\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class,\n                () -> this.loanTransactionHelper.adjustLoanTransaction(\"randomNonExistingLoanExternalId\",\n                        \"randomNonExistingLoanTransactionExternalId\", new PostLoansLoanIdTransactionsTransactionIdRequest()));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loan.external.id.invalid\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class, () -> this.loanTransactionHelper.adjustLoanTransaction(loanExternalIdStr,\n                \"randomNonExistingLoanTransactionExternalId\", new PostLoansLoanIdTransactionsTransactionIdRequest()));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loan.transaction.external.id.invalid\"));\n\n        // PUT\n        exception = assertThrows(CallFailedRuntimeException.class,\n                () -> this.loanTransactionHelper.undoWaiveLoanCharge(\"randomNonExistingLoanExternalId\",\n                        \"randomNonExistingLoanTransactionExternalId\", new PutChargeTransactionChangesRequest()));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loan.external.id.invalid\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class, () -> this.loanTransactionHelper.undoWaiveLoanCharge(loanExternalIdStr,\n                \"randomNonExistingLoanTransactionExternalId\", new PutChargeTransactionChangesRequest()));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loan.transaction.external.id.invalid\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class,\n                () -> this.loanTransactionHelper.getLoanCharges(\"randomNonExistingLoanExternalId\"));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loan.external.id.invalid\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class,\n                () -> this.loanTransactionHelper.getLoanChargeTemplate(\"randomNonExistingLoanExternalId\"));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loan.external.id.invalid\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class,\n                () -> this.loanTransactionHelper.getLoanCharge(\"randomNonExistingLoanExternalId\", \"randomNonExistingLoanChargeExternalId\"));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loan.external.id.invalid\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class,\n                () -> this.loanTransactionHelper.getLoanCharge(-1L, (long) penalty1LoanChargeId));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loanCharge.id.invalid.for.given.loan\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class,\n                () -> this.loanTransactionHelper.getLoanCharge(loanExternalIdStr, (long) penalty1LoanChargeId));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loanCharge.id.invalid.for.given.loan\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class,\n                () -> this.loanTransactionHelper.getLoanCharge(loanExternalIdStr, \"randomNonExistingLoanChargeExternalId\"));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loanCharge.external.id.invalid\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class,\n                () -> this.loanTransactionHelper.payLoanCharge(\"randomNonExistingLoanExternalId\", \"randomNonExistingLoanChargeExternalId\",\n                        new PostLoansLoanIdChargesChargeIdRequest()));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loan.external.id.invalid\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class, () -> this.loanTransactionHelper.payLoanCharge(loanExternalIdStr,\n                \"randomNonExistingLoanChargeExternalId\", new PostLoansLoanIdChargesChargeIdRequest()));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loanCharge.external.id.invalid\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class,\n                () -> this.loanTransactionHelper.updateLoanCharge(\"randomNonExistingLoanExternalId\",\n                        \"randomNonExistingLoanChargeExternalId\", new PutLoansLoanIdChargesChargeIdRequest()));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loan.external.id.invalid\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class, () -> this.loanTransactionHelper.updateLoanCharge(loanExternalIdStr,\n                \"randomNonExistingLoanChargeExternalId\", new PutLoansLoanIdChargesChargeIdRequest()));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loanCharge.external.id.invalid\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class, () -> this.loanTransactionHelper\n                .deleteLoanCharge(\"randomNonExistingLoanExternalId\", \"randomNonExistingLoanChargeExternalId\"));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loan.external.id.invalid\"));\n\n        exception = assertThrows(CallFailedRuntimeException.class,\n                () -> this.loanTransactionHelper.deleteLoanCharge(loanExternalIdStr, \"randomNonExistingLoanChargeExternalId\"));\n        assertEquals(404, exception.getResponse().code());\n        assertTrue(exception.getMessage().contains(\"error.msg.loanCharge.external.id.invalid\"));\n    }"}
{"prompt": "Create a test that tests loan", "completion": "    @Test\n    public void loan() {\n\n        GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(requestSpec, responseSpec, 50, true);\n        GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n        new BusinessDateHelper().updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                .date(\"2022.10.10\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n        try {\n            ArrayList<Integer> rangeIds = new ArrayList<>();\n            // First Range\n            String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n            PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec,\n                    responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n            jsonRange = DelinquencyRangesHelper.getAsJSON(4, 60);\n\n            GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                    delinquencyRangeResponse.getResourceId());\n\n            // Second Range\n            delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n\n            String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n            PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                    responseSpec, jsonBucket);\n\n            final String loanProductJSON = new LoanProductTestBuilder().withPrincipal(\"1000\").withRepaymentTypeAsMonth()\n                    .withRepaymentAfterEvery(\"1\").withNumberOfRepayments(\"1\").withRepaymentTypeAsMonth().withinterestRatePerPeriod(\"0\")\n                    .withInterestRateFrequencyTypeAsMonths().withAmortizationTypeAsEqualPrincipalPayment()\n                    .withInterestTypeAsDecliningBalance().withAccountingRuleAsNone()\n                    .withInterestCalculationPeriodTypeAsRepaymentPeriod(true).withDaysInMonth(\"30\").withDaysInYear(\"365\")\n                    .withMoratorium(\"0\", \"0\").withDelinquencyBucket(delinquencyBucketResponse.getResourceId())\n                    .withInArrearsTolerance(\"1001\").withMultiDisburse().withDisallowExpectedDisbursements(true).build(null);\n            final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJSON);\n\n            final PostClientsResponse client = clientHelper.createClient(ClientHelper.defaultClientCreationRequest());\n\n            String loanExternalIdStr = UUID.randomUUID().toString();\n            final HashMap loan = applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr);\n            Integer loanId = (Integer) loan.get(\"resourceId\");\n            String resourceExternalId = (String) loan.get(\"resourceExternalId\");\n            assertEquals(loanExternalIdStr, resourceExternalId);\n\n            LocalDate actualDate = LocalDate.of(2022, 10, 10);\n\n            GetLoansApprovalTemplateResponse loanApprovalResult = this.loanTransactionHelper.getLoanApprovalTemplate(loanExternalIdStr);\n            assertEquals(actualDate, loanApprovalResult.getApprovalDate());\n            assertEquals(1000.0, loanApprovalResult.getApprovalAmount());\n            assertEquals(1000.0, loanApprovalResult.getNetDisbursalAmount());\n\n            GetLoansLoanIdResponse loanDetailsResult = this.loanTransactionHelper.getLoanDetails(loanExternalIdStr);\n            assertEquals(loanExternalIdStr, loanDetailsResult.getExternalId());\n\n            this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanId);\n            String txnExternalIdStr = UUID.randomUUID().toString();\n            final HashMap disbursedLoanResult = this.loanTransactionHelper.disburseLoan(\"03 September 2022\", loanId, \"1000\",\n                    txnExternalIdStr);\n\n            // Check whether the provided external id was retrieved\n            assertEquals(txnExternalIdStr, disbursedLoanResult.get(\"subResourceExternalId\"));\n\n            String txnExternalIdStr2 = UUID.randomUUID().toString();\n            final HashMap disbursedLoanResult2 = this.loanTransactionHelper.disburseLoan(\"04 September 2022\", loanId, \"1000\",\n                    txnExternalIdStr2);\n\n            // Check whether the provided external id was retrieved\n            assertEquals(txnExternalIdStr2, disbursedLoanResult2.get(\"subResourceExternalId\"));\n\n            PutLoansLoanIdResponse markLoanAsFraudResult = this.loanTransactionHelper.modifyLoanApplication(loanExternalIdStr,\n                    \"markAsFraud\", new PutLoansLoanIdRequest().fraud(true));\n            assertEquals(loanExternalIdStr, markLoanAsFraudResult.getResourceExternalId());\n\n            List<GetDelinquencyTagHistoryResponse> delinquencyTagHistoryResponseResult = this.loanTransactionHelper\n                    .getLoanDelinquencyTags(loanExternalIdStr);\n            assertEquals(1, delinquencyTagHistoryResponseResult.size());\n            assertEquals((long) loanId, delinquencyTagHistoryResponseResult.get(0).getLoanId());\n\n            String loanExternalIdStr2 = UUID.randomUUID().toString();\n            applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr2);\n\n            PutLoansLoanIdResponse modifyLoanApplicationResult = this.loanTransactionHelper.modifyLoanApplication(loanExternalIdStr2,\n                    \"modify\",\n                    new PutLoansLoanIdRequest().submittedOnDate(\"31 August 2022\").dateFormat(\"dd MMMM yyyy\").locale(\"en\")\n                            .loanType(\"individual\").productId(loanProductID).clientId(client.getClientId()).interestType(0)\n                            .interestCalculationPeriodType(1).interestRatePerPeriod(0).isEqualAmortization(false).loanTermFrequency(30)\n                            .loanTermFrequencyType(0).maxOutstandingLoanBalance(10000L).numberOfRepayments(1).principal(10000L)\n                            .repaymentEvery(30).repaymentFrequencyType(0).transactionProcessingStrategyCode(\"mifos-standard-strategy\")\n                            .expectedDisbursementDate(\"2 September 2022\").amortizationType(1));\n\n            assertEquals(loanExternalIdStr2, modifyLoanApplicationResult.getResourceExternalId());\n            DeleteLoansLoanIdResponse deleteLoanApplicationResult = this.loanTransactionHelper.deleteLoanApplication(loanExternalIdStr2);\n            assertEquals(loanExternalIdStr2, deleteLoanApplicationResult.getResourceExternalId());\n\n            String loanExternalIdStr3 = UUID.randomUUID().toString();\n            applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr3);\n            PostLoansLoanIdResponse result = this.loanTransactionHelper.rejectLoan(loanExternalIdStr3,\n                    new PostLoansLoanIdRequest().rejectedOnDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            assertEquals(loanExternalIdStr3, result.getResourceExternalId());\n\n            String loanExternalIdStr4 = UUID.randomUUID().toString();\n            applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr4);\n            result = this.loanTransactionHelper.withdrawnByApplicantLoan(loanExternalIdStr4,\n                    new PostLoansLoanIdRequest().withdrawnOnDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            assertEquals(loanExternalIdStr4, result.getResourceExternalId());\n\n            String loanExternalIdStr5 = UUID.randomUUID().toString();\n            applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr5);\n            this.loanTransactionHelper.approveLoan(loanExternalIdStr5,\n                    new PostLoansLoanIdRequest().approvedOnDate(\"2 September 2022\").approvedLoanAmount(new BigDecimal(\"1000\"))\n                            .expectedDisbursementDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            result = this.loanTransactionHelper.disburseLoan(loanExternalIdStr5,\n                    new PostLoansLoanIdRequest().actualDisbursementDate(\"2 September 2022\").transactionAmount(new BigDecimal(\"1000\"))\n                            .locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            // It's commented out for now, till it got fixed to return the loan externalId as well\n            // assertEquals(loanExternalIdStr5, result.getResourceExternalId());\n\n            String loanExternalIdStr6 = UUID.randomUUID().toString();\n            applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr6);\n            this.loanTransactionHelper.approveLoan(loanExternalIdStr6,\n                    new PostLoansLoanIdRequest().approvedOnDate(\"2 September 2022\").approvedLoanAmount(new BigDecimal(\"1000\"))\n                            .expectedDisbursementDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            result = this.loanTransactionHelper.undoApprovalLoan(loanExternalIdStr6, new PostLoansLoanIdRequest());\n            assertEquals(loanExternalIdStr6, result.getResourceExternalId());\n\n            final Integer savingsId = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec,\n                    client.getClientId().intValue(), \"10000.0\");\n\n            String loanExternalIdStr7 = UUID.randomUUID().toString();\n            applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr7, savingsId.toString());\n            this.loanTransactionHelper.approveLoan(loanExternalIdStr7,\n                    new PostLoansLoanIdRequest().approvedOnDate(\"2 September 2022\").approvedLoanAmount(new BigDecimal(\"1000\"))\n                            .expectedDisbursementDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            result = this.loanTransactionHelper.disburseToSavingsLoan(loanExternalIdStr7,\n                    new PostLoansLoanIdRequest().actualDisbursementDate(\"2 September 2022\").transactionAmount(new BigDecimal(\"1000\"))\n                            .locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            assertEquals(loanExternalIdStr7, result.getResourceExternalId());\n\n            String loanExternalIdStr8 = UUID.randomUUID().toString();\n            applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr8);\n            this.loanTransactionHelper.approveLoan(loanExternalIdStr8,\n                    new PostLoansLoanIdRequest().approvedOnDate(\"2 September 2022\").approvedLoanAmount(new BigDecimal(\"1000\"))\n                            .expectedDisbursementDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            this.loanTransactionHelper.disburseLoan(loanExternalIdStr8,\n                    new PostLoansLoanIdRequest().actualDisbursementDate(\"2 September 2022\").transactionAmount(new BigDecimal(\"1000\"))\n                            .locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            result = this.loanTransactionHelper.undoDisbursalLoan(loanExternalIdStr8, new PostLoansLoanIdRequest());\n            assertEquals(loanExternalIdStr8, result.getResourceExternalId());\n\n            String loanExternalIdStr9 = UUID.randomUUID().toString();\n            applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr9);\n            this.loanTransactionHelper.approveLoan(loanExternalIdStr9,\n                    new PostLoansLoanIdRequest().approvedOnDate(\"2 September 2022\").approvedLoanAmount(new BigDecimal(\"1000\"))\n                            .expectedDisbursementDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            this.loanTransactionHelper.disburseLoan(loanExternalIdStr9,\n                    new PostLoansLoanIdRequest().actualDisbursementDate(\"2 September 2022\").transactionAmount(new BigDecimal(\"1000\"))\n                            .locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            this.loanTransactionHelper.disburseLoan(loanExternalIdStr9,\n                    new PostLoansLoanIdRequest().actualDisbursementDate(\"3 September 2022\").transactionAmount(new BigDecimal(\"1000\"))\n                            .locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            result = this.loanTransactionHelper.undoLastDisbursalLoan(loanExternalIdStr9, new PostLoansLoanIdRequest());\n            assertEquals(loanExternalIdStr9, result.getResourceExternalId());\n\n            Integer loanOfficerId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n            String loanExternalIdStr10 = UUID.randomUUID().toString();\n            applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr10);\n            result = this.loanTransactionHelper.assignLoanOfficerLoan(loanExternalIdStr10, new PostLoansLoanIdRequest()\n                    .assignmentDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\").toLoanOfficerId(loanOfficerId));\n            assertEquals(loanExternalIdStr10, result.getResourceExternalId());\n            result = this.loanTransactionHelper.unassignLoanOfficerLoan(loanExternalIdStr10,\n                    new PostLoansLoanIdRequest().unassignedDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            assertEquals(loanExternalIdStr10, result.getResourceExternalId());\n\n            String loanExternalIdStr11 = UUID.randomUUID().toString();\n            applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr11);\n            result = this.loanTransactionHelper.recoverGuaranteesLoan(loanExternalIdStr11, new PostLoansLoanIdRequest());\n            assertEquals(loanExternalIdStr11, result.getResourceExternalId());\n\n            String loanExternalIdStr12 = UUID.randomUUID().toString();\n            applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr12);\n            result = this.loanTransactionHelper.assignDelinquencyLoan(loanExternalIdStr12, new PostLoansLoanIdRequest());\n            assertEquals(loanExternalIdStr12, result.getResourceExternalId());\n\n            String loanExternalIdStr13 = UUID.randomUUID().toString();\n            applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr13);\n            result = this.loanTransactionHelper.approveLoan(loanExternalIdStr13,\n                    new PostLoansLoanIdRequest().approvedOnDate(\"2 September 2022\").approvedLoanAmount(new BigDecimal(\"1000\"))\n                            .expectedDisbursementDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            assertEquals(loanExternalIdStr13, result.getResourceExternalId());\n\n            PostLoansLoanIdTransactionsResponse closeRescheduleResult = this.loanTransactionHelper.closeRescheduledLoan(loanExternalIdStr13,\n                    new PostLoansLoanIdTransactionsRequest().transactionDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            assertEquals(loanExternalIdStr13, closeRescheduleResult.getResourceExternalId());\n\n            String loanExternalIdStr14 = UUID.randomUUID().toString();\n            applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr14);\n            String transactionExternalId = UUID.randomUUID().toString();\n            result = this.loanTransactionHelper.approveLoan(loanExternalIdStr14,\n                    new PostLoansLoanIdRequest().approvedOnDate(\"2 September 2022\").approvedLoanAmount(new BigDecimal(\"1000\"))\n                            .expectedDisbursementDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            assertEquals(loanExternalIdStr14, result.getResourceExternalId());\n            this.loanTransactionHelper.disburseLoan(loanExternalIdStr14,\n                    new PostLoansLoanIdRequest().actualDisbursementDate(\"2 September 2022\").transactionAmount(new BigDecimal(\"1000\"))\n                            .locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            PostLoansLoanIdTransactionsResponse closeResult = this.loanTransactionHelper.closeLoan(loanExternalIdStr14,\n                    new PostLoansLoanIdTransactionsRequest().transactionDate(\"3 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\")\n                            .externalId(transactionExternalId));\n            assertEquals(transactionExternalId, closeResult.getResourceExternalId());\n\n            String loanExternalIdStr15 = UUID.randomUUID().toString();\n            String transactionExternalId2 = UUID.randomUUID().toString();\n            applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr15);\n            result = this.loanTransactionHelper.approveLoan(loanExternalIdStr15,\n                    new PostLoansLoanIdRequest().approvedOnDate(\"2 September 2022\").approvedLoanAmount(new BigDecimal(\"1000\"))\n                            .expectedDisbursementDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            this.loanTransactionHelper.disburseLoan(loanExternalIdStr15,\n                    new PostLoansLoanIdRequest().actualDisbursementDate(\"2 September 2022\").transactionAmount(new BigDecimal(\"1000\"))\n                            .locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            assertEquals(loanExternalIdStr15, result.getResourceExternalId());\n            PostLoansLoanIdTransactionsResponse forecloseResult = this.loanTransactionHelper.forecloseLoan(loanExternalIdStr15,\n                    new PostLoansLoanIdTransactionsRequest().transactionDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\")\n                            .externalId(transactionExternalId2));\n            assertEquals(transactionExternalId2, forecloseResult.getResourceExternalId());\n\n            String loanExternalIdStr16 = UUID.randomUUID().toString();\n            String transactionExternalId3 = UUID.randomUUID().toString();\n            applyForLoanApplication(client.getClientId().intValue(), loanProductID, loanExternalIdStr16);\n            this.loanTransactionHelper.approveLoan(loanExternalIdStr16,\n                    new PostLoansLoanIdRequest().approvedOnDate(\"2 September 2022\").approvedLoanAmount(new BigDecimal(\"1000\"))\n                            .expectedDisbursementDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            this.loanTransactionHelper.disburseLoan(loanExternalIdStr16,\n                    new PostLoansLoanIdRequest().actualDisbursementDate(\"2 September 2022\").transactionAmount(new BigDecimal(\"1000\"))\n                            .locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            this.loanTransactionHelper.disburseLoan(loanExternalIdStr16,\n                    new PostLoansLoanIdRequest().actualDisbursementDate(\"2 September 2022\").transactionAmount(new BigDecimal(\"1000\"))\n                            .locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n            PostLoansLoanIdTransactionsResponse chargeOffResult = this.loanTransactionHelper.chargeOffLoan(loanExternalIdStr16,\n                    new PostLoansLoanIdTransactionsRequest().transactionDate(\"2 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\")\n                            .externalId(transactionExternalId3));\n            assertEquals(transactionExternalId3, chargeOffResult.getResourceExternalId());\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(requestSpec, responseSpec, 50, false);\n        }\n    }"}
{"prompt": "Create a test that tests test External Services Configuration", "completion": "    @Test\n    public void testExternalServicesConfiguration() {\n        this.externalServicesConfigurationHelper = new ExternalServicesConfigurationHelper(this.requestSpec, this.responseSpec);\n\n        // Checking for S3\n        String configName = \"s3_access_key\";\n        ArrayList<HashMap> externalServicesConfig = ExternalServicesConfigurationHelper\n                .getExternalServicesConfigurationByServiceName(requestSpec, responseSpec, \"S3\");\n        Assertions.assertNotNull(externalServicesConfig);\n        for (Integer configIndex = 0; configIndex < externalServicesConfig.size(); configIndex++) {\n            String name = (String) externalServicesConfig.get(configIndex).get(\"name\");\n            String value = null;\n            if (name.equals(configName)) {\n                value = (String) externalServicesConfig.get(configIndex).get(\"value\");\n                if (value == null) {\n                    value = \"testnull\";\n                }\n                String newValue = \"test\";\n                LOG.info(\"{} : {}\", name, value);\n                HashMap arrayListValue = ExternalServicesConfigurationHelper.updateValueForExternaServicesConfiguration(requestSpec,\n                        responseSpec, \"S3\", name, newValue);\n                Assertions.assertNotNull(arrayListValue.get(\"value\"));\n                Assertions.assertEquals(arrayListValue.get(\"value\"), newValue);\n                HashMap arrayListValue1 = ExternalServicesConfigurationHelper.updateValueForExternaServicesConfiguration(requestSpec,\n                        responseSpec, \"S3\", name, value);\n                Assertions.assertNotNull(arrayListValue1.get(\"value\"));\n                Assertions.assertEquals(arrayListValue1.get(\"value\"), value);\n            }\n\n        }\n\n        // Checking for SMTP:\n\n        configName = \"username\";\n        externalServicesConfig = ExternalServicesConfigurationHelper.getExternalServicesConfigurationByServiceName(requestSpec,\n                responseSpec, \"SMTP\");\n        Assertions.assertNotNull(externalServicesConfig);\n\n        for (Integer configIndex = 0; configIndex < externalServicesConfig.size(); configIndex++) {\n            String name = (String) externalServicesConfig.get(configIndex).get(\"name\");\n            String value = null;\n            if (name.equals(configName)) {\n                value = (String) externalServicesConfig.get(configIndex).get(\"value\");\n                if (value == null) {\n                    value = \"testnull\";\n                }\n                String newValue = \"test\";\n                LOG.info(\"{} : {}\", name, value);\n                HashMap arrayListValue = ExternalServicesConfigurationHelper.updateValueForExternaServicesConfiguration(requestSpec,\n                        responseSpec, \"SMTP\", name, newValue);\n                Assertions.assertNotNull(arrayListValue.get(\"value\"));\n                Assertions.assertEquals(arrayListValue.get(\"value\"), newValue);\n                HashMap arrayListValue1 = ExternalServicesConfigurationHelper.updateValueForExternaServicesConfiguration(requestSpec,\n                        responseSpec, \"SMTP\", name, value);\n                Assertions.assertNotNull(arrayListValue1.get(\"value\"));\n                Assertions.assertEquals(arrayListValue1.get(\"value\"), value);\n            }\n\n        }\n\n    }"}
{"prompt": "Create a test that tests test Financial Activity Accounts", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testFinancialActivityAccounts() {\n\n        /** Create a Liability and an Asset Transfer Account **/\n        Account liabilityTransferAccount = accountHelper.createLiabilityAccount();\n        Account assetTransferAccount = accountHelper.createAssetAccount();\n        Assertions.assertNotNull(assetTransferAccount);\n        Assertions.assertNotNull(liabilityTransferAccount);\n\n        /*** Create A Financial Activity to Account Mapping **/\n        Integer financialActivityAccountId = (Integer) financialActivityAccountHelper.createFinancialActivityAccount(\n                LIABILITY_TRANSFER_FINANCIAL_ACTIVITY_ID, liabilityTransferAccount.getAccountID(), responseSpec,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(financialActivityAccountId);\n\n        /***\n         * Fetch Created Financial Activity to Account Mapping and validate created values\n         **/\n        assertFinancialActivityAccountCreation(financialActivityAccountId, LIABILITY_TRANSFER_FINANCIAL_ACTIVITY_ID,\n                liabilityTransferAccount);\n\n        /**\n         * Update Existing Financial Activity to Account Mapping and assert changes\n         **/\n        Account newLiabilityTransferAccount = accountHelper.createLiabilityAccount();\n        Assertions.assertNotNull(newLiabilityTransferAccount);\n\n        HashMap changes = (HashMap) financialActivityAccountHelper.updateFinancialActivityAccount(financialActivityAccountId,\n                LIABILITY_TRANSFER_FINANCIAL_ACTIVITY_ID, newLiabilityTransferAccount.getAccountID(), responseSpec,\n                CommonConstants.RESPONSE_CHANGES);\n        Assertions.assertEquals(newLiabilityTransferAccount.getAccountID(), changes.get(\"glAccountId\"));\n\n        /** Validate update works correctly **/\n        assertFinancialActivityAccountCreation(financialActivityAccountId, LIABILITY_TRANSFER_FINANCIAL_ACTIVITY_ID,\n                newLiabilityTransferAccount);\n\n        /** Update with Invalid Financial Activity should fail **/\n        List<HashMap> invalidFinancialActivityUpdateError = (List<HashMap>) financialActivityAccountHelper.updateFinancialActivityAccount(\n                financialActivityAccountId, 232, newLiabilityTransferAccount.getAccountID(), responseSpecForValidationError,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"validation.msg.financialactivityaccount.financialActivityId.is.not.one.of.expected.enumerations\",\n                invalidFinancialActivityUpdateError.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        /** Creating Duplicate Financial Activity should fail **/\n        List<HashMap> duplicateFinancialActivityAccountError = (List<HashMap>) financialActivityAccountHelper\n                .createFinancialActivityAccount(LIABILITY_TRANSFER_FINANCIAL_ACTIVITY_ID, liabilityTransferAccount.getAccountID(),\n                        responseSpecForDomainRuleViolation, CommonConstants.RESPONSE_ERROR);\n        assertEquals(DuplicateFinancialActivityAccountFoundException.getErrorcode(),\n                duplicateFinancialActivityAccountError.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        /**\n         * Associating incorrect GL account types with a financial activity should fail\n         **/\n        List<HashMap> invalidFinancialActivityAccountError = (List<HashMap>) financialActivityAccountHelper.updateFinancialActivityAccount(\n                financialActivityAccountId, assetTransferFinancialActivityId, newLiabilityTransferAccount.getAccountID(),\n                responseSpecForDomainRuleViolation, CommonConstants.RESPONSE_ERROR);\n        assertEquals(FinancialActivityAccountInvalidException.getErrorcode(),\n                invalidFinancialActivityAccountError.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        /** Should be able to delete a Financial Activity to Account Mapping **/\n        Integer deletedFinancialActivityAccountId = financialActivityAccountHelper\n                .deleteFinancialActivityAccount(financialActivityAccountId, responseSpec, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(deletedFinancialActivityAccountId);\n        Assertions.assertEquals(financialActivityAccountId, deletedFinancialActivityAccountId);\n\n        /*** Trying to fetch a Deleted Account Mapping should give me a 404 **/\n        financialActivityAccountHelper.getFinancialActivityAccount(deletedFinancialActivityAccountId, responseSpecForResourceNotFoundError);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Product Creation", "completion": "    @Test\n    public void testFixedDepositProductCreation() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n\n        /***\n         * Create GL Accounts for product account mapping\n         */\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        final String accountingRule = CASH_BASED;\n        /***\n         * Create FD product with charts (must be 200 OK)\n         */\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount, liabilityAccount,\n                incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        /***\n         * Create FD product without charts (must be 400 Bad Request)\n         */\n        this.responseSpec = new ResponseSpecBuilder().expectStatusCode(400).build();\n        createFixedDepositProductWithoutCharts(VALID_FROM, VALID_TO, accountingRule, assetAccount, liabilityAccount, incomeAccount,\n                expenseAccount);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Premature Closure Type Withdrawal", "completion": "    @Test\n    public void testFixedDepositAccountWithPrematureClosureTypeWithdrawal() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        /***\n         * Create GL Accounts for product account mapping\n         */\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        final String CLOSED_ON_DATE = dateFormat.format(Calendar.getInstance().getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        /***\n         * Create FD product with CashBased accounting enabled\n         */\n        final String accountingRule = CASH_BASED;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount, liabilityAccount,\n                incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        /***\n         * Apply for FD account with created product and verify status\n         */\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        /***\n         * Approve the FD account and verify whether account is approved\n         */\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        /***\n         * Activate the FD Account and verify whether account is activated\n         */\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n\n        Float depositAmount = (Float) accountSummary.get(\"totalDeposits\");\n\n        /***\n         * Verify journal entries posted for initial deposit transaction which happened at activation time\n         */\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, ACTIVATION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, ACTIVATION_DATE, liablilityAccountInitialEntry);\n\n        /***\n         * Update interest earned of FD account\n         */\n        fixedDepositAccountId = this.fixedDepositAccountHelper.calculateInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        /***\n         * Post interest and verify the account summary\n         */\n        Integer transactionIdForPostInterest = this.fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n\n        /***\n         * Verify journal entries transactions for interest posting transaction\n         */\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n        this.fixedDepositAccountHelper.calculatePrematureAmountForFixedDeposit(fixedDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.fixedDepositAccountHelper.prematureCloseForFixedDeposit(\n                fixedDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsPrematureClosed(fixedDepositAccountStatusHashMap);\n\n        /***\n         * Verify journal entry transactions for preclosure transaction\n         */\n        HashMap accountDetails = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float maturityAmount = Float.valueOf(accountDetails.get(\"maturityAmount\").toString());\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.DEBIT));\n\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Premature Closure Type Withdrawal WITH HOLD TAX", "completion": "    @Test\n    public void testFixedDepositAccountWithPrematureClosureTypeWithdrawal_WITH_HOLD_TAX() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        /***\n         * Create GL Accounts for product account mapping\n         */\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n        final Account liabilityAccountForTax = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        final String CLOSED_ON_DATE = dateFormat.format(Calendar.getInstance().getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        /***\n         * Create FD product with CashBased accounting enabled\n         */\n        final String accountingRule = CASH_BASED;\n        final Integer taxGroupId = createTaxGroup(\"10\", liabilityAccountForTax);\n        Integer fixedDepositProductId = createFixedDepositProductWithWithHoldTax(VALID_FROM, VALID_TO, String.valueOf(taxGroupId),\n                accountingRule, assetAccount, liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        /***\n         * Apply for FD account with created product and verify status\n         */\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        /***\n         * Approve the FD account and verify whether account is approved\n         */\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        /***\n         * Activate the FD Account and verify whether account is activated\n         */\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n\n        Float depositAmount = (Float) accountSummary.get(\"totalDeposits\");\n\n        /***\n         * Verify journal entries posted for initial deposit transaction which happened at activation time\n         */\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, ACTIVATION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, ACTIVATION_DATE, liablilityAccountInitialEntry);\n\n        /***\n         * Update interest earned of FD account\n         */\n        fixedDepositAccountId = this.fixedDepositAccountHelper.calculateInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        /***\n         * Post interest and verify the account summary\n         */\n        Integer transactionIdForPostInterest = this.fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n        Assertions.assertNull(accountSummary.get(\"totalWithholdTax\"));\n\n        /***\n         * Verify journal entries transactions for interest posting transaction\n         */\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n        this.fixedDepositAccountHelper.calculatePrematureAmountForFixedDeposit(fixedDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.fixedDepositAccountHelper.prematureCloseForFixedDeposit(\n                fixedDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsPrematureClosed(fixedDepositAccountStatusHashMap);\n\n        /***\n         * Verify journal entry transactions for preclosure transaction\n         */\n        HashMap accountDetails = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float maturityAmount = Float.valueOf(accountDetails.get(\"maturityAmount\").toString());\n\n        HashMap summary = (HashMap) accountDetails.get(\"summary\");\n        Assertions.assertNotNull(summary.get(\"totalWithholdTax\"));\n        Float withHoldTax = (Float) summary.get(\"totalWithholdTax\");\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccountForTax, CLOSED_ON_DATE,\n                new JournalEntry(withHoldTax, JournalEntry.TransactionType.CREDIT));\n\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account Closure Type Withdrawal WITH HOLD TAX", "completion": "    @Test\n    public void testFixedDepositAccountClosureTypeWithdrawal_WITH_HOLD_TAX() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        /***\n         * Create GL Accounts for product account mapping\n         */\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n        final Account liabilityAccountForTax = this.accountHelper.createLiabilityAccount();\n\n        DateTimeFormatter monthDayFormat = new DateTimeFormatterBuilder().appendPattern(\"dd MMM\").toFormatter();\n        DateTimeFormatter currentDateFormat = new DateTimeFormatterBuilder().appendPattern(\"dd\").toFormatter();\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(20);\n        final String VALID_FROM = Utils.dateFormatter.format(todaysDate);\n        todaysDate = todaysDate.plusYears(10);\n        final String VALID_TO = Utils.dateFormatter.format(todaysDate);\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(20);\n        final String SUBMITTED_ON_DATE = Utils.dateFormatter.format(todaysDate);\n        final String APPROVED_ON_DATE = Utils.dateFormatter.format(todaysDate);\n        final String ACTIVATION_DATE = Utils.dateFormatter.format(todaysDate);\n\n        LocalDate closedOn = todaysDate.plusMonths(14);\n        final String CLOSED_ON_DATE = Utils.dateFormatter.format(closedOn);\n\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        /***\n         * Create FD product with CashBased accounting enabled\n         */\n        final Integer taxGroupId = createTaxGroup(\"10\", liabilityAccountForTax);\n        Integer fixedDepositProductId = createFixedDepositProductWithWithHoldTax(VALID_FROM, VALID_TO, String.valueOf(taxGroupId),\n                CASH_BASED, assetAccount, liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        /***\n         * Apply for FD account with created product and verify status\n         */\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        /***\n         * Approve the FD account and verify whether account is approved\n         */\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        /***\n         * Activate the FD Account and verify whether account is activated\n         */\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n\n        Float depositAmount = (Float) accountSummary.get(\"totalDeposits\");\n\n        /***\n         * Verify journal entries posted for initial deposit transaction which happened at activation time\n         */\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liabilityAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, ACTIVATION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, ACTIVATION_DATE, liabilityAccountInitialEntry);\n\n        /***\n         * Update interest earned of FD account\n         */\n        fixedDepositAccountId = this.fixedDepositAccountHelper.calculateInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        /***\n         * Post interest and verify the account summary\n         */\n        Integer transactionIdForPostInterest = this.fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n        accountSummary.get(\"totalInterestPosted\");\n        Assertions.assertNull(accountSummary.get(\"totalWithholdTax\"));\n\n        /***\n         * FD account verify whether account is matured\n         */\n\n        SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n        String JobName = \"Update Deposit Accounts Maturity details\";\n        schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        HashMap accountDetails = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        HashMap summary = (HashMap) accountDetails.get(\"summary\");\n        Assertions.assertNotNull(summary.get(\"totalWithholdTax\"));\n        Float withHoldTax = (Float) summary.get(\"totalWithholdTax\");\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccountForTax, CLOSED_ON_DATE,\n                new JournalEntry(withHoldTax, JournalEntry.TransactionType.CREDIT));\n\n        fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsMatured(fixedDepositAccountStatusHashMap);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Period Interest Rate Chart", "completion": "    @Test\n    public void testFixedDepositAccountWithPeriodInterestRateChart() {\n        final String chartToUse = \"period\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 6.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Period Interest Rate Chart AMOUNT VARIATION", "completion": "    @Test\n    public void testFixedDepositAccountWithPeriodInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"period\";\n        final String depositAmount = \"2000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 6.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Period Interest Rate Chart PERIOD VARIATION", "completion": "    @Test\n    public void testFixedDepositAccountWithPeriodInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"period\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"18\";\n        final Float interestRate = (float) 7.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Amount Interest Rate Chart", "completion": "    @Test\n    public void testFixedDepositAccountWithAmountInterestRateChart() {\n        final String chartToUse = \"amount\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 7.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Amount Interest Rate Chart AMOUNT VARIATION", "completion": "    @Test\n    public void testFixedDepositAccountWithAmountInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"amount\";\n        final String depositAmount = \"5000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 5.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Amount Interest Rate Chart PERIOD VARIATION", "completion": "    @Test\n    public void testFixedDepositAccountWithAmountInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"amount\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"26\";\n        final Float interestRate = (float) 7.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Period And Amount Interest Rate Chart", "completion": "    @Test\n    public void testFixedDepositAccountWithPeriodAndAmountInterestRateChart() {\n        final String chartToUse = \"period_amount\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 7.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Period And Amount Interest Rate Chart AMOUNT VARIATION", "completion": "    @Test\n    public void testFixedDepositAccountWithPeriodAndAmountInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"period_amount\";\n        final String depositAmount = \"5000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 6.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Period And Amount Interest Rate Chart PERIOD VARIATION", "completion": "    @Test\n    public void testFixedDepositAccountWithPeriodAndAmountInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"period_amount\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"20\";\n        final Float interestRate = (float) 9.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Amount And Period Interest Rate Chart", "completion": "    @Test\n    public void testFixedDepositAccountWithAmountAndPeriodInterestRateChart() {\n        final String chartToUse = \"amount_period\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 8.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Amount And Period Interest Rate Chart AMOUNT VARIATION", "completion": "    @Test\n    public void testFixedDepositAccountWithAmountAndPeriodInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"amount_period\";\n        final String depositAmount = \"5000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = (float) 6.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Amount And Period Interest Rate Chart PERIOD VARIATION", "completion": "    @Test\n    public void testFixedDepositAccountWithAmountAndPeriodInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"amount_period\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"6\";\n        final Float interestRate = (float) 7.0;\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Premature Closure Type Transfer To Savings", "completion": "    @Test\n    public void testFixedDepositAccountWithPrematureClosureTypeTransferToSavings() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        /***\n         * Create GL Accounts for product account mapping\n         */\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        final String CLOSED_ON_DATE = dateFormat.format(Calendar.getInstance().getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        /***\n         * Create Savings product with CashBased accounting enabled\n         */\n        final String accountingRule = CASH_BASED;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE, accountingRule,\n                assetAccount, liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientId, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        /***\n         * Create FD product with CashBased accounting enabled\n         */\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount, liabilityAccount,\n                incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n\n        Float depositAmount = (Float) accountSummary.get(\"totalDeposits\");\n\n        /***\n         * Verify journal entries posted for initial deposit transaction which happened at activation time\n         */\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, ACTIVATION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, ACTIVATION_DATE, liablilityAccountInitialEntry);\n\n        /***\n         * Update interest earned of FD account\n         */\n        fixedDepositAccountId = this.fixedDepositAccountHelper.calculateInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        /***\n         * Post interest and verify the account summary\n         */\n        Integer transactionIdForPostInterest = this.fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n\n        /***\n         * Verify journal entries transactions for interest posting transaction\n         */\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n        HashMap savingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balanceBefore = (Float) savingsSummaryBefore.get(\"accountBalance\");\n\n        /***\n         * Retrieve mapped financial account for liability transfer\n         */\n        Account financialAccount = getMappedLiabilityFinancialAccount();\n\n        this.fixedDepositAccountHelper.calculatePrematureAmountForFixedDeposit(fixedDepositAccountId, CLOSED_ON_DATE);\n\n        /***\n         * Preclose the account and verify journal entries\n         */\n        Integer prematureClosureTransactionId = (Integer) this.fixedDepositAccountHelper.prematureCloseForFixedDeposit(\n                fixedDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_TRANSFER_TO_SAVINGS, savingsId, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsPrematureClosed(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float prematurityAmount = (Float) fixedDepositData.get(\"maturityAmount\");\n\n        /***\n         * Verify journal entry transactions for preclosure transaction As this transaction is an account transfer you\n         * should get financial account mapping details and verify amounts\n         */\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, CLOSED_ON_DATE,\n                new JournalEntry(prematurityAmount, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(prematurityAmount, JournalEntry.TransactionType.DEBIT));\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(financialAccount, CLOSED_ON_DATE,\n                new JournalEntry(prematurityAmount, JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(prematurityAmount, JournalEntry.TransactionType.CREDIT));\n\n        HashMap savingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balanceAfter = (Float) savingsSummaryAfter.get(\"accountBalance\");\n        Float expectedSavingsBalance = balanceBefore + prematurityAmount;\n\n        Assertions.assertEquals(expectedSavingsBalance, balanceAfter, \"Verifying Savings Account Balance after Premature Closure\");\n\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Premature Closure Type Reinvest", "completion": "    @Test\n    public void testFixedDepositAccountWithPrematureClosureTypeReinvest() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        FixedDepositAccountHelper fixedDepositAccountHelperValidationError = new FixedDepositAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        /***\n         * Create GL Accounts for product account mapping\n         */\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        final String CLOSED_ON_DATE = dateFormat.format(Calendar.getInstance().getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        /***\n         * Create FD product with CashBased accounting enabled\n         */\n        final String accountingRule = CASH_BASED;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount, liabilityAccount,\n                incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n\n        Float depositAmount = (Float) accountSummary.get(\"totalDeposits\");\n\n        /***\n         * Verify journal entries posted for initial deposit transaction which happened at activation time\n         */\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountInitialEntry = { new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, ACTIVATION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, ACTIVATION_DATE, liablilityAccountInitialEntry);\n\n        fixedDepositAccountId = this.fixedDepositAccountHelper.calculateInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        Integer transactionIdForPostInterest = this.fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        accountSummary = this.fixedDepositAccountHelper.getFixedDepositSummary(fixedDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n\n        /***\n         * Verify journal entries transactions for interest posting transaction\n         */\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n        this.fixedDepositAccountHelper.calculatePrematureAmountForFixedDeposit(fixedDepositAccountId, CLOSED_ON_DATE);\n\n        ArrayList<HashMap> errorResponse = (ArrayList<HashMap>) fixedDepositAccountHelperValidationError.prematureCloseForFixedDeposit(\n                fixedDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_REINVEST, null, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"validation.msg.fixeddepositaccount.onAccountClosureId.reinvest.not.allowed\",\n                errorResponse.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account Updation", "completion": "    @Test\n    public void testFixedDepositAccountUpdation() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        monthDayFormat.format(todaysDate.getTime());\n        String submittedOnDate = dateFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        FixedDepositProductHelper.retrieveAllFixedDepositProducts(this.requestSpec, this.responseSpec);\n        FixedDepositProductHelper.retrieveFixedDepositProductById(this.requestSpec, this.responseSpec, fixedDepositProductId.toString());\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                submittedOnDate, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        todaysDate.add(Calendar.DATE, -1);\n        submittedOnDate = dateFormat.format(todaysDate.getTime());\n        HashMap modificationsHashMap = this.fixedDepositAccountHelper.updateFixedDepositAccount(clientId.toString(),\n                fixedDepositProductId.toString(), fixedDepositAccountId.toString(), VALID_FROM, VALID_TO, WHOLE_TERM, submittedOnDate);\n        Assertions.assertTrue(modificationsHashMap.containsKey(\"submittedOnDate\"));\n\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account Undo Approval", "completion": "    @Test\n    public void testFixedDepositAccountUndoApproval() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.undoApproval(fixedDepositAccountId);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account Rejected And Closed", "completion": "    @Test\n    public void testFixedDepositAccountRejectedAndClosed() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String REJECTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.rejectApplication(fixedDepositAccountId, REJECTED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsRejected(fixedDepositAccountStatusHashMap);\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsClosed(fixedDepositAccountStatusHashMap);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account Withdrawn By Client And Closed", "completion": "    @Test\n    public void testFixedDepositAccountWithdrawnByClientAndClosed() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String WITHDRAWN_ON_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.withdrawApplication(fixedDepositAccountId, WITHDRAWN_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsWithdrawn(fixedDepositAccountStatusHashMap);\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsClosed(fixedDepositAccountStatusHashMap);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account Is Deleted", "completion": "    @Test\n    public void testFixedDepositAccountIsDeleted() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountId = (Integer) this.fixedDepositAccountHelper.deleteFixedDepositApplication(fixedDepositAccountId, \"resourceId\");\n        Assertions.assertNotNull(fixedDepositAccountId);\n    }"}
{"prompt": "Create a test that tests test Maturity Amount For Monthly Compounding And Monthly Posting With 360 Days", "completion": "    @Test\n    public void testMaturityAmountForMonthlyCompoundingAndMonthlyPosting_With_360_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        todaysDate.add(Calendar.DATE, -(currentDate - 1));\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, MONTHLY, MONTHLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, depositAmount, depositPeriod,\n                interestPerDay, MONTHLY_INTERVAL, MONTHLY_INTERVAL);\n\n        LOG.info(\"{}\", principal.toString());\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Maturity amount for Recurring Deposit Account\");\n    }"}
{"prompt": "Create a test that tests test Premature Closure Amount With Penal Interest For Whole Term With 360", "completion": "    @Test\n    public void testPrematureClosureAmountWithPenalInterestForWholeTerm_With_360() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateTimeFormatter dateFormat = Utils.dateFormatter;\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(3);\n        final String VALID_FROM = dateFormat.format(todaysDate);\n        todaysDate = todaysDate.plusYears(10);\n        final String VALID_TO = dateFormat.format(todaysDate);\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n        todaysDate = todaysDate.minusDays(1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate);\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate);\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        final String CLOSED_ON_DATE = dateFormat.format(todaysDate);\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        this.fixedDepositAccountHelper.updateInterestCalculationConfigForFixedDeposit(clientId.toString(), fixedDepositProductId.toString(),\n                fixedDepositAccountId.toString(), SUBMITTED_ON_DATE, VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM,\n                INTEREST_CALCULATION_USING_DAILY_BALANCE, MONTHLY, MONTHLY);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float principal = (Float) fixedDepositAccountData.get(\"depositAmount\");\n        Integer depositPeriod = (Integer) fixedDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) fixedDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Float preClosurePenalInterestRate = (Float) fixedDepositAccountData.get(\"preClosurePenalInterest\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = FixedDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, fixedDepositProductId);\n\n        Float interestRate = FixedDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        interestRate -= preClosurePenalInterestRate;\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        log.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        todaysDate = todaysDate.minusMonths(1);\n        todaysDate = todaysDate.minusDays(1);\n\n        Float interestPerMonth = (float) (interestPerDay * principal * DAYS.between(todaysDate, Utils.getLocalDateOfTenant()));\n        principal += interestPerMonth;\n        log.info(\"{}\", Utils.dateFormatter.format(todaysDate));\n        log.info(\"IPM = {}\", interestPerMonth);\n        log.info(\"principal = {}\", principal);\n\n        Integer transactionIdForPostInterest = this.fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n\n        this.fixedDepositAccountHelper.calculatePrematureAmountForFixedDeposit(fixedDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.fixedDepositAccountHelper.prematureCloseForFixedDeposit(\n                fixedDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsPrematureClosed(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        Float maturityAmount = (float) fixedDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    }"}
{"prompt": "Create a test that tests test Maturity Amount For Monthly Compounding And Monthly Posting With 365 Days", "completion": "    @Test\n    public void testMaturityAmountForMonthlyCompoundingAndMonthlyPosting_With_365_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        todaysDate.add(Calendar.DATE, -(currentDate - 1));\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, depositAmount, depositPeriod,\n                interestPerDay, MONTHLY_INTERVAL, MONTHLY_INTERVAL);\n\n        LOG.info(\"{}\", principal.toString());\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Maturity amount for Recurring Deposit Account\");\n    }"}
{"prompt": "Create a test that tests test Premature Closure Amount With Penal Interest For Whole Term With 365", "completion": "    @Test\n    public void testPrematureClosureAmountWithPenalInterestForWholeTerm_With_365() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateTimeFormatter dateFormat = new DateTimeFormatterBuilder().appendPattern(\"dd MMMM yyyy\").toFormatter();\n\n        LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(3);\n        final String VALID_FROM = dateFormat.format(todaysDate);\n        todaysDate = todaysDate.plusYears(10);\n        final String VALID_TO = dateFormat.format(todaysDate);\n\n        todaysDate = Utils.getLocalDateOfTenant();\n        todaysDate = todaysDate.minusMonths(1);\n        todaysDate = todaysDate.minusDays(1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate);\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate);\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate);\n        LocalDate activationDate = todaysDate;\n        todaysDate = todaysDate.plusMonths(1);\n        todaysDate = todaysDate.plusDays(1);\n        final String CLOSED_ON_DATE = dateFormat.format(todaysDate);\n        LocalDate closingDate = todaysDate;\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float principal = (Float) fixedDepositAccountData.get(\"depositAmount\");\n        Integer depositPeriod = (Integer) fixedDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) fixedDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Float preClosurePenalInterestRate = (Float) fixedDepositAccountData.get(\"preClosurePenalInterest\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = FixedDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, fixedDepositProductId);\n\n        Float interestRate = FixedDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        interestRate -= preClosurePenalInterestRate;\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        log.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        long daysBetween = DAYS.between(activationDate, closingDate);\n        Float totalInterest = (float) (interestPerDay * principal * daysBetween);\n        principal += totalInterest;\n        log.info(\"principal = {}\", principal);\n\n        this.fixedDepositAccountHelper.calculatePrematureAmountForFixedDeposit(fixedDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.fixedDepositAccountHelper.prematureCloseForFixedDeposit(\n                fixedDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositAccountIsPrematureClosed(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        Float maturityAmount = (float) fixedDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    }"}
{"prompt": "Create a test that tests test Premature Closure Amount With Penal Interest Till Premature Withdrawal With 365 Days", "completion": "    @Test\n    public void testPrematureClosureAmountWithPenalInterestTillPrematureWithdrawal_With_365_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        todaysDate.add(Calendar.DAY_OF_MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.MONTH, 1);\n        todaysDate.add(Calendar.DAY_OF_MONTH, 1);\n        final String CLOSED_ON_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, TILL_PREMATURE_WITHDRAWAL, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Float preClosurePenalInterestRate = (Float) recurringDepositAccountData.get(\"preClosurePenalInterest\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Calendar activationDate = Calendar.getInstance();\n        activationDate.add(Calendar.MONTH, -1);\n        activationDate.add(Calendar.DAY_OF_MONTH, -1);\n        ZonedDateTime start = ZonedDateTime.ofInstant(activationDate.getTime().toInstant(), Utils.getZoneIdOfTenant());\n\n        Calendar prematureClosureDate = Calendar.getInstance();\n        ZonedDateTime end = ZonedDateTime.ofInstant(prematureClosureDate.getTime().toInstant(), Utils.getZoneIdOfTenant());\n\n        Integer depositedPeriod = Math.toIntExact(ChronoUnit.MONTHS.between(start.toLocalDate(), end.toLocalDate()));\n\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(depositTransactionId);\n\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"totalDeposits\");\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositedPeriod);\n        interestRate -= preClosurePenalInterestRate;\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.MONTH, -1);\n        calendar.add(Calendar.DAY_OF_MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(calendar.getTime()));\n        Integer daysInMonth = calendar.getActualMaximum(Calendar.DATE);\n        daysInMonth = daysInMonth - currentDate + 1;\n        Float interestPerMonth = (float) (interestPerDay * principal * daysInMonth);\n        principal += interestPerMonth + depositAmount;\n        calendar.add(Calendar.DATE, daysInMonth);\n        LOG.info(\"{}\", monthDayFormat.format(calendar.getTime()));\n\n        expectedFirstDepositOnDate = dateFormat.format(calendar.getTime());\n        Integer transactionIdForDeposit = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(transactionIdForDeposit);\n\n        currentDate = currentDate - 1;\n        interestPerMonth = (float) (interestPerDay * principal * currentDate);\n        LOG.info(\"IPM = {}\", interestPerMonth);\n        principal += interestPerMonth;\n        LOG.info(\"principal = {}\", principal);\n\n        HashMap recurringDepositPrematureData = this.recurringDepositAccountHelper\n                .calculatePrematureAmountForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.recurringDepositAccountHelper.prematureCloseForRecurringDeposit(\n                recurringDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsPrematureClosed(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    }"}
{"prompt": "Create a test that tests test Premature Closure Amount With Penal Interest Till Premature Withdrawal With 360 Days", "completion": "    @Test\n    public void testPrematureClosureAmountWithPenalInterestTillPrematureWithdrawal_With_360_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        todaysDate.add(Calendar.DAY_OF_MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.MONTH, 1);\n        todaysDate.add(Calendar.DAY_OF_MONTH, 1);\n        final String CLOSED_ON_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, TILL_PREMATURE_WITHDRAWAL, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_360, TILL_PREMATURE_WITHDRAWAL, INTEREST_CALCULATION_USING_DAILY_BALANCE, MONTHLY, MONTHLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Float preClosurePenalInterestRate = (Float) recurringDepositAccountData.get(\"preClosurePenalInterest\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Calendar activationDate = Calendar.getInstance();\n        activationDate.add(Calendar.MONTH, -1);\n        activationDate.add(Calendar.DAY_OF_MONTH, -1);\n        ZonedDateTime start = ZonedDateTime.ofInstant(activationDate.getTime().toInstant(), Utils.getZoneIdOfTenant());\n\n        Calendar prematureClosureDate = Calendar.getInstance();\n        ZonedDateTime end = ZonedDateTime.ofInstant(prematureClosureDate.getTime().toInstant(), Utils.getZoneIdOfTenant());\n\n        Integer depositedPeriod = Math.toIntExact(ChronoUnit.MONTHS.between(start.toLocalDate(), end.toLocalDate()));\n\n        Integer transactionIdForDeposit = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(transactionIdForDeposit);\n\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"totalDeposits\");\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositedPeriod);\n        interestRate -= preClosurePenalInterestRate;\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.MONTH, -1);\n        calendar.add(Calendar.DAY_OF_MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(calendar.getTime()));\n        Integer daysInMonth = calendar.getActualMaximum(Calendar.DATE);\n        daysInMonth = daysInMonth - currentDate + 1;\n        Float interestPerMonth = (float) (interestPerDay * principal * daysInMonth);\n        principal += interestPerMonth + depositAmount;\n        calendar.add(Calendar.DATE, daysInMonth);\n        LOG.info(\"{}\", monthDayFormat.format(calendar.getTime()));\n\n        expectedFirstDepositOnDate = dateFormat.format(calendar.getTime());\n        Integer newTransactionIdForDeposit = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(newTransactionIdForDeposit);\n\n        currentDate = currentDate - 1;\n        interestPerMonth = (float) (interestPerDay * principal * currentDate);\n        LOG.info(\"IPM = {}\", interestPerMonth);\n        principal += interestPerMonth;\n        LOG.info(\"principal = {}\", principal);\n\n        HashMap recurringDepositPrematureData = this.recurringDepositAccountHelper\n                .calculatePrematureAmountForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.recurringDepositAccountHelper.prematureCloseForRecurringDeposit(\n                recurringDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsPrematureClosed(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    }"}
{"prompt": "Create a test that tests test Maturity Amount For Daily Compounding And Monthly Posting With 365 Days", "completion": "    @Test\n    public void testMaturityAmountForDailyCompoundingAndMonthlyPosting_With_365_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        todaysDate.add(Calendar.DATE, -(currentDate - 1));\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_365, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, DAILY, MONTHLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, DAILY_COMPOUNDING_INTERVAL, MONTHLY_INTERVAL);\n\n        LOG.info(\"{}\", principal.toString());\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Maturity amount for Recurring Deposit Account\");\n\n    }"}
{"prompt": "Create a test that tests test Maturity Amount For Daily Compounding And Monthly Posting With 360 Days", "completion": "    @Test\n    public void testMaturityAmountForDailyCompoundingAndMonthlyPosting_With_360_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        todaysDate.add(Calendar.DATE, -(currentDate - 1));\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, DAILY, MONTHLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, DAILY_COMPOUNDING_INTERVAL, MONTHLY_INTERVAL);\n\n        LOG.info(\"{}\", principal.toString());\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Maturity amount for Recurring Deposit Account\");\n\n    }"}
{"prompt": "Create a test that tests test Maturity Amount For Daily Compounding And Annually Posting With 365 Days", "completion": "    @Test\n    public void testMaturityAmountForDailyCompoundingAndAnnuallyPosting_With_365_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        LOG.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_365, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, DAILY, ANNUALLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        LOG.info(\"per day = {} \", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, DAILY_COMPOUNDING_INTERVAL, ANNUL_INTERVAL);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Maturity amount\");\n\n    }"}
{"prompt": "Create a test that tests test Maturity Amount Daily Compounding And Annually Posting With 360 Days", "completion": "    @Test\n    public void testMaturityAmountDailyCompoundingAndAnnuallyPostingWith_360_Days() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        log.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        this.fixedDepositAccountHelper.updateInterestCalculationConfigForFixedDeposit(clientId.toString(), fixedDepositProductId.toString(),\n                fixedDepositAccountId.toString(), SUBMITTED_ON_DATE, VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM,\n                INTEREST_CALCULATION_USING_DAILY_BALANCE, DAILY, ANNUALLY);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float principal = (Float) fixedDepositAccountData.get(\"depositAmount\");\n        Integer depositPeriod = (Integer) fixedDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) fixedDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = FixedDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, fixedDepositProductId);\n\n        Float interestRate = FixedDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        log.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = FixedDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, depositPeriod, interestPerDay,\n                DAILY_COMPOUNDING_INTERVAL, ANNUL_INTERVAL);\n\n        fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) fixedDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Maturity amount\");\n\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit With Bi Annual Compounding And Posting 365 Days", "completion": "    @Test\n    public void testFixedDepositWithBi_AnnualCompoundingAndPosting_365_Days() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        log.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        this.fixedDepositAccountHelper.updateInterestCalculationConfigForFixedDeposit(clientId.toString(), fixedDepositProductId.toString(),\n                fixedDepositAccountId.toString(), SUBMITTED_ON_DATE, VALID_FROM, VALID_TO, DAYS_365, WHOLE_TERM,\n                INTEREST_CALCULATION_USING_DAILY_BALANCE, BI_ANNUALLY, BI_ANNUALLY);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float principal = (Float) fixedDepositAccountData.get(\"depositAmount\");\n        Integer depositPeriod = (Integer) fixedDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) fixedDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = FixedDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, fixedDepositProductId);\n\n        Float interestRate = FixedDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        log.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = FixedDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, depositPeriod, interestPerDay,\n                BIANNULLY_INTERVAL, BIANNULLY_INTERVAL);\n\n        fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) fixedDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit With Bi Annual Compounding And Posting 360 Days", "completion": "    @Test\n    public void testFixedDepositWithBi_AnnualCompoundingAndPosting_360_Days() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        log.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        this.fixedDepositAccountHelper.updateInterestCalculationConfigForFixedDeposit(clientId.toString(), fixedDepositProductId.toString(),\n                fixedDepositAccountId.toString(), SUBMITTED_ON_DATE, VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM,\n                INTEREST_CALCULATION_USING_DAILY_BALANCE, BI_ANNUALLY, BI_ANNUALLY);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float principal = (Float) fixedDepositAccountData.get(\"depositAmount\");\n        Integer depositPeriod = (Integer) fixedDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) fixedDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = FixedDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, fixedDepositProductId);\n\n        Float interestRate = FixedDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        log.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = FixedDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, depositPeriod, interestPerDay,\n                BIANNULLY_INTERVAL, BIANNULLY_INTERVAL);\n\n        fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) fixedDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit With Quarterly Compounding And Quarterly Posting 365 Days", "completion": "    @Test\n    public void testFixedDepositWithQuarterlyCompoundingAndQuarterlyPosting_365_Days() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        log.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        this.fixedDepositAccountHelper.updateInterestCalculationConfigForFixedDeposit(clientId.toString(), fixedDepositProductId.toString(),\n                fixedDepositAccountId.toString(), SUBMITTED_ON_DATE, VALID_FROM, VALID_TO, DAYS_365, WHOLE_TERM,\n                INTEREST_CALCULATION_USING_DAILY_BALANCE, QUARTERLY, QUARTERLY);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float principal = (Float) fixedDepositAccountData.get(\"depositAmount\");\n        Integer depositPeriod = (Integer) fixedDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) fixedDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = FixedDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, fixedDepositProductId);\n\n        Float interestRate = FixedDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        log.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = FixedDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, depositPeriod, interestPerDay,\n                QUARTERLY_INTERVAL, QUARTERLY_INTERVAL);\n\n        fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) fixedDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit With Quarterly Compounding And Quarterly Posting 360 Days", "completion": "    @Test\n    public void testFixedDepositWithQuarterlyCompoundingAndQuarterlyPosting_360_Days() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        log.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        dateFormat.format(todaysDate.getTime());\n        monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM);\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        this.fixedDepositAccountHelper.updateInterestCalculationConfigForFixedDeposit(clientId.toString(), fixedDepositProductId.toString(),\n                fixedDepositAccountId.toString(), SUBMITTED_ON_DATE, VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM,\n                INTEREST_CALCULATION_USING_DAILY_BALANCE, QUARTERLY, QUARTERLY);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        HashMap fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n        Float principal = (Float) fixedDepositAccountData.get(\"depositAmount\");\n        Integer depositPeriod = (Integer) fixedDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) fixedDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = FixedDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, fixedDepositProductId);\n\n        Float interestRate = FixedDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        log.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = FixedDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, depositPeriod, interestPerDay,\n                QUARTERLY_INTERVAL, QUARTERLY_INTERVAL);\n\n        fixedDepositAccountData = FixedDepositAccountHelper.getFixedDepositAccountById(this.requestSpec, this.responseSpec,\n                fixedDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) fixedDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Rollover Maturity Amount", "completion": "    @Test\n    public void testFixedDepositAccountWithRolloverMaturityAmount() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        /***\n         * Create GL Accounts for product account mapping\n         */\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        /***\n         * Create FD product with CashBased accounting enabled\n         */\n        final String accountingRule = CASH_BASED;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount, liabilityAccount,\n                incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        /***\n         * Set maturityInstructionId as re-invest principal+interest\n         */\n        final Integer maturityInstructionId = 300;\n\n        /***\n         * Apply for FD account with created product and verify status\n         */\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM, maturityInstructionId);\n\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        /***\n         * Approve the FD account and verify whether account is approved\n         */\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        /***\n         * Activate the FD Account and verify whether account is activated\n         */\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n    }"}
{"prompt": "Create a test that tests test Fixed Deposit Account With Rollover Principal", "completion": "    @Test\n    public void testFixedDepositAccountWithRolloverPrincipal() {\n        this.fixedDepositProductHelper = new FixedDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.fixedDepositAccountHelper = new FixedDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        /***\n         * Create GL Accounts for product account mapping\n         */\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        /***\n         * Create FD product with CashBased accounting enabled\n         */\n        final String accountingRule = CASH_BASED;\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount, liabilityAccount,\n                incomeAccount, expenseAccount);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        /***\n         * Set maturityInstructionId as re-invest principal\n         */\n        final Integer maturityInstructionId = 400;\n\n        /***\n         * Apply for FD account with created product and verify status\n         */\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM, maturityInstructionId);\n\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(this.requestSpec,\n                this.responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        /***\n         * Approve the FD account and verify whether account is approved\n         */\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        /***\n         * Activate the FD Account and verify whether account is activated\n         */\n        fixedDepositAccountStatusHashMap = this.fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n    }"}
{"prompt": "Create a test that tests test Savings Interest Posting At Period End", "completion": "    @Test\n    public void testSavingsInterestPostingAtPeriodEnd() {\n        // client activation, savings activation and 1st transaction date\n        final String startDate = \"01 December 2013\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        // Configuring global config flags\n        configureInterestPosting(true, 4);\n\n        final Integer savingsId = createSavingsAccount(clientID, startDate);\n\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"1000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        /***\n         * Perform Post interest transaction and verify the posted transaction date\n         */\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        HashMap accountDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) accountDetails.get(\"transactions\");\n        HashMap<String, Object> interestPostingTransaction = transactions.get(transactions.size() - 2);\n        for (Map.Entry<String, Object> entry : interestPostingTransaction.entrySet()) {\n            LOG.info(\"{} - {}\", entry.getKey(), entry.getValue().toString());\n        }\n        // 1st Dec 13 to 31st March 14 - 365 days, daily compounding using daily\n        // balance\n        // 33.7016 obtained from formula in excel provided by Subramanya\n        assertEquals(\"33.7016\", interestPostingTransaction.get(\"amount\").toString(), \"Equality check for interest posted amount\");\n        assertEquals(\"[2014, 3, 31]\", interestPostingTransaction.get(\"date\").toString(), \"Date check for Interest Posting transaction\");\n\n    }"}
{"prompt": "Create a test that tests test Create Fund", "completion": "    @Test\n    public void testCreateFund() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n    }"}
{"prompt": "Create a test that tests test Create Fund With Empty Name", "completion": "    @Test\n    public void testCreateFundWithEmptyName() {\n        FundsHelper fh = FundsHelper.create(null).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final Long fundID = createFund(jsonData, this.requestSpec, responseSpec);\n        Assertions.assertNull(fundID);\n    }"}
{"prompt": "Create a test that tests test Create Fund With Empty External Id", "completion": "    @Test\n    public void testCreateFundWithEmptyExternalId() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(null).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n    }"}
{"prompt": "Create a test that tests test Create Fund With Duplicate Name", "completion": "    @Test\n    public void testCreateFundWithDuplicateName() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        FundsHelper fh2 = FundsHelper.create(fh.getName()).externalId(UUID.randomUUID().toString()).build();\n        jsonData = fh2.toJSON();\n\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final Long fundID2 = createFund(jsonData, this.requestSpec, responseSpec);\n        Assertions.assertNull(fundID2);\n    }"}
{"prompt": "Create a test that tests test Create Fund With Duplicate External Id", "completion": "    @Test\n    public void testCreateFundWithDuplicateExternalId() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        FundsHelper fh2 = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(fh.getExternalId()).build();\n        jsonData = fh2.toJSON();\n\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final Long fundID2 = createFund(jsonData, this.requestSpec, responseSpec);\n        Assertions.assertNull(fundID2);\n    }"}
{"prompt": "Create a test that tests test Create Fund With Invalid Name", "completion": "    @Test\n    public void testCreateFundWithInvalidName() {\n        FundsHelper fh = FundsHelper.create(Utils.randomStringGenerator(\"\", 120)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final Long fundID = createFund(jsonData, this.requestSpec, responseSpec);\n        Assertions.assertNull(fundID);\n    }"}
{"prompt": "Create a test that tests test Create Fund With Invalid External Id", "completion": "    @Test\n    public void testCreateFundWithInvalidExternalId() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(Utils.randomStringGenerator(\"fund-\", 120))\n                .build();\n        String jsonData = fh.toJSON();\n\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final Long fundID = createFund(jsonData, this.requestSpec, responseSpec);\n        Assertions.assertNull(fundID);\n    }"}
{"prompt": "Create a test that tests test Retrieve Fund", "completion": "    @Test\n    public void testRetrieveFund() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        jsonData = FundsResourceHandler.retrieveFund(fundID, this.requestSpec, this.statusOkResponseSpec);\n        FundsHelper fh2 = FundsHelper.fromJSON(jsonData);\n\n        assertEquals(fh.getName(), fh2.getName());\n    }"}
{"prompt": "Create a test that tests test Retrieve All Funds", "completion": "    @Test\n    public void testRetrieveAllFunds() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        List<FundsHelper> fhList = FundsResourceHandler.retrieveAllFunds(this.requestSpec, this.statusOkResponseSpec);\n\n        Assertions.assertNotNull(fhList);\n        assertThat(fhList.size(), greaterThanOrEqualTo(1));\n        assertThat(fhList, hasItem(fh));\n    }"}
{"prompt": "Create a test that tests test Retrieve Unknown Fund", "completion": "    @Test\n    public void testRetrieveUnknownFund() {\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(404).build();\n        String jsonData = FundsResourceHandler.retrieveFund(Long.MAX_VALUE, this.requestSpec, responseSpec);\n        HashMap<String, Object> map = new Gson().fromJson(jsonData, new TypeToken<HashMap<String, Object>>() {}.getType());\n        assertEquals(\"error.msg.resource.not.found\", map.get(\"userMessageGlobalisationCode\"));\n    }"}
{"prompt": "Create a test that tests test Update Fund", "completion": "    @Test\n    public void testUpdateFund() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        String newName = Utils.uniqueRandomStringGenerator(\"\", 10);\n        String newExternalId = UUID.randomUUID().toString();\n        FundsHelper fh2 = FundsResourceHandler.updateFund(fundID, newName, newExternalId, this.requestSpec, this.statusOkResponseSpec);\n\n        Assertions.assertEquals(newName, fh2.getName());\n        Assertions.assertEquals(newExternalId, fh2.getExternalId());\n    }"}
{"prompt": "Create a test that tests test Update Unknown Fund", "completion": "    @Test\n    public void testUpdateUnknownFund() {\n        String newName = Utils.uniqueRandomStringGenerator(\"\", 10);\n        String newExternalId = UUID.randomUUID().toString();\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(404).build();\n        FundsHelper fh = FundsResourceHandler.updateFund(Long.MAX_VALUE, newName, newExternalId, this.requestSpec, responseSpec);\n        Assertions.assertNull(fh);\n    }"}
{"prompt": "Create a test that tests test Update Fund With Invalid New Name", "completion": "    @Test\n    public void testUpdateFundWithInvalidNewName() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        String newName = Utils.randomStringGenerator(\"\", 120);\n        String newExternalId = UUID.randomUUID().toString();\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(400).build();\n        FundsHelper fh2 = FundsResourceHandler.updateFund(fundID, newName, newExternalId, this.requestSpec, responseSpec);\n\n        Assertions.assertNull(fh2);\n    }"}
{"prompt": "Create a test that tests test Update Fund With New External Id", "completion": "    @Test\n    public void testUpdateFundWithNewExternalId() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        String newExternalId = UUID.randomUUID().toString();\n        FundsHelper fh2 = FundsResourceHandler.updateFund(fundID, null, newExternalId, this.requestSpec, this.statusOkResponseSpec);\n\n        Assertions.assertEquals(newExternalId, fh2.getExternalId());\n    }"}
{"prompt": "Create a test that tests test Update Fund With Invalid New External Id", "completion": "    @Test\n    public void testUpdateFundWithInvalidNewExternalId() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        String newName = Utils.uniqueRandomStringGenerator(\"\", 10);\n        String newExternalId = Utils.randomStringGenerator(\"fund-\", 120);\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(400).build();\n        FundsHelper fh2 = FundsResourceHandler.updateFund(fundID, newName, newExternalId, this.requestSpec, responseSpec);\n\n        Assertions.assertNull(fh2);\n    }"}
{"prompt": "Create a test that tests test Update Fund With New Name", "completion": "    @Test\n    public void testUpdateFundWithNewName() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        String newName = Utils.uniqueRandomStringGenerator(\"\", 10);\n        FundsHelper fh2 = FundsResourceHandler.updateFund(fundID, newName, null, this.requestSpec, this.statusOkResponseSpec);\n\n        Assertions.assertEquals(newName, fh2.getName());\n    }"}
{"prompt": "Create a test that tests test Update Fund With Empty Params", "completion": "    @Test\n    public void testUpdateFundWithEmptyParams() {\n        FundsHelper fh = FundsHelper.create(Utils.uniqueRandomStringGenerator(\"\", 10)).externalId(UUID.randomUUID().toString()).build();\n        String jsonData = fh.toJSON();\n\n        final Long fundID = createFund(jsonData, this.requestSpec, this.statusOkResponseSpec);\n        Assertions.assertNotNull(fundID);\n\n        FundsHelper fh2 = FundsResourceHandler.updateFund(fundID, null, null, this.requestSpec, this.statusOkResponseSpec);\n\n        Assertions.assertNull(fh2.getName());\n        Assertions.assertNull(fh2.getExternalId());\n\n        // assert that there was no change in\n        // the name and external ID of the fund\n        jsonData = FundsResourceHandler.retrieveFund(fundID, this.requestSpec, this.statusOkResponseSpec);\n        FundsHelper fh3 = new Gson().fromJson(jsonData, FundsHelper.class);\n\n        Assertions.assertEquals(fh.getName(), fh3.getName());\n        Assertions.assertEquals(fh.getExternalId(), fh3.getExternalId());\n    }"}
{"prompt": "Create a test that tests test Interest Charged From Date Same As Disbursal Date", "completion": "    @Test\n    public void testInterestChargedFromDateSameAsDisbursalDate() {\n        this.globalConfigurationHelper = new GlobalConfigurationHelper(this.requestSpec, this.responseSpec);\n\n        // Retrieving All Global Configuration details\n        final ArrayList<HashMap> globalConfig = GlobalConfigurationHelper.getAllGlobalConfigurations(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(globalConfig);\n\n        String configName = \"interest-charged-from-date-same-as-disbursal-date\";\n        boolean newBooleanValue = true;\n\n        for (Integer configIndex = 0; configIndex < globalConfig.size(); configIndex++) {\n            if (globalConfig.get(configIndex).get(\"name\").equals(configName)) {\n                String configId = globalConfig.get(configIndex).get(\"id\").toString();\n                Integer updateConfigId = GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec,\n                        this.responseSpec, configId.toString(), newBooleanValue);\n                Assertions.assertNotNull(updateConfigId);\n                break;\n            }\n        }\n\n    }"}
{"prompt": "Create a test that tests test Global Configurations", "completion": "    @Test\n    public void testGlobalConfigurations() {\n        this.globalConfigurationHelper = new GlobalConfigurationHelper(this.requestSpec, this.responseSpec);\n\n        // Retrieving All Global Configuration details\n        final ArrayList<HashMap> globalConfig = GlobalConfigurationHelper.getAllGlobalConfigurations(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(globalConfig);\n\n        String configName = \"penalty-wait-period\";\n        for (Integer configIndex = 0; configIndex < globalConfig.size() - 1; configIndex++) {\n            if (globalConfig.get(configIndex).get(\"name\").equals(configName)) {\n                Integer configId = (Integer) globalConfig.get(configIndex).get(\"id\");\n                Assertions.assertNotNull(configId);\n\n                HashMap configDataBefore = GlobalConfigurationHelper.getGlobalConfigurationById(this.requestSpec, this.responseSpec,\n                        configId.toString());\n                Assertions.assertNotNull(configDataBefore);\n\n                Integer value = (Integer) configDataBefore.get(\"value\") + 1;\n\n                // Updating Value for penalty-wait-period Global Configuration\n                configId = GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec,\n                        configId.toString(), value.toString());\n                Assertions.assertNotNull(configId);\n\n                HashMap configDataAfter = GlobalConfigurationHelper.getGlobalConfigurationById(this.requestSpec, this.responseSpec,\n                        configId.toString());\n\n                // Verifying Value for penalty-wait-period after Updation\n                Assertions.assertEquals(value, configDataAfter.get(\"value\"), \"Verifying Global Config Value after Updation\");\n\n                // Updating Enabled Flag for penalty-wait-period Global\n                // Configuration\n                Boolean enabled = (Boolean) globalConfig.get(configIndex).get(\"enabled\");\n\n                if (enabled == true) {\n                    enabled = false;\n                } else {\n                    enabled = true;\n                }\n\n                configId = GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec, this.responseSpec,\n                        configId.toString(), enabled);\n\n                configDataAfter = GlobalConfigurationHelper.getGlobalConfigurationById(this.requestSpec, this.responseSpec,\n                        configId.toString());\n\n                // Verifying Enabled Flag for penalty-wait-period after Updation\n                Assertions.assertEquals(enabled, configDataAfter.get(\"enabled\"), \"Verifying Enabled Flag Global Config after Updation\");\n                break;\n            }\n        }\n    }"}
{"prompt": "Create a test that tests test Global Configuration Is Cache Enabled", "completion": "    @Test\n    public void testGlobalConfigurationIsCacheEnabled() {\n        this.globalConfigurationHelper = new GlobalConfigurationHelper(this.requestSpec, this.responseSpec);\n\n        // Retrieving Is Cache Enabled Global Configuration details\n        ArrayList<HashMap> isCacheGlobalConfig = GlobalConfigurationHelper.getGlobalConfigurationIsCacheEnabled(this.requestSpec,\n                this.responseSpec);\n        Assertions.assertNotNull(isCacheGlobalConfig);\n\n        for (Integer cacheType = 0; cacheType <= isCacheGlobalConfig.size() - 1; cacheType++) {\n\n            // Retrieving Is Cache Enabled Global Configuration details\n            isCacheGlobalConfig = GlobalConfigurationHelper.getGlobalConfigurationIsCacheEnabled(this.requestSpec, this.responseSpec);\n            Assertions.assertNotNull(isCacheGlobalConfig);\n\n            HashMap cacheTypeAsHashMap = (HashMap) isCacheGlobalConfig.get(cacheType).get(\"cacheType\");\n            Integer cacheTypeId = (Integer) cacheTypeAsHashMap.get(\"id\");\n            String cacheTypeValue = (String) cacheTypeAsHashMap.get(\"value\");\n            Boolean enabled = (Boolean) isCacheGlobalConfig.get(cacheType).get(\"enabled\");\n\n            if (cacheTypeValue.compareTo(\"No cache\") == 0 && enabled == true) {\n                cacheTypeId += 1;\n            } else if (cacheTypeValue.compareTo(\"Single node\") == 0 && enabled == true) {\n                cacheTypeId -= 1;\n            }\n\n            HashMap changes = GlobalConfigurationHelper.updateIsCacheEnabledForGlobalConfiguration(this.requestSpec, this.responseSpec,\n                    cacheTypeId.toString());\n            Assertions.assertEquals(cacheTypeId, changes.get(\"cacheType\"), \"Verifying Is Cache Enabled Global Config after Updation\");\n        }\n    }"}
{"prompt": "Create a test that tests test Global Config Force Password Reset Days", "completion": "    @Test\n    public void testGlobalConfigForcePasswordResetDays() {\n\n        // Retrieving All Global Configuration details\n        final ArrayList<HashMap> globalConfig = GlobalConfigurationHelper.getAllGlobalConfigurations(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(globalConfig);\n\n        String configName = \"force-password-reset-days\";\n        String newValue = \"0\";\n        String newBooleanValue = \"true\";\n\n        for (Integer configIndex = 0; configIndex < globalConfig.size() - 1; configIndex++) {\n            if (globalConfig.get(configIndex).get(\"name\").equals(configName)) {\n                Integer configId = (Integer) globalConfig.get(configIndex).get(\"id\");\n                Assertions.assertNotNull(configId);\n\n                /*\n                 * Update force-password-reset-days with value as 0 and Enable as true - failure case\n                 */\n                ArrayList error = (ArrayList) GlobalConfigurationHelper.updatePasswordResetDaysForGlobalConfiguration(this.requestSpec,\n                        this.httpStatusForidden, configId, newValue, newBooleanValue, CommonConstants.RESPONSE_ERROR);\n                HashMap hash = (HashMap) error.get(0);\n\n                Assertions.assertEquals(\"error.msg.password.reset.days.value.must.be.greater.than.zero\",\n                        hash.get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE),\n                        \"Force Password Reset days value must be greater than zero.\");\n\n                /*\n                 * Update force-password-reset-days with value as 50 and Enable as true - success case\n                 */\n                final HashMap updateSuccess = (HashMap) GlobalConfigurationHelper.updatePasswordResetDaysForGlobalConfiguration(\n                        this.requestSpec, this.responseSpec, configId, \"50\", newBooleanValue, \"changes\");\n                Assertions.assertNotNull(updateSuccess);\n\n                /* Update with value as 0 and Enable as false - success case */\n                final HashMap updateSuccess1 = (HashMap) GlobalConfigurationHelper.updatePasswordResetDaysForGlobalConfiguration(\n                        this.requestSpec, this.responseSpec, configId, newValue, \"false\", \"changes\");\n                Assertions.assertNotNull(updateSuccess1);\n\n                /*\n                 * Update without sending value and Enable as true - failure case\n                 */\n                ArrayList failure = (ArrayList) GlobalConfigurationHelper.updatePasswordResetDaysForGlobalConfiguration(this.requestSpec,\n                        this.httpStatusForidden, configId, null, newBooleanValue, CommonConstants.RESPONSE_ERROR);\n                HashMap failureHash = (HashMap) failure.get(0);\n                Assertions.assertEquals(\"error.msg.password.reset.days.value.must.be.greater.than.zero\",\n                        failureHash.get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE),\n                        \"Force Password Reset days value must be greater than zero.\");\n\n                break;\n            }\n        }\n        /* Update other global configuration property */\n        String otherConfigName = \"maker-checker\";\n        for (Integer configIndex = 0; configIndex < globalConfig.size() - 1; configIndex++) {\n            if (globalConfig.get(configIndex).get(\"name\").equals(otherConfigName)) {\n                String configId = globalConfig.get(configIndex).get(\"id\").toString();\n                Integer updateConfigId = GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec,\n                        configId, newValue);\n                Assertions.assertNotNull(updateConfigId);\n                break;\n            }\n        }\n    }"}
{"prompt": "Create a test that tests check Group Loan Create And Disburse Flow", "completion": "    @Test\n    public void checkGroupLoanCreateAndDisburseFlow() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n\n        final Integer loanProductID = createLoanProduct();\n        final Integer loanID = applyForLoanApplication(groupID, loanProductID);\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec,\n                loanID);\n        verifyLoanRepaymentSchedule(loanSchedule);\n    }"}
{"prompt": "Create a test that tests check Glim Account Commands", "completion": "    @Test\n    public void checkGlimAccountCommands() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        final Integer loanProductID = createLoanProduct();\n\n        HashMap<String, Integer> glim = applyForGlimApplication(clientID, groupID, loanProductID);\n        LOG.info(\"Glim Loan Application: {} \", glim);\n\n        final Integer glimId = glim.get(\"glimId\");\n        LOG.info(\"GlimId : {} \", glimId);\n\n        final Integer loanId = glim.get(\"loanId\");\n        LOG.info(\"LoanId : {} \", loanId);\n\n        List<Map<String, Object>> approvalFormData = new ArrayList<>();\n        approvalFormData.add(approvalFormData(loanId, \"22 September 2011\"));\n\n        HashMap loanStatusHashMap = this.loanTransactionHelper.approveGlimAccount(this.requestSpec, this.responseSpec, approvalFormData,\n                glimId);\n        LOG.info(\"glim approval loanSchedule: {} \", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.disburseGlimAccount(\"25 September 2011\", glimId);\n        LOG.info(\"glim disbursement loanSchedule: {} \", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.undoDisburseGlimAccount(glimId);\n        LOG.info(\"glim undodisbursement loanSchedule: {} \", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.undoApprovalGlimAccount(glimId);\n        LOG.info(\"glim undoApproval loanSchedule: {} \", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.rejectGlimAccount(\"22 September 2011\", glimId);\n        LOG.info(\"glim reject loanSchedule: {} \", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanAccountRejected(loanStatusHashMap);\n    }"}
{"prompt": "Create a test that tests get Glim Account By Group Id", "completion": "    @Test\n    public void getGlimAccountByGroupId() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final Integer loanProductID = createLoanProduct();\n        Assertions.assertNotNull(loanProductID);\n\n        HashMap<String, Integer> glim = applyForGlimApplication(clientID, groupID, loanProductID);\n        LOG.info(\"Glim Loan Application: {} \", glim);\n\n        final Integer glimId = glim.get(\"glimId\");\n        LOG.info(\"GlimId: {} \", glimId);\n\n        final Integer loanId = glim.get(\"loanId\");\n        LOG.info(\"LoanId: {} \", loanId);\n\n        final List<String> retrievedGlimId = GroupHelper.verifyRetrieveGlimAccountsByGroupId(this.requestSpec, this.responseSpec, groupID);\n        Assertions.assertNotNull(retrievedGlimId.toString());\n    }"}
{"prompt": "Create a test that tests get Glim Account By Glim Id", "completion": "    @Test\n    public void getGlimAccountByGlimId() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final Integer loanProductID = createLoanProduct();\n        Assertions.assertNotNull(loanProductID);\n\n        HashMap<String, Integer> glim = applyForGlimApplication(clientID, groupID, loanProductID);\n        LOG.info(\"Glim Loan Application: {} \", glim);\n\n        final Integer glimId = glim.get(\"glimId\");\n        LOG.info(\"GlimId: {} \", glimId);\n\n        final Integer loanId = glim.get(\"loanId\");\n        LOG.info(\"LoanId: {} \", loanId);\n\n        final List<String> retrievedGlimAccountId = GroupHelper.verifyRetrieveGlimAccountsByGlimId(this.requestSpec, this.responseSpec,\n                glimId);\n        Assertions.assertNotNull(retrievedGlimAccountId);\n    }"}
{"prompt": "Create a test that tests test Gsim Savings Account REJECT APPLICATION", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testGsimSavingsAccount_REJECT_APPLICATION() {\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        List<Map<String, Object>> clientArray = new ArrayList<>();\n        clientArray.add(clientArray(clientID, groupID, savingsProductID, \"08 January 2013\"));\n\n        final Integer gsimID = this.savingsAccountHelper.applyForGsimApplication(clientArray);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.approveGsimSavings(gsimID);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        List<HashMap> error1 = savingsAccountHelperValidationError.rejectGsimApplicationWithErrorCode(gsimID,\n                SavingsAccountHelper.CREATED_DATE_PLUS_ONE);\n        assertEquals(\"validation.msg.savingsaccount.reject.not.in.submittedandpendingapproval.state\",\n                error1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        savingsStatusHashMap = this.savingsAccountHelper.undoApprovalGsimSavings(gsimID);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        error1 = savingsAccountHelperValidationError.rejectGsimApplicationWithErrorCode(gsimID, SavingsAccountHelper.getFutureDate());\n        assertEquals(\"validation.msg.savingsaccount.reject.cannot.be.a.future.date\",\n                error1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        error1 = savingsAccountHelperValidationError.rejectGsimApplicationWithErrorCode(gsimID,\n                SavingsAccountHelper.CREATED_DATE_MINUS_ONE);\n        assertEquals(\"validation.msg.savingsaccount.reject.cannot.be.before.submittal.date\",\n                error1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        savingsStatusHashMap = this.savingsAccountHelper.rejectGsimApplication(gsimID);\n        SavingsStatusChecker.verifySavingsIsRejected(savingsStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Gsim Savings Account DEPOSIT APPLICATION", "completion": "    @Test\n    public void testGsimSavingsAccount_DEPOSIT_APPLICATION() {\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        List<Map<String, Object>> clientArray = new ArrayList<>();\n        clientArray.add(clientArray(clientID, groupID, savingsProductID, \"08 January 2013\"));\n        LOG.info(\"client Array : {} \", clientArray);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(groupID, savingsProductID, ACCOUNT_TYPE_GROUP);\n        Assertions.assertNotNull(savingsId);\n\n        String name = PaymentTypeHelper.randomNameGenerator(\"P_T\", 5);\n        String description = PaymentTypeHelper.randomNameGenerator(\"PT_Desc\", 15);\n        Boolean isCashPayment = true;\n        Integer position = 1;\n\n        Integer paymentTypeId = PaymentTypeHelper.createPaymentType(requestSpec, responseSpec, name, description, isCashPayment, position);\n        Assertions.assertNotNull(paymentTypeId);\n\n        List<Map<String, Object>> savingsArray = new ArrayList<>();\n        final Integer transactionAmount = 2500;\n        savingsArray.add(savingsArray(paymentTypeId, savingsId, transactionAmount, \"10 March 2013\"));\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final Integer depositId = this.savingsAccountHelper.depositGsimApplication(savingsId, savingsArray);\n        Assertions.assertNotNull(depositId);\n\n    }"}
{"prompt": "Create a test that tests test Gsim Savings Account CLOSE APPLICATION", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testGsimSavingsAccount_CLOSE_APPLICATION() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"1000.0\";\n        final String enforceMinRequiredBalance = \"true\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        List<Map<String, Object>> clientArray = new ArrayList<>();\n        clientArray.add(clientArray(clientID, groupID, savingsProductID, \"08 January 2013\"));\n\n        final Integer gsimID = this.savingsAccountHelper.applyForGsimApplication(clientArray);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.approveGsimSavings(gsimID);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateGsimSavings(gsimID);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        final String CLOSEDON_DATE = dateFormat.format(todaysDate.getTime());\n        String withdrawBalance = \"false\";\n        ArrayList<HashMap> savingsAccountErrorData = (ArrayList<HashMap>) validationErrorHelper\n                .closeGsimSavingsAccountAndGetBackRequiredField(gsimID, withdrawBalance, CommonConstants.RESPONSE_ERROR, CLOSEDON_DATE);\n        assertEquals(\"validation.msg.savingsaccount.close.results.in.balance.not.zero\",\n                savingsAccountErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        withdrawBalance = \"true\";\n        savingsStatusHashMap = this.savingsAccountHelper.closeGsimSavingsAccount(gsimID, withdrawBalance);\n        SavingsStatusChecker.verifySavingsAccountIsClosed(savingsStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Gsim Savings Account UPDATE APPLICATION", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testGsimSavingsAccount_UPDATE_APPLICATION() {\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"1000.0\";\n        final String enforceMinRequiredBalance = \"true\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        List<Map<String, Object>> clientArray = new ArrayList<>();\n        clientArray.add(clientArray(clientID, groupID, savingsProductID, \"08 January 2013\"));\n\n        final Integer gsimID = this.savingsAccountHelper.applyForGsimApplication(clientArray);\n\n        HashMap savingsStatusHashMap = this.savingsAccountHelper.updateGsimApplication(gsimID, clientID, groupID, savingsProductID);\n        LOG.info(\"savingsStatusHashMap: {} \", savingsStatusHashMap);\n        Assertions.assertTrue(savingsStatusHashMap.containsKey(\"savingsId\"));\n\n    }"}
{"prompt": "Create a test that tests get Gsim Account", "completion": "    @Test\n    public void getGsimAccount() {\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(400).build();\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        // Assertions.assertNotNull(clientID);\n\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        Assertions.assertNotNull(groupID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        Assertions.assertNotNull(groupID);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = \"1000.0\";\n        final String enforceMinRequiredBalance = \"true\";\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance);\n        Assertions.assertNotNull(savingsProductID);\n\n        List<Map<String, Object>> clientArray = new ArrayList<>();\n        clientArray.add(clientArray(clientID, groupID, savingsProductID, \"08 January 2013\"));\n        final Integer gsimID = this.savingsAccountHelper.applyForGsimApplication(clientArray);\n\n        final List<String> retrievedGsimId = GroupHelper.verifyRetrieveGsimAccounts(this.requestSpec, this.responseSpec, groupID);\n        Assertions.assertNotNull(retrievedGsimId.toString());\n    }"}
{"prompt": "Create a test that tests check Group Functions", "completion": "    @Test\n    public void checkGroupFunctions() {\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec);\n        GroupHelper.verifyGroupCreatedOnServer(this.requestSpec, this.responseSpec, groupID);\n\n        groupID = GroupHelper.activateGroup(this.requestSpec, this.responseSpec, groupID.toString());\n        GroupHelper.verifyGroupActivatedOnServer(this.requestSpec, this.responseSpec, groupID, true);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        GroupHelper.verifyGroupMembers(this.requestSpec, this.responseSpec, groupID, clientID);\n\n        groupID = GroupHelper.disAssociateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        GroupHelper.verifyEmptyGroupMembers(this.requestSpec, this.responseSpec, groupID);\n\n        final String updatedGroupName = GroupHelper.randomNameGenerator(\"Group-\", 5);\n        groupID = GroupHelper.updateGroup(this.requestSpec, this.responseSpec, updatedGroupName, groupID.toString());\n        GroupHelper.verifyGroupDetails(this.requestSpec, this.responseSpec, groupID, \"name\", updatedGroupName);\n\n        // NOTE: removed as consistently provides false positive result on\n        // cloudbees server.\n        // groupID = GroupHelper.createGroup(this.requestSpec,\n        // this.responseSpec);\n        // GroupHelper.deleteGroup(this.requestSpec, this.responseSpec,\n        // groupID.toString());\n        // GroupHelper.verifyGroupDeleted(this.requestSpec, this.responseSpec,\n        // groupID);\n    }"}
{"prompt": "Create a test that tests assign Staff To Group", "completion": "    @Test\n    public void assignStaffToGroup() {\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec);\n        GroupHelper.verifyGroupCreatedOnServer(this.requestSpec, this.responseSpec, groupID);\n\n        final String updateGroupName = Utils.uniqueRandomStringGenerator(\"Savings Group Help_\", 5);\n        groupID = GroupHelper.activateGroup(this.requestSpec, this.responseSpec, groupID.toString());\n        Integer updateGroupId = GroupHelper.updateGroup(this.requestSpec, this.responseSpec, updateGroupName, groupID.toString());\n\n        // create client and add client to group\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        GroupHelper.verifyGroupMembers(this.requestSpec, this.responseSpec, groupID, clientID);\n\n        // create staff\n        Integer createStaffId1 = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        LOG.info(\"--------------creating first staff with id------------- {}\", createStaffId1);\n        Assertions.assertNotNull(createStaffId1);\n\n        Integer createStaffId2 = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        LOG.info(\"--------------creating second staff with id------------- {}\", createStaffId2);\n        Assertions.assertNotNull(createStaffId2);\n\n        // assign staff \"createStaffId1\" to group\n        HashMap assignStaffGroupId = (HashMap) GroupHelper.assignStaff(this.requestSpec, this.responseSpec, groupID.toString(),\n                createStaffId1.longValue());\n        assertEquals(assignStaffGroupId.get(\"staffId\"), createStaffId1, \"Verify assigned staff id is the same as id sent\");\n\n        // assign staff \"createStaffId2\" to client\n        final HashMap assignStaffToClientChanges = (HashMap) ClientHelper.assignStaffToClient(this.requestSpec, this.responseSpec,\n                clientID.toString(), createStaffId2.toString());\n        assertEquals(assignStaffToClientChanges.get(\"staffId\"), createStaffId2, \"Verify assigned staff id is the same as id sent\");\n\n        final Integer loanProductId = this.createLoanProduct();\n\n        final Integer loanId = this.applyForLoanApplication(clientID, loanProductId, this.principal);\n\n        this.loanTransactionHelper.approveLoan(\"20 September 2014\", loanId);\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2014\", loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n\n        final HashMap assignStaffAndInheritStaffForClientAccounts = (HashMap) GroupHelper.assignStaffInheritStaffForClientAccounts(\n                this.requestSpec, this.responseSpec, groupID.toString(), createStaffId1.toString());\n        final Integer getClientStaffId = ClientHelper.getClientsStaffId(this.requestSpec, this.responseSpec, clientID.toString());\n\n        // assert if client staff officer has change Note client was assigned\n        // staff with createStaffId2\n        assertNotEquals(assignStaffAndInheritStaffForClientAccounts.get(\"staffId\"), createStaffId2, \"Verify if client stuff has changed\");\n        assertEquals(assignStaffAndInheritStaffForClientAccounts.get(\"staffId\"), getClientStaffId,\n                \"Verify if client inherited staff assigned above\");\n\n        // assert if clients loan officer has changed\n        final Integer loanOfficerId = this.loanTransactionHelper.getLoanOfficerId(loanId.toString());\n        assertEquals(assignStaffAndInheritStaffForClientAccounts.get(\"staffId\"), loanOfficerId, \"Verify if client loan inherited staff\");\n\n    }"}
{"prompt": "Create a test that tests should Send Office Creation Notification", "completion": "    @Test\n    public void shouldSendOfficeCreationNotification() {\n        // Subject to https://echo-webhook.herokuapp.com being up\n        // See http://www.jamesward.com/2014/06/11/testing-webhooks-was-a-pain-so-i-fixed-the-glitch\n        final String uniqueId = UUID.randomUUID().toString();\n        final String payloadURL = \"http://echo-webhook.herokuapp.com:80/\" + uniqueId + \"/\";\n        final Integer hookId = this.hookHelper.createHook(payloadURL);\n        Assertions.assertNotNull(hookId);\n        final Integer createdOfficeID = this.officeHelper.createOffice(\"01 January 2012\");\n        Assertions.assertNotNull(createdOfficeID);\n        try {\n            // sleep for a three seconds after each failure to increase the likelihood of the previous request for\n            // creating office completing\n            for (int i = 0; i < 6; i++) {\n                try {\n                    final String json = RestAssured.get(payloadURL.replace(\"?\", \"\")).asString();\n                    final Integer notificationOfficeId = JsonPath.with(json).get(\"officeId\");\n                    Assertions.assertEquals(createdOfficeID, notificationOfficeId,\n                            \"Equality check for created officeId and hook received payload officeId\");\n                    LOG.info(\"Notification Office Id - {}\", notificationOfficeId);\n                    i = 6;\n                } catch (Exception e) {\n                    TimeUnit.SECONDS.sleep(3);\n                    i++;\n                }\n            }\n\n        } catch (final Exception e) {\n            if (e instanceof HttpHostConnectException) {\n                fail(\"Failed to connect to https://echo-webhook.herokuapp.com platform\");\n            }\n            throw new RuntimeException(e);\n        } finally {\n            this.hookHelper.deleteHook(hookId.longValue());\n        }\n    }"}
{"prompt": "Create a test that tests create Update And Delete Hook", "completion": "    @Test\n    public void createUpdateAndDeleteHook() {\n        final String payloadURL = \"http://echo-webhook.herokuapp.com:80/Z7RXoCBdLSFMDrpn/\";\n        final String updateURL = \"http://localhost\";\n\n        Long hookId = this.hookHelper.createHook(payloadURL).longValue();\n        Assertions.assertNotNull(hookId);\n        this.hookHelper.verifyHookCreatedOnServer(hookId);\n        LOG.info(\"---------------------SUCCESSFULLY CREATED AND VERIFIED HOOK------------------------- {}\", hookId);\n        this.hookHelper.updateHook(updateURL, hookId);\n        this.hookHelper.verifyUpdateHook(updateURL, hookId);\n        LOG.info(\"---------------------SUCCESSFULLY UPDATED AND VERIFIED HOOK------------------------- {}\", hookId);\n        this.hookHelper.deleteHook(hookId);\n        this.hookHelper.verifyDeleteHook(hookId);\n        LOG.info(\"---------------------SUCCESSFULLY DELETED AND VERIFIED HOOK------------------------- {}\", hookId);\n    }"}
{"prompt": "Create a test that tests shoud The Second Request With Same Idempotency Key Will Failure Too", "completion": "    @Test\n    public void shoudTheSecondRequestWithSameIdempotencyKeyWillFailureToo() {\n        ResponseSpecification responseSpecForError = new ResponseSpecBuilder().expectStatusCode(400).build();\n        List<BusinessStep> requestBody = new ArrayList<>();\n        String idempotencyKey = UUID.randomUUID().toString();\n        // IdempotencyHelper.configuredApiParameterErrorFromJsonString(response.getBody().asString())\n\n        Response response1 = IdempotencyHelper.updateBusinessStepOrderWithError(requestSpec, responseSpecForError, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKey);\n        Assertions.assertNull(response1.getHeader(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        String originalBody = response1.getBody().asString();\n\n        Response response2 = IdempotencyHelper.updateBusinessStepOrderWithError(requestSpec, responseSpecForError, LOAN_JOB_NAME,\n                IdempotencyHelper.toJsonString(requestBody), idempotencyKey);\n        Assertions.assertNotNull(response2.getHeader(AbstractIdempotentCommandException.IDEMPOTENT_CACHE_HEADER));\n        Assertions.assertEquals(originalBody, response2.getBody().asString());\n    }"}
{"prompt": "Create a test that tests test Get Head Office Works When Instance Mode Is Read Only", "completion": "    @ConfigureInstanceMode(readEnabled = true, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = false)\n    @Test\n    public void testGetHeadOfficeWorks_WhenInstanceModeIsReadOnly() {\n        // given\n        // when\n        GetOfficesResponse result = OfficeHelper.getHeadOffice(requestSpec, responseSpec200);\n        // then\n        assertNotNull(result);\n    }"}
{"prompt": "Create a test that tests test Get Head Office Works When Instance Mode Is Write Only", "completion": "    @ConfigureInstanceMode(readEnabled = false, writeEnabled = true, batchWorkerEnabled = false, batchManagerEnabled = false)\n    @Test\n    public void testGetHeadOfficeWorks_WhenInstanceModeIsWriteOnly() {\n        // given\n        // when\n        GetOfficesResponse result = OfficeHelper.getHeadOffice(requestSpec, responseSpec200);\n        // then\n        assertNotNull(result);\n    }"}
{"prompt": "Create a test that tests test Get Head Office Doesnt Work When Instance Mode Is Batch Only", "completion": "    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = true, batchManagerEnabled = true)\n    @Test\n    public void testGetHeadOfficeDoesntWork_WhenInstanceModeIsBatchOnly() {\n        // given\n        // when\n        OfficeHelper.getHeadOffice(requestSpec, responseSpec405);\n        // then no exception is thrown\n    }"}
{"prompt": "Create a test that tests test Create Client Doesnt Work When Read Only", "completion": "    @ConfigureInstanceMode(readEnabled = true, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = false)\n    @Test\n    public void testCreateClientDoesntWork_WhenReadOnly() {\n        // given\n        PostClientsRequest request = ClientHelper.defaultClientCreationRequest();\n        // when\n        ClientHelper.createClient(requestSpec, responseSpec405, request);\n        // then no exception thrown\n    }"}
{"prompt": "Create a test that tests test Create Client Works When Write Only", "completion": "    @ConfigureInstanceMode(readEnabled = false, writeEnabled = true, batchWorkerEnabled = false, batchManagerEnabled = false)\n    @Test\n    public void testCreateClientWorks_WhenWriteOnly() {\n        // given\n        PostClientsRequest request = ClientHelper.defaultClientCreationRequest();\n        // when\n        Integer result = ClientHelper.createClient(requestSpec, responseSpec200, request);\n        // then\n        assertNotNull(result);\n    }"}
{"prompt": "Create a test that tests test Create Client Doesnt Work When Batch Only", "completion": "    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = true, batchManagerEnabled = true)\n    @Test\n    public void testCreateClientDoesntWork_WhenBatchOnly() {\n        // given\n        PostClientsRequest request = ClientHelper.defaultClientCreationRequest();\n        // when\n        ClientHelper.createClient(requestSpec, responseSpec405, request);\n        // then no exception thrown\n    }"}
{"prompt": "Create a test that tests test Run Scheduler Job Doesnt Work When Read Only", "completion": "    @ConfigureInstanceMode(readEnabled = true, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = false)\n    @Test\n    public void testRunSchedulerJobDoesntWork_WhenReadOnly() {\n        // given\n        // when\n        schedulerJobHelper.runSchedulerJob(jobId, responseSpec405);\n        // then no exception thrown\n    }"}
{"prompt": "Create a test that tests test Run Scheduler Job Doesnt Work When Write Only", "completion": "    @ConfigureInstanceMode(readEnabled = false, writeEnabled = true, batchWorkerEnabled = false, batchManagerEnabled = false)\n    @Test\n    public void testRunSchedulerJobDoesntWork_WhenWriteOnly() {\n        // given\n        // when\n        schedulerJobHelper.runSchedulerJob(jobId, responseSpec405);\n        // then no exception thrown\n    }"}
{"prompt": "Create a test that tests test Run Scheduler Job Works When Batch Only", "completion": "    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = true, batchManagerEnabled = true)\n    @Test\n    public void testRunSchedulerJobWorks_WhenBatchOnly() {\n        // given\n        // when\n        schedulerJobHelper.runSchedulerJob(jobId);\n        // then no exception thrown\n    }"}
{"prompt": "Create a test that tests loan Arrears Ageing COBBusiness Step Test", "completion": "    @Test\n    public void loanArrearsAgeingCOBBusinessStepTest() {\n        // Set Business Date\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            LocalDate businessDate = Utils.getLocalDateOfTenant();\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n\n            LocalDate operationDate = businessDate.minusDays(40);\n            String loanOperationDate = Utils.dateFormatter.format(operationDate);\n\n            // create Client\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n\n            // create Loan Product\n\n            // Delinquency Bucket\n            final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketId);\n\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                    delinquencyBucketId);\n            assertNotNull(getLoanProductsProductResponse);\n\n            // Loan1 ExternalId\n            String loan1ExternalIdStr = UUID.randomUUID().toString();\n\n            // create Loan Account for Client with Loan Product type 1\n            Long loanProductId = getLoanProductsProductResponse.getId();\n            final Integer loanId_1 = createLoanAccount(loanOperationDate, clientId, loanProductId, loan1ExternalIdStr);\n\n            String loan2ExternalIdStr = UUID.randomUUID().toString();\n            final Integer loanId_2 = createLoanAccount(loanOperationDate, clientId, loanProductId, loan2ExternalIdStr);\n\n            // Run Loan cob with verfying business step for Update Arrears ageing details\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n\n            // COB Step Validation\n            final JobBusinessStepConfigData jobBusinessStepConfigData = BusinessStepConfigurationHelper\n                    .getConfiguredBusinessStepsByJobName(requestSpec, responseSpec, BusinessConfigurationApiTest.LOAN_JOB_NAME);\n            assertNotNull(jobBusinessStepConfigData);\n            assertEquals(BusinessConfigurationApiTest.LOAN_JOB_NAME, jobBusinessStepConfigData.getJobName());\n            assertTrue(jobBusinessStepConfigData.getBusinessSteps().size() > 0);\n            assertTrue(jobBusinessStepConfigData.getBusinessSteps().stream()\n                    .anyMatch(businessStep -> UPDATE_LOAN_ARREARS_AGING.equals(businessStep.getStepName())));\n\n            // Run the Loan COB Job\n            final String jobName = \"Loan COB\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            // verify Arrears details are updated for both the loans, by verifying loan summary fields for\n            // principalOverdue,totalOverdue,overdueSinceddate\n\n            // Retrieve Loan 1 with loanId\n            GetLoansLoanIdResponse loan1Details = loanTransactionHelper.getLoanDetails((long) loanId_1);\n            GetLoansLoanIdSummary loan1Summary = loan1Details.getSummary();\n            assertNotNull(loan1Summary);\n            assertNotNull(loan1Summary.getOverdueSinceDate());\n            assertEquals(loan1Summary.getPrincipalOverdue(), 1000.00);\n            assertEquals(loan1Summary.getTotalOverdue(), 1000.00);\n\n            // Retrieve Loan 2 with loanId\n            GetLoansLoanIdResponse loan2Details = loanTransactionHelper.getLoanDetails((long) loanId_2);\n            GetLoansLoanIdSummary loan2Summary = loan2Details.getSummary();\n            assertNotNull(loan2Summary);\n            assertNotNull(loan2Summary.getOverdueSinceDate());\n            assertEquals(loan2Summary.getPrincipalOverdue(), 1000.00);\n            assertEquals(loan2Summary.getTotalOverdue(), 1000.00);\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests loan Credit Refund Payout Get Created With Chargeback Test", "completion": "    @Test\n    public void loanCreditRefundPayoutGetCreatedWithChargebackTest() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        // Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        // make Repayment with full amount, Loan balance becomes zero, Loan closes\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 September 2022\").locale(\"en\")\n                        .transactionAmount(1000.0));\n\n        // Chargeback full repayment amount to add to principal balance\n        PostLoansLoanIdTransactionsResponse chargebackResponse = loanTransactionHelper.chargebackLoanTransaction(loanExternalIdStr,\n                repaymentTransaction_1.getResourceId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().locale(\"en\").transactionAmount(1000.0).paymentTypeId(1L));\n\n        GetLoansLoanIdTransactionsTransactionIdResponse chargebackTransactionResponse = loanTransactionHelper\n                .getLoanTransactionDetails(chargebackResponse.getLoanId(), chargebackResponse.getResourceId());\n        assertEquals(1L, chargebackTransactionResponse.getPaymentDetailData().getPaymentType().getId());\n\n        // Verify Goodwill Credit can be created with full amount\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"8 September 2022\").locale(\"en\")\n                        .transactionAmount(1000.0));\n        assertNotNull(goodwillCredit_1);\n        assertEquals(goodwillCredit_1.getLoanId(), (long) loanId);\n\n        // Verify Goodwill Credit can be created after balance is zero again\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_2 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"9 September 2022\").locale(\"en\")\n                        .transactionAmount(10.0));\n        assertNotNull(goodwillCredit_2);\n        assertEquals(goodwillCredit_2.getLoanId(), (long) loanId);\n\n        // Verify Payout refund can be created after balance is zero again\n        final PostLoansLoanIdTransactionsResponse payoutRefund_1 = loanTransactionHelper.makePayoutRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"9 September 2022\").locale(\"en\")\n                        .transactionAmount(10.0));\n        assertNotNull(payoutRefund_1);\n        assertEquals(payoutRefund_1.getLoanId(), (long) loanId);\n\n        // Verify Merchant refund can be created after balance is zero again\n        final PostLoansLoanIdTransactionsResponse merchantIssuedRefund_1 = loanTransactionHelper.makeMerchantIssuedRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"10 September 2022\").locale(\"en\")\n                        .transactionAmount(10.0));\n        assertNotNull(merchantIssuedRefund_1);\n        assertEquals(merchantIssuedRefund_1.getLoanId(), (long) loanId);\n\n    }"}
{"prompt": "Create a test that tests test Mark Loan As Fraud", "completion": "    @Test\n    public void testMarkLoanAsFraud() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, todaysDate);\n            final String command = \"markAsFraud\";\n            // Client and Loan account creation\n            final Integer loanId = createAccounts(15, 1);\n\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n\n            // Default values Not Null and False\n            assertNotNull(getLoansLoanIdResponse.getFraud());\n            assertEquals(Boolean.FALSE, getLoansLoanIdResponse.getFraud());\n\n            String payload = loanTransactionHelper.getLoanFraudPayloadAsJSON(\"fraud\", \"true\");\n            // Send the request, not expecting any errors (because only open loan restriction removed)\n            PutLoansLoanIdResponse putLoansLoanIdResponse = loanTransactionHelper.modifyLoanCommand(loanId, command, payload,\n                    this.responseSpecError);\n\n            String statusCode = getLoansLoanIdResponse.getStatus().getCode();\n            log.info(\"Loan with Id {} is with Status {}\", getLoansLoanIdResponse.getId(), statusCode);\n\n            // Approve the Loan active\n            loanTransactionHelper.approveLoan(operationDate, this.amountVal, loanId, null);\n            putLoansLoanIdResponse = loanTransactionHelper.modifyLoanCommand(loanId, command, payload, this.responseSpecError);\n\n            // Default values Not Null and False\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            assertNotNull(getLoansLoanIdResponse.getFraud());\n            assertEquals(Boolean.FALSE, getLoansLoanIdResponse.getFraud());\n            statusCode = getLoansLoanIdResponse.getStatus().getCode();\n            log.info(\"Loan with Id {} is with Status {}\", getLoansLoanIdResponse.getId(), statusCode);\n\n            loanTransactionHelper.disburseLoanWithNetDisbursalAmount(operationDate, loanId, this.amountVal);\n\n            // Mark On the Fraud\n            putLoansLoanIdResponse = loanTransactionHelper.modifyLoanCommand(loanId, command, payload, this.responseSpec);\n            assertNotNull(putLoansLoanIdResponse);\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            assertNotNull(getLoansLoanIdResponse.getFraud());\n            assertEquals(Boolean.TRUE, getLoansLoanIdResponse.getFraud());\n\n            // Mark Off the Fraud\n            payload = loanTransactionHelper.getLoanFraudPayloadAsJSON(\"fraud\", \"false\");\n            putLoansLoanIdResponse = loanTransactionHelper.modifyLoanCommand(loanId, command, payload, this.responseSpec);\n            assertNotNull(putLoansLoanIdResponse);\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            assertNotNull(getLoansLoanIdResponse.getFraud());\n            assertEquals(Boolean.FALSE, getLoansLoanIdResponse.getFraud());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests loan Overpaid Date Status Test", "completion": "    @Test\n    public void loanOverpaidDateStatusTest() {\n        // Set business date\n        try {\n            final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, todaysDate);\n\n            // Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            // Delinquency Bucket\n            final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketId);\n\n            // Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                    delinquencyBucketId);\n            assertNotNull(getLoanProductsProductResponse);\n\n            final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n            // make Repayments\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 September 2022\").locale(\"en\")\n                            .transactionAmount(200.0));\n\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_2 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"6 September 2022\").locale(\"en\")\n                            .transactionAmount(200.0));\n\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_3 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"7 September 2022\").locale(\"en\")\n                            .transactionAmount(500.0));\n\n            // make repayment to make loan overpaid\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_4 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"9 September 2022\").locale(\"en\")\n                            .transactionAmount(200.0));\n\n            // check loan overpaid date is not null and is set as Business date and loan status\n            GetLoansLoanIdResponse loanDetailsOverpaid = loanTransactionHelper.getLoanDetails((long) loanId);\n            assertTrue(loanDetailsOverpaid.getStatus().getOverpaid());\n            assertNotNull(loanDetailsOverpaid.getOverpaidOnDate());\n            assertEquals(loanDetailsOverpaid.getOverpaidOnDate(), LocalDate.of(2022, 9, 9));\n\n            // reverse repayment to make loan not overpaid and overpaid date is reset\n            loanTransactionHelper.reverseRepayment(loanId, repaymentTransaction_4.getResourceId().intValue(), \"10 September 2022\");\n            GetLoansLoanIdResponse loanDetailsNotOverpaidAfterReversal = loanTransactionHelper.getLoanDetails((long) loanId);\n            assertFalse(loanDetailsNotOverpaidAfterReversal.getStatus().getOverpaid());\n            assertNull(loanDetailsNotOverpaidAfterReversal.getOverpaidOnDate());\n\n            // make repayment to make loan overpaid again\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_5 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"11 September 2022\").locale(\"en\")\n                            .transactionAmount(200.0));\n\n            // check loan overpaid date is not null and is set as Business date and loan status\n            GetLoansLoanIdResponse loanDetailsOverpaid_1 = loanTransactionHelper.getLoanDetails((long) loanId);\n            assertTrue(loanDetailsOverpaid_1.getStatus().getOverpaid());\n            assertNotNull(loanDetailsOverpaid_1.getOverpaidOnDate());\n            assertEquals(loanDetailsOverpaid_1.getOverpaidOnDate(), LocalDate.of(2022, 9, 11));\n\n            // Credit balance refund to reset overpaid status\n            loanTransactionHelper.creditBalanceRefund(\"12 September 2022\", Float.valueOf(100), null, loanId, \"\");\n            GetLoansLoanIdResponse loanDetailsNotOverpaidAfterCBR = loanTransactionHelper.getLoanDetails((long) loanId);\n            assertFalse(loanDetailsNotOverpaidAfterCBR.getStatus().getOverpaid());\n            assertNull(loanDetailsNotOverpaidAfterCBR.getOverpaidOnDate());\n\n            // reverse repayment to make loan active again\n            loanTransactionHelper.reverseRepayment(loanId, repaymentTransaction_2.getResourceId().intValue(), \"13 September 2022\");\n            GetLoansLoanIdResponse loanDetailsNotOverpaidAfterReversal_1 = loanTransactionHelper.getLoanDetails((long) loanId);\n            assertFalse(loanDetailsNotOverpaidAfterReversal_1.getStatus().getOverpaid());\n            assertNull(loanDetailsNotOverpaidAfterReversal_1.getOverpaidOnDate());\n\n            // make repayment to make loan overpaid again\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_6 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"14 September 2022\").locale(\"en\")\n                            .transactionAmount(300.0));\n\n            // check loan overpaid date is not null and is set as Business date and loan status\n            GetLoansLoanIdResponse loanDetailsOverpaid_3 = loanTransactionHelper.getLoanDetails((long) loanId);\n            assertTrue(loanDetailsOverpaid_3.getStatus().getOverpaid());\n            assertNotNull(loanDetailsOverpaid_3.getOverpaidOnDate());\n            assertEquals(loanDetailsOverpaid_3.getOverpaidOnDate(), LocalDate.of(2022, 9, 14));\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n\n    }"}
{"prompt": "Create a test that tests loan Accrual Transaction On Charge Submitted Test Accrual Accounting Api", "completion": "    @Test\n    public void loanAccrualTransactionOnChargeSubmittedTest_Accrual_Accounting_Api() {\n        try {\n\n            // Accounts oof periodic accrual\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            // Set business date\n            LocalDate currentDate = LocalDate.of(2023, 03, 3);\n            final String accrualRunTillDate = dateFormatter.format(currentDate);\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"submitted-date\");\n            // Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            // Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper, assetAccount,\n                    incomeAccount, expenseAccount, overpaymentAccount);\n            assertNotNull(getLoanProductsProductResponse);\n\n            final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n            // Add Charge Penalty\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            LocalDate targetDate = LocalDate.of(2023, 3, 10);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n            assertNotNull(penalty1LoanChargeId);\n\n            // Add Charge Fee\n            Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 14);\n            final String feeChargeAddedDate = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeChargeAddedDate, \"10\"));\n\n            assertNotNull(feeLoanChargeId);\n\n            // Run accrual for charge created date\n            this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(accrualRunTillDate);\n\n            // verify accrual transaction created for charges create date\n            checkAccrualTransaction(currentDate, 0.0f, 10.0f, 10.0f, loanId);\n\n            // Set business date\n            LocalDate futureDate = LocalDate.of(2023, 03, 4);\n            final String nextAccrualRunDate = dateFormatter.format(futureDate);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, futureDate);\n\n            // make repayment\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"4 March 2023\").locale(\"en\")\n                            .transactionAmount(100.0));\n\n            // Add Charge\n            Integer feeCharge_1 = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 21);\n            final String feeChargeAddedDate_1 = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId_1 = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge_1), feeChargeAddedDate_1, \"10\"));\n\n            assertNotNull(feeLoanChargeId_1);\n\n            // Run accrual for charge created date\n            this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(nextAccrualRunDate);\n\n            // verify accrual transaction created for charges create date\n            checkAccrualTransaction(futureDate, 0.0f, 10.0f, 0.0f, loanId);\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"due-date\");\n        }\n\n    }"}
{"prompt": "Create a test that tests loan Accrual Transaction On Charge Submitted Test Add Periodic Accrual Transactions Job", "completion": "    @Test\n    public void loanAccrualTransactionOnChargeSubmittedTest_Add_Periodic_Accrual_Transactions_Job() {\n        try {\n\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n            // Accounts oof periodic accrual\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            // Set business date\n            LocalDate currentDate = LocalDate.of(2023, 03, 3);\n            final String accrualRunTillDate = dateFormatter.format(currentDate);\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"submitted-date\");\n            // Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            // Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper, assetAccount,\n                    incomeAccount, expenseAccount, overpaymentAccount);\n            assertNotNull(getLoanProductsProductResponse);\n\n            final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n            // Add Charge Penalty\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            LocalDate targetDate = LocalDate.of(2023, 3, 10);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n            assertNotNull(penalty1LoanChargeId);\n\n            // Add Charge Fee\n            Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 14);\n            final String feeChargeAddedDate = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeChargeAddedDate, \"10\"));\n\n            assertNotNull(feeLoanChargeId);\n\n            // Run periodic accrual job for business date\n            final String jobName = \"Add Periodic Accrual Transactions\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            // verify accrual transaction created for charges create date\n            checkAccrualTransaction(currentDate, 0.0f, 10.0f, 10.0f, loanId);\n\n            // Set business date\n            LocalDate futureDate = LocalDate.of(2023, 03, 4);\n            final String nextAccrualRunDate = dateFormatter.format(futureDate);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, futureDate);\n\n            // make repayment\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"4 March 2023\").locale(\"en\")\n                            .transactionAmount(100.0));\n\n            // Add Charge\n            Integer feeCharge_1 = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 21);\n            final String feeChargeAddedDate_1 = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId_1 = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge_1), feeChargeAddedDate_1, \"10\"));\n\n            assertNotNull(feeLoanChargeId_1);\n\n            // Run periodic accrual job for business date\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            // verify accrual transaction created for charges create date\n            checkAccrualTransaction(futureDate, 0.0f, 10.0f, 0.0f, loanId);\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"due-date\");\n        }\n    }"}
{"prompt": "Create a test that tests loan Accrual Transaction On Charge Submitted Test Loan COB Add Periodic Accrual Entries Business Step", "completion": "    @Test\n    public void loanAccrualTransactionOnChargeSubmittedTest_Loan_COB_AddPeriodicAccrualEntriesBusinessStep() {\n        try {\n\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n            // Accounts oof periodic accrual\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            // Set business date\n            LocalDate currentDate = LocalDate.of(2023, 03, 3);\n            final String accrualRunTillDate = dateFormatter.format(currentDate);\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"submitted-date\");\n            // Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            // Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper, assetAccount,\n                    incomeAccount, expenseAccount, overpaymentAccount);\n            assertNotNull(getLoanProductsProductResponse);\n\n            final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n            // Add Charge Penalty\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            LocalDate targetDate = LocalDate.of(2023, 3, 10);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n            assertNotNull(penalty1LoanChargeId);\n\n            // Add Charge Fee\n            Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 14);\n            final String feeChargeAddedDate = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeChargeAddedDate, \"10\"));\n\n            assertNotNull(feeLoanChargeId);\n\n            // Run cob job for business date + 1\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate.plusDays(1));\n\n            final String jobName = \"Loan COB\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            // verify accrual transaction created for charges create date\n            checkAccrualTransaction(currentDate, 0.0f, 10.0f, 10.0f, loanId);\n\n            // Set business date\n            LocalDate futureDate = LocalDate.of(2023, 03, 4);\n            final String nextAccrualRunDate = dateFormatter.format(futureDate);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, futureDate);\n\n            // make repayment\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"4 March 2023\").locale(\"en\")\n                            .transactionAmount(100.0));\n\n            // Add Charge\n            Integer feeCharge_1 = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 21);\n            final String feeChargeAddedDate_1 = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId_1 = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge_1), feeChargeAddedDate_1, \"10\"));\n\n            assertNotNull(feeLoanChargeId_1);\n\n            // Run cob job for business date + 1\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, futureDate.plusDays(1));\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            // verify accrual transaction created for charges create date\n            checkAccrualTransaction(futureDate, 0.0f, 10.0f, 0.0f, loanId);\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"due-date\");\n        }\n    }"}
{"prompt": "Create a test that tests loan Accrual Transaction On Charge Submitted Test Add Accrual Transactions Job", "completion": "    @Test\n    public void loanAccrualTransactionOnChargeSubmittedTest_Add_Accrual_Transactions_Job() {\n        try {\n\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n            // Accounts oof periodic accrual\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            // Set business date\n            LocalDate currentDate = LocalDate.of(2023, 03, 3);\n            final String accrualRunTillDate = dateFormatter.format(currentDate);\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"submitted-date\");\n            // Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            // Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper, assetAccount,\n                    incomeAccount, expenseAccount, overpaymentAccount);\n            assertNotNull(getLoanProductsProductResponse);\n\n            final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n            // Add Charge Penalty\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            LocalDate targetDate = LocalDate.of(2023, 3, 10);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n            assertNotNull(penalty1LoanChargeId);\n\n            // Add Charge Fee\n            Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 14);\n            final String feeChargeAddedDate = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeChargeAddedDate, \"10\"));\n\n            assertNotNull(feeLoanChargeId);\n\n            // Run accrual entries job for business date\n            final String jobName = \"Add Accrual Transactions\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            // verify accrual transaction created for charges create date\n            checkAccrualTransaction(currentDate, 0.0f, 10.0f, 10.0f, loanId);\n\n            // Set business date\n            LocalDate futureDate = LocalDate.of(2023, 03, 4);\n            final String nextAccrualRunDate = dateFormatter.format(futureDate);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, futureDate);\n\n            // make repayment\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"4 March 2023\").locale(\"en\")\n                            .transactionAmount(100.0));\n\n            // Add Charge\n            Integer feeCharge_1 = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n            targetDate = LocalDate.of(2023, 3, 21);\n            final String feeChargeAddedDate_1 = dateFormatter.format(targetDate);\n            Integer feeLoanChargeId_1 = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge_1), feeChargeAddedDate_1, \"10\"));\n\n            assertNotNull(feeLoanChargeId_1);\n\n            // Run accrual entries job for business date\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            // verify accrual transaction created for charges create date\n            checkAccrualTransaction(futureDate, 0.0f, 10.0f, 0.0f, loanId);\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"due-date\");\n        }\n    }"}
{"prompt": "Create a test that tests loan Accrual Transaction On Charge Submitted With Multiple Repayments Test Add Periodic Accrual Transactions Job", "completion": "    @Test\n    public void loanAccrualTransactionOnChargeSubmitted_With_Multiple_Repayments_Test_Add_Periodic_Accrual_Transactions_Job() {\n        try {\n\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n            // Accounts oof periodic accrual\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            // Set business date\n            LocalDate currentDate = LocalDate.of(2023, 03, 3);\n            final String accrualRunTillDate = dateFormatter.format(currentDate);\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"submitted-date\");\n            // Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            // Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductMultipleRepayments(\n                    loanTransactionHelper, assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            assertNotNull(getLoanProductsProductResponse);\n\n            final Integer loanId = createLoanAccountMultipleRepayments(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n            // Add Charge Penalty\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            // Due for future date in one of the schedule\n            LocalDate targetDate = LocalDate.of(2023, 3, 10);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n            assertNotNull(penalty1LoanChargeId);\n\n            // Add Charge Penalty\n            Integer penalty_1 = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            // Due for future date in different of the schedule\n            targetDate = LocalDate.of(2023, 3, 17);\n            final String penaltyChargeAddedDate = dateFormatter.format(targetDate);\n            Integer penaltyLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty_1), penaltyChargeAddedDate, \"10\"));\n\n            assertNotNull(penaltyLoanChargeId);\n\n            // Run periodic accrual job for business date\n            final String jobName = \"Add Periodic Accrual Transactions\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            // verify multiple accrual transactions are created on charge created date according to repayment schedule\n            // to which charge due date falls\n            checkAccrualTransactionsForMultipleRepaymentSchedulesChargeDueDate(currentDate, loanId);\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"due-date\");\n        }\n    }"}
{"prompt": "Create a test that tests loan Accrual Transaction On Charge Submitted multiple disbursement reversal test Loan COB", "completion": "    @Test\n    public void loanAccrualTransactionOnChargeSubmitted_multiple_disbursement_reversal_test_Loan_COB() {\n        try {\n\n            final SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n            // Accounts oof periodic accrual\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            // Set business date\n            LocalDate currentDate = LocalDate.of(2023, 03, 3);\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"submitted-date\");\n            // Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            // Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductMultipleDisbursements(\n                    loanTransactionHelper, assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n            assertNotNull(getLoanProductsProductResponse);\n\n            final Integer loanId = createLoanAccountMultipleRepaymentsDisbursement(clientId, getLoanProductsProductResponse.getId(),\n                    loanExternalIdStr);\n\n            loanTransactionHelper.disburseLoanWithTransactionAmount(\"03 March 2023\", loanId, \"1000\");\n\n            // Add Charge Penalty\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            LocalDate targetDate = LocalDate.of(2023, 3, 9);\n            final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n            assertNotNull(penalty1LoanChargeId);\n\n            // Run cob job for business date + 1\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate.plusDays(1));\n\n            final String jobName = \"Loan COB\";\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            // verify accrual transaction created for charges create date\n            checkAccrualTransaction(currentDate, 0.0f, 0.0f, 10.0f, loanId);\n\n            // Set business date\n            LocalDate futureDate = LocalDate.of(2023, 03, 4);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, futureDate);\n\n            loanTransactionHelper.disburseLoanWithTransactionAmount(\"04 March 2023\", loanId, \"300\");\n\n            // verify accrual transaction exists with same date,amount and is not reversed by regeneration of repayment\n            // schedule\n            checkAccrualTransaction(currentDate, 0.0f, 0.0f, 10.0f, loanId);\n\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateChargeAccrualDateConfiguration(this.requestSpec, this.responseSpec, \"due-date\");\n        }\n    }"}
{"prompt": "Create a test that tests test No Accrual Transaction Reversal For Multiple Disbursement With Charge For Loan Account With No Interest Bearing Schedule Periodic Accrual", "completion": "    @Test\n    public void testNoAccrualTransactionReversalForMultipleDisbursementWithChargeForLoanAccountWithNoInterestBearingSchedulePeriodicAccrual() {\n\n        // Accounts for periodic accrual\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        // Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithMultipleDisbursement(\n                loanTransactionHelper, delinquencyBucketId, assetAccount, incomeAccount, expenseAccount, overpaymentAccount);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n        // 1st disbursement\n        loanTransactionHelper.disburseLoanWithTransactionAmount(\"03 September 2022\", loanId, \"100\");\n        // 2nd disbursement\n        loanTransactionHelper.disburseLoanWithTransactionAmount(\"04 September 2022\", loanId, \"300\");\n\n        // Add Charge\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 4);\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        // Run accrual till charge date\n        this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(penaltyCharge1AddedDate);\n\n        // verify accrual transaction created\n        checkAccrualTransaction(targetDate, 0.0f, 0.0f, 10.0f, loanId);\n\n        // 3rd disbursement\n        loanTransactionHelper.disburseLoanWithTransactionAmount(\"05 September 2022\", loanId, \"600\");\n\n        // verify accrual transaction exists with same date,amount and is not reversed by regeneration of repayment\n        // schedule\n        checkAccrualTransaction(targetDate, 0.0f, 0.0f, 10.0f, loanId);\n\n    }"}
{"prompt": "Create a test that tests test Last Accrual Transaction Reversal Recalculation For Loan Account With Interest Bearing Schedule With Declining Balance", "completion": "    @Test\n    public void testLastAccrualTransactionReversalRecalculationForLoanAccountWithInterestBearingScheduleWithDecliningBalance() {\n\n        try {\n            // Set business date\n            LocalDate currentDate = LocalDate.of(2022, 05, 8);\n            final String accrualRunTillDate = dateFormatter.format(currentDate);\n\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, currentDate);\n\n            // Accounts oof periodic accrual\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            // Loan ExternalId\n            String loanExternalIdStr = UUID.randomUUID().toString();\n\n            // Client and Loan account creation\n\n            final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n\n            // create loan product\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithInterestRecalculation(assetAccount,\n                    incomeAccount, expenseAccount, overpaymentAccount);\n            assertNotNull(getLoanProductsProductResponse);\n            // create loan account\n            final Integer loanId = createLoanAccountWithInterestRecalculation(clientId, getLoanProductsProductResponse.getId(),\n                    loanExternalIdStr);\n            // run accruals till business date\n            this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(accrualRunTillDate);\n            // check amount for last accrual on business date\n            checkAccrualTransaction(currentDate, 0.82f, 0.0f, 0.0f, loanId);\n            // make repayment on due date\n            final PostLoansLoanIdTransactionsResponse repaymentTransaction = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                    new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 February 2022\").locale(\"en\")\n                            .transactionAmount(106.57));\n            // check previous accrual is reversed and new accrual created for same date and different amount.\n            checkAccrualTransaction(currentDate, 0.71f, 0.0f, 0.0f, loanId);\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n\n    }"}
{"prompt": "Create a test that tests loan Application Approved Amount Less Than Proposed Amount", "completion": "    @Test\n    public void loanApplicationApprovedAmountLessThanProposedAmount() {\n\n        final String proposedAmount = \"8000\";\n        final String approvalAmount = \"5000\";\n        final String approveDate = \"20 September 2012\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, proposedAmount);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        final String expectedDisbursementDate = null;\n        List<HashMap> approveTranches = null;\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(approveDate, expectedDisbursementDate, approvalAmount,\n                loanID, approveTranches);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests loan Application Approved Amount Greater Than Proposed Amount", "completion": "    @Test\n    public void loanApplicationApprovedAmountGreaterThanProposedAmount() {\n\n        final String proposedAmount = \"5000\";\n        final String approvalAmount = \"9000\";\n        final String approveDate = \"20 September 2011\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, proposedAmount);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpecForStatusCode403);\n\n        @SuppressWarnings(\"unchecked\")\n        List<HashMap> error = (List<HashMap>) this.loanTransactionHelper.approveLoan(approveDate, approvalAmount, loanID,\n                CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.loan.approval.amount.can't.be.greater.than.loan.amount.demanded\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    }"}
{"prompt": "Create a test that tests loan Application Approval And Validation For Multi Disburse Loans", "completion": "    @Test\n    public void loanApplicationApprovalAndValidationForMultiDisburseLoans() {\n\n        List<HashMap> createTranches = new ArrayList<>();\n        createTranches.add(createTrancheDetail(\"01 March 2014\", \"1000\"));\n        createTranches.add(createTrancheDetail(\"23 March 2014\", \"4000\"));\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        LOG.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientID);\n\n        final Integer loanProductID = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withInterestTypeAsDecliningBalance().withTranches(true)\n                        .withInterestCalculationPeriodTypeAsRepaymentPeriod(true).build(null));\n        LOG.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductID);\n\n        this.trancheLoansApprovedAmountLesserThanProposedAmount(clientID, loanProductID, createTranches);\n        this.trancheLoansApprovalValidation(clientID, loanProductID, createTranches);\n\n    }"}
{"prompt": "Create a test that tests loan Application Rejection For Periodic Accrual Accounting Loan Product Test", "completion": "    @Test\n    public void loanApplicationRejectionForPeriodicAccrualAccountingLoanProductTest() {\n\n        Account assetAccount = this.accountHelper.createAssetAccount();\n        Account incomeAccount = this.accountHelper.createIncomeAccount();\n        Account expenseAccount = this.accountHelper.createExpenseAccount();\n        Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        // Create Loan Product with Periodic Accrual accounting\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccounting(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Client and Loan account creation\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n\n        final Integer loanId = createLoanAccount(clientId, loanProductID, loanExternalIdStr);\n\n        // verify Loan status as submitted and pending approval\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getPendingApproval());\n\n        // Reject Loan application\n        PostLoansLoanIdResponse result = this.loanTransactionHelper.rejectLoan(loanExternalIdStr,\n                new PostLoansLoanIdRequest().rejectedOnDate(\"3 September 2022\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n\n        // Verify Loan application status is Rejected\n        assertTrue(result.getChanges().getStatus().getValue().equals(\"Rejected\"));\n\n    }"}
{"prompt": "Create a test that tests validate Seed Date31", "completion": "    @Test\n    public void validateSeedDate31() {\n        final Integer clientId = createClient(CLIENT_ACTIVATION_DATE);\n\n        String firstRepaymentDate = \"31 January 2023\";\n        Integer loanProductId = createLoanProductEntity();\n\n        Integer loanId = applyForLoanApplication(clientId, loanProductId, firstRepaymentDate);\n\n        final ArrayList<HashMap> repaymentPeriods = (ArrayList<HashMap>) this.loanTransactionHelper\n                .getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanId);\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 1, 31)), repaymentPeriods.get(1).get(DUE_DATE),\n                \"Checking for Due Date for 1st Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 2, 28)), repaymentPeriods.get(2).get(DUE_DATE),\n                \"Checking for Due Date for 2nd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 3, 31)), repaymentPeriods.get(3).get(DUE_DATE),\n                \"Checking for Due Date for 3rd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 4, 30)), repaymentPeriods.get(4).get(DUE_DATE),\n                \"Checking for Due Date for 4th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 5, 31)), repaymentPeriods.get(5).get(DUE_DATE),\n                \"Checking for Due Date for 5th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 6, 30)), repaymentPeriods.get(6).get(DUE_DATE),\n                \"Checking for Due Date for 6th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 7, 31)), repaymentPeriods.get(7).get(DUE_DATE),\n                \"Checking for Due Date for 7th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 8, 31)), repaymentPeriods.get(8).get(DUE_DATE),\n                \"Checking for Due Date for 8th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 9, 30)), repaymentPeriods.get(9).get(DUE_DATE),\n                \"Checking for Due Date for 9th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 10, 31)), repaymentPeriods.get(10).get(DUE_DATE),\n                \"Checking for Due Date for 10th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 11, 30)), repaymentPeriods.get(11).get(DUE_DATE),\n                \"Checking for Due Date for 11th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 12, 31)), repaymentPeriods.get(12).get(DUE_DATE),\n                \"Checking for Due Date for 12th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 1, 31)), repaymentPeriods.get(13).get(DUE_DATE),\n                \"Checking for Due Date for 13th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 2, 29)), repaymentPeriods.get(14).get(DUE_DATE),\n                \"Checking for Due Date for 14th Month\");\n    }"}
{"prompt": "Create a test that tests validate Seed Date30", "completion": "    @Test\n    public void validateSeedDate30() {\n        final Integer clientId = createClient(CLIENT_ACTIVATION_DATE);\n\n        String firstRepaymentDate = \"30 January 2023\";\n        Integer loanProductId = createLoanProductEntity();\n\n        Integer loanId = applyForLoanApplication(clientId, loanProductId, firstRepaymentDate);\n\n        final ArrayList<HashMap> repaymentPeriods = (ArrayList<HashMap>) this.loanTransactionHelper\n                .getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanId);\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 1, 30)), repaymentPeriods.get(1).get(DUE_DATE),\n                \"Checking for Due Date for 1st Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 2, 28)), repaymentPeriods.get(2).get(DUE_DATE),\n                \"Checking for Due Date for 2nd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 3, 30)), repaymentPeriods.get(3).get(DUE_DATE),\n                \"Checking for Due Date for 3rd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 4, 30)), repaymentPeriods.get(4).get(DUE_DATE),\n                \"Checking for Due Date for 4th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 5, 30)), repaymentPeriods.get(5).get(DUE_DATE),\n                \"Checking for Due Date for 5th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 6, 30)), repaymentPeriods.get(6).get(DUE_DATE),\n                \"Checking for Due Date for 6th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 7, 30)), repaymentPeriods.get(7).get(DUE_DATE),\n                \"Checking for Due Date for 7th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 8, 30)), repaymentPeriods.get(8).get(DUE_DATE),\n                \"Checking for Due Date for 8th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 9, 30)), repaymentPeriods.get(9).get(DUE_DATE),\n                \"Checking for Due Date for 9th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 10, 30)), repaymentPeriods.get(10).get(DUE_DATE),\n                \"Checking for Due Date for 10th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 11, 30)), repaymentPeriods.get(11).get(DUE_DATE),\n                \"Checking for Due Date for 11th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 12, 30)), repaymentPeriods.get(12).get(DUE_DATE),\n                \"Checking for Due Date for 12th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 1, 30)), repaymentPeriods.get(13).get(DUE_DATE),\n                \"Checking for Due Date for 13th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 2, 29)), repaymentPeriods.get(14).get(DUE_DATE),\n                \"Checking for Due Date for 14th Month\");\n    }\n\n    @SuppressWarnings({ \"unchecked\" }"}
{"prompt": "Create a test that tests validate Seed Date28", "completion": "    @Test\n    public void validateSeedDate28() {\n        final Integer clientId = createClient(CLIENT_ACTIVATION_DATE);\n\n        String firstRepaymentDate = \"28 January 2023\";\n        Integer loanProductId = createLoanProductEntity();\n\n        Integer loanId = applyForLoanApplication(clientId, loanProductId, firstRepaymentDate);\n\n        final ArrayList<HashMap> repaymentPeriods = (ArrayList<HashMap>) this.loanTransactionHelper\n                .getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanId);\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 1, 28)), repaymentPeriods.get(1).get(DUE_DATE),\n                \"Checking for Due Date for 1st Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 2, 28)), repaymentPeriods.get(2).get(DUE_DATE),\n                \"Checking for Due Date for 2nd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 3, 28)), repaymentPeriods.get(3).get(DUE_DATE),\n                \"Checking for Due Date for 3rd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 4, 28)), repaymentPeriods.get(4).get(DUE_DATE),\n                \"Checking for Due Date for 4th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 5, 28)), repaymentPeriods.get(5).get(DUE_DATE),\n                \"Checking for Due Date for 5th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 6, 28)), repaymentPeriods.get(6).get(DUE_DATE),\n                \"Checking for Due Date for 6th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 7, 28)), repaymentPeriods.get(7).get(DUE_DATE),\n                \"Checking for Due Date for 7th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 8, 28)), repaymentPeriods.get(8).get(DUE_DATE),\n                \"Checking for Due Date for 8th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 9, 28)), repaymentPeriods.get(9).get(DUE_DATE),\n                \"Checking for Due Date for 9th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 10, 28)), repaymentPeriods.get(10).get(DUE_DATE),\n                \"Checking for Due Date for 10th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 11, 28)), repaymentPeriods.get(11).get(DUE_DATE),\n                \"Checking for Due Date for 11th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 12, 28)), repaymentPeriods.get(12).get(DUE_DATE),\n                \"Checking for Due Date for 12th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 1, 28)), repaymentPeriods.get(13).get(DUE_DATE),\n                \"Checking for Due Date for 13th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 2, 28)), repaymentPeriods.get(14).get(DUE_DATE),\n                \"Checking for Due Date for 14th Month\");\n    }\n\n    @SuppressWarnings({ \"unchecked\" }"}
{"prompt": "Create a test that tests validate Seed Date25", "completion": "    @Test\n    public void validateSeedDate25() {\n        final Integer clientId = createClient(CLIENT_ACTIVATION_DATE);\n\n        String firstRepaymentDate = \"25 January 2023\";\n        Integer loanProductId = createLoanProductEntity();\n\n        Integer loanId = applyForLoanApplication(clientId, loanProductId, firstRepaymentDate);\n\n        final ArrayList<HashMap> repaymentPeriods = (ArrayList<HashMap>) this.loanTransactionHelper\n                .getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanId);\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 1, 25)), repaymentPeriods.get(1).get(DUE_DATE),\n                \"Checking for Due Date for 1st Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 2, 25)), repaymentPeriods.get(2).get(DUE_DATE),\n                \"Checking for Due Date for 2nd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 3, 25)), repaymentPeriods.get(3).get(DUE_DATE),\n                \"Checking for Due Date for 3rd Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 4, 25)), repaymentPeriods.get(4).get(DUE_DATE),\n                \"Checking for Due Date for 4th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 5, 25)), repaymentPeriods.get(5).get(DUE_DATE),\n                \"Checking for Due Date for 5th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 6, 25)), repaymentPeriods.get(6).get(DUE_DATE),\n                \"Checking for Due Date for 6th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 7, 25)), repaymentPeriods.get(7).get(DUE_DATE),\n                \"Checking for Due Date for 7th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 8, 25)), repaymentPeriods.get(8).get(DUE_DATE),\n                \"Checking for Due Date for 8th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 9, 25)), repaymentPeriods.get(9).get(DUE_DATE),\n                \"Checking for Due Date for 9th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 10, 25)), repaymentPeriods.get(10).get(DUE_DATE),\n                \"Checking for Due Date for 10th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 11, 25)), repaymentPeriods.get(11).get(DUE_DATE),\n                \"Checking for Due Date for 11th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2023, 12, 25)), repaymentPeriods.get(12).get(DUE_DATE),\n                \"Checking for Due Date for 12th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 1, 25)), repaymentPeriods.get(13).get(DUE_DATE),\n                \"Checking for Due Date for 13th Month\");\n\n        assertEquals(new ArrayList<>(Arrays.asList(2024, 2, 25)), repaymentPeriods.get(14).get(DUE_DATE),\n                \"Checking for Due Date for 14th Month\");\n    }"}
{"prompt": "Create a test that tests loan Application Undo Last Tranche", "completion": "    @Test\n    public void loanApplicationUndoLastTranche() {\n\n        final String proposedAmount = \"5000\";\n        final String approvalAmount = \"2000\";\n        final String approveDate = \"01 March 2014\";\n        final String expectedDisbursementDate = \"01 March 2014\";\n        final String disbursalDate = \"01 March 2014\";\n\n        // CREATE CLIENT\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        LOG.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientID);\n\n        // CREATE LOAN MULTIDISBURSAL PRODUCT\n        final Integer loanProductID = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withInterestTypeAsDecliningBalance().withTranches(true)\n                        .withInterestCalculationPeriodTypeAsRepaymentPeriod(true).build(null));\n        LOG.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductID);\n\n        // CREATE TRANCHES\n        List<HashMap> createTranches = new ArrayList<>();\n        createTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"01 March 2014\", \"1000\"));\n        createTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"23 June 2014\", \"4000\"));\n\n        // APPROVE TRANCHES\n        List<HashMap> approveTranches = new ArrayList<>();\n        approveTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"01 March 2014\", \"1000\"));\n        approveTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"23 June 2014\", \"1000\"));\n\n        // APPLY FOR LOAN WITH TRANCHES\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, proposedAmount, \"2\", createTranches);\n        LOG.info(\"-----------------------------------LOAN CREATED WITH LOANID------------------------------------------------- {}\", loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n\n        // VALIDATE THE LOAN STATUS\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(approveDate, expectedDisbursementDate, approvalAmount,\n                loanID, approveTranches);\n\n        // VALIDATE THE LOAN IS APPROVED\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        // DISBURSE A LOAN\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(disbursalDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n\n        // VALIDATE THE LOAN IS ACTIVE STATUS\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        LOG.info(\"-------------Make repayment 1-----------\");\n        this.loanTransactionHelper.makeRepayment(\"01 April 2014\", Float.valueOf(\"420\"), loanID);\n        LOG.info(\"-------------Make repayment 2-----------\");\n        this.loanTransactionHelper.makeRepayment(\"01 May 2014\", Float.valueOf(\"412\"), loanID);\n        LOG.info(\"-------------Make repayment 3-----------\");\n        this.loanTransactionHelper.makeRepayment(\"01 June 2014\", Float.valueOf(\"204\"), loanID);\n        // DISBURSE A SECOND TRANCHE\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"23 June 2014\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        // UNDO LAST TRANCHE\n        Float disbursedAmount = this.loanTransactionHelper.undoLastDisbursal(loanID);\n        validateDisbursedAmount(disbursedAmount);\n    }"}
{"prompt": "Create a test that tests loan Application Undo Last Tranche To Close", "completion": "    @Test\n    public void loanApplicationUndoLastTrancheToClose() {\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        LocalDate transactionDate = LocalDate.of(todaysDate.getYear(), 1, 1);\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n        LOG.info(\"Operation date {}\", transactionDate);\n\n        final String proposedAmount = \"1000\";\n\n        // CREATE CLIENT\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        LOG.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientID);\n\n        // CREATE LOAN MULTIDISBURSAL PRODUCT\n        final Integer loanProductID = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withInterestTypeAsDecliningBalance().withTranches(true)\n                        .withDisallowExpectedDisbursements(true).withInterestCalculationPeriodTypeAsRepaymentPeriod(true).build(null));\n        LOG.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductID);\n\n        // APPLY FOR LOAN WITH TRANCHES\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, proposedAmount, \"0\", new ArrayList<>());\n\n        LOG.info(\"-----------------------------------LOAN CREATED WITH LOANID------------------------------------------------- {}\", loanID);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        this.loanTransactionHelper.approveLoan(operationDate, proposedAmount, loanID, null);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.approved\");\n\n        // DISBURSE A LOAN\n        loanTransactionHelper.disburseLoanWithTransactionAmount(operationDate, loanID, \"500\");\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        // VALIDATE THE LOAN IS ACTIVE STATUS\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n        loanTransactionHelper.evaluateLoanDisbursementDetails(getLoansLoanIdResponse, 1, Double.valueOf(\"500.00\"));\n\n        // DISBURSE A LOAN (second)\n        transactionDate = transactionDate.plusDays(2);\n        operationDate = Utils.dateFormatter.format(transactionDate);\n        LOG.info(\"Operation date {}\", transactionDate);\n        loanTransactionHelper.disburseLoanWithTransactionAmount(operationDate, loanID, \"500\");\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        // VALIDATE THE LOAN IS ACTIVE STATUS\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n        loanTransactionHelper.evaluateLoanDisbursementDetails(getLoansLoanIdResponse, 2, Double.valueOf(\"1000.00\"));\n\n        // BACKDATE REPAYMENT\n        transactionDate = transactionDate.minusDays(1);\n        operationDate = Utils.dateFormatter.format(transactionDate);\n        LOG.info(\"Operation date {}\", transactionDate);\n        Float amount = Float.valueOf(\"500.00\");\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanID);\n        assertNotNull(loanIdTransactionsResponse);\n        LOG.info(\"Loan Transaction Id: {} {}\", loanID, loanIdTransactionsResponse.getResourceId());\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        // VALIDATE THE LOAN IS ACTIVE STATUS\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n        loanTransactionHelper.evaluateLoanDisbursementDetails(getLoansLoanIdResponse, 2, Double.valueOf(\"1000.00\"));\n        loanTransactionHelper.validateLoanTotalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"500.00\"));\n\n        // UNDO LAST TRANCHE\n        this.loanTransactionHelper.undoLastDisbursal(loanID);\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        // VALIDATE THE LOAN IS ACTIVE STATUS\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n        loanTransactionHelper.validateLoanTotalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"0.00\"));\n    }"}
{"prompt": "Create a test that tests loan Application Undo Last Tranche With Same Date", "completion": "    @Test\n    public void loanApplicationUndoLastTrancheWithSameDate() {\n\n        final String proposedAmount = \"5000\";\n        final String approveDate = \"01 March 2014\";\n        final String disbursalDate = \"01 March 2014\";\n\n        // CREATE CLIENT\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        LOG.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientID);\n\n        // CREATE LOAN MULTIDISBURSAL PRODUCT\n        final Integer loanProductID = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withInterestTypeAsDecliningBalance().withTranches(true)\n                        .withDisallowExpectedDisbursements(true).withInterestCalculationPeriodTypeAsRepaymentPeriod(true).build(null));\n        LOG.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductID);\n\n        // APPLY FOR LOAN WITH TRANCHES\n        final Integer loanID = applyForLoanApplicationWithTranches(clientID, loanProductID, proposedAmount, \"0\", new ArrayList<>());\n\n        LOG.info(\"-----------------------------------LOAN CREATED WITH LOANID------------------------------------------------- {}\", loanID);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        this.loanTransactionHelper.approveLoan(approveDate, proposedAmount, loanID, null);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.approved\");\n\n        // DISBURSE A LOAN\n        loanTransactionHelper.disburseLoanWithTransactionAmount(disbursalDate, loanID, \"1000\");\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        // VALIDATE THE LOAN IS ACTIVE STATUS\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n        loanTransactionHelper.evaluateLoanDisbursementDetails(getLoansLoanIdResponse, 1, Double.valueOf(\"1000.00\"));\n\n        // DISBURSE A LOAN (second)\n        loanTransactionHelper.disburseLoanWithTransactionAmount(disbursalDate, loanID, \"2000\");\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        // VALIDATE THE LOAN IS ACTIVE STATUS\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n        loanTransactionHelper.evaluateLoanDisbursementDetails(getLoansLoanIdResponse, 2, Double.valueOf(\"3000.00\"));\n\n        // UNDO LAST TRANCHE\n        this.loanTransactionHelper.undoLastDisbursal(loanID);\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n        assertNotNull(getLoansLoanIdResponse);\n        // VALIDATE THE LOAN IS ACTIVE STATUS\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n        loanTransactionHelper.evaluateLoanDisbursementDetails(getLoansLoanIdResponse, 1, Double.valueOf(\"1000.00\"));\n        loanTransactionHelper.validateLoanTotalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"1000.00\"));\n    }"}
{"prompt": "Create a test that tests test Catch Up In Locked Instance", "completion": "    @Test\n    public void testCatchUpInLockedInstance() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"0\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n            loanAccountLockHelper = new LoanAccountLockHelper(requestSpec, new ResponseSpecBuilder().expectStatusCode(202).build());\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            loanAccountLockHelper.placeSoftLockOnLoanAccount(loanID, \"LOAN_INLINE_COB_PROCESSING\", \"Sample error\");\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 5));\n\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n            loanCOBCatchUpHelper.executeLoanCOBCatchUp();\n\n            Utils.conditionalSleepWithMaxWait(30, 5, () -> loanCOBCatchUpHelper.isLoanCOBCatchUpRunning());\n\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 4), loan.getLastClosedBusinessDate());\n\n            requestSpec = UserHelper.getSimpleUserWithoutBypassPermission(requestSpec, responseSpec);\n\n            final BatchRequest br1 = BatchHelper.repayLoanRequestWithGivenLoanId(4730L, loanID, \"10\", LocalDate.of(2020, 3, 5));\n\n            final List<BatchRequest> batchRequests = new ArrayList<>();\n\n            batchRequests.add(br1);\n\n            final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n            final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec,\n                    this.responseSpec, jsonifiedRequest);\n            Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(0).getStatusCode(), \"Verify Status Code 200 for Repayment\");\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 4), loan.getLastClosedBusinessDate());\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"2\");\n        }\n    }"}
{"prompt": "Create a test that tests loan Transaction Chargeback For Payment Type Repayment Transaction Test", "completion": "    @Test\n    public void loanTransactionChargebackForPaymentTypeRepaymentTransactionTest() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        // Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        // make Repayment\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 September 2022\").locale(\"en\")\n                        .transactionAmount(500.0));\n\n        // verify transaction relation and outstanding balance\n        reviewLoanTransactionRelations(loanId, repaymentTransaction_1.getResourceId(), 0, Double.valueOf(\"500.00\"));\n\n        GetLoansLoanIdResponse loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 500.0);\n\n        // chargeback on Repayment\n        PostLoansLoanIdTransactionsResponse chargebackTransactionResponse = loanTransactionHelper.chargebackLoanTransaction(\n                loanExternalIdStr, repaymentTransaction_1.getResourceId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().locale(\"en\").transactionAmount(500.0).paymentTypeId(1L));\n\n        // verify transaction relation and outstanding balance\n        assertNotNull(chargebackTransactionResponse);\n        reviewLoanTransactionRelations(loanId, repaymentTransaction_1.getResourceId(), 1, Double.valueOf(\"500.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionResponse.getResourceId(), 0, Double.valueOf(\"1000.00\"));\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 1000.0);\n\n        // Goodwill Credit\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"6 September 2022\").locale(\"en\")\n                        .transactionAmount(200.0));\n\n        // verify transaction relation and outstanding balance\n        reviewLoanTransactionRelations(loanId, goodwillCredit_1.getResourceId(), 0, Double.valueOf(\"300.00\"));\n\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 800.0);\n\n        // chargeback on Goodwill Credit Transaction\n        chargebackTransactionResponse = loanTransactionHelper.chargebackLoanTransaction(loanExternalIdStr, goodwillCredit_1.getResourceId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().locale(\"en\").transactionAmount(200.0).paymentTypeId(1L));\n\n        // verify transaction relation and outstanding balance\n        assertNotNull(chargebackTransactionResponse);\n        reviewLoanTransactionRelations(loanId, goodwillCredit_1.getResourceId(), 1, Double.valueOf(\"300.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionResponse.getResourceId(), 0, Double.valueOf(\"1000.00\"));\n\n        // Payout Refund\n\n        final PostLoansLoanIdTransactionsResponse payoutRefund_1 = loanTransactionHelper.makePayoutRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"7 September 2022\").locale(\"en\")\n                        .transactionAmount(300.0));\n\n        // verify transaction relation and outstanding balance\n        reviewLoanTransactionRelations(loanId, payoutRefund_1.getResourceId(), 0, Double.valueOf(\"0.00\"));\n\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 700.0);\n\n        // chargeback on Payout Refund Transaction\n        chargebackTransactionResponse = loanTransactionHelper.chargebackLoanTransaction(loanExternalIdStr, payoutRefund_1.getResourceId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().locale(\"en\").transactionAmount(300.0).paymentTypeId(1L));\n\n        // verify transaction relation and outstanding balance\n        assertNotNull(chargebackTransactionResponse);\n        reviewLoanTransactionRelations(loanId, payoutRefund_1.getResourceId(), 1, Double.valueOf(\"0.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionResponse.getResourceId(), 0, Double.valueOf(\"1000.00\"));\n\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 1000.0);\n\n        // Merchant Issued Refund\n\n        final PostLoansLoanIdTransactionsResponse merchantIssuedRefund_1 = loanTransactionHelper.makeMerchantIssuedRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"8 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        // verify transaction relation and outstanding balance\n        reviewLoanTransactionRelations(loanId, merchantIssuedRefund_1.getResourceId(), 0, Double.valueOf(\"0.00\"));\n\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 900.0);\n\n        // chargeback on Merchant Issued Refund Transaction\n        chargebackTransactionResponse = loanTransactionHelper.chargebackLoanTransaction(loanExternalIdStr,\n                merchantIssuedRefund_1.getResourceId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().locale(\"en\").transactionAmount(100.0).paymentTypeId(1L));\n\n        // verify transaction relation and outstanding balance\n        assertNotNull(chargebackTransactionResponse);\n        reviewLoanTransactionRelations(loanId, merchantIssuedRefund_1.getResourceId(), 1, Double.valueOf(\"0.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionResponse.getResourceId(), 0, Double.valueOf(\"1000.00\"));\n\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 1000.0);\n\n    }"}
{"prompt": "Create a test that tests loan Chargeback Not Allowed For Reversed Payment Type Repayment Test", "completion": "    @Test\n    public void loanChargebackNotAllowedForReversedPaymentTypeRepaymentTest() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        // Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        // Merchant Refund\n        final PostLoansLoanIdTransactionsResponse merchantIssuedRefund_2 = loanTransactionHelper.makeMerchantIssuedRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"8 September 2022\").locale(\"en\")\n                        .transactionAmount(50.0));\n\n        // reverse Merchant Refund\n        loanTransactionHelper.reverseRepayment(loanId, merchantIssuedRefund_2.getResourceId().intValue(), \"8 September 2022\");\n\n        // apply Chargeback should give 503 error\n        final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId,\n                merchantIssuedRefund_2.getResourceId(), \"50.00\", 1, responseSpecErr503);\n\n    }"}
{"prompt": "Create a test that tests loan Charge Off Accounting Treatment Test For Periodic Accrual Accounting", "completion": "    @Test\n    public void loanChargeOffAccountingTreatmentTestForPeriodicAccrualAccounting() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Product to GL account mapping for test\n        // ASSET\n        // -fundSourceAccountId,loanPortfolioAccountId,transfersInSuspenseAccountId,receivableFeeAccountId,receivablePenaltyAccountId,receivableInterestAccountId\n        // INCOME-interestOnLoanAccountId,incomeFromFeeAccountId,incomeFromPenaltyAccountId,incomeFromRecoveryAccountId,incomeFromChargeOffInterestAccountId,incomeFromChargeOffFeesAccountId,incomeFromChargeOffPenaltyAccountId,incomeFromGoodwillCreditInterestAccountId,incomeFromGoodwillCreditFeesAccountId,incomeFromGoodwillCreditPenaltyAccountId\n        // EXPENSE-writeOffAccountId,goodwillCreditAccountId,chargeOffExpenseAccountId,chargeOffFraudExpenseAccountId\n        // LIABILITY-overpaymentLiabilityAccountId\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccounting(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final Integer loanId = createLoanAccount(clientId, loanProductID, loanExternalIdStr);\n\n        // apply charges\n        Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 5);\n        final String feeCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeCharge1AddedDate, \"10\"));\n\n        // apply penalty\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        // set loan as chargeoff\n        String randomText = Utils.randomStringGenerator(\"en\", 5) + Utils.randomNumberGenerator(6) + Utils.randomStringGenerator(\"is\", 5);\n        Integer chargeOffReasonId = CodeHelper.createChargeOffCodeValue(requestSpec, responseSpec, randomText, 1);\n        String transactionExternalId = UUID.randomUUID().toString();\n        this.loanTransactionHelper.chargeOffLoan((long) loanId, new PostLoansLoanIdTransactionsRequest().transactionDate(\"6 September 2022\")\n                .locale(\"en\").dateFormat(\"dd MMMM yyyy\").externalId(transactionExternalId).chargeOffReasonId((long) chargeOffReasonId));\n\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal Entries For ChargeOff Transaction\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"6 September 2022\",\n                new JournalEntry(1020, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"6 September 2022\",\n                new JournalEntry(1000, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.DEBIT));\n\n        // make Repayment\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"7 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal Entries for Repayment transaction\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"7 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"7 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.DEBIT));\n\n        // Merchant Refund\n        final PostLoansLoanIdTransactionsResponse merchantIssuedRefund_1 = loanTransactionHelper.makeMerchantIssuedRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"8 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal Entries for Merchant Refund\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"8 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"8 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.DEBIT));\n\n        // Payout Refund\n        final PostLoansLoanIdTransactionsResponse payoutRefund_1 = loanTransactionHelper.makePayoutRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"9 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal Entries for Payout Refund\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"9 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"9 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.DEBIT));\n\n        // Goodwill Credit\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"10 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal Entries for Goodwill Credit\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"10 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"10 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.CREDIT));\n\n        // make overpaid repayment\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"11 September 2022\").locale(\"en\")\n                        .transactionAmount(720.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getOverpaid());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal entries for overpaid repayment\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, \"11 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"11 September 2022\",\n                new JournalEntry(620, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"11 September 2022\",\n                new JournalEntry(720, JournalEntry.TransactionType.DEBIT));\n\n        // CBR for making loan active again\n        final PostLoansLoanIdTransactionsResponse cbr_transaction = loanTransactionHelper.makeCreditBalanceRefund(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"12 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        // Charge Adjustment making loan overpaid\n        final PostLoansLoanIdChargesChargeIdResponse chargeAdjustmentResult = loanTransactionHelper.chargeAdjustment((long) loanId,\n                (long) feeLoanChargeId, new PostLoansLoanIdChargesChargeIdRequest().amount(10.0).locale(\"en\"));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getOverpaid());\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        String transactionDate = Utils.dateFormatter.format(todaysDate);\n\n        // verify Journal entries for Charge Adjustment\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, transactionDate,\n                new JournalEntry(10, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, transactionDate,\n                new JournalEntry(10, JournalEntry.TransactionType.DEBIT));\n    }"}
{"prompt": "Create a test that tests loan Charge Off Fraud Accounting Treatment Test For Cash Based Accounting", "completion": "    @Test\n    public void loanChargeOffFraudAccountingTreatmentTestForCashBasedAccounting() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Product to GL account mapping for test\n        // ASSET\n        // -fundSourceAccountId,loanPortfolioAccountId,transfersInSuspenseAccountId\n        // INCOME-interestOnLoanAccountId,incomeFromFeeAccountId,incomeFromPenaltyAccountId,incomeFromRecoveryAccountId,incomeFromChargeOffInterestAccountId,incomeFromChargeOffFeesAccountId,incomeFromChargeOffPenaltyAccountId,incomeFromGoodwillCreditInterestAccountId,incomeFromGoodwillCreditFeesAccountId,incomeFromGoodwillCreditPenaltyAccountId\n        // EXPENSE-writeOffAccountId,goodwillCreditAccountId,chargeOffExpenseAccountId,chargeOffFraudExpenseAccountId\n        // LIABILITY-overpaymentLiabilityAccountId\n\n        final Integer loanProductID = createLoanProductWithCashBasedAccounting(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final Integer loanId = createLoanAccount(clientId, loanProductID, loanExternalIdStr);\n\n        // apply charges\n        Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 5);\n        final String feeCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeCharge1AddedDate, \"10\"));\n\n        // apply penalty\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        // set loan as fraud\n        final String command = \"markAsFraud\";\n        String payload = loanTransactionHelper.getLoanFraudPayloadAsJSON(\"fraud\", \"true\");\n        PutLoansLoanIdResponse putLoansLoanIdResponse = loanTransactionHelper.modifyLoanCommand(loanId, command, payload,\n                this.responseSpec);\n\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getFraud());\n\n        // set loan as chargeoff\n        String randomText = Utils.randomStringGenerator(\"en\", 5) + Utils.randomNumberGenerator(6) + Utils.randomStringGenerator(\"is\", 5);\n        Integer chargeOffReasonId = CodeHelper.createChargeOffCodeValue(requestSpec, responseSpec, randomText, 1);\n        String transactionExternalId = UUID.randomUUID().toString();\n        this.loanTransactionHelper.chargeOffLoan((long) loanId, new PostLoansLoanIdTransactionsRequest().transactionDate(\"6 September 2022\")\n                .locale(\"en\").dateFormat(\"dd MMMM yyyy\").externalId(transactionExternalId).chargeOffReasonId((long) chargeOffReasonId));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getFraud());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal Entries For ChargeOff Transaction\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"6 September 2022\",\n                new JournalEntry(1000, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"6 September 2022\",\n                new JournalEntry(1000, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.DEBIT));\n\n        // make Repayment\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"7 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getFraud());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal Entries for Repayment transaction\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"7 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"7 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.DEBIT));\n\n        // Merchant Refund\n        final PostLoansLoanIdTransactionsResponse merchantIssuedRefund_1 = loanTransactionHelper.makeMerchantIssuedRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"8 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getFraud());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal Entries for Merchant Refund\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"8 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"8 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.DEBIT));\n\n        // Payout Refund\n        final PostLoansLoanIdTransactionsResponse payoutRefund_1 = loanTransactionHelper.makePayoutRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"9 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getFraud());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal Entries for Payout Refund\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"9 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"9 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.DEBIT));\n\n        // Goodwill Credit\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"10 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getFraud());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal Entries for Goodwill Credit\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"10 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"10 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.CREDIT));\n\n        // make overpaid repayment\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"11 September 2022\").locale(\"en\")\n                        .transactionAmount(720.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getOverpaid());\n        assertTrue(loanDetails.getFraud());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal entries for overpaid repayment\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, \"11 September 2022\",\n                new JournalEntry(100, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"11 September 2022\",\n                new JournalEntry(620, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"11 September 2022\",\n                new JournalEntry(720, JournalEntry.TransactionType.DEBIT));\n\n        // CBR for making loan active again\n        final PostLoansLoanIdTransactionsResponse cbr_transaction = loanTransactionHelper.makeCreditBalanceRefund(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"12 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        // Charge Adjustment making loan overpaid\n        final PostLoansLoanIdChargesChargeIdResponse chargeAdjustmentResult = loanTransactionHelper.chargeAdjustment((long) loanId,\n                (long) feeLoanChargeId, new PostLoansLoanIdChargesChargeIdRequest().amount(10.0).locale(\"en\"));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getOverpaid());\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n        String transactionDate = Utils.dateFormatter.format(todaysDate);\n\n        // verify Journal entries for Charge Adjustment\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(overpaymentAccount, transactionDate,\n                new JournalEntry(10, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, transactionDate,\n                new JournalEntry(10, JournalEntry.TransactionType.DEBIT));\n    }"}
{"prompt": "Create a test that tests loan Accounting Treatment Test For Goodwill Credit Periodic Accrual Accounting No Charge Off", "completion": "    @Test\n    public void loanAccountingTreatmentTestForGoodwillCreditPeriodicAccrualAccounting_NoChargeOff() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Product to GL account mapping for test\n        // ASSET\n        // -fundSourceAccountId,loanPortfolioAccountId,transfersInSuspenseAccountId,receivableFeeAccountId,receivablePenaltyAccountId,receivableInterestAccountId\n        // INCOME-interestOnLoanAccountId,incomeFromFeeAccountId,incomeFromPenaltyAccountId,incomeFromRecoveryAccountId,incomeFromChargeOffInterestAccountId,incomeFromChargeOffFeesAccountId,incomeFromChargeOffPenaltyAccountId,incomeFromGoodwillCreditInterestAccountId,incomeFromGoodwillCreditFeesAccountId,incomeFromGoodwillCreditPenaltyAccountId\n        // EXPENSE-writeOffAccountId,goodwillCreditAccountId,chargeOffExpenseAccountId,chargeOffFraudExpenseAccountId\n        // LIABILITY-overpaymentLiabilityAccountId\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccounting(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final Integer loanId = createLoanAccount(clientId, loanProductID, loanExternalIdStr);\n\n        // apply charges\n        Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 5);\n        final String feeCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeCharge1AddedDate, \"10\"));\n\n        // apply penalty\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"110\", true));\n\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n\n        // Goodwill Credit\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"06 September 2022\").locale(\"en\")\n                        .transactionAmount(800.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n\n        // verify Journal Entries for Goodwill Credit\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"6 September 2022\",\n                new JournalEntry(800, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"6 September 2022\",\n                new JournalEntry(780, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.DEBIT));\n\n    }"}
{"prompt": "Create a test that tests loan Accounting Treatment Test For Goodwill Credit Periodic Accrual Accounting Charge Off", "completion": "    @Test\n    public void loanAccountingTreatmentTestForGoodwillCreditPeriodicAccrualAccounting_ChargeOff() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Product to GL account mapping for test\n        // ASSET\n        // -fundSourceAccountId,loanPortfolioAccountId,transfersInSuspenseAccountId,receivableFeeAccountId,receivablePenaltyAccountId,receivableInterestAccountId\n        // INCOME-interestOnLoanAccountId,incomeFromFeeAccountId,incomeFromPenaltyAccountId,incomeFromRecoveryAccountId,incomeFromChargeOffInterestAccountId,incomeFromChargeOffFeesAccountId,incomeFromChargeOffPenaltyAccountId,incomeFromGoodwillCreditInterestAccountId,incomeFromGoodwillCreditFeesAccountId,incomeFromGoodwillCreditPenaltyAccountId\n        // EXPENSE-writeOffAccountId,goodwillCreditAccountId,chargeOffExpenseAccountId,chargeOffFraudExpenseAccountId\n        // LIABILITY-overpaymentLiabilityAccountId\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccounting(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final Integer loanId = createLoanAccount(clientId, loanProductID, loanExternalIdStr);\n\n        // apply charges\n        Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 5);\n        final String feeCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeCharge1AddedDate, \"10\"));\n\n        // apply penalty\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        // set loan as chargeoff\n        String randomText = Utils.randomStringGenerator(\"en\", 5) + Utils.randomNumberGenerator(6) + Utils.randomStringGenerator(\"is\", 5);\n        Integer chargeOffReasonId = CodeHelper.createChargeOffCodeValue(requestSpec, responseSpec, randomText, 1);\n        String transactionExternalId = UUID.randomUUID().toString();\n        this.loanTransactionHelper.chargeOffLoan((long) loanId, new PostLoansLoanIdTransactionsRequest().transactionDate(\"6 September 2022\")\n                .locale(\"en\").dateFormat(\"dd MMMM yyyy\").externalId(transactionExternalId).chargeOffReasonId((long) chargeOffReasonId));\n\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal Entries For ChargeOff Transaction\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"6 September 2022\",\n                new JournalEntry(1020, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"6 September 2022\",\n                new JournalEntry(1000, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.DEBIT));\n\n        // Goodwill Credit\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"08 September 2022\").locale(\"en\")\n                        .transactionAmount(800.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal Entries for Goodwill Credit\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"8 September 2022\",\n                new JournalEntry(800, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"8 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"8 September 2022\",\n                new JournalEntry(780, JournalEntry.TransactionType.DEBIT));\n\n    }"}
{"prompt": "Create a test that tests loan Accounting Treatment Test For Cash Based Accounting No Charge Off", "completion": "    @Test\n    public void loanAccountingTreatmentTestForCashBasedAccounting_NoChargeOff() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Product to GL account mapping for test\n        // ASSET\n        // -fundSourceAccountId,loanPortfolioAccountId,transfersInSuspenseAccountId\n        // INCOME-interestOnLoanAccountId,incomeFromFeeAccountId,incomeFromPenaltyAccountId,incomeFromRecoveryAccountId,incomeFromChargeOffInterestAccountId,incomeFromChargeOffFeesAccountId,incomeFromChargeOffPenaltyAccountId,incomeFromGoodwillCreditInterestAccountId,incomeFromGoodwillCreditFeesAccountId,incomeFromGoodwillCreditPenaltyAccountId\n        // EXPENSE-writeOffAccountId,goodwillCreditAccountId,chargeOffExpenseAccountId,chargeOffFraudExpenseAccountId\n        // LIABILITY-overpaymentLiabilityAccountId\n\n        final Integer loanProductID = createLoanProductWithCashBasedAccounting(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final Integer loanId = createLoanAccount(clientId, loanProductID, loanExternalIdStr);\n\n        // apply charges\n        Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 5);\n        final String feeCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeCharge1AddedDate, \"10\"));\n\n        // apply penalty\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n\n        // Goodwill Credit\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"06 September 2022\").locale(\"en\")\n                        .transactionAmount(800.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n\n        // verify Journal Entries for Goodwill Credit\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"6 September 2022\",\n                new JournalEntry(780, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(10, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(10, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"6 September 2022\",\n                new JournalEntry(780, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.DEBIT));\n\n    }"}
{"prompt": "Create a test that tests loan Accounting Treatment Test For Cash Based Accounting Charge Off", "completion": "    @Test\n    public void loanAccountingTreatmentTestForCashBasedAccounting_ChargeOff() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Product to GL account mapping for test\n        // ASSET\n        // -fundSourceAccountId,loanPortfolioAccountId,transfersInSuspenseAccountId\n        // INCOME-interestOnLoanAccountId,incomeFromFeeAccountId,incomeFromPenaltyAccountId,incomeFromRecoveryAccountId,incomeFromChargeOffInterestAccountId,incomeFromChargeOffFeesAccountId,incomeFromChargeOffPenaltyAccountId,incomeFromGoodwillCreditInterestAccountId,incomeFromGoodwillCreditFeesAccountId,incomeFromGoodwillCreditPenaltyAccountId\n        // EXPENSE-writeOffAccountId,goodwillCreditAccountId,chargeOffExpenseAccountId,chargeOffFraudExpenseAccountId\n        // LIABILITY-overpaymentLiabilityAccountId\n\n        final Integer loanProductID = createLoanProductWithCashBasedAccounting(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final Integer loanId = createLoanAccount(clientId, loanProductID, loanExternalIdStr);\n\n        // apply charges\n        Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 5);\n        final String feeCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeCharge1AddedDate, \"10\"));\n\n        // apply penalty\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n\n        // set loan as chargeoff\n        String randomText = Utils.randomStringGenerator(\"en\", 5) + Utils.randomNumberGenerator(6) + Utils.randomStringGenerator(\"is\", 5);\n        Integer chargeOffReasonId = CodeHelper.createChargeOffCodeValue(requestSpec, responseSpec, randomText, 1);\n        String transactionExternalId = UUID.randomUUID().toString();\n        this.loanTransactionHelper.chargeOffLoan((long) loanId, new PostLoansLoanIdTransactionsRequest().transactionDate(\"6 September 2022\")\n                .locale(\"en\").dateFormat(\"dd MMMM yyyy\").externalId(transactionExternalId).chargeOffReasonId((long) chargeOffReasonId));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal Entries For ChargeOff Transaction\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"6 September 2022\",\n                new JournalEntry(1000, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"6 September 2022\",\n                new JournalEntry(1000, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.DEBIT));\n\n        // Goodwill Credit\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"10 September 2022\").locale(\"en\")\n                        .transactionAmount(800.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertTrue(loanDetails.getChargedOff());\n\n        // verify Journal Entries for Goodwill Credit\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, \"6 September 2022\",\n                new JournalEntry(1000, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForExpenseAccount(expenseAccount, \"6 September 2022\",\n                new JournalEntry(1000, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForIncomeAccount(incomeAccount, \"6 September 2022\",\n                new JournalEntry(20, JournalEntry.TransactionType.DEBIT));\n    }"}
{"prompt": "Create a test that tests test Apply Loan Specific Due Date Fee With Disbursement Date", "completion": "    @Test\n    public void testApplyLoanSpecificDueDateFeeWithDisbursementDate() {\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n\n        // Client and Loan account creation\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithPeriodicAccrual(loanTransactionHelper,\n                null);\n        assertNotNull(getLoanProductsProductResponse);\n\n        // Older date to have more than one overdue installment\n        LocalDate transactionDate = todaysDate;\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n        log.info(\"Operation date {}\", transactionDate);\n\n        // Create Loan Account\n        final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                getLoanProductsProductResponse.getId().toString(), operationDate, \"12\", \"0\");\n\n        // Get loan details\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), false);\n\n        // Apply Loan Charge with specific due date\n\n        final String feeAmount = \"10.00\";\n        String payloadJSON = ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, feeAmount, false);\n        final PostChargesResponse postChargesResponse = ChargesHelper.createLoanCharge(requestSpec, responseSpec, payloadJSON);\n        assertNotNull(postChargesResponse);\n        final Long loanChargeId = postChargesResponse.getResourceId();\n\n        payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(loanChargeId.toString(), operationDate, feeAmount);\n        PostLoansLoanIdChargesResponse postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON,\n                responseSpec);\n        assertNotNull(postLoansLoanIdChargesResponse);\n\n        // Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"10.00\"), false);\n\n        // Run Accruals\n        log.info(\"Running Periodic Accrual for date {}\", transactionDate);\n        periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n\n        final Long transactionId = loanTransactionHelper.evaluateLastLoanTransactionData(getLoansLoanIdResponse,\n                \"loanTransactionType.accrual\", operationDate, Double.valueOf(\"10.00\"));\n        assertNotNull(transactionId);\n        log.info(\"transactionId {}\", transactionId);\n\n        final GetJournalEntriesTransactionIdResponse journalEntriesResponse = journalEntryHelper.getJournalEntries(\"L\" + transactionId);\n        assertNotNull(journalEntriesResponse);\n        final List<JournalEntryTransactionItem> journalEntries = journalEntriesResponse.getPageItems();\n        assertEquals(2, journalEntries.size());\n        assertEquals(10, journalEntries.get(0).getAmount());\n        assertEquals(10, journalEntries.get(1).getAmount());\n        assertEquals(transactionDate, journalEntries.get(0).getTransactionDate());\n        assertEquals(transactionDate, journalEntries.get(1).getTransactionDate());\n\n        // Make a full repayment to close the Loan\n        Float amount = Float.valueOf(\"1010.00\");\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        log.info(\"Loan Transaction Id: {} {}\", loanId, loanIdTransactionsResponse.getResourceId());\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(\"0.00\"), Double.valueOf(\"0.00\"), false);\n\n    }"}
{"prompt": "Create a test that tests test Apply Loan Specific Due Date Penalty With Disbursement Date", "completion": "    @Test\n    public void testApplyLoanSpecificDueDatePenaltyWithDisbursementDate() {\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n\n        // Client and Loan account creation\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithPeriodicAccrual(loanTransactionHelper,\n                null);\n        assertNotNull(getLoanProductsProductResponse);\n\n        // Older date to have more than one overdue installment\n        LocalDate transactionDate = todaysDate;\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n        log.info(\"Operation date {}\", transactionDate);\n\n        // Create Loan Account\n        final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                getLoanProductsProductResponse.getId().toString(), operationDate, \"12\", \"0\");\n\n        // Get loan details\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), true);\n\n        // Apply Loan Charge with specific due date\n\n        final String feeAmount = \"10.00\";\n        String payloadJSON = ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, feeAmount, true);\n        final PostChargesResponse postChargesResponse = ChargesHelper.createLoanCharge(requestSpec, responseSpec, payloadJSON);\n        assertNotNull(postChargesResponse);\n        final Long loanChargeId = postChargesResponse.getResourceId();\n        assertNotNull(loanChargeId);\n\n        payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(loanChargeId.toString(), operationDate, feeAmount);\n        PostLoansLoanIdChargesResponse postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON,\n                responseSpec);\n        assertNotNull(postLoansLoanIdChargesResponse);\n\n        // Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"10.00\"), true);\n\n        // Run Accruals\n        log.info(\"Running Periodic Accrual for date {}\", transactionDate);\n        periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n\n        final Long transactionId = loanTransactionHelper.evaluateLastLoanTransactionData(getLoansLoanIdResponse,\n                \"loanTransactionType.accrual\", operationDate, Double.valueOf(\"10.00\"));\n        assertNotNull(transactionId);\n        log.info(\"transactionId {}\", transactionId);\n\n        final GetJournalEntriesTransactionIdResponse journalEntriesResponse = journalEntryHelper.getJournalEntries(\"L\" + transactionId);\n        assertNotNull(journalEntriesResponse);\n        final List<JournalEntryTransactionItem> journalEntries = journalEntriesResponse.getPageItems();\n        assertEquals(2, journalEntries.size());\n        assertEquals(10, journalEntries.get(0).getAmount());\n        assertEquals(10, journalEntries.get(1).getAmount());\n        assertEquals(transactionDate, journalEntries.get(0).getTransactionDate());\n        assertEquals(transactionDate, journalEntries.get(1).getTransactionDate());\n\n        // Make a full repayment to close the Loan\n        Float amount = Float.valueOf(\"1010.00\");\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        log.info(\"Loan Transaction Id: {} {}\", loanId, loanIdTransactionsResponse.getResourceId());\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(\"0.00\"), Double.valueOf(\"0.00\"), true);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n\n    }"}
{"prompt": "Create a test that tests test Apply And Waive Loan Specific Due Date Penalty With Disbursement Date", "completion": "    @Test\n    public void testApplyAndWaiveLoanSpecificDueDatePenaltyWithDisbursementDate() {\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n\n        // Client and Loan account creation\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper, null);\n        assertNotNull(getLoanProductsProductResponse);\n\n        // Older date to have more than one overdue installment\n        LocalDate transactionDate = todaysDate;\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n        log.info(\"Operation date {}\", transactionDate);\n\n        // Create Loan Account\n        final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                getLoanProductsProductResponse.getId().toString(), operationDate, \"12\", \"0\");\n\n        // Get loan details\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), true);\n\n        // Apply Loan Charge with specific due date\n        final String feeAmount = \"10.00\";\n        String payloadJSON = ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, feeAmount, true);\n        final PostChargesResponse postChargesResponse = ChargesHelper.createLoanCharge(requestSpec, responseSpec, payloadJSON);\n        assertNotNull(postChargesResponse);\n        final Long chargeId = postChargesResponse.getResourceId();\n        assertNotNull(chargeId);\n\n        payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(chargeId.toString(), operationDate, feeAmount);\n        PostLoansLoanIdChargesResponse postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON,\n                responseSpec);\n        assertNotNull(postLoansLoanIdChargesResponse);\n        final Long loanChargeId = postLoansLoanIdChargesResponse.getResourceId();\n        assertNotNull(loanChargeId);\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"10.00\"), true);\n\n        // Waive the Loan Charge\n        final PostLoansLoanIdChargesChargeIdResponse postWaiveLoanChargesResponse = loanTransactionHelper.applyLoanChargeCommand(loanId,\n                loanChargeId, \"waive\", Utils.emptyJson());\n        assertNotNull(postWaiveLoanChargesResponse);\n\n        // evaluate the outstanding\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), true);\n\n        // Make a full repayment to close the Loan\n        Float amount = Float.valueOf(\"1000.00\");\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        log.info(\"Loan Transaction Id: {} {}\", loanId, loanIdTransactionsResponse.getResourceId());\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n\n    }"}
{"prompt": "Create a test that tests test Apply Fee Accrual On Closed Date", "completion": "    @Test\n    public void testApplyFeeAccrualOnClosedDate() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, todaysDate);\n\n            // Client and Loan account creation\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithPeriodicAccrual(\n                    loanTransactionHelper, null);\n            assertNotNull(getLoanProductsProductResponse);\n\n            LocalDate transactionDate = LocalDate.of(Utils.getLocalDateOfTenant().getYear(), 1, 1);\n            String operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Disbursement date {}\", transactionDate);\n\n            // Create Loan Account\n            final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                    getLoanProductsProductResponse.getId().toString(), operationDate, \"1\", \"0\");\n\n            // Get loan details\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), true);\n\n            // Apply Loan Charge with specific due date\n            String feeAmount = \"10.00\";\n            String payloadJSON = ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, feeAmount, true);\n            final PostChargesResponse postChargesResponse = ChargesHelper.createLoanCharge(requestSpec, responseSpec, payloadJSON);\n            assertNotNull(postChargesResponse);\n            final Long chargeId = postChargesResponse.getResourceId();\n            assertNotNull(chargeId);\n\n            // First Loan Charge\n            transactionDate = transactionDate.plusDays(1);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, transactionDate);\n            operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Operation date {}\", transactionDate);\n            payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(chargeId.toString(), operationDate, feeAmount);\n            PostLoansLoanIdChargesResponse postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON,\n                    responseSpec);\n            assertNotNull(postLoansLoanIdChargesResponse);\n            final Long loanChargeId01 = postLoansLoanIdChargesResponse.getResourceId();\n            assertNotNull(loanChargeId01);\n\n            // Run Accruals\n            log.info(\"Running Periodic Accrual for date {}\", transactionDate);\n            periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.evaluateLoanTransactionData(getLoansLoanIdResponse, \"loanTransactionType.accrual\",\n                    Double.valueOf(\"10.00\"));\n\n            // Repay the first charge fully, 10\n            Float amount = Float.valueOf(\"10.00\");\n            transactionDate = transactionDate.plusDays(40);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, transactionDate);\n            operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Operation date {}\", transactionDate);\n            PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                    loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            log.info(\"Loan Transaction Id: {} {}\", loanId, loanIdTransactionsResponse.getResourceId());\n\n            // Second Loan Charge\n            feeAmount = \"15.00\";\n            transactionDate = transactionDate.plusDays(1);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, transactionDate);\n            operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Operation date {}\", transactionDate);\n            payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(chargeId.toString(), operationDate, feeAmount);\n            postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON, responseSpec);\n            assertNotNull(postLoansLoanIdChargesResponse);\n            final Long loanChargeId02 = postLoansLoanIdChargesResponse.getResourceId();\n            assertNotNull(loanChargeId02);\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"15.00\"), true);\n\n            // Run Accruals\n            log.info(\"Running Periodic Accrual for date {}\", transactionDate);\n            periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.evaluateLoanTransactionData(getLoansLoanIdResponse, \"loanTransactionType.accrual\",\n                    Double.valueOf(\"25.00\"));\n\n            // Third Loan Charge\n            feeAmount = \"25.00\";\n            transactionDate = transactionDate.plusDays(1);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, transactionDate);\n            operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Operation date {}\", transactionDate);\n            payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(chargeId.toString(), operationDate, feeAmount);\n            postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON, responseSpec);\n            assertNotNull(postLoansLoanIdChargesResponse);\n            final Long loanChargeId03 = postLoansLoanIdChargesResponse.getResourceId();\n            assertNotNull(loanChargeId03);\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"40.00\"), true);\n            loanTransactionHelper.evaluateLoanTransactionData(getLoansLoanIdResponse, \"loanTransactionType.accrual\",\n                    Double.valueOf(\"25.00\"));\n\n            amount = Float.valueOf(\"1040.00\");\n            loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount, loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            log.info(\"Loan Transaction Id: {} {}\", loanId, loanIdTransactionsResponse.getResourceId());\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n            loanTransactionHelper.evaluateLoanTransactionData(getLoansLoanIdResponse, \"loanTransactionType.accrual\",\n                    Double.valueOf(\"50.00\"));\n\n            final Long transactionId = loanTransactionHelper.evaluateLastLoanTransactionData(getLoansLoanIdResponse,\n                    \"loanTransactionType.accrual\", operationDate, Double.valueOf(\"25.00\"));\n            assertNotNull(transactionId);\n            log.info(\"transactionId {}\", transactionId);\n\n            final GetJournalEntriesTransactionIdResponse journalEntriesResponse = journalEntryHelper\n                    .getJournalEntries(\"L\" + transactionId.toString());\n            assertNotNull(journalEntriesResponse);\n            final List<JournalEntryTransactionItem> journalEntries = journalEntriesResponse.getPageItems();\n            assertEquals(2, journalEntries.size());\n            assertEquals(25, journalEntries.get(0).getAmount());\n            assertEquals(25, journalEntries.get(1).getAmount());\n            assertEquals(transactionDate, journalEntries.get(0).getTransactionDate());\n            assertEquals(transactionDate, journalEntries.get(1).getTransactionDate());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Apply Fee Accrual When Loan Overpaid", "completion": "    @Test\n    public void testApplyFeeAccrualWhenLoanOverpaid() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, todaysDate);\n\n            // Client and Loan account creation\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n            final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithPeriodicAccrual(\n                    loanTransactionHelper, null);\n            assertNotNull(getLoanProductsProductResponse);\n\n            LocalDate transactionDate = LocalDate.of(Utils.getLocalDateOfTenant().getYear(), 1, 1);\n            String operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Disbursement date {}\", transactionDate);\n\n            // Create Loan Account\n            final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                    getLoanProductsProductResponse.getId().toString(), operationDate, \"1\", \"0\");\n\n            // Get loan details\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), true);\n\n            // Apply Loan Charge with specific due date\n            String feeAmount = \"10.00\";\n            String payloadJSON = ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, feeAmount, true);\n            final PostChargesResponse postChargesResponse = ChargesHelper.createLoanCharge(requestSpec, responseSpec, payloadJSON);\n            assertNotNull(postChargesResponse);\n            final Long chargeId = postChargesResponse.getResourceId();\n            assertNotNull(chargeId);\n\n            // First Loan Charge\n            transactionDate = transactionDate.plusDays(1);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, transactionDate);\n            operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Operation date {}\", transactionDate);\n            payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(chargeId.toString(), operationDate, feeAmount);\n            PostLoansLoanIdChargesResponse postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON,\n                    responseSpec);\n            assertNotNull(postLoansLoanIdChargesResponse);\n            final Long loanChargeId01 = postLoansLoanIdChargesResponse.getResourceId();\n            assertNotNull(loanChargeId01);\n\n            Float amount = Float.valueOf(\"1020.00\");\n            transactionDate = transactionDate.plusDays(2);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, transactionDate);\n            operationDate = Utils.dateFormatter.format(transactionDate);\n            log.info(\"Operation date {}\", transactionDate);\n            PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                    loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            log.info(\"Loan Transaction Id: {} {}\", loanId, loanIdTransactionsResponse.getResourceId());\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.overpaid\");\n\n            final Long transactionId = loanTransactionHelper.evaluateLastLoanTransactionData(getLoansLoanIdResponse,\n                    \"loanTransactionType.accrual\", operationDate, Double.valueOf(\"10.00\"));\n            assertNotNull(transactionId);\n            log.info(\"transactionId {}\", transactionId);\n\n            final GetJournalEntriesTransactionIdResponse journalEntriesResponse = journalEntryHelper.getJournalEntries(\"L\" + transactionId);\n            assertNotNull(journalEntriesResponse);\n            final List<JournalEntryTransactionItem> journalEntries = journalEntriesResponse.getPageItems();\n            assertEquals(2, journalEntries.size());\n            assertEquals(10, journalEntries.get(0).getAmount());\n            assertEquals(10, journalEntries.get(1).getAmount());\n            assertEquals(transactionDate, journalEntries.get(0).getTransactionDate());\n            assertEquals(transactionDate, journalEntries.get(1).getTransactionDate());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Apply Loan Specific Due Date Penalty With Disbursement Date With Multiple Disbursement", "completion": "    @Test\n    public void testApplyLoanSpecificDueDatePenaltyWithDisbursementDateWithMultipleDisbursement() {\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n\n        // Client and Loan account creation\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithPeriodicAccrual(loanTransactionHelper,\n                null);\n        assertNotNull(getLoanProductsProductResponse);\n\n        // Older date to have more than one overdue installment\n        LocalDate transactionDate = todaysDate;\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n        log.info(\"Operation date {}\", transactionDate);\n\n        // Create Loan Account\n        final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                getLoanProductsProductResponse.getId().toString(), operationDate, \"12\", \"0\");\n\n        // Get loan details\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), true);\n\n        // Apply Loan Charge with specific due date\n\n        final String feeAmount = \"10.00\";\n        String payloadJSON = ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, feeAmount, true);\n        final PostChargesResponse postChargesResponse = ChargesHelper.createLoanCharge(requestSpec, responseSpec, payloadJSON);\n        assertNotNull(postChargesResponse);\n        final Long loanChargeId = postChargesResponse.getResourceId();\n        assertNotNull(loanChargeId);\n\n        payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(loanChargeId.toString(), operationDate, feeAmount);\n        PostLoansLoanIdChargesResponse postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON,\n                responseSpec);\n        assertNotNull(postLoansLoanIdChargesResponse);\n\n        periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n\n        // Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"10.00\"), true);\n\n        loanTransactionHelper.disburseLoan((long) loanId, new PostLoansLoanIdRequest().actualDisbursementDate(operationDate)\n                .transactionAmount(new BigDecimal(\"1000\")).locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n\n        // Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.parseDouble(principalAmount) * 2, Double.valueOf(\"10.00\"), true);\n\n        operationDate = Utils.dateFormatter.format(transactionDate.plusMonths(1));\n        payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(loanChargeId.toString(), operationDate, feeAmount);\n        postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON, responseSpec);\n\n        // Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.parseDouble(principalAmount) * 2, Double.valueOf(\"20.00\"), true);\n    }"}
{"prompt": "Create a test that tests test Apply Loan Specific Due Date Penalty Accrual With Disbursement Date With Multiple Disbursement", "completion": "    @Test\n    public void testApplyLoanSpecificDueDatePenaltyAccrualWithDisbursementDateWithMultipleDisbursement() {\n\n        final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n\n        // Client and Loan account creation\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProductWithPeriodicAccrual(loanTransactionHelper,\n                null);\n        assertNotNull(getLoanProductsProductResponse);\n\n        // Older date to have more than one overdue installment\n        LocalDate transactionDate = todaysDate.minusDays(2);\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n        log.info(\"Operation date {}\", transactionDate);\n\n        // Create Loan Account\n        final Integer loanId = createLoanAccount(loanTransactionHelper, clientId.toString(),\n                getLoanProductsProductResponse.getId().toString(), operationDate, \"12\", \"0\");\n\n        // Get loan details\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"0.00\"), true);\n\n        // Apply Loan Charge with specific due date\n\n        final String feeAmount = \"10.00\";\n        String payloadJSON = ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, feeAmount, true);\n        final PostChargesResponse postChargesResponse = ChargesHelper.createLoanCharge(requestSpec, responseSpec, payloadJSON);\n        assertNotNull(postChargesResponse);\n        final Long loanChargeId = postChargesResponse.getResourceId();\n        assertNotNull(loanChargeId);\n\n        payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(loanChargeId.toString(), operationDate, feeAmount);\n        PostLoansLoanIdChargesResponse postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON,\n                responseSpec);\n        assertNotNull(postLoansLoanIdChargesResponse);\n\n        periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n\n        // Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.valueOf(principalAmount), Double.valueOf(\"10.00\"), true);\n\n        transactionDate = transactionDate.plusDays(1);\n        operationDate = Utils.dateFormatter.format(transactionDate);\n\n        loanTransactionHelper.disburseLoan((long) loanId, new PostLoansLoanIdRequest().actualDisbursementDate(operationDate)\n                .transactionAmount(new BigDecimal(\"1000\")).locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n\n        // Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.parseDouble(principalAmount) * 2, Double.valueOf(\"10.00\"), true);\n\n        periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n\n        operationDate = Utils.dateFormatter.format(transactionDate.plusMonths(1));\n        payloadJSON = LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(loanChargeId.toString(), operationDate, feeAmount);\n        postLoansLoanIdChargesResponse = loanTransactionHelper.addChargeForLoan(loanId, payloadJSON, responseSpec);\n\n        transactionDate = transactionDate.plusDays(1);\n        operationDate = Utils.dateFormatter.format(transactionDate);\n        periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(operationDate);\n        // Get loan details expecting to have a delinquency classification\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        validateLoanAccount(getLoansLoanIdResponse, Double.parseDouble(principalAmount) * 2, Double.valueOf(\"20.00\"), true);\n    }"}
{"prompt": "Create a test that tests test Loan COBCatch Up Works When In Batch Manager Mode", "completion": "    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = true)\n    @Test\n    public void testLoanCOBCatchUpWorksWhenInBatchManagerMode() {\n        loanCOBCatchUpHelper.executeLoanCOBCatchUp();\n    }"}
{"prompt": "Create a test that tests test Loan COBCatch Up Does Not Works When Not In Batch Manager Mode", "completion": "    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = true, batchManagerEnabled = false)\n    @Test\n    public void testLoanCOBCatchUpDoesNotWorksWhenNotInBatchManagerMode() {\n        CallFailedRuntimeException exception = assertThrows(CallFailedRuntimeException.class,\n                () -> loanCOBCatchUpHelper.executeLoanCOBCatchUp());\n        assertEquals(405, exception.getResponse().code());\n    }"}
{"prompt": "Create a test that tests test Loan COBCatch Up Get Status Works When In Batch Manager Mode", "completion": "    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = true)\n    @Test\n    public void testLoanCOBCatchUpGetStatusWorksWhenInBatchManagerMode() {\n        loanCOBCatchUpHelper.executeGetLoanCatchUpStatus();\n    }"}
{"prompt": "Create a test that tests test Loan COBCatch Up Get Status Does Not Works When Not In Batch Manager Mode", "completion": "    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = true, batchManagerEnabled = false)\n    @Test\n    public void testLoanCOBCatchUpGetStatusDoesNotWorksWhenNotInBatchManagerMode() {\n        CallFailedRuntimeException exception = assertThrows(CallFailedRuntimeException.class,\n                () -> loanCOBCatchUpHelper.executeGetLoanCatchUpStatus());\n        assertEquals(405, exception.getResponse().code());\n    }"}
{"prompt": "Create a test that tests test Loan COBCatch Up Other Get Apis Works When In Batch Manager And Read Mode", "completion": "    @ConfigureInstanceMode(readEnabled = true, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = true)\n    @Test\n    public void testLoanCOBCatchUpOtherGetApisWorksWhenInBatchManagerAndReadMode() {\n        loanCOBCatchUpHelper.executeRetrieveOldestCOBProcessedLoan();\n    }"}
{"prompt": "Create a test that tests test Loan COBCatch Up Other Get Apis Works When In Read Only Mode", "completion": "    @ConfigureInstanceMode(readEnabled = true, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = false)\n    @Test\n    public void testLoanCOBCatchUpOtherGetApisWorksWhenInReadOnlyMode() {\n        loanCOBCatchUpHelper.executeRetrieveOldestCOBProcessedLoan();\n    }"}
{"prompt": "Create a test that tests test Scheduler Works When In Batch Manager Mode", "completion": "    @ConfigureInstanceMode(readEnabled = false, writeEnabled = false, batchWorkerEnabled = false, batchManagerEnabled = true)\n    @Test\n    public void testSchedulerWorksWhenInBatchManagerMode() {\n        schedulerJobHelper.updateSchedulerStatus(false);\n    }"}
{"prompt": "Create a test that tests test Scheduler Does Not Works When Not In Batch Manager Mode", "completion": "    @ConfigureInstanceMode(readEnabled = true, writeEnabled = true, batchWorkerEnabled = true, batchManagerEnabled = false)\n    @Test\n    public void testSchedulerDoesNotWorksWhenNotInBatchManagerMode() {\n        CallFailedRuntimeException exception = assertThrows(CallFailedRuntimeException.class,\n                () -> schedulerJobHelper.updateSchedulerStatus(false));\n        assertEquals(405, exception.getResponse().code());\n    }"}
{"prompt": "Create a test that tests loan Application Validate Disbursal Date", "completion": "    @Test\n    public void loanApplicationValidateDisbursalDate() {\n\n        final String proposedAmount = \"5000\";\n        final String approveDate = \"01 March 2014\";\n        final String disbursalDate = \"02 March 2014\";\n\n        // CREATE CLIENT\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        LOG.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientID);\n\n        // CREATE LOAN PRODUCT\n        final Integer loanProductID = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withSyncExpectedWithDisbursementDate(true).build(null));\n        LOG.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductID);\n\n        // APPLY FOR LOAN\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, proposedAmount);\n        LOG.info(\"-----------------------------------LOAN CREATED WITH LOANID------------------------------------------------- {}\", loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n\n        // VALIDATE THE LOAN STATUS\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(approveDate, loanID);\n\n        // VALIDATE THE LOAN IS APPROVED\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        // DISBURSE A LOAN\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        @SuppressWarnings(\"unchecked\")\n        List<HashMap> disbursalError = (List<HashMap>) this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(disbursalDate, loanID,\n                this.responseForbiddenError, JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n\n        Assertions.assertEquals(disbursalError.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE),\n                \"error.msg.actual.disbursement.date.does.not.match.with.expected.disbursal.date\");\n\n    }"}
{"prompt": "Create a test that tests create And Validate Multi Disburse Loans Based On Emi", "completion": "    @Test\n    public void createAndValidateMultiDisburseLoansBasedOnEmi() {\n        List<HashMap> createTranches = new ArrayList<>();\n        String id = null;\n        String installmentAmount = \"800\";\n        String withoutInstallmentAmount = \"\";\n        String proposedAmount = \"10000\";\n        createTranches.add(this.loanTransactionHelper.createTrancheDetail(id, \"01 June 2015\", \"5000\"));\n        createTranches.add(this.loanTransactionHelper.createTrancheDetail(id, \"01 September 2015\", \"5000\"));\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        log.info(\"---------------------------------CLIENT CREATED WITH ID---------------------------------------------------{}\", clientID);\n\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder()\n                .withInterestTypeAsDecliningBalance().withMoratorium(\"\", \"\").withAmortizationTypeAsEqualInstallments().withTranches(true)\n                .withInterestCalculationPeriodTypeAsRepaymentPeriod(true).build(null));\n        log.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductID);\n\n        final Integer loanIDWithEmi = applyForLoanApplicationWithEmiAmount(clientID, loanProductID, proposedAmount, createTranches,\n                installmentAmount);\n\n        log.info(\"-----------------------------------LOAN CREATED WITH EMI LOANID------------------------------------------------- {}\",\n                loanIDWithEmi);\n\n        HashMap repaymentScheduleWithEmi = (HashMap) this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec,\n                loanIDWithEmi, \"repaymentSchedule\");\n\n        ArrayList<HashMap> periods = (ArrayList<HashMap>) repaymentScheduleWithEmi.get(\"periods\");\n        assertEquals(15, periods.size());\n\n        this.validateRepaymentScheduleWithEMI(periods);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanIDWithEmi);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        log.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(\"01 June 2015\", \"01 June 2015\", \"10000\", loanIDWithEmi,\n                createTranches);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        log.info(\n                \"-----------------------------------MULTI DISBURSAL LOAN WITH EMI APPROVED SUCCESSFULLY---------------------------------------\");\n\n        final Integer loanIDWithoutEmi = applyForLoanApplicationWithEmiAmount(clientID, loanProductID, proposedAmount, createTranches,\n                withoutInstallmentAmount);\n\n        this.loanTransactionHelper.getLoanDetail(this.requestSpec, this.responseSpec, loanIDWithoutEmi, \"repaymentSchedule\");\n\n        ArrayList<HashMap> periods1 = (ArrayList<HashMap>) repaymentScheduleWithEmi.get(\"periods\");\n        assertEquals(15, periods1.size());\n\n        log.info(\"-----------------------------------LOAN CREATED WITHOUT EMI LOANID------------------------------------------------- {}\",\n                loanIDWithoutEmi);\n\n        /* To be uncommented once issue MIFOSX-2006 is closed. */\n        // this.validateRepaymentScheduleWithoutEMI(periods1);\n\n        HashMap loanStatusMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanIDWithoutEmi);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusMap);\n\n        log.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(\"01 June 2015\", \"01 June 2015\", \"10000\",\n                loanIDWithoutEmi, createTranches);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        log.info(\n                \"-----------------------------------MULTI DISBURSAL LOAN WITHOUT EMI APPROVED SUCCESSFULLY---------------------------------------\");\n\n    }"}
{"prompt": "Create a test that tests validate Equal Installments For Multi Tranche Loan", "completion": "    @Test\n    public void validateEqualInstallmentsForMultiTrancheLoan() {\n        final String operationDate = \"01 January 2014\";\n        final String principal = \"1000\";\n        final String disbursedPrincipal = \"900\";\n\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, operationDate);\n        log.info(\"-----------------CLIENT CREATED WITH ID------------------- {}\", clientId);\n\n        final String loanProductJSON = new LoanProductTestBuilder().withAmortizationTypeAsEqualInstallments() //\n                .withInterestTypeAsDecliningBalance().withMoratorium(\"\", \"\").withInterestCalculationPeriodTypeAsRepaymentPeriod(true)\n                .withInterestTypeAsDecliningBalance() //\n                .withMultiDisburse() //\n                .withDisallowExpectedDisbursements(true) //\n                .build(null);\n        log.info(\"Product {}\", loanProductJSON);\n        final Integer loanProductId = this.loanTransactionHelper.getLoanProductId(loanProductJSON);\n        log.info(\"------------------LOAN PRODUCT CREATED WITH ID----------- {}\", loanProductId);\n\n        final Integer loanId = applyForMultiTrancheLoanApplication(clientId.toString(), loanProductId.toString(), principal, operationDate);\n\n        log.info(\"-------------------LOAN CREATED WITH loanId----------------- {}\", loanId);\n\n        this.loanTransactionHelper.approveLoanWithApproveAmount(operationDate, expectedDisbursementDate, principal, loanId, null);\n        log.info(\"-------------------MULTI DISBURSAL LOAN APPROVED SUCCESSFULLY-------\");\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        this.loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        loanTransactionHelper.disburseLoanWithTransactionAmount(operationDate, loanId, disbursedPrincipal);\n        log.info(\"-------------------MULTI DISBURSAL LOAN DISBURSED SUCCESSFULLY-------\");\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        this.loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n        final Double limit = 2.0;\n        evaluateEqualInstallmentsForRepaymentSchedule(getLoansLoanIdResponse.getRepaymentSchedule(), limit);\n        log.info(\"-----------MULTI DISBURSAL LOAN EQUAL INSTALLMENTS SUCCESSFULLY-------\");\n    }"}
{"prompt": "Create a test that tests create Approve And Validate Multi Disburse Loan", "completion": "    @Test\n    public void createApproveAndValidateMultiDisburseLoan() throws ParseException {\n\n        List<HashMap> createTranches = new ArrayList<>();\n        String id = null;\n        createTranches.add(this.loanTransactionHelper.createTrancheDetail(id, \"01 March 2014\", \"1000\"));\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        log.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientID);\n\n        final Integer loanProductID = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withInterestTypeAsDecliningBalance().withTranches(true)\n                        .withInterestCalculationPeriodTypeAsRepaymentPeriod(true).build(null));\n        log.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductID);\n\n        this.loanId = applyForLoanApplicationWithTranches(clientID, loanProductID, proposedAmount, createTranches);\n        log.info(\"-----------------------------------LOAN CREATED WITH LOANID------------------------------------------------- {}\",\n                this.loanId);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        log.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(approveDate, expectedDisbursementDate, approvalAmount,\n                this.loanId, createTranches);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        log.info(\"-----------------------------------MULTI DISBURSAL LOAN APPROVED SUCCESSFULLY---------------------------------------\");\n        ArrayList<HashMap> disbursementDetails = (ArrayList<HashMap>) this.loanTransactionHelper.getLoanDetail(this.requestSpec,\n                this.responseSpec, this.loanId, \"disbursementDetails\");\n        this.disbursementId = (Integer) disbursementDetails.get(0).get(\"id\");\n        this.editLoanDisbursementDetails();\n    }"}
{"prompt": "Create a test that tests allow Modify Loan Application After Undo Disbursal With Tranches", "completion": "    @Test\n    public void allowModifyLoanApplicationAfterUndoDisbursalWithTranches() throws ParseException {\n        final String operationDate = this.approveDate;\n        List<HashMap> tranches = new ArrayList<>();\n        String principal = \"1000\";\n        final List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, operationDate);\n        log.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientId);\n\n        final Integer loanProductId = this.loanTransactionHelper\n                .getLoanProductId(new LoanProductTestBuilder().withInterestTypeAsDecliningBalance().withTranches(true)\n                        .withDisallowExpectedDisbursements(true).withInterestCalculationPeriodTypeAsRepaymentPeriod(true).build(null));\n        log.info(\"----------------------------------LOAN PRODUCT CREATED WITH ID------------------------------------------- {}\",\n                loanProductId);\n        GetLoanProductsProductIdResponse getLoanProductsProductIdResponse = this.loanTransactionHelper.getLoanProduct(loanProductId);\n        assertNotNull(getLoanProductsProductIdResponse);\n        log.info(\"Loan Product Id {} with DisallowExpectectedDisbursements in {}\", loanProductId,\n                getLoanProductsProductIdResponse.getDisallowExpectedDisbursements());\n        assertEquals(true, getLoanProductsProductIdResponse.getDisallowExpectedDisbursements());\n\n        final Integer loanId = applyForLoanApplicationWithTranches(clientId, loanProductId, proposedAmount, tranches);\n        log.info(\"-----------------------------------LOAN CREATED WITH LOANID------------------------------------------------- {}\", loanId);\n\n        loanTransactionHelper.approveLoanWithApproveAmount(operationDate, operationDate, approvalAmount, loanId, tranches);\n        GetLoansLoanIdResponse getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size());\n        log.info(\"-------------------MULTI DISBURSAL LOAN APPROVED SUCCESSFULLY-------\");\n        assertEquals(0, getLoansLoanIdResponse.getDisbursementDetails().size(), \"Disbursement details items\");\n\n        loanTransactionHelper.disburseLoanWithTransactionAmount(operationDate, loanId, principal);\n\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size());\n        log.info(\"-------------------MULTI DISBURSAL LOAN DISBURSED SUCCESSFULLY-------\");\n        assertEquals(1, getLoansLoanIdResponse.getDisbursementDetails().size(), \"Disbursement details items\");\n\n        PostLoansLoanIdResponse postLoansLoanIdResponse = this.loanTransactionHelper.applyLoanCommand(loanId, \"undoDisbursal\");\n        assertNotNull(postLoansLoanIdResponse);\n        log.info(\"-------------------UNDO DISBURSAL LOAN SUCCESSFULLY-------\");\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size());\n        assertEquals(0, getLoansLoanIdResponse.getDisbursementDetails().size(), \"Disbursement details items\");\n\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size());\n        assertEquals(0, getLoansLoanIdResponse.getDisbursementDetails().size(), \"Disbursement details items\");\n\n        postLoansLoanIdResponse = this.loanTransactionHelper.applyLoanCommand(loanId, \"undoApproval\");\n        assertNotNull(postLoansLoanIdResponse);\n        log.info(\"-------------------UNDO APPROVAL LOAN SUCCESSFULLY-------\");\n\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size());\n\n        principal = \"10000\";\n        final String loanApplicationJSON = buildLoanApplicationJSON(clientId, loanProductId, principal, tranches, operationDate,\n                collaterals);\n        log.info(\"Modify Loan Application: {}\", loanApplicationJSON);\n        PutLoansLoanIdResponse putLoansLoanIdResponse = this.loanTransactionHelper.modifyLoanApplication(loanId, loanApplicationJSON);\n        assertNotNull(putLoansLoanIdResponse);\n\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {} and Principal {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size(),\n                getLoansLoanIdResponse.getPrincipal());\n\n        // ReDo the Approval and Disbursement\n        loanTransactionHelper.approveLoanWithApproveAmount(operationDate, operationDate, approvalAmount, loanId, null);\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size());\n\n        loanTransactionHelper.disburseLoanWithTransactionAmount(operationDate, loanId, principal);\n\n        getLoansLoanIdResponse = this.loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        log.info(\"Loan Id {} with Status {} with Disbursement details {}\", getLoansLoanIdResponse.getId(),\n                getLoansLoanIdResponse.getStatus().getCode(), getLoansLoanIdResponse.getDisbursementDetails().size());\n        log.info(\"-------------------MULTI DISBURSAL LOAN DISBURSED SUCCESSFULLY-------\");\n        assertEquals(1, getLoansLoanIdResponse.getDisbursementDetails().size(), \"Disbursement details items\");\n    }"}
{"prompt": "Create a test that tests check Loan Create And Disburse Flow With Fixed Principal Percentage", "completion": "    @Test\n    public void checkLoanCreateAndDisburseFlowWithFixedPrincipalPercentage() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(ACCOUNTING_NONE);\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, null, null, \"100000.00\");\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec,\n                loanID);\n        verifyLoanRepaymentScheduleForEqualPrincipal(loanSchedule);\n    }"}
{"prompt": "Create a test that tests check Loan Create And Disburse Flow With Fixed Principal Percentage With Principal Grace", "completion": "    @Test\n    public void checkLoanCreateAndDisburseFlowWithFixedPrincipalPercentageWithPrincipalGrace() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProduct(ACCOUNTING_NONE);\n        final Integer loanID = applyForLoanApplicationWithPrincipalGrace(clientID, loanProductID, null, null, \"100000.00\");\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec,\n                loanID);\n        verifyLoanRepaymentScheduleForEqualPrincipalWithPrincipalGrace(loanSchedule);\n    }"}
{"prompt": "Create a test that tests check Loan Create And Disburse Flow With Fixed Principal Percentage And Flat Interest", "completion": "    @Test\n    public void checkLoanCreateAndDisburseFlowWithFixedPrincipalPercentageAndFlatInterest() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer loanProductID = createLoanProductWithFlatInterest(ACCOUNTING_NONE);\n        final Integer loanID = applyForLoanApplicationWithFlatInterest(clientID, loanProductID, null, null, \"100000.00\");\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec,\n                loanID);\n        verifyLoanRepaymentScheduleForEqualPrincipalAndFlatInterest(loanSchedule);\n    }"}
{"prompt": "Create a test that tests loan Last Repayment Details Test Closed Loan", "completion": "    @Test\n    public void loanLastRepaymentDetailsTestClosedLoan() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        // Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        // make Repayments\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 September 2022\").locale(\"en\")\n                        .transactionAmount(500.0));\n\n        GetLoansLoanIdResponse loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n\n        // verify loan is active and last repayment details\n        LocalDate lastRepaymentDate_1 = LocalDate.of(2022, 9, 5);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getDelinquent());\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentAmount());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentAmount(), 500);\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentDate());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentDate(), lastRepaymentDate_1);\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_2 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"6 September 2022\").locale(\"en\")\n                        .transactionAmount(500.0));\n\n        // verify loan is closed and last repayment details\n\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n\n        LocalDate lastRepaymentDate_2 = LocalDate.of(2022, 9, 6);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getClosedObligationsMet());\n        assertNotNull(loanDetails.getDelinquent());\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentAmount());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentAmount(), 500);\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentDate());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentDate(), lastRepaymentDate_2);\n\n    }"}
{"prompt": "Create a test that tests loan Last Repayment Details Test Overpaid Loan", "completion": "    @Test\n    public void loanLastRepaymentDetailsTestOverpaidLoan() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        // Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        // make Repayments\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 September 2022\").locale(\"en\")\n                        .transactionAmount(500.0));\n\n        GetLoansLoanIdResponse loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n\n        // verify loan is active and last repayment details\n        LocalDate lastRepaymentDate_1 = LocalDate.of(2022, 9, 5);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getActive());\n        assertNotNull(loanDetails.getDelinquent());\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentAmount());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentAmount(), 500);\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentDate());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentDate(), lastRepaymentDate_1);\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_2 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"6 September 2022\").locale(\"en\")\n                        .transactionAmount(600.0));\n\n        // verify loan is overpaid and last repayment details\n        loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n\n        LocalDate lastRepaymentDate_2 = LocalDate.of(2022, 9, 6);\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getOverpaid());\n        assertNotNull(loanDetails.getDelinquent());\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentAmount());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentAmount(), 600);\n        assertNotNull(loanDetails.getDelinquent().getLastRepaymentDate());\n        assertEquals(loanDetails.getDelinquent().getLastRepaymentDate(), lastRepaymentDate_2);\n\n    }"}
{"prompt": "Create a test that tests loan Add Charge For Paid Off Loan With Refund Test", "completion": "    @Test\n    public void loanAddChargeForPaidOffLoanWithRefundTest() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        // Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        // make Repayments\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"4 September 2022\").locale(\"en\")\n                        .transactionAmount(1000.0));\n\n        GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        final Integer loanRepaymentScheduleSize = loanDetails.getRepaymentSchedule().getPeriods().size();\n        assertTrue(loanDetails.getStatus().getClosedObligationsMet());\n\n        // make payout refund\n        final PostLoansLoanIdTransactionsResponse payoutRefund_1 = loanTransactionHelper.makePayoutRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"4 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertTrue(loanDetails.getStatus().getOverpaid());\n\n        // apply charges on date before maturity date\n        Integer feeCharge = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 4);\n        final String feeChargeAddedDate = dateFormatter.format(targetDate);\n        Integer feeLoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge), feeChargeAddedDate, \"10\"));\n\n        assertNotNull(feeLoanChargeId);\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertEquals(loanDetails.getRepaymentSchedule().getPeriods().size(), loanRepaymentScheduleSize);\n\n        // apply charges on date after maturity date\n        Integer feeCharge_1 = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n\n        LocalDate targetDate_1 = LocalDate.of(2022, 10, 4);\n        final String feeCharge1AddedDate = dateFormatter.format(targetDate_1);\n        Integer feeLoanChargeId_1 = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(feeCharge_1), feeCharge1AddedDate, \"10\"));\n\n        assertNotNull(feeLoanChargeId_1);\n        loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n        assertEquals(loanDetails.getRepaymentSchedule().getPeriods().size(), loanRepaymentScheduleSize + 1);\n\n    }"}
{"prompt": "Create a test that tests loan Product Creation With Due Days Configuration For Repayment Event Test", "completion": "    @Test\n    public void loanProductCreationWithDueDaysConfigurationForRepaymentEventTest() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        // event days configuration\n        Integer dueDaysForRepaymentEvent = 1;\n        Integer overDueDaysForRepaymentEvent = 2;\n\n        // Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        Integer loanProductId = createLoanProductWithDueDaysForRepaymentEvent(loanTransactionHelper, delinquencyBucketId,\n                dueDaysForRepaymentEvent, overDueDaysForRepaymentEvent);\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = loanTransactionHelper.getLoanProduct(loanProductId);\n        assertNotNull(getLoanProductsProductResponse);\n        assertNotNull(getLoanProductsProductResponse.getDueDaysForRepaymentEvent());\n        assertNotNull(getLoanProductsProductResponse.getOverDueDaysForRepaymentEvent());\n        assertEquals(getLoanProductsProductResponse.getDueDaysForRepaymentEvent(), dueDaysForRepaymentEvent);\n        assertEquals(getLoanProductsProductResponse.getOverDueDaysForRepaymentEvent(), overDueDaysForRepaymentEvent);\n    }"}
{"prompt": "Create a test that tests loan Product Update With Due Days Configuration For Repayment Event Test", "completion": "    @Test\n    public void loanProductUpdateWithDueDaysConfigurationForRepaymentEventTest() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        // Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        // Modify Loan Product\n        PutLoanProductsProductIdResponse loanProductModifyResponse = updateLoanProduct(loanTransactionHelper,\n                getLoanProductsProductResponse.getId());\n        assertNotNull(loanProductModifyResponse);\n\n    }"}
{"prompt": "Create a test that tests test Loan Repayment Reschedule At Disbursement", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testLoanRepaymentRescheduleAtDisbursement() {\n\n        final String approvalAmount = \"10000\";\n        final String approveDate = \"01 March 2015\";\n        final String expectedDisbursementDate = \"01 March 2015\";\n        final String disbursementDate = \"01 March 2015\";\n        final String adjustRepaymentDate = \"16 March 2015\";\n\n        // CREATE CLIENT\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2014\");\n        LOG.info(\"---------------------------------CLIENT CREATED WITH ID--------------------------------------------------- {}\", clientID);\n\n        // CREATE LOAN MULTIDISBURSAL PRODUCT WITH INTEREST RECALCULATION\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.RBI_INDIA_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"0\",\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null);\n\n        // CREATE TRANCHES\n        List<HashMap> createTranches = new ArrayList<>();\n        createTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"01 March 2015\", \"5000\"));\n        createTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"01 May 2015\", \"5000\"));\n\n        // APPROVE TRANCHES\n        List<HashMap> approveTranches = new ArrayList<>();\n        approveTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"01 March 2015\", \"5000\"));\n        approveTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(\"01 May 2015\", \"5000\"));\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        // APPLY FOR TRANCHE LOAN WITH INTEREST RECALCULATION\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientID, loanProductID, disbursementDate,\n                LoanApplicationTestBuilder.RBI_INDIA_STRATEGY, new ArrayList<HashMap>(0), createTranches, collaterals);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n\n        // VALIDATE THE LOAN STATUS\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(approveDate, expectedDisbursementDate, approvalAmount,\n                loanID, approveTranches);\n\n        // VALIDATE THE LOAN IS APPROVED\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        // DISBURSE A FIRST TRANCHE\n        this.loanTransactionHelper.disburseLoanWithRepaymentReschedule(disbursementDate, loanID, adjustRepaymentDate);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n\n        ArrayList<HashMap> loanRepaymnetSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, generalResponseSpec,\n                loanID);\n        HashMap firstInstallement = loanRepaymnetSchedule.get(1);\n        Map<String, Object> expectedvalues = new HashMap<>(3);\n        Calendar date = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        date.set(2015, Calendar.MARCH, 16);\n        expectedvalues.put(\"dueDate\", getDateAsArray(date, 0));\n        expectedvalues.put(\"principalDue\", \"834.71\");\n        expectedvalues.put(\"interestDue\", \"49.32\");\n        expectedvalues.put(\"feeChargesDue\", \"0\");\n        expectedvalues.put(\"penaltyChargesDue\", \"0\");\n        expectedvalues.put(\"totalDueForPeriod\", \"884.03\");\n\n        // VALIDATE REPAYMENT SCHEDULE\n        verifyLoanRepaymentSchedule(firstInstallement, expectedvalues);\n\n    }"}
{"prompt": "Create a test that tests test Create Loan Reschedule Request With Interest Appropriation", "completion": "    @Test\n    public void testCreateLoanRescheduleRequestWithInterestAppropriation() {\n        // create all required entities\n        this.createRequiredEntities();\n        this.createAndApproveLoanRescheduleRequestForRecoverInterestInterestFirst();\n\n    }"}
{"prompt": "Create a test that tests test Create Loan Reschedule Request Fail If Loan Is Charged Off", "completion": "    @Test\n    public void testCreateLoanRescheduleRequestFailIfLoanIsChargedOff() {\n        // create all required entities\n        this.createRequiredEntitiesNoInterest();\n        this.createLoanRescheduleRequestWhichFailsAsLoanIdChargedOff();\n\n    }"}
{"prompt": "Create a test that tests test Create Loan Reschedule Request With Recalculation Enabled", "completion": "    @Test\n    public void testCreateLoanRescheduleRequestWithRecalculationEnabled() {\n        // create all required entities\n        this.createRequiredEntitiesWithRecalculationEnabled();\n        this.createAndApproveLoanRescheduleRequestWithRecalculationEnabled();\n    }"}
{"prompt": "Create a test that tests test Create Loan Reschedule Request For Interest Appropriation And Fixed EMI", "completion": "    @Test\n    public void testCreateLoanRescheduleRequestForInterestAppropriationAndFixedEMI() {\n        // create all required entities\n        this.createRequiredEntities();\n        this.createAndApproveLoanRescheduleRequestForRecoverInterestFirstAndFixedEMI();\n    }"}
{"prompt": "Create a test that tests test Create Loan Reschedule Request With Multple Interest Appropriation", "completion": "    @Test\n    public void testCreateLoanRescheduleRequestWithMultpleInterestAppropriation() {\n        // create all required entities\n        this.createRequiredEntities();\n        this.createAndApproveLoanRescheduleRequestForRecoverInterestInterestFirst();\n\n        this.createAndApproveLoanRescheduleRequestForSecondInterestAppropriation();\n\n    }"}
{"prompt": "Create a test that tests test Create Loan Interest Greater Than EMIFrom Gap With Recalculation Enabled And Principal Compounding Off", "completion": "    @Test\n    public void testCreateLoanInterestGreaterThanEMIFromGapWithRecalculationEnabledAndPrincipalCompoundingOff() {\n        this.enableConfig();\n        this.enablePrincipalCompoundingConfig();\n        // create all required entities\n        this.createRequiredEntitiesWithRecalculationEnabledWithPrincipalCompoundingOff();\n        this.createApproveLoanRescheduleRequestWithRecalculationEnabledWithPrincipalCompoundingOff();\n        this.disablePrincipalCompoundingConfig();\n        this.disableConfig();\n    }"}
{"prompt": "Create a test that tests test Create Loan Reschedule Request", "completion": "    @Test\n    public void testCreateLoanRescheduleRequest() {\n        this.createLoanRescheduleRequest();\n    }"}
{"prompt": "Create a test that tests test Reject Loan Reschedule Request", "completion": "    @Test\n    public void testRejectLoanRescheduleRequest() {\n        this.createLoanRescheduleRequest();\n\n        LOG.info(\"-----------------------------REJECTING LOAN RESCHEDULE REQUEST--------------------------\");\n\n        final String requestJSON = new LoanRescheduleRequestTestBuilder().getRejectLoanRescheduleRequestJSON();\n        this.loanRescheduleRequestHelper.rejectLoanRescheduleRequest(this.loanRescheduleRequestId, requestJSON);\n\n        final HashMap response = (HashMap) this.loanRescheduleRequestHelper.getLoanRescheduleRequest(loanRescheduleRequestId, \"statusEnum\");\n        assertTrue((Boolean) response.get(\"rejected\"));\n\n        LOG.info(\"Successfully rejected loan reschedule request (ID: {} )\", this.loanRescheduleRequestId);\n    }"}
{"prompt": "Create a test that tests test Approve Loan Reschedule Request", "completion": "    @Test\n    public void testApproveLoanRescheduleRequest() {\n        this.createLoanRescheduleRequest();\n\n        LOG.info(\"-----------------------------APPROVING LOAN RESCHEDULE REQUEST--------------------------\");\n\n        final String requestJSON = new LoanRescheduleRequestTestBuilder().getApproveLoanRescheduleRequestJSON();\n        this.loanRescheduleRequestHelper.approveLoanRescheduleRequest(this.loanRescheduleRequestId, requestJSON);\n\n        final HashMap response = (HashMap) this.loanRescheduleRequestHelper.getLoanRescheduleRequest(loanRescheduleRequestId, \"statusEnum\");\n        assertTrue((Boolean) response.get(\"approved\"));\n\n        final Integer numberOfRepayments = (Integer) this.loanTransactionHelper.getLoanDetail(requestSpec, generalResponseSpec, loanId,\n                \"numberOfRepayments\");\n        final HashMap loanSummary = this.loanTransactionHelper.getLoanSummary(requestSpec, generalResponseSpec, loanId);\n        final Float totalExpectedRepayment = (Float) loanSummary.get(\"totalExpectedRepayment\");\n\n        assertEquals(12, numberOfRepayments, \"NUMBER OF REPAYMENTS is NOK\");\n        assertEquals(118000, totalExpectedRepayment, \"TOTAL EXPECTED REPAYMENT is NOK\");\n\n        LOG.info(\"Successfully approved loan reschedule request (ID: {})\", this.loanRescheduleRequestId);\n    }"}
{"prompt": "Create a test that tests test Create Loan Reschedule Change EMIRequest", "completion": "    @Test\n    public void testCreateLoanRescheduleChangeEMIRequest() {\n        this.createLoanRescheduleChangeEMIRequest();\n    }"}
{"prompt": "Create a test that tests test Reschedule After Late Payment", "completion": "    @Test\n    public void testRescheduleAfterLatePayment() {\n        this.enableConfig();\n        this.enablePrincipalCompoundingConfig();\n        WorkingDaysHelper.updateWorkingDaysWeekDays(this.requestSpec, this.responseSpec);\n        // create all required entities\n        this.createRequiredEntitiesWithLatePayment();\n        this.createApproveLoanRescheduleRequestAfterLatePayment();\n        WorkingDaysHelper.updateWorkingDays(this.requestSpec, this.responseSpec);\n        this.disablePrincipalCompoundingConfig();\n        this.disableConfig();\n    }"}
{"prompt": "Create a test that tests test Multiple Advance Payment With Reschedule", "completion": "    @Test\n    public void testMultipleAdvancePaymentWithReschedule() {\n        this.enableConfig();\n        this.enablePrincipalCompoundingConfig();\n        WorkingDaysHelper.updateWorkingDaysWeekDays(this.requestSpec, this.responseSpec);\n        // create all required entities\n        this.createRequiredEntitiesForTestMultipleAdvancePaymentWithReschedule();\n        this.doMultipleAdvancePaymentsAndVerifySchedule();\n        WorkingDaysHelper.updateWorkingDays(this.requestSpec, this.responseSpec);\n        this.disablePrincipalCompoundingConfig();\n        this.disableConfig();\n    }"}
{"prompt": "Create a test that tests test Center Rescheduling Loans With Interest Recalculation Enabled", "completion": "    @SuppressWarnings(\"rawtypes\")\n    @Test\n    public void testCenterReschedulingLoansWithInterestRecalculationEnabled() {\n\n        Integer officeId = new OfficeHelper(requestSpec, responseSpec).createOffice(\"01 July 2007\");\n        String name = \"TestFullCreation\" + new Timestamp(new java.util.Date().getTime());\n        String externalId = UUID.randomUUID().toString();\n        int staffId = StaffHelper.createStaff(requestSpec, responseSpec);\n        int[] groupMembers = generateGroupMembers(1, officeId);\n        final String centerActivationDate = \"01 July 2007\";\n        Integer centerId = CenterHelper.createCenter(name, officeId, externalId, staffId, groupMembers, centerActivationDate, requestSpec,\n                responseSpec);\n        CenterDomain center = CenterHelper.retrieveByID(centerId, requestSpec, responseSpec);\n        Integer groupId = groupMembers[0];\n        Assertions.assertNotNull(center);\n        Assertions.assertTrue(center.getStaffId() == staffId);\n        Assertions.assertTrue(center.isActive() == true);\n\n        Integer calendarId = createCalendarMeeting(centerId);\n\n        Integer clientId = createClient(officeId);\n\n        associateClientsToGroup(groupId, clientId);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n        Calendar today = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        today.add(Calendar.DAY_OF_MONTH, -14);\n        // CREATE A LOAN PRODUCT\n        final String disbursalDate = dateFormat.format(today.getTime());\n        final String recalculationRestFrequencyDate = \"01 January 2012\";\n        final boolean isMultiTrancheLoan = false;\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientId), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        // CREATE LOAN MULTIDISBURSAL PRODUCT WITH INTEREST RECALCULATION\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.RBI_INDIA_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"0\", recalculationRestFrequencyDate,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, isMultiTrancheLoan, null, null);\n\n        // APPLY FOR TRANCHE LOAN WITH INTEREST RECALCULATION\n        final Integer loanId = applyForLoanApplicationForInterestRecalculation(clientId, groupId, calendarId, loanProductID, disbursalDate,\n                recalculationRestFrequencyDate, LoanApplicationTestBuilder.RBI_INDIA_STRATEGY, new ArrayList<HashMap>(0), null,\n                collaterals);\n\n        // Test for loan account is created\n        Assertions.assertNotNull(loanId);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanId);\n\n        // Test for loan account is created, can be approved\n        this.loanTransactionHelper.approveLoan(disbursalDate, loanId);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanId);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        // Test for loan account approved can be disbursed\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(disbursalDate, loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanId);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        LOG.info(\"---------------------------------CHANGING GROUP MEETING DATE ------------------------------------------\");\n        Calendar todaysdate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysdate.add(Calendar.DAY_OF_MONTH, 14);\n        String oldMeetingDate = dateFormat.format(todaysdate.getTime());\n        todaysdate.add(Calendar.DAY_OF_MONTH, 1);\n        final String centerMeetingNewStartDate = dateFormat.format(todaysdate.getTime());\n        CalendarHelper.updateMeetingCalendarForCenter(this.requestSpec, this.responseSpec, centerId, calendarId.toString(), oldMeetingDate,\n                centerMeetingNewStartDate);\n\n        ArrayList loanRepaymnetSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, generalResponseSpec, loanId);\n        // VERIFY RESCHEDULED DATE\n        ArrayList dueDateLoanSchedule = (ArrayList) ((HashMap) loanRepaymnetSchedule.get(2)).get(\"dueDate\");\n        assertEquals(getDateAsArray(todaysdate, 0), dueDateLoanSchedule);\n\n        // VERIFY THE INTEREST\n        Float interestDue = (Float) ((HashMap) loanRepaymnetSchedule.get(2)).get(\"interestDue\");\n        assertEquals(\"90.82\", String.valueOf(interestDue));\n    }"}
{"prompt": "Create a test that tests test Center Rescheduling Multi Tranche Loans With Interest Recalculation Enabled", "completion": "    @SuppressWarnings(\"rawtypes\")\n    @Test\n    public void testCenterReschedulingMultiTrancheLoansWithInterestRecalculationEnabled() {\n\n        Integer officeId = new OfficeHelper(requestSpec, responseSpec).createOffice(\"01 July 2007\");\n        String name = \"TestFullCreation\" + new Timestamp(new java.util.Date().getTime());\n        String externalId = UUID.randomUUID().toString();\n        int staffId = StaffHelper.createStaff(requestSpec, responseSpec);\n        int[] groupMembers = generateGroupMembers(1, officeId);\n        final String centerActivationDate = \"01 July 2007\";\n        Integer centerId = CenterHelper.createCenter(name, officeId, externalId, staffId, groupMembers, centerActivationDate, requestSpec,\n                responseSpec);\n        CenterDomain center = CenterHelper.retrieveByID(centerId, requestSpec, responseSpec);\n        Integer groupId = groupMembers[0];\n        Assertions.assertNotNull(center);\n        Assertions.assertTrue(center.getStaffId() == staffId);\n        Assertions.assertTrue(center.isActive() == true);\n\n        Integer calendarId = createCalendarMeeting(centerId);\n\n        Integer clientId = createClient(officeId);\n\n        associateClientsToGroup(groupId, clientId);\n\n        // CREATE A LOAN PRODUCT\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n        Calendar today = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        today.add(Calendar.DAY_OF_MONTH, -14);\n        // CREATE A LOAN PRODUCT\n        final String approveDate = dateFormat.format(today.getTime());\n        final String expectedDisbursementDate = dateFormat.format(today.getTime());\n        final String disbursementDate = dateFormat.format(today.getTime());\n        final String approvalAmount = \"10000\";\n        final String recalculationRestFrequencyDate = \"01 January 2012\";\n        final boolean isMultiTrancheLoan = true;\n\n        // CREATE LOAN MULTIDISBURSAL PRODUCT WITH INTEREST RECALCULATION\n        final Integer loanProductID = createLoanProductWithInterestRecalculation(LoanProductTestBuilder.RBI_INDIA_STRATEGY,\n                LoanProductTestBuilder.RECALCULATION_COMPOUNDING_METHOD_NONE,\n                LoanProductTestBuilder.RECALCULATION_STRATEGY_REDUCE_NUMBER_OF_INSTALLMENTS,\n                LoanProductTestBuilder.RECALCULATION_FREQUENCY_TYPE_DAILY, \"0\", recalculationRestFrequencyDate,\n                LoanProductTestBuilder.INTEREST_APPLICABLE_STRATEGY_ON_PRE_CLOSE_DATE, null, isMultiTrancheLoan, null, null);\n\n        Calendar secondTrancheDate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        secondTrancheDate.add(Calendar.DAY_OF_MONTH, -7);\n        String secondDisbursement = dateFormat.format(secondTrancheDate.getTime());\n\n        // CREATE TRANCHES\n        List<HashMap> createTranches = new ArrayList<>();\n        createTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(disbursementDate, \"5000\"));\n        createTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(secondDisbursement, \"5000\"));\n\n        // APPROVE TRANCHES\n        List<HashMap> approveTranches = new ArrayList<>();\n        approveTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(disbursementDate, \"5000\"));\n        approveTranches.add(this.loanApplicationApprovalTest.createTrancheDetail(secondDisbursement, \"5000\"));\n\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientId), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        // APPLY FOR TRANCHE LOAN WITH INTEREST RECALCULATION\n        final Integer loanID = applyForLoanApplicationForInterestRecalculation(clientId, groupId, calendarId, loanProductID,\n                disbursementDate, recalculationRestFrequencyDate, LoanApplicationTestBuilder.RBI_INDIA_STRATEGY, new ArrayList<HashMap>(0),\n                createTranches, collaterals);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n\n        // VALIDATE THE LOAN STATUS\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoanWithApproveAmount(approveDate, expectedDisbursementDate, approvalAmount,\n                loanID, approveTranches);\n\n        // VALIDATE THE LOAN IS APPROVED\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        // DISBURSE THE FIRST TRANCHE\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(disbursementDate, loanID, \"5000\");\n\n        LOG.info(\"---------------------------------CHANGING GROUP MEETING DATE ------------------------------------------\");\n        Calendar todaysdate = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        todaysdate.add(Calendar.DAY_OF_MONTH, 14);\n        String oldMeetingDate = dateFormat.format(todaysdate.getTime());\n        todaysdate.add(Calendar.DAY_OF_MONTH, 1);\n        final String centerMeetingNewStartDate = dateFormat.format(todaysdate.getTime());\n        CalendarHelper.updateMeetingCalendarForCenter(this.requestSpec, this.responseSpec, centerId, calendarId.toString(), oldMeetingDate,\n                centerMeetingNewStartDate);\n\n        ArrayList loanRepaymnetSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, generalResponseSpec, loanID);\n        // VERIFY RESCHEDULED DATE\n        ArrayList dueDateLoanSchedule = (ArrayList) ((HashMap) loanRepaymnetSchedule.get(2)).get(\"dueDate\");\n        assertEquals(getDateAsArray(todaysdate, 0), dueDateLoanSchedule);\n\n        // VERIFY THE INTEREST\n        Float interestDue = (Float) ((HashMap) loanRepaymnetSchedule.get(2)).get(\"interestDue\");\n        assertEquals(\"41.05\", String.valueOf(interestDue));\n\n        // DISBURSE THE SECOND TRANCHE (for let the loan test lifecycle callback to close the loan\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(secondDisbursement, loanID, \"5000\");\n    }"}
{"prompt": "Create a test that tests reopen Closed Loan", "completion": "    @Test\n    public void reopenClosedLoan() {\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingNoInterest(assetAccount, incomeAccount, expenseAccount,\n                overpaymentAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"0\");\n\n        final float FEE_PORTION = 50.0f;\n        final float PENALTY_PORTION = 100.0f;\n        final float NEXT_FEE_PORTION = 55.0f;\n        final float NEXT_PENALTY_PORTION = 105.0f;\n\n        Integer flat = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(FEE_PORTION), false));\n        Integer flatSpecifiedDueDate = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(PENALTY_PORTION), true));\n\n        Integer flatNext = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(NEXT_FEE_PORTION), false));\n        Integer flatSpecifiedDueDateNext = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper\n                .getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, String.valueOf(NEXT_PENALTY_PORTION), true));\n\n        HashMap<String, Object> loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(EXPECTED_DISBURSAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        LocalDate targetDate = LocalDate.of(2011, 3, 4);\n        final String loanDisbursementDate = dateFormatter.format(targetDate);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(2, loanSchedule.size());\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesDue\"));\n        assertEquals(0, loanSchedule.get(1).get(\"feeChargesOutstanding\"));\n        assertEquals(0, loanSchedule.get(1).get(\"penaltyChargesDue\"));\n        assertEquals(0, loanSchedule.get(1).get(\"penaltyChargesOutstanding\"));\n        assertEquals(10000.0f, loanSchedule.get(1).get(\"totalDueForPeriod\"));\n        assertEquals(10000.0f, loanSchedule.get(1).get(\"totalOutstandingForPeriod\"));\n\n        targetDate = LocalDate.of(2011, 3, 10);\n        String repaymentDateStr = dateFormatter.format(targetDate);\n        loanTransactionHelper.makeRepayment(repaymentDateStr, 10000.0f, loanID);\n\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n        targetDate = LocalDate.of(2011, 4, 13);\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatSpecifiedDueDate), penaltyCharge1AddedDate,\n                        String.valueOf(PENALTY_PORTION)));\n\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(3, loanSchedule.size());\n        assertEquals(0, loanSchedule.get(2).get(\"feeChargesDue\"));\n        assertEquals(0, loanSchedule.get(2).get(\"feeChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesDue\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"totalDueForPeriod\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"totalOutstandingForPeriod\"));\n        assertEquals(LocalDate.of(2011, 4, 13), LocalDate.of((int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(0),\n                (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(1), (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(2)));\n\n        targetDate = LocalDate.of(2011, 4, 14);\n        String runOnDateStr = dateFormatter.format(targetDate);\n        this.periodicAccrualAccountingHelper.runPeriodicAccrualAccounting(runOnDateStr);\n\n        // Transaction date will be the due date of the instalment (in case of N+1 scenario)\n        this.loanTransactionHelper.checkAccrualTransactionForRepayment(LocalDate.of(2011, 4, 13), 0.0f, 0.0f, PENALTY_PORTION, loanID);\n\n        loanTransactionHelper.waiveChargesForLoan(loanID, penalty1LoanChargeId,\n                LoanTransactionHelper.getWaiveChargeJSON(String.valueOf(2)));\n\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(3, loanSchedule.size());\n        assertEquals(0, loanSchedule.get(2).get(\"feeChargesDue\"));\n        assertEquals(0, loanSchedule.get(2).get(\"feeChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesDue\"));\n        assertEquals(0.0f, loanSchedule.get(2).get(\"penaltyChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesWaived\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"totalDueForPeriod\"));\n        assertEquals(0.0f, loanSchedule.get(2).get(\"totalOutstandingForPeriod\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"totalWaivedForPeriod\"));\n        assertEquals(LocalDate.of(2011, 4, 13), LocalDate.of((int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(0),\n                (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(1), (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(2)));\n\n        targetDate = LocalDate.of(2011, 4, 14);\n        String penaltyCharge2AddedDate = dateFormatter.format(targetDate);\n        Integer penalty2LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(flatSpecifiedDueDate), penaltyCharge2AddedDate,\n                        String.valueOf(PENALTY_PORTION)));\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(3, loanSchedule.size());\n        assertEquals(0, loanSchedule.get(2).get(\"feeChargesDue\"));\n        assertEquals(0, loanSchedule.get(2).get(\"feeChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION + PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesDue\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesWaived\"));\n        assertEquals(PENALTY_PORTION + PENALTY_PORTION, loanSchedule.get(2).get(\"totalDueForPeriod\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"totalOutstandingForPeriod\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"totalWaivedForPeriod\"));\n        assertEquals(LocalDate.of(2011, 4, 14), LocalDate.of((int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(0),\n                (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(1), (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(2)));\n\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        targetDate = LocalDate.of(2011, 4, 15);\n        repaymentDateStr = dateFormatter.format(targetDate);\n        loanTransactionHelper.makeRepayment(repaymentDateStr, PENALTY_PORTION, loanID);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(3, loanSchedule.size());\n        assertEquals(0, loanSchedule.get(2).get(\"feeChargesDue\"));\n        assertEquals(0, loanSchedule.get(2).get(\"feeChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION + PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesDue\"));\n        assertEquals(0.0f, loanSchedule.get(2).get(\"penaltyChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesWaived\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesPaid\"));\n        assertEquals(PENALTY_PORTION + PENALTY_PORTION, loanSchedule.get(2).get(\"totalDueForPeriod\"));\n        assertEquals(0.0f, loanSchedule.get(2).get(\"totalOutstandingForPeriod\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"totalWaivedForPeriod\"));\n        // Might need to change if refund should update the due date of N+1 instalment\n        assertEquals(LocalDate.of(2011, 4, 14), LocalDate.of((int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(0),\n                (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(1), (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(2)));\n\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n        loanTransactionHelper.loanChargeRefund(penalty2LoanChargeId, null, PENALTY_PORTION, null, loanID, \"resourceId\");\n\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsOverPaid(loanStatusHashMap);\n\n        loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n        assertEquals(3, loanSchedule.size());\n        assertEquals(0, loanSchedule.get(2).get(\"feeChargesDue\"));\n        assertEquals(0, loanSchedule.get(2).get(\"feeChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION + PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesDue\"));\n        assertEquals(0.0f, loanSchedule.get(2).get(\"penaltyChargesOutstanding\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesWaived\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"penaltyChargesPaid\"));\n        assertEquals(PENALTY_PORTION + PENALTY_PORTION, loanSchedule.get(2).get(\"totalDueForPeriod\"));\n        assertEquals(0.0f, loanSchedule.get(2).get(\"totalOutstandingForPeriod\"));\n        assertEquals(PENALTY_PORTION, loanSchedule.get(2).get(\"totalWaivedForPeriod\"));\n        // Might need to change if refund should update the due date of N+1 instalment\n        assertEquals(LocalDate.of(2011, 4, 14), LocalDate.of((int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(0),\n                (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(1), (int) ((List) loanSchedule.get(2).get(\"dueDate\")).get(2)));\n    }"}
{"prompt": "Create a test that tests apply Loan Transaction Chargeback", "completion": "    @Test\n    public void applyLoanTransactionChargeback() {\n        // Client and Loan account creation\n        final Integer loanId = createAccounts(15, 1, true);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        Float amount = Float.valueOf(amountVal);\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        final Long transactionId = loanIdTransactionsResponse.getResourceId();\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n\n        reviewLoanTransactionRelations(loanId, transactionId, 0, Double.valueOf(\"0.00\"));\n\n        final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"1000.00\", 0,\n                responseSpec);\n\n        reviewLoanTransactionRelations(loanId, transactionId, 1, Double.valueOf(\"0.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionId, 0, Double.valueOf(\"1000.00\"));\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n\n        loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, amount.doubleValue());\n\n        GetJournalEntriesTransactionIdResponse journalEntries = journalEntryHelper\n                .getJournalEntries(\"L\" + chargebackTransactionId.toString());\n        assertEquals(2L, journalEntries.getTotalFilteredRecords());\n        assertEquals(1000.0, journalEntries.getPageItems().get(0).getAmount());\n        assertEquals(\"CREDIT\", journalEntries.getPageItems().get(0).getEntryType().getValue());\n\n        assertEquals(1000.0, journalEntries.getPageItems().get(1).getAmount());\n        assertEquals(\"DEBIT\", journalEntries.getPageItems().get(1).getEntryType().getValue());\n\n        // Try to reverse a Loan Transaction charge back\n        PostLoansLoanIdTransactionsResponse reverseTransactionResponse = loanTransactionHelper.reverseLoanTransaction(loanId,\n                chargebackTransactionId, operationDate, responseSpecErr403);\n\n        // Try to reverse a Loan Transaction repayment with linked transactions\n        reverseTransactionResponse = loanTransactionHelper.reverseLoanTransaction(loanId, transactionId, operationDate, responseSpecErr503);\n    }"}
{"prompt": "Create a test that tests apply And Adjust Loan Transaction Chargeback", "completion": "    @Test\n    public void applyAndAdjustLoanTransactionChargeback() {\n        // Client and Loan account creation\n        final Integer loanId = createAccounts(15, 1, false);\n\n        Float amount = Float.valueOf(amountVal);\n        PostLoansLoanIdTransactionsResponse loanTransactionResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanTransactionResponse);\n        final Long transactionId = loanTransactionResponse.getResourceId();\n\n        final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"1000.00\", 0,\n                responseSpec);\n\n        // Then\n        loanTransactionHelper.adjustLoanTransaction(loanId, chargebackTransactionId, operationDate, responseSpecErr403);\n    }"}
{"prompt": "Create a test that tests apply Loan Transaction Chargeback With Amount Zero", "completion": "    @Test\n    public void applyLoanTransactionChargebackWithAmountZero() {\n        // Client and Loan account creation\n        final Integer loanId = createAccounts(15, 1, false);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        Float amount = Float.valueOf(amountVal);\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        final Long transactionId = loanIdTransactionsResponse.getResourceId();\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n\n        loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"0.00\", 0, responseSpecErr400);\n    }"}
{"prompt": "Create a test that tests apply Loan Transaction Chargeback In Long Term Loan", "completion": "    @Disabled(\"Failing test.Need rework\")\n    @Test\n    public void applyLoanTransactionChargebackInLongTermLoan() {\n        // Client and Loan account creation\n        final Integer daysToSubtract = 1;\n        final Integer numberOfRepayments = 3;\n        final Integer loanId = createAccounts(daysToSubtract, numberOfRepayments, false);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        final String baseAmount = \"333.33\";\n        Float amount = Float.valueOf(baseAmount);\n        final LocalDate transactionDate = this.todaysDate.minusMonths(numberOfRepayments - 1).plusDays(3);\n        String operationDate = Utils.dateFormatter.format(transactionDate);\n\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        final Long transactionId = loanIdTransactionsResponse.getResourceId();\n        reviewLoanTransactionRelations(loanId, transactionId, 0, Double.valueOf(\"666.67\"));\n\n        final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, amount.toString(), 0,\n                responseSpec);\n        reviewLoanTransactionRelations(loanId, transactionId, 1, Double.valueOf(\"666.67\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionId, 0, Double.valueOf(\"1000.00\"));\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(amountVal));\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n        GetLoansLoanIdRepaymentSchedule getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n        for (GetLoansLoanIdRepaymentPeriod period : getLoanRepaymentSchedule.getPeriods()) {\n            if (period.getPeriod() != null && period.getPeriod() == 3) {\n                log.info(\"Period number {} for due date {} and totalDueForPeriod {}\", period.getPeriod(), period.getDueDate(),\n                        period.getTotalDueForPeriod());\n                assertEquals(Double.valueOf(\"666.67\"), period.getTotalDueForPeriod());\n            }\n        }\n\n        loanTransactionHelper.evaluateLoanSummaryAdjustments(getLoansLoanIdResponse, Double.valueOf(baseAmount));\n        DelinquencyBucketsHelper.evaluateLoanCollectionData(getLoansLoanIdResponse, 0, Double.valueOf(\"0.00\"));\n    }"}
{"prompt": "Create a test that tests apply Loan Transaction Chargeback Over No Repayment Type", "completion": "    @Test\n    public void applyLoanTransactionChargebackOverNoRepaymentType() {\n        // Client and Loan account creation\n        final Integer loanId = createAccounts(15, 1, false);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        List<GetLoansLoanIdTransactions> loanTransactions = getLoansLoanIdResponse.getTransactions();\n        assertNotNull(loanTransactions);\n        log.info(\"Loan Id {} with {} transactions\", loanId, loanTransactions.size());\n        assertEquals(2, loanTransactions.size());\n        GetLoansLoanIdTransactions loanTransaction = loanTransactions.iterator().next();\n        log.info(\"Try to apply the Charge back over transaction Id {} with type {}\", loanTransaction.getId(),\n                loanTransaction.getType().getCode());\n\n        loanTransactionHelper.applyChargebackTransaction(loanId, loanTransaction.getId(), amountVal, 0, responseSpecErr503);\n    }"}
{"prompt": "Create a test that tests apply Loan Transaction Chargeback After Mature", "completion": "    @Test\n    public void applyLoanTransactionChargebackAfterMature() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, todaysDate);\n            log.info(\"Current Business date {}\", todaysDate);\n\n            // Client and Loan account creation\n            final Integer loanId = createAccounts(45, 1, false);\n\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            GetDelinquencyRangesResponse delinquencyRange = getLoansLoanIdResponse.getDelinquencyRange();\n            assertNotNull(delinquencyRange);\n            log.info(\"Loan Delinquency Range is {}\", delinquencyRange.getClassification());\n\n            GetLoansLoanIdRepaymentSchedule getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n            log.info(\"Loan with {} periods\", getLoanRepaymentSchedule.getPeriods().size());\n            assertEquals(2, getLoanRepaymentSchedule.getPeriods().size());\n\n            Float amount = Float.valueOf(amountVal);\n            PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                    loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            final Long transactionId = loanIdTransactionsResponse.getResourceId();\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n\n            reviewLoanTransactionRelations(loanId, transactionId, 0, Double.valueOf(\"0.00\"));\n\n            Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"500.00\", 0,\n                    responseSpec);\n\n            reviewLoanTransactionRelations(loanId, transactionId, 1, Double.valueOf(\"0.00\"));\n            reviewLoanTransactionRelations(loanId, chargebackTransactionId, 0, Double.valueOf(\"500.00\"));\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n\n            loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"500.00\"));\n\n            // N+1 Scenario\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n            getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n            log.info(\"Loan with {} periods\", getLoanRepaymentSchedule.getPeriods().size());\n            assertEquals(3, getLoanRepaymentSchedule.getPeriods().size());\n            getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n            for (GetLoansLoanIdRepaymentPeriod period : getLoanRepaymentSchedule.getPeriods()) {\n                if (period.getPeriod() != null && period.getPeriod() == 2) {\n                    log.info(\"Period number {} for due date {} and totalDueForPeriod {}\", period.getPeriod(), period.getDueDate(),\n                            period.getTotalDueForPeriod());\n                    assertEquals(Double.valueOf(\"500.00\"), period.getPrincipalDue());\n                }\n            }\n\n            chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"300.00\", 0, responseSpec);\n\n            reviewLoanTransactionRelations(loanId, transactionId, 2, Double.valueOf(\"0.00\"));\n            reviewLoanTransactionRelations(loanId, chargebackTransactionId, 0, Double.valueOf(\"800.00\"));\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n\n            delinquencyRange = getLoansLoanIdResponse.getDelinquencyRange();\n            assertNull(delinquencyRange);\n            log.info(\"Loan Delinquency Range is null {}\", (delinquencyRange == null));\n\n            loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"800.00\"));\n\n            // N+1 Scenario -- Remains the same periods number\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n            getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n            log.info(\"Loan with {} periods\", getLoanRepaymentSchedule.getPeriods().size());\n            assertEquals(3, getLoanRepaymentSchedule.getPeriods().size());\n            getLoanRepaymentSchedule = getLoansLoanIdResponse.getRepaymentSchedule();\n            for (GetLoansLoanIdRepaymentPeriod period : getLoanRepaymentSchedule.getPeriods()) {\n                if (period.getPeriod() != null && period.getPeriod() == 2) {\n                    log.info(\"Period number {} for due date {} and totalDueForPeriod {}\", period.getPeriod(), period.getDueDate(),\n                            period.getTotalDueForPeriod());\n                    assertEquals(Double.valueOf(\"800.00\"), period.getPrincipalDue());\n                }\n            }\n\n            // Move the Business date few days to get Collection data\n            LocalDate businessDate = todaysDate.plusDays(4);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, businessDate);\n            log.info(\"Current Business date {}\", businessDate);\n\n            // Get loan details expecting to have a delinquency classification\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            DelinquencyBucketsHelper.evaluateLoanCollectionData(getLoansLoanIdResponse, 4, Double.valueOf(\"800.00\"));\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests apply Loan Transaction Chargeback With Loan Overpaid To Loan Active", "completion": "    @Test\n    public void applyLoanTransactionChargebackWithLoanOverpaidToLoanActive() {\n        // Client and Loan account creation\n        final Integer loanId = createAccounts(15, 1, true);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        Float amount = Float.valueOf(\"1100.00\");\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        final Long transactionId = loanIdTransactionsResponse.getResourceId();\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.overpaid\");\n\n        reviewLoanTransactionRelations(loanId, transactionId, 0, Double.valueOf(\"0.00\"));\n\n        final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"200.00\", 0,\n                responseSpec);\n\n        reviewLoanTransactionRelations(loanId, transactionId, 1, Double.valueOf(\"0.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionId, 0, Double.valueOf(\"100.00\"));\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.active\");\n\n        loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"100.00\"));\n        GetJournalEntriesTransactionIdResponse journalEntries = journalEntryHelper\n                .getJournalEntries(\"L\" + chargebackTransactionId.toString());\n        assertEquals(3L, journalEntries.getTotalFilteredRecords());\n        assertEquals(100.0, journalEntries.getPageItems().get(0).getAmount());\n        assertEquals(\"DEBIT\", journalEntries.getPageItems().get(0).getEntryType().getValue());\n\n        assertEquals(200.0, journalEntries.getPageItems().get(1).getAmount());\n        assertEquals(\"CREDIT\", journalEntries.getPageItems().get(1).getEntryType().getValue());\n\n        assertEquals(100.0, journalEntries.getPageItems().get(2).getAmount());\n        assertEquals(\"DEBIT\", journalEntries.getPageItems().get(2).getEntryType().getValue());\n\n        final GetDelinquencyRangesResponse delinquencyRange = getLoansLoanIdResponse.getDelinquencyRange();\n        assertNull(delinquencyRange);\n        log.info(\"Loan Delinquency Range is null {}\", (delinquencyRange == null));\n    }"}
{"prompt": "Create a test that tests apply Loan Transaction Chargeback With Loan Overpaid To Loan Close", "completion": "    @Test\n    public void applyLoanTransactionChargebackWithLoanOverpaidToLoanClose() {\n        // Client and Loan account creation\n        final Integer loanId = createAccounts(15, 1, false);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        Float amount = Float.valueOf(\"1100.00\");\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        final Long transactionId = loanIdTransactionsResponse.getResourceId();\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.overpaid\");\n\n        reviewLoanTransactionRelations(loanId, transactionId, 0, Double.valueOf(\"0.00\"));\n\n        final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"100.00\", 0,\n                responseSpec);\n\n        reviewLoanTransactionRelations(loanId, transactionId, 1, Double.valueOf(\"0.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionId, 0, Double.valueOf(\"0.00\"));\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n\n        loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"0.00\"));\n    }"}
{"prompt": "Create a test that tests apply Loan Transaction Chargeback With Loan Overpaid To Keep As Loan Overpaid", "completion": "    @Test\n    public void applyLoanTransactionChargebackWithLoanOverpaidToKeepAsLoanOverpaid() {\n        // Client and Loan account creation\n        final Integer loanId = createAccounts(15, 1, true);\n\n        GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n\n        loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n        Float amount = Float.valueOf(\"1100.00\");\n        PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                loanId);\n        assertNotNull(loanIdTransactionsResponse);\n        final Long transactionId = loanIdTransactionsResponse.getResourceId();\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.overpaid\");\n\n        reviewLoanTransactionRelations(loanId, transactionId, 0, Double.valueOf(\"0.00\"));\n\n        GetDelinquencyRangesResponse delinquencyRange = getLoansLoanIdResponse.getDelinquencyRange();\n        assertNull(delinquencyRange);\n        log.info(\"Loan Delinquency Range is null {}\", (delinquencyRange == null));\n        final Long chargebackTransactionId = loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"50.00\", 0,\n                responseSpec);\n        reviewLoanTransactionRelations(loanId, transactionId, 1, Double.valueOf(\"0.00\"));\n        reviewLoanTransactionRelations(loanId, chargebackTransactionId, 0, Double.valueOf(\"0.00\"));\n\n        getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n        assertNotNull(getLoansLoanIdResponse);\n        loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.overpaid\");\n\n        delinquencyRange = getLoansLoanIdResponse.getDelinquencyRange();\n        assertNull(delinquencyRange);\n        log.info(\"Loan Delinquency Range is null {}\", (delinquencyRange == null));\n\n        loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, Double.valueOf(\"0.00\"));\n\n        GetJournalEntriesTransactionIdResponse journalEntries = journalEntryHelper\n                .getJournalEntries(\"L\" + chargebackTransactionId.toString());\n        assertEquals(2L, journalEntries.getTotalFilteredRecords());\n        assertEquals(50.0, journalEntries.getPageItems().get(0).getAmount());\n        assertEquals(\"CREDIT\", journalEntries.getPageItems().get(0).getEntryType().getValue());\n\n        assertEquals(50.0, journalEntries.getPageItems().get(1).getAmount());\n        assertEquals(\"DEBIT\", journalEntries.getPageItems().get(1).getEntryType().getValue());\n    }"}
{"prompt": "Create a test that tests apply Multiple Loan Transaction Chargeback", "completion": "    @Test\n    public void applyMultipleLoanTransactionChargeback() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            final LocalDate todaysDate = Utils.getLocalDateOfTenant();\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, todaysDate);\n            log.info(\"Current Business date {}\", todaysDate);\n\n            // Client and Loan account creation\n            final Integer loanId = createAccounts(15, 1, false);\n\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            Float amount = Float.valueOf(amountVal);\n            PostLoansLoanIdTransactionsResponse loanIdTransactionsResponse = loanTransactionHelper.makeLoanRepayment(operationDate, amount,\n                    loanId);\n            assertNotNull(loanIdTransactionsResponse);\n            final Long transactionId = loanIdTransactionsResponse.getResourceId();\n\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            assertNotNull(getLoansLoanIdResponse);\n            loanTransactionHelper.validateLoanStatus(getLoansLoanIdResponse, \"loanStatusType.closed.obligations.met\");\n\n            // First round, empty array\n            reviewLoanTransactionRelations(loanId, transactionId, 0, Double.valueOf(\"0.00\"));\n\n            loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"200.00\", 0, responseSpec);\n\n            Double expectedAmount = Double.valueOf(\"200.00\");\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, expectedAmount);\n\n            loanTransactionHelper.evaluateLoanSummaryAdjustments(getLoansLoanIdResponse, expectedAmount);\n            loanTransactionHelper.printDelinquencyData(getLoansLoanIdResponse);\n            DelinquencyBucketsHelper.evaluateLoanCollectionData(getLoansLoanIdResponse, 0, Double.valueOf(\"0.00\"));\n\n            // Second round, array size equal to 1\n            reviewLoanTransactionRelations(loanId, transactionId, 1, Double.valueOf(\"0.00\"));\n\n            loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"300.00\", 1, responseSpec);\n\n            expectedAmount = Double.valueOf(\"500.00\");\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, expectedAmount);\n\n            loanTransactionHelper.evaluateLoanSummaryAdjustments(getLoansLoanIdResponse, expectedAmount);\n            DelinquencyBucketsHelper.evaluateLoanCollectionData(getLoansLoanIdResponse, 0, Double.valueOf(\"0.00\"));\n\n            // Third round, array size equal to 2\n            reviewLoanTransactionRelations(loanId, transactionId, 2, Double.valueOf(\"0.00\"));\n\n            loanTransactionHelper.applyChargebackTransaction(loanId, transactionId, \"500.00\", 0, responseSpec);\n\n            expectedAmount = Double.valueOf(\"1000.00\");\n            getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanId);\n            loanTransactionHelper.validateLoanPrincipalOustandingBalance(getLoansLoanIdResponse, expectedAmount);\n\n            loanTransactionHelper.evaluateLoanSummaryAdjustments(getLoansLoanIdResponse, expectedAmount);\n            loanTransactionHelper.printRepaymentSchedule(getLoansLoanIdResponse);\n\n            DelinquencyBucketsHelper.evaluateLoanCollectionData(getLoansLoanIdResponse, 0, Double.valueOf(\"0.00\"));\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests loan Transaction Chargeback Of Full Amount For Overpaid Loan Test", "completion": "    @Test\n    public void loanTransactionChargebackOfFullAmountForOverpaidLoanTest() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        // Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        // make Repayments\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 September 2022\").locale(\"en\")\n                        .transactionAmount(450.0));\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_2 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"6 September 2022\").locale(\"en\")\n                        .transactionAmount(450.0));\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_3 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"7 September 2022\").locale(\"en\")\n                        .transactionAmount(300.0));\n\n        GetLoansLoanIdResponse loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n\n        // verify loan is overpaid\n        assertNotNull(loanDetails);\n        assertTrue(loanDetails.getStatus().getOverpaid());\n        assertEquals(loanDetails.getTotalOverpaid(), 200.0);\n\n        // verify loan outstanding\n        assertNotNull(loanDetails.getSummary());\n        assertEquals(loanDetails.getSummary().getTotalOutstanding(), 0.0);\n\n        // verify last transaction amount distribution\n        GetLoansLoanIdTransactionsTransactionIdResponse loanTransaction = loanTransactionHelper.getLoanTransaction(loanId,\n                repaymentTransaction_3.getResourceId().intValue());\n\n        assertNotNull(loanTransaction);\n        assertEquals(loanTransaction.getAmount(), 300.0);\n        assertEquals(loanTransaction.getPrincipalPortion(), 100.0);\n\n        // chargeback for full amount on last repayment for which the amount is 300 and principal is 100 due to\n        // overpayment adjustment\n        // This verifies that validation for chargeback amount is with total amount of transaction and not principal\n        // portion.\n        PostLoansLoanIdTransactionsResponse chargebackTransactionResponse = loanTransactionHelper.chargebackLoanTransaction(\n                loanExternalIdStr, repaymentTransaction_3.getResourceId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().locale(\"en\").transactionAmount(300.0).paymentTypeId(1L));\n\n        assertNotNull(chargebackTransactionResponse);\n        GetLoansLoanIdResponse loanDetailsAfterChargeback = loanTransactionHelper.getLoanDetails((long) loanId);\n        assertNotNull(loanDetailsAfterChargeback);\n        assertTrue(loanDetailsAfterChargeback.getStatus().getActive());\n\n        // verify loan outstanding\n        assertNotNull(loanDetailsAfterChargeback.getSummary());\n        assertEquals(loanDetailsAfterChargeback.getSummary().getTotalOutstanding(), 100.0);\n\n        // verify chargeback transaction amount distribution\n        GetLoansLoanIdTransactionsTransactionIdResponse chargebackTransaction = loanTransactionHelper.getLoanTransaction(loanId,\n                chargebackTransactionResponse.getResourceId().intValue());\n\n        assertNotNull(chargebackTransaction);\n        assertEquals(chargebackTransaction.getAmount(), 300.0);\n        assertEquals(chargebackTransaction.getPrincipalPortion(), 100.0);\n\n    }"}
{"prompt": "Create a test that tests loan Transaction Reverse Replay Relation Test", "completion": "    @Test\n    public void loanTransactionReverseReplayRelationTest() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        // Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        // Add Charge\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 7);\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        // make repayment\n\n        // Set Loan transaction externalId for transaction getting reversed and replayed\n        String loanTransactionExternalIdStr = UUID.randomUUID().toString();\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"15 September 2022\").locale(\"en\")\n                        .transactionAmount(11.0).externalId(loanTransactionExternalIdStr));\n\n        // make backdated repayment for reverse replay\n        final PostLoansLoanIdTransactionsResponse backDatedRepaymentTransaction = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"10 September 2022\").locale(\"en\")\n                        .transactionAmount(5.0));\n\n        // get transaction relationship for new transaction using externalId of reversed loan transaction\n\n        Long reversedAndReplayedTransactionId = repaymentTransaction.getResourceId();\n        Long backDatedRepaymentTransactionId = backDatedRepaymentTransaction.getResourceId();\n\n        GetLoansLoanIdTransactionsTransactionIdResponse getLoansTransactionResponse = loanTransactionHelper\n                .getLoanTransactionDetails((long) loanId, loanTransactionExternalIdStr);\n        assertNotNull(getLoansTransactionResponse);\n        assertNotNull(getLoansTransactionResponse.getTransactionRelations());\n\n        // test replayed relationship\n        GetLoanTransactionRelation transactionRelation = getLoansTransactionResponse.getTransactionRelations().iterator().next();\n        assertEquals(reversedAndReplayedTransactionId, transactionRelation.getToLoanTransaction());\n        assertEquals(\"REPLAYED\", transactionRelation.getRelationType());\n    }"}
{"prompt": "Create a test that tests loan Transaction Summary Test", "completion": "    @Test\n    public void loanTransactionSummaryTest() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        // Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        // make Repayments\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"5 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_2 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"6 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_3 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"7 September 2022\").locale(\"en\")\n                        .transactionAmount(50.0));\n\n        // reverse Repayment\n        loanTransactionHelper.reverseRepayment(loanId, repaymentTransaction_3.getResourceId().intValue(), \"7 September 2022\");\n\n        // Merchant Refund\n        final PostLoansLoanIdTransactionsResponse merchantIssuedRefund_1 = loanTransactionHelper.makeMerchantIssuedRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"8 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        final PostLoansLoanIdTransactionsResponse merchantIssuedRefund_2 = loanTransactionHelper.makeMerchantIssuedRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"8 September 2022\").locale(\"en\")\n                        .transactionAmount(50.0));\n\n        // reverse Merchant Refund\n        loanTransactionHelper.reverseRepayment(loanId, merchantIssuedRefund_2.getResourceId().intValue(), \"8 September 2022\");\n\n        // Payout Refund\n        final PostLoansLoanIdTransactionsResponse payoutRefund_1 = loanTransactionHelper.makePayoutRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"9 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        final PostLoansLoanIdTransactionsResponse payoutRefund_2 = loanTransactionHelper.makePayoutRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"9 September 2022\").locale(\"en\")\n                        .transactionAmount(50.0));\n\n        // reverse Payout Refund\n        loanTransactionHelper.reverseRepayment(loanId, payoutRefund_2.getResourceId().intValue(), \"9 September 2022\");\n\n        // Goodwill Credit\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_1 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"10 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        final PostLoansLoanIdTransactionsResponse goodwillCredit_2 = loanTransactionHelper.makeGoodwillCredit((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"10 September 2022\").locale(\"en\")\n                        .transactionAmount(50.0));\n\n        // reverse Goodwill Credit\n        loanTransactionHelper.reverseRepayment(loanId, goodwillCredit_2.getResourceId().intValue(), \"10 September 2022\");\n\n        // Chargeback\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_4 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"11 September 2022\").locale(\"en\")\n                        .transactionAmount(150.0));\n\n        loanTransactionHelper.chargebackLoanTransaction(loanExternalIdStr, repaymentTransaction_4.getResourceId(),\n                new PostLoansLoanIdTransactionsTransactionIdRequest().locale(\"en\").transactionAmount(50.0).paymentTypeId(1L));\n\n        // Charge Adjustment\n\n        // Add Charge\n        Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n        LocalDate targetDate = LocalDate.of(2022, 9, 10);\n        final String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n        Integer penalty1LoanChargeId = this.loanTransactionHelper.addChargesForLoan(loanId,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\"));\n\n        PostLoansLoanIdChargesChargeIdResponse chargeAdjustmentResult = loanTransactionHelper.chargeAdjustment((long) loanId,\n                (long) penalty1LoanChargeId, new PostLoansLoanIdChargesChargeIdRequest().amount(10.0).locale(\"en\"));\n\n        // Retrieve Loan with loanId\n\n        GetLoansLoanIdResponse loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n\n        // verify transaction summary fields\n\n        GetLoansLoanIdSummary loanSummary = loanDetails.getSummary();\n\n        assertNotNull(loanSummary);\n\n        // repayment\n        assertEquals(loanSummary.getTotalRepaymentTransaction(), 350.00);\n        // repayment reversed\n        assertEquals(loanSummary.getTotalRepaymentTransactionReversed(), 50.00);\n        // merchant refund\n        assertEquals(loanSummary.getTotalMerchantRefund(), 100.00);\n        // merchant refund reversed\n        assertEquals(loanSummary.getTotalMerchantRefundReversed(), 50.00);\n        // payout refund\n        assertEquals(loanSummary.getTotalPayoutRefund(), 100.00);\n        // payout refund reversed\n        assertEquals(loanSummary.getTotalPayoutRefundReversed(), 50.00);\n        // goodwill credit\n        assertEquals(loanSummary.getTotalGoodwillCredit(), 100.00);\n        // goodwill credit reversed\n        assertEquals(loanSummary.getTotalGoodwillCreditReversed(), 50.00);\n        // charge adjustment\n        assertEquals(loanSummary.getTotalChargeAdjustment(), 10.00);\n        // charge\n        assertEquals(loanSummary.getTotalChargeback(), 50.00);\n    }"}
{"prompt": "Create a test that tests last Repayment Amount Test", "completion": "    @Test\n    public void lastRepaymentAmountTest() {\n        // Loan ExternalId\n        String loanExternalIdStr = UUID.randomUUID().toString();\n\n        // Delinquency Bucket\n        final Integer delinquencyBucketId = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec, responseSpec);\n        final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                delinquencyBucketId);\n\n        // Client and Loan account creation\n\n        final Integer clientId = clientHelper.createClient(ClientHelper.defaultClientCreationRequest()).getClientId().intValue();\n        final GetLoanProductsProductIdResponse getLoanProductsProductResponse = createLoanProduct(loanTransactionHelper,\n                delinquencyBucketId);\n        assertNotNull(getLoanProductsProductResponse);\n\n        final Integer loanId = createLoanAccount(clientId, getLoanProductsProductResponse.getId(), loanExternalIdStr);\n\n        // Merchant Refund\n        final PostLoansLoanIdTransactionsResponse merchantIssuedRefund = loanTransactionHelper.makeMerchantIssuedRefund((long) loanId,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"8 September 2022\").locale(\"en\")\n                        .transactionAmount(20.0));\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_1 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"7 September 2022\").locale(\"en\")\n                        .transactionAmount(100.0));\n\n        final PostLoansLoanIdTransactionsResponse repaymentTransaction_2 = loanTransactionHelper.makeLoanRepayment(loanExternalIdStr,\n                new PostLoansLoanIdTransactionsRequest().dateFormat(\"dd MMMM yyyy\").transactionDate(\"6 September 2022\").locale(\"en\")\n                        .transactionAmount(50.0));\n\n        // Retrieve Loan with loanId\n        GetLoansLoanIdResponse loanDetails = loanTransactionHelper.getLoanDetails((long) loanId);\n\n        assertEquals(20.0, loanDetails.getDelinquent().getLastPaymentAmount());\n        assertEquals(LocalDate.of(2022, 9, 8), loanDetails.getDelinquent().getLastPaymentDate());\n\n        assertEquals(100.0, loanDetails.getDelinquent().getLastRepaymentAmount());\n        assertEquals(LocalDate.of(2022, 9, 7), loanDetails.getDelinquent().getLastRepaymentDate());\n    }"}
{"prompt": "Create a test that tests loan Withdrawn By Applicant", "completion": "    @Test\n    public void loanWithdrawnByApplicant() {\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        this.loanTransactionHelper.withdrawLoanApplicationByClient(\"03 April 2012\", loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsNotActive(loanStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests check Client Loan WRITTEN OFF", "completion": "    @Test\n    public void checkClientLoan_WRITTEN_OFF() {\n        // CREATE CLIENT\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, DATE_OF_JOINING);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        // CREATE LOAN PRODUCT\n        final Integer loanProductID = createLoanProduct();\n        // APPLY FOR LOAN\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"28 September 2010\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n\n        // DISBURSE\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(DISBURSEMENT_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LOG.info(\"DISBURSE {}\", loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // MAKE REPAYMENTS\n        final float repayment_with_interest = 680.0f;\n\n        this.loanTransactionHelper.verifyRepaymentScheduleEntryFor(1, 4000.0F, loanID);\n        this.loanTransactionHelper.makeRepayment(\"01 January 2011\", repayment_with_interest, loanID);\n\n        HashMap toLoanSummaryAfter = this.loanTransactionHelper.getLoanSummary(requestSpec, responseSpec, loanID);\n        Assertions.assertTrue(Float.valueOf(\"500.0\").compareTo(Float.valueOf(String.valueOf(toLoanSummaryAfter.get(\"principalPaid\")))) == 0,\n                \"Checking for Principal paid \");\n        Assertions.assertTrue(Float.valueOf(\"180.0\").compareTo(Float.valueOf(String.valueOf(toLoanSummaryAfter.get(\"interestPaid\")))) == 0,\n                \"Checking for interestPaid paid \");\n        Assertions.assertTrue(\n                Float.valueOf(\"680.0\").compareTo(Float.valueOf(String.valueOf(toLoanSummaryAfter.get(\"totalRepayment\")))) == 0,\n                \"Checking for total paid \");\n\n        // WRITE OFF LOAN AND CHECK ACCOUNT IS CLOSED\n        LoanStatusChecker.verifyLoanAccountIsClosed(this.loanTransactionHelper.writeOffLoan(\"01 January 2011\", loanID));\n        toLoanSummaryAfter = this.loanTransactionHelper.getLoanSummary(requestSpec, responseSpec, loanID);\n        Assertions.assertTrue(\n                Float.valueOf(\"4000.0\").compareTo(Float.valueOf(String.valueOf(toLoanSummaryAfter.get(\"principalWrittenOff\")))) == 0,\n                \"Checking for Principal written off \");\n        Assertions.assertTrue(\n                Float.valueOf(\"1440.0\").compareTo(Float.valueOf(String.valueOf(toLoanSummaryAfter.get(\"interestWrittenOff\")))) == 0,\n                \"Checking for interestPaid written off \");\n        Assertions.assertTrue(\n                Float.valueOf(\"5440.0\").compareTo(Float.valueOf(String.valueOf(toLoanSummaryAfter.get(\"totalWrittenOff\")))) == 0,\n                \"Checking for total written off \");\n\n    }"}
{"prompt": "Create a test that tests test Makercheker Inbox List", "completion": "    @Test\n    public void testMakerchekerInboxList() {\n        // given\n        // when\n        final ArrayList<GetMakerCheckerResponse> makerCheckerList = this.makercheckersHelper.getMakerCheckerList();\n\n        assertNotNull(makerCheckerList);\n    }"}
{"prompt": "Create a test that tests create Loan Entity WITH DAY BETWEEN DISB DATE AND REPAY START DATE GREATER THAN MIN DAY CRITERIA", "completion": "    @Test\n    public void createLoanEntity_WITH_DAY_BETWEEN_DISB_DATE_AND_REPAY_START_DATE_GREATER_THAN_MIN_DAY_CRITERIA() {\n\n        this.requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n        this.requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n        this.responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        // create all required entities\n        this.createRequiredEntities();\n\n        final String disbursalDate = \"04 September 2014\";\n        final String firstRepaymentDate = \"11 September 2014\";\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                this.clientId.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final String loanApplicationJSON = new LoanApplicationTestBuilder().withPrincipal(loanPrincipalAmount)\n                .withLoanTermFrequency(numberOfRepayments).withLoanTermFrequencyAsWeeks().withNumberOfRepayments(numberOfRepayments)\n                .withRepaymentEveryAfter(\"1\").withRepaymentFrequencyTypeAsMonths().withAmortizationTypeAsEqualInstallments()\n                .withInterestCalculationPeriodTypeAsDays().withInterestRatePerPeriod(interestRatePerPeriod)\n                .withRepaymentFrequencyTypeAsWeeks().withSubmittedOnDate(disbursalDate).withExpectedDisbursementDate(disbursalDate)\n                .withPrincipalGrace(\"2\").withInterestGrace(\"2\").withFirstRepaymentDate(firstRepaymentDate).withCollaterals(collaterals)\n                .build(this.clientId.toString(), this.loanProductId.toString(), null);\n\n        this.loanId = this.loanTransactionHelper.getLoanId(loanApplicationJSON);\n\n        // Test for loan account is created\n        Assertions.assertNotNull(this.loanId);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        // Test for loan account is created, can be approved\n        this.loanTransactionHelper.approveLoan(disbursalDate, this.loanId);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        // Test for loan account approved can be disbursed\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, this.loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(disbursalDate, this.loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, this.loanId);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests create Loan Entity WITH DAY BETWEEN DISB DATE AND REPAY START DATE LESS THAN MIN DAY CRITERIA", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void createLoanEntity_WITH_DAY_BETWEEN_DISB_DATE_AND_REPAY_START_DATE_LESS_THAN_MIN_DAY_CRITERIA() {\n\n        this.requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n        this.requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n        this.responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n        this.responseSpecForStatusCode403 = new ResponseSpecBuilder().expectStatusCode(403).build();\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n        // create all required entities\n        this.createRequiredEntities();\n\n        // loanTransactionHelper is reassigned to accept 403 status code from\n        // server\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpecForStatusCode403);\n\n        final String disbursalDate = \"04 September 2014\";\n        final String firstRepaymentDate = \"05 September 2014\";\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                this.clientId.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final String loanApplicationJSON = new LoanApplicationTestBuilder().withPrincipal(loanPrincipalAmount)\n                .withLoanTermFrequency(numberOfRepayments).withLoanTermFrequencyAsWeeks().withNumberOfRepayments(numberOfRepayments)\n                .withRepaymentEveryAfter(\"1\").withRepaymentFrequencyTypeAsMonths().withAmortizationTypeAsEqualInstallments()\n                .withInterestCalculationPeriodTypeAsDays().withInterestRatePerPeriod(interestRatePerPeriod)\n                .withRepaymentFrequencyTypeAsWeeks().withSubmittedOnDate(disbursalDate).withExpectedDisbursementDate(disbursalDate)\n                .withPrincipalGrace(\"2\").withInterestGrace(\"2\").withFirstRepaymentDate(firstRepaymentDate).withCollaterals(collaterals)\n                .build(this.clientId.toString(), this.loanProductId.toString(), null);\n\n        List<HashMap> error = (List<HashMap>) this.loanTransactionHelper.createLoanAccount(loanApplicationJSON,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.loan.days.between.first.repayment.and.disbursal.are.less.than.minimum.allowed\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    }"}
{"prompt": "Create a test that tests test Create Client Note", "completion": "    @Test\n    public void testCreateClientNote() {\n        String noteText = \"this is a test note\";\n\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createClientNote(requestSpec, responseSpec, clientId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getClientNote(requestSpec, responseSpec, clientId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n    }"}
{"prompt": "Create a test that tests test Update Client Note", "completion": "    @Test\n    public void testUpdateClientNote() {\n        String noteText = \"this is a test note\";\n\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createClientNote(requestSpec, responseSpec, clientId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getClientNote(requestSpec, responseSpec, clientId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        String updatedNoteText = \"this is an updated test note\";\n\n        String updateRequest = \"{\\\"note\\\": \\\"\" + updatedNoteText + \"\\\"}\";\n        NotesHelper.updateClientNote(requestSpec, responseSpec, clientId, noteId, updateRequest);\n\n        receivedNoteText = NotesHelper.getClientNote(requestSpec, responseSpec, clientId, noteId);\n        Assertions.assertEquals(updatedNoteText, receivedNoteText);\n    }"}
{"prompt": "Create a test that tests test Delete Client Note", "completion": "    @Test\n    public void testDeleteClientNote() {\n        String noteText = \"this is a test note\";\n\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createClientNote(requestSpec, responseSpec, clientId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getClientNote(requestSpec, responseSpec, clientId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        NotesHelper.deleteClientNote(requestSpec, responseSpec, clientId, noteId);\n\n        NotesHelper.getClientNote(requestSpec, responseSpec404, clientId, noteId);\n    }"}
{"prompt": "Create a test that tests test Create Group Note", "completion": "    @Test\n    public void testCreateGroupNote() {\n        String noteText = \"this is a test group note\";\n\n        Integer groupId = GroupHelper.createGroup(requestSpec, responseSpec);\n        Assertions.assertNotNull(groupId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createGroupNote(requestSpec, responseSpec, groupId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getGroupNote(requestSpec, responseSpec, groupId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n    }"}
{"prompt": "Create a test that tests test Update Group Note", "completion": "    @Test\n    public void testUpdateGroupNote() {\n        String noteText = \"this is a test group note\";\n\n        Integer groupId = GroupHelper.createGroup(requestSpec, responseSpec);\n        Assertions.assertNotNull(groupId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createGroupNote(requestSpec, responseSpec, groupId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getGroupNote(requestSpec, responseSpec, groupId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        String updatedNoteText = \"this is an updated test group note\";\n\n        String updateRequest = \"{\\\"note\\\": \\\"\" + updatedNoteText + \"\\\"}\";\n        NotesHelper.updateGroupNote(requestSpec, responseSpec, groupId, noteId, updateRequest);\n\n        receivedNoteText = NotesHelper.getGroupNote(requestSpec, responseSpec, groupId, noteId);\n        Assertions.assertEquals(updatedNoteText, receivedNoteText);\n    }"}
{"prompt": "Create a test that tests test Delete Group Note", "completion": "    @Test\n    public void testDeleteGroupNote() {\n        String noteText = \"this is a test group note\";\n\n        Integer groupId = GroupHelper.createGroup(requestSpec, responseSpec);\n        Assertions.assertNotNull(groupId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createGroupNote(requestSpec, responseSpec, groupId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getGroupNote(requestSpec, responseSpec, groupId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        NotesHelper.deleteGroupNote(requestSpec, responseSpec, groupId, noteId);\n\n        NotesHelper.getGroupNote(requestSpec, responseSpec404, groupId, noteId);\n    }"}
{"prompt": "Create a test that tests test Create Loan Note", "completion": "    @Test\n    public void testCreateLoanNote() {\n        String noteText = \"this is a test loan note\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanId = applyForLoanApplication(clientID, loanProductID);\n        Assertions.assertNotNull(loanId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createLoanNote(requestSpec, responseSpec, loanId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getLoanNote(requestSpec, responseSpec, loanId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n    }"}
{"prompt": "Create a test that tests test Create Savings Note", "completion": "    @Test\n    public void testCreateSavingsNote() {\n        final String noteText = \"this is a test Savings note\";\n        final String testDate = \"01 January 2012\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, testDate);\n        // Savings Account\n        final String savingsProductJSON = this.savingsProductHelper.withInterestCompoundingPeriodTypeAsDaily()\n                .withInterestPostingPeriodTypeAsDaily().withInterestCalculationPeriodTypeAsDailyBalance().build();\n        final Integer savingsProductId = SavingsProductHelper.createSavingsProduct(savingsProductJSON, requestSpec, responseSpec);\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplicationOnDate(clientID, savingsProductId, \"INDIVIDUAL\",\n                testDate);\n        Assertions.assertNotNull(savingsId);\n\n        // Notes\n        final String payload = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        final PostResourceTypeResourceIdNotesResponse postNoteResponse = NotesHelper.createSavingsNote(requestSpec, responseSpec, savingsId,\n                payload);\n        Assertions.assertNotNull(postNoteResponse);\n        Assertions.assertNotNull(postNoteResponse.getResourceId());\n\n        final GetResourceTypeResourceIdNotesNoteIdResponse getNoteResponse = NotesHelper.getSavingsNote(requestSpec, responseSpec,\n                savingsId, postNoteResponse.getResourceId());\n        Assertions.assertNotNull(getNoteResponse);\n        Assertions.assertEquals(noteText, getNoteResponse.getNote());\n    }"}
{"prompt": "Create a test that tests test Update Loan Note", "completion": "    @Test\n    public void testUpdateLoanNote() {\n        String noteText = \"this is a test loan note\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanId = applyForLoanApplication(clientID, loanProductID);\n        Assertions.assertNotNull(loanId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createLoanNote(requestSpec, responseSpec, loanId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getLoanNote(requestSpec, responseSpec, loanId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        String updatedNoteText = \"this is an updated test loan note\";\n\n        String updateRequest = \"{\\\"note\\\": \\\"\" + updatedNoteText + \"\\\"}\";\n        NotesHelper.updateLoanNote(requestSpec, responseSpec, loanId, noteId, updateRequest);\n\n        receivedNoteText = NotesHelper.getLoanNote(requestSpec, responseSpec, loanId, noteId);\n        Assertions.assertEquals(updatedNoteText, receivedNoteText);\n    }"}
{"prompt": "Create a test that tests test Delete Loan Note", "completion": "    @Test\n    public void testDeleteLoanNote() {\n        String noteText = \"this is a test loan note\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanId = applyForLoanApplication(clientID, loanProductID);\n        Assertions.assertNotNull(loanId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createLoanNote(requestSpec, responseSpec, loanId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getLoanNote(requestSpec, responseSpec, loanId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        NotesHelper.deleteLoanNote(requestSpec, responseSpec, loanId, noteId);\n\n        NotesHelper.getLoanNote(requestSpec, responseSpec404, loanId, noteId);\n    }"}
{"prompt": "Create a test that tests test Create Loan Transaction Note", "completion": "    @Test\n    public void testCreateLoanTransactionNote() {\n        String noteText = \"this is a test loan transaction note\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanId = applyForLoanApplication(clientID, loanProductID);\n        Assertions.assertNotNull(loanId);\n\n        this.loanTransactionHelper.approveLoan(\"02 April 2012\", loanId);\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 April 2012\", loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        HashMap repayment = this.loanTransactionHelper.makeRepayment(\"02 April 2012\", 100.0f, loanId);\n        Integer loanTransactionId = (Integer) repayment.get(\"resourceId\");\n        Assertions.assertNotNull(loanTransactionId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n    }"}
{"prompt": "Create a test that tests test Update Loan Transaction Note", "completion": "    @Test\n    public void testUpdateLoanTransactionNote() {\n        String noteText = \"this is a test loan transaction note\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanId = applyForLoanApplication(clientID, loanProductID);\n        Assertions.assertNotNull(loanId);\n\n        this.loanTransactionHelper.approveLoan(\"02 April 2012\", loanId);\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 April 2012\", loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        HashMap repayment = this.loanTransactionHelper.makeRepayment(\"02 April 2012\", 100.0f, loanId);\n        Integer loanTransactionId = (Integer) repayment.get(\"resourceId\");\n        Assertions.assertNotNull(loanTransactionId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        String updatedNoteText = \"this is an updated test loan transaction note\";\n\n        String updateRequest = \"{\\\"note\\\": \\\"\" + updatedNoteText + \"\\\"}\";\n        NotesHelper.updateLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, noteId, updateRequest);\n\n        receivedNoteText = NotesHelper.getLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, noteId);\n        Assertions.assertEquals(updatedNoteText, receivedNoteText);\n\n    }"}
{"prompt": "Create a test that tests test Delete Loan Transaction Note", "completion": "    @Test\n    public void testDeleteLoanTransactionNote() {\n        String noteText = \"this is a test loan transaction note\";\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 January 2012\");\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        final Integer loanId = applyForLoanApplication(clientID, loanProductID);\n        Assertions.assertNotNull(loanId);\n\n        this.loanTransactionHelper.approveLoan(\"02 April 2012\", loanId);\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanId);\n        this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 April 2012\", loanId,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        HashMap repayment = this.loanTransactionHelper.makeRepayment(\"02 April 2012\", 100.0f, loanId);\n        Integer loanTransactionId = (Integer) repayment.get(\"resourceId\");\n        Assertions.assertNotNull(loanTransactionId);\n\n        String request = \"{\\\"note\\\": \\\"\" + noteText + \"\\\"}\";\n        Integer noteId = NotesHelper.createLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, request);\n        Assertions.assertNotNull(noteId);\n\n        String receivedNoteText = NotesHelper.getLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, noteId);\n        Assertions.assertEquals(noteText, receivedNoteText);\n\n        NotesHelper.deleteLoanTransactionNote(requestSpec, responseSpec, loanTransactionId, noteId);\n\n        NotesHelper.getLoanTransactionNote(requestSpec, responseSpec404, loanTransactionId, noteId);\n    }"}
{"prompt": "Create a test that tests test Notification Retrieval Works When No Notifications Are Available", "completion": "    @Test\n    public void testNotificationRetrievalWorksWhenNoNotificationsAreAvailable() {\n        // given\n        // when\n        GetNotificationsResponse response = NotificationHelper.getNotifications(requestSpec, responseSpec);\n        // then\n        Assertions.assertNotNull(response);\n    }"}
{"prompt": "Create a test that tests test Notification Retrieval Works When One Notification Is Available", "completion": "    @Test\n    public void testNotificationRetrievalWorksWhenOneNotificationIsAvailable() {\n        // given\n        PostClientsRequest clientRequest = ClientHelper.defaultClientCreationRequest();\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec, clientRequest);\n        Assertions.assertNotNull(clientId);\n\n        // when\n        NotificationHelper.waitUntilNotificationsAreAvailable(newUserRequestSpec, newUserResponseSpec);\n        GetNotificationsResponse response = NotificationHelper.getNotifications(newUserRequestSpec, newUserResponseSpec);\n        // then\n        Assertions.assertNotNull(response);\n        List<GetNotification> pageItems = response.getPageItems();\n        Assertions.assertEquals(1, pageItems.size());\n        GetNotification firstNotification = pageItems.get(0);\n        Assertions.assertEquals(SUPER_USER_ID, firstNotification.getActorId());\n        Assertions.assertEquals(false, firstNotification.getIsRead());\n        Assertions.assertEquals(CREATED_ACTION_TYPE, firstNotification.getAction());\n        Assertions.assertEquals(clientId.longValue(), firstNotification.getObjectId());\n        Assertions.assertEquals(CLIENT_OBJECT_TYPE, firstNotification.getObjectType());\n    }"}
{"prompt": "Create a test that tests test Office Modification", "completion": "    @Test\n    public void testOfficeModification() {\n        OfficeHelper oh = new OfficeHelper(requestSpec, responseSpec);\n        int officeId = oh.createOffice(\"01 July 2007\");\n        String name = Utils.uniqueRandomStringGenerator(\"New_Office_\", 4);\n        String date = \"02 July 2007\";\n        String[] dateArr = { \"2007\", \"7\", \"2\" };\n\n        oh.updateOffice(officeId, name, date);\n        OfficeDomain newOffice = oh.retrieveOfficeByID(officeId);\n\n        Assertions.assertTrue(name.equals(newOffice.getName()));\n        Assertions.assertArrayEquals(dateArr, newOffice.getOpeningDate());\n    }"}
{"prompt": "Create a test that tests update Password Preferences", "completion": "    @Test\n    public void updatePasswordPreferences() {\n        String validationPolicyId = \"2\";\n        PasswordPreferencesHelper.updatePasswordPreferences(requestSpec, responseSpec, validationPolicyId);\n        this.validateIfThePasswordIsUpdated(validationPolicyId);\n    }"}
{"prompt": "Create a test that tests update With Invalid Policy Id", "completion": "    @Test\n    public void updateWithInvalidPolicyId() {\n        String invalidValidationPolicyId = \"2000\";\n        final List<HashMap> error = (List) PasswordPreferencesHelper.updateWithInvalidValidationPolicyId(requestSpec, generalResponseSpec,\n                invalidValidationPolicyId, CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.password.validation.policy.id.invalid\", error.get(0).get(\"userMessageGlobalisationCode\"),\n                \"Password Validation Policy with identifier 2000 does not exist\");\n    }"}
{"prompt": "Create a test that tests test Payment Type", "completion": "    @Test\n    public void testPaymentType() {\n        String name = PaymentTypeHelper.randomNameGenerator(\"P_T\", 5);\n        String description = PaymentTypeHelper.randomNameGenerator(\"PT_Desc\", 15);\n        Boolean isCashPayment = true;\n        Integer position = 1;\n\n        Integer paymentTypeId = PaymentTypeHelper.createPaymentType(requestSpec, responseSpec, name, description, isCashPayment, position);\n        Assertions.assertNotNull(paymentTypeId);\n        PaymentTypeHelper.verifyPaymentTypeCreatedOnServer(requestSpec, responseSpec, paymentTypeId);\n        PaymentTypeDomain paymentTypeResponse = PaymentTypeHelper.retrieveById(requestSpec, responseSpec, paymentTypeId);\n        Assertions.assertEquals(name, paymentTypeResponse.getName());\n        Assertions.assertEquals(description, paymentTypeResponse.getDescription());\n        Assertions.assertEquals(isCashPayment, paymentTypeResponse.getIsCashPayment());\n        Assertions.assertEquals(position, paymentTypeResponse.getPosition());\n\n        // Update Payment Type\n        String newName = PaymentTypeHelper.randomNameGenerator(\"P_TU\", 5);\n        String newDescription = PaymentTypeHelper.randomNameGenerator(\"PTU_Desc\", 15);\n        Boolean isCashPaymentUpdatedValue = false;\n        Integer newPosition = 2;\n\n        HashMap request = new HashMap();\n        request.put(\"name\", newName);\n        request.put(\"description\", newDescription);\n        request.put(\"isCashPayment\", isCashPaymentUpdatedValue);\n        request.put(\"position\", newPosition);\n        PaymentTypeHelper.updatePaymentType(paymentTypeId, request, requestSpec, responseSpec);\n        PaymentTypeDomain paymentTypeUpdatedResponse = PaymentTypeHelper.retrieveById(requestSpec, responseSpec, paymentTypeId);\n        Assertions.assertEquals(newName, paymentTypeUpdatedResponse.getName());\n        Assertions.assertEquals(newDescription, paymentTypeUpdatedResponse.getDescription());\n        Assertions.assertEquals(isCashPaymentUpdatedValue, paymentTypeUpdatedResponse.getIsCashPayment());\n        Assertions.assertEquals(newPosition, paymentTypeUpdatedResponse.getPosition());\n\n        // Delete\n        Integer deletedPaymentTypeId = PaymentTypeHelper.deletePaymentType(paymentTypeId, requestSpec, responseSpec);\n        Assertions.assertEquals(paymentTypeId, deletedPaymentTypeId);\n        ResponseSpecification responseSpecification = new ResponseSpecBuilder().expectStatusCode(404).build();\n        PaymentTypeHelper.retrieveById(requestSpec, responseSpecification, paymentTypeId);\n\n    }"}
{"prompt": "Create a test that tests get Product Mix List", "completion": "    @Test\n    public void getProductMixList() {\n        final ArrayList productMixList = this.productMixHelper.getProductsMixList();\n        Assertions.assertNotNull(productMixList);\n\n        final HashMap productMixTemplate = (HashMap) this.productMixHelper.getProductMixTemplate();\n        Assertions.assertNotNull(productMixTemplate);\n    }"}
{"prompt": "Create a test that tests test Rates For Loans", "completion": "    @Test\n    public void testRatesForLoans() {\n\n        // Retrieving all Rates\n        ArrayList<HashMap> allRatesData = RatesHelper.getRates(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(allRatesData);\n\n        // Testing Creation and Update of Loan Rate\n        final Integer loanRateId = RatesHelper.createRates(this.requestSpec, this.responseSpec, RatesHelper.getLoanRateJSON());\n        Assertions.assertNotNull(loanRateId);\n\n        // Update Rate percentage\n        HashMap changes = RatesHelper.updateRates(this.requestSpec, this.responseSpec, loanRateId, RatesHelper.getModifyRateJSON());\n\n        HashMap rateDataAfterChanges = RatesHelper.getRateById(this.requestSpec, this.responseSpec, loanRateId);\n        Assertions.assertEquals(rateDataAfterChanges.get(\"percentage\"), changes.get(\"percentage\"), \"Verifying Rate after modification\");\n\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Premature Closure Type Withdrawal", "completion": "    @Test\n    public void testRecurringDepositAccountWithPrematureClosureTypeWithdrawal() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        /***\n         * Create GL Accounts for product account mapping\n         */\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        final String CLOSED_ON_DATE = dateFormat.format(Calendar.getInstance().getTime());\n\n        /***\n         * Create client for applying Deposit account\n         */\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        /***\n         * Create RD product with CashBased accounting enabled\n         */\n        final String accountingRule = CASH_BASED;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount,\n                liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        /***\n         * Apply for RD account with created product and verify status\n         */\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        /***\n         * Approve the RD account and verify whether account is approved\n         */\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        /***\n         * Activate the RD Account and verify whether account is activated\n         */\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n\n        /***\n         * Perform Deposit transaction and verify journal entries are posted for the transaction\n         */\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                depositAmount, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(depositTransactionId);\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, expectedFirstDepositOnDate,\n                new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, expectedFirstDepositOnDate,\n                new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT));\n\n        /***\n         * Update interest earned field for RD account\n         */\n        recurringDepositAccountId = this.recurringDepositAccountHelper.calculateInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        /***\n         * Post interest and verify journal entries\n         */\n        Integer transactionIdForPostInterest = this.recurringDepositAccountHelper\n                .postInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        HashMap accountSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n        /***\n         * Calculate expected premature closure amount\n         */\n        HashMap recurringDepositPrematureData = this.recurringDepositAccountHelper\n                .calculatePrematureAmountForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE);\n\n        /***\n         * Preclose the RD account verify whether account is preClosed\n         */\n        Integer prematureClosureTransactionId = (Integer) this.recurringDepositAccountHelper.prematureCloseForRecurringDeposit(\n                recurringDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsPrematureClosed(recurringDepositAccountStatusHashMap);\n\n        /***\n         * Verify journal entry transactions for preclosure transaction\n         */\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n        Float maturityAmount = Float.valueOf(recurringDepositAccountData.get(\"maturityAmount\").toString());\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.CREDIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.DEBIT));\n\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Premature Closure Type Transfer To Savings", "completion": "    @Test\n    public void testRecurringDepositAccountWithPrematureClosureTypeTransferToSavings() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        /***\n         * Create GL Accounts for product account mapping\n         */\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        final String CLOSED_ON_DATE = dateFormat.format(Calendar.getInstance().getTime());\n\n        /***\n         * Create client for applying Deposit and Savings accounts\n         */\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        /***\n         * Create Savings product with CashBased accounting enabled\n         */\n        final String accountingRule = CASH_BASED;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE, accountingRule,\n                assetAccount, liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(savingsProductID);\n\n        /***\n         * Create Savings account and verify status is pending\n         */\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientId, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        /***\n         * Approve the savings account and verify account is approved\n         */\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        /***\n         * Activate the savings account and verify account is activated\n         */\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        /***\n         * Create RD product with CashBased accounting enabled\n         */\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount,\n                liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        /***\n         * Apply for RD account with created product and verify status\n         */\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        /***\n         * Approve the RD account and verify whether account is approved\n         */\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        /***\n         * Activate the RD Account and verify whether account is activated\n         */\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n\n        /***\n         * Perform Deposit transaction and verify journal entries are posted for the transaction\n         */\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                depositAmount, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(depositTransactionId);\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, expectedFirstDepositOnDate,\n                new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, expectedFirstDepositOnDate,\n                new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT));\n\n        /***\n         * Update interest earned field for RD account\n         */\n        recurringDepositAccountId = this.recurringDepositAccountHelper.calculateInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        /***\n         * Post interest and verify journal entries\n         */\n        Integer transactionIdForPostInterest = this.recurringDepositAccountHelper\n                .postInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        HashMap accountSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n        /***\n         * Get saving account balance before preClosing RD account\n         */\n        HashMap savingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balanceBefore = (Float) savingsSummaryBefore.get(\"accountBalance\");\n\n        HashMap recurringDepositPrematureData = this.recurringDepositAccountHelper\n                .calculatePrematureAmountForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE);\n\n        /***\n         * Retrieve mapped financial account for liability transfer\n         */\n        Account financialAccount = getMappedLiabilityFinancialAccount();\n\n        /***\n         * Preclose the RD account verify whether account is preClosed\n         */\n        Integer prematureClosureTransactionId = (Integer) this.recurringDepositAccountHelper.prematureCloseForRecurringDeposit(\n                recurringDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_TRANSFER_TO_SAVINGS, savingsId,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsPrematureClosed(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n        Float maturityAmount = Float.valueOf(recurringDepositAccountData.get(\"maturityAmount\").toString());\n        /***\n         * Verify journal entry transactions for preclosure transaction As this transaction is an account transfer you\n         * should get financial account mapping details and verify amounts\n         */\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.DEBIT));\n\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(financialAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.CREDIT));\n        /***\n         * Verify rd account maturity amount and savings account balance\n         */\n        HashMap recurringDepositData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n        Float prematurityAmount = (Float) recurringDepositData.get(\"maturityAmount\");\n\n        HashMap savingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Float balanceAfter = (Float) savingsSummaryAfter.get(\"accountBalance\");\n        Float expectedSavingsBalance = balanceBefore + prematurityAmount;\n\n        Assertions.assertTrue(Math.abs(expectedSavingsBalance - balanceAfter) < THRESHOLD,\n                \"Verifying Savings Account Balance after Premature Closure\");\n\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Premature Closure Type Transfer To Savings WITH HOLD TAX", "completion": "    @Test\n    public void testRecurringDepositAccountWithPrematureClosureTypeTransferToSavings_WITH_HOLD_TAX() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        /***\n         * Create GL Accounts for product account mapping\n         */\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n        final Account liabilityAccountForTax = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        final String CLOSED_ON_DATE = dateFormat.format(Calendar.getInstance().getTime());\n\n        /***\n         * Create client for applying Deposit and Savings accounts\n         */\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        /***\n         * Create Savings product with CashBased accounting enabled\n         */\n        final String accountingRule = CASH_BASED;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE, accountingRule,\n                assetAccount, liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(savingsProductID);\n\n        /***\n         * Create Savings account and verify status is pending\n         */\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientId, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        /***\n         * Approve the savings account and verify account is approved\n         */\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        /***\n         * Activate the savings account and verify account is activated\n         */\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        /***\n         * Create RD product with CashBased accounting enabled\n         */\n        final Integer taxGroupId = createTaxGroup(\"10\", liabilityAccountForTax);\n        Integer recurringDepositProductId = createRecurringDepositProductWithWithHoldTax(VALID_FROM, VALID_TO, String.valueOf(taxGroupId),\n                accountingRule, assetAccount, liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        /***\n         * Apply for RD account with created product and verify status\n         */\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        /***\n         * Approve the RD account and verify whether account is approved\n         */\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        /***\n         * Activate the RD Account and verify whether account is activated\n         */\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n\n        /***\n         * Perform Deposit transaction and verify journal entries are posted for the transaction\n         */\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                depositAmount, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(depositTransactionId);\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, expectedFirstDepositOnDate,\n                new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, expectedFirstDepositOnDate,\n                new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT));\n\n        /***\n         * Update interest earned field for RD account\n         */\n        recurringDepositAccountId = this.recurringDepositAccountHelper.calculateInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        /***\n         * Post interest and verify journal entries\n         */\n        Integer transactionIdForPostInterest = this.recurringDepositAccountHelper\n                .postInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        HashMap accountSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n        Assertions.assertNull(accountSummary.get(\"totalWithholdTax\"));\n\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n        /***\n         * Get saving account balance before preClosing RD account\n         */\n        HashMap savingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balanceBefore = (Float) savingsSummaryBefore.get(\"accountBalance\");\n\n        HashMap recurringDepositPrematureData = this.recurringDepositAccountHelper\n                .calculatePrematureAmountForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE);\n\n        /***\n         * Retrieve mapped financial account for liability transfer\n         */\n        Account financialAccount = getMappedLiabilityFinancialAccount();\n\n        /***\n         * Preclose the RD account verify whether account is preClosed\n         */\n        Integer prematureClosureTransactionId = (Integer) this.recurringDepositAccountHelper.prematureCloseForRecurringDeposit(\n                recurringDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_TRANSFER_TO_SAVINGS, savingsId,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsPrematureClosed(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n        Float maturityAmount = Float.valueOf(recurringDepositAccountData.get(\"maturityAmount\").toString());\n        /***\n         * Verify journal entry transactions for preclosure transaction As this transaction is an account transfer you\n         * should get financial account mapping details and verify amounts\n         */\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.CREDIT),\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.DEBIT));\n\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(financialAccount, CLOSED_ON_DATE,\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.DEBIT),\n                new JournalEntry(maturityAmount, JournalEntry.TransactionType.CREDIT));\n        /***\n         * Verify rd account maturity amount and savings account balance\n         */\n        HashMap recurringDepositData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n        Float prematurityAmount = (Float) recurringDepositData.get(\"maturityAmount\");\n        HashMap summary = (HashMap) recurringDepositData.get(\"summary\");\n        Assertions.assertNotNull(summary.get(\"totalWithholdTax\"));\n        Float withHoldTax = (Float) summary.get(\"totalWithholdTax\");\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccountForTax, CLOSED_ON_DATE,\n                new JournalEntry(withHoldTax, JournalEntry.TransactionType.CREDIT));\n\n        HashMap savingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Float balanceAfter = (Float) savingsSummaryAfter.get(\"accountBalance\");\n        Float expectedSavingsBalance = balanceBefore + prematurityAmount;\n\n        Assertions.assertTrue(Math.abs(expectedSavingsBalance - balanceAfter) < THRESHOLD,\n                \"Verifying Savings Account Balance after Premature Closure\");\n\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Closure Type Transfer To Savings WITH HOLD TAX", "completion": "    @Test\n    @Disabled // TODO FINERACT-1248\n    public void testRecurringDepositAccountWithClosureTypeTransferToSavings_WITH_HOLD_TAX() throws InterruptedException {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        /***\n         * Create GL Accounts for product account mapping\n         */\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n        final Account liabilityAccountForTax = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -20);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -20);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        Calendar closedOn = Calendar.getInstance();\n        closedOn.add(Calendar.MONTH, -6);\n        final String CLOSED_ON_DATE = dateFormat.format(closedOn.getTime());\n\n        /***\n         * Create client for applying Deposit and Savings accounts\n         */\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        /***\n         * Create Savings product with CashBased accounting enabled\n         */\n        final String accountingRule = CASH_BASED;\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE, accountingRule,\n                assetAccount, liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(savingsProductID);\n\n        /***\n         * Create Savings account and verify status is pending\n         */\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientId, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(this.requestSpec, this.responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        /***\n         * Approve the savings account and verify account is approved\n         */\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        /***\n         * Activate the savings account and verify account is activated\n         */\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        /***\n         * Create RD product with CashBased accounting enabled\n         */\n        final Integer taxGroupId = createTaxGroup(\"10\", liabilityAccountForTax);\n        Integer recurringDepositProductId = createRecurringDepositProductWithWithHoldTax(VALID_FROM, VALID_TO, String.valueOf(taxGroupId),\n                accountingRule, assetAccount, liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        /***\n         * Apply for RD account with created product and verify status\n         */\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        /***\n         * Approve the RD account and verify whether account is approved\n         */\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        /***\n         * Activate the RD Account and verify whether account is activated\n         */\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n\n        /***\n         * Perform Deposit transaction and verify journal entries are posted for the transaction\n         */\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -20);\n\n        for (int i = 0; i < 14; i++) {\n            Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                    depositAmount, dateFormat.format(todaysDate.getTime()));\n            Assertions.assertNotNull(depositTransactionId);\n\n            this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, dateFormat.format(todaysDate.getTime()),\n                    new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT));\n            this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, dateFormat.format(todaysDate.getTime()),\n                    new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT));\n            todaysDate.add(Calendar.MONTH, 1);\n        }\n\n        /***\n         * FD account verify whether account is matured\n         */\n\n        SchedulerJobHelper schedulerJobHelper = new SchedulerJobHelper(requestSpec);\n        String JobName = \"Update Deposit Accounts Maturity details\";\n        schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        HashMap accountDetails = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        HashMap summary = (HashMap) accountDetails.get(\"summary\");\n        Assertions.assertNotNull(summary.get(\"totalWithholdTax\"));\n        Float withHoldTax = (Float) summary.get(\"totalWithholdTax\");\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccountForTax, CLOSED_ON_DATE,\n                new JournalEntry(withHoldTax, JournalEntry.TransactionType.CREDIT));\n\n        recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsMatured(recurringDepositAccountStatusHashMap);\n\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Premature Closure Type Reinvest", "completion": "    @Test\n    public void testRecurringDepositAccountWithPrematureClosureTypeReinvest() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        RecurringDepositAccountHelper recurringDepositAccountHelperValidationError = new RecurringDepositAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n\n        /***\n         * Create GL Accounts for product account mapping\n         */\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer numberOfDaysLeft = daysInMonth - currentDate + 1;\n        todaysDate.add(Calendar.DATE, numberOfDaysLeft);\n        final String INTEREST_POSTED_DATE = dateFormat.format(todaysDate.getTime());\n        final String CLOSED_ON_DATE = dateFormat.format(Calendar.getInstance().getTime());\n\n        /***\n         * Create client for applying Deposit account\n         */\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        /***\n         * Create RD product with CashBased accounting enabled\n         */\n        final String accountingRule = CASH_BASED;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount,\n                liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        ArrayList<HashMap> allRecurringDepositProductsData = RecurringDepositProductHelper\n                .retrieveAllRecurringDepositProducts(this.requestSpec, this.responseSpec);\n        HashMap recurringDepositProductData = RecurringDepositProductHelper.retrieveRecurringDepositProductById(this.requestSpec,\n                this.responseSpec, recurringDepositProductId.toString());\n\n        /***\n         * Apply for RD account with created product and verify status\n         */\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        /***\n         * Approve the RD account and verify whether account is approved\n         */\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        /***\n         * Activate the RD Account and verify whether account is activated\n         */\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n\n        /***\n         * Perform Deposit transaction and verify journal entries are posted for the transaction\n         */\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(depositTransactionId);\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, expectedFirstDepositOnDate,\n                new JournalEntry(depositAmount, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, expectedFirstDepositOnDate,\n                new JournalEntry(depositAmount, JournalEntry.TransactionType.CREDIT));\n\n        /***\n         * Update interest earned field for RD account\n         */\n        recurringDepositAccountId = this.recurringDepositAccountHelper.calculateInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        /***\n         * Post interest and verify journal entries\n         */\n        Integer transactionIdForPostInterest = this.recurringDepositAccountHelper\n                .postInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        HashMap accountSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float totalInterestPosted = (Float) accountSummary.get(\"totalInterestPosted\");\n\n        final JournalEntry[] expenseAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liablilityAccountEntry = { new JournalEntry(totalInterestPosted, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(expenseAccount, INTEREST_POSTED_DATE, expenseAccountEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, INTEREST_POSTED_DATE, liablilityAccountEntry);\n\n        /***\n         * Calculate expected premature closure amount\n         */\n        HashMap recurringDepositPrematureData = this.recurringDepositAccountHelper\n                .calculatePrematureAmountForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE);\n\n        /***\n         * Expected to get an error response from api because re-invest option is not supported for account preClosure\n         */\n        ArrayList<HashMap> errorResponse = (ArrayList<HashMap>) recurringDepositAccountHelperValidationError\n                .prematureCloseForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_REINVEST, null,\n                        CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"validation.msg.recurringdepositaccount.onAccountClosureId.reinvest.not.allowed\",\n                errorResponse.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account Updation", "completion": "    @Test\n    public void testRecurringDepositAccountUpdation() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        todaysDate.add(Calendar.DATE, -1);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateRecurringDepositAccount(clientId.toString(),\n                recurringDepositProductId.toString(), recurringDepositAccountId.toString(), VALID_FROM, VALID_TO, WHOLE_TERM,\n                SUBMITTED_ON_DATE);\n        Assertions.assertTrue(modificationsHashMap.containsKey(\"submittedOnDate\"));\n\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account Undo Approval", "completion": "    @Test\n    public void testRecurringDepositAccountUndoApproval() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.undoApproval(recurringDepositAccountId);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account Rejected And Closed", "completion": "    @Test\n    public void testRecurringDepositAccountRejectedAndClosed() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String REJECTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.rejectApplication(recurringDepositAccountId,\n                REJECTED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsRejected(recurringDepositAccountStatusHashMap);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsClosed(recurringDepositAccountStatusHashMap);\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account Withdrawn By Client And Closed", "completion": "    @Test\n    public void testRecurringDepositAccountWithdrawnByClientAndClosed() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String WITHDRAWN_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.withdrawApplication(recurringDepositAccountId,\n                WITHDRAWN_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsWithdrawn(recurringDepositAccountStatusHashMap);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsClosed(recurringDepositAccountStatusHashMap);\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account Is Deleted", "completion": "    @Test\n    public void testRecurringDepositAccountIsDeleted() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountId = (Integer) this.recurringDepositAccountHelper\n                .deleteRecurringDepositApplication(recurringDepositAccountId, \"resourceId\");\n        Assertions.assertNotNull(recurringDepositAccountId);\n    }"}
{"prompt": "Create a test that tests test Update And Undo Transaction For Recurring Deposit Account", "completion": "    @Test\n    public void testUpdateAndUndoTransactionForRecurringDepositAccount() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        /***\n         * Create GL Accounts for product account mapping\n         */\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.MONTH, 1);\n        final String DEPOSIT_DATE = dateFormat.format(todaysDate.getTime());\n\n        /***\n         * Create client for applying Deposit account\n         */\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        /***\n         * Create RD product with CashBased accounting enabled\n         */\n        final String accountingRule = CASH_BASED;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule, assetAccount,\n                liabilityAccount, incomeAccount, expenseAccount);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        /***\n         * Apply for RD account with created product and verify status\n         */\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        /***\n         * Approve the RD account and verify whether account is approved\n         */\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        /***\n         * Activate the RD Account and verify whether account is activated\n         */\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositSummaryBefore = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float balanceBefore = (Float) recurringDepositSummaryBefore.get(\"accountBalance\");\n\n        /***\n         * Perform Deposit transaction and verify journal entries are posted for the transaction\n         */\n        Integer transactionIdForDeposit = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, DEPOSIT_DATE);\n        Assertions.assertNotNull(transactionIdForDeposit);\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, DEPOSIT_DATE,\n                new JournalEntry(DEPOSIT_AMOUNT, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, DEPOSIT_DATE,\n                new JournalEntry(DEPOSIT_AMOUNT, JournalEntry.TransactionType.CREDIT));\n\n        /***\n         * verify account balances after transactions\n         */\n        Float expectedBalanceAfter = balanceBefore + DEPOSIT_AMOUNT;\n        HashMap recurringDepositSummaryAfter = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float balanceAfter = (Float) recurringDepositSummaryAfter.get(\"accountBalance\");\n\n        Assertions.assertEquals(expectedBalanceAfter, balanceAfter, \"Verifying account balance after deposit\");\n\n        /***\n         * Update transaction and verify account balance after transaction\n         */\n        Float updatedTransactionAmount = DEPOSIT_AMOUNT - 1000.0f;\n        Integer updateTransactionId = this.recurringDepositAccountHelper.updateTransactionForRecurringDeposit(recurringDepositAccountId,\n                transactionIdForDeposit, DEPOSIT_DATE, updatedTransactionAmount);\n        Assertions.assertNotNull(updateTransactionId);\n\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, DEPOSIT_DATE,\n                new JournalEntry(updatedTransactionAmount, JournalEntry.TransactionType.DEBIT));\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, DEPOSIT_DATE,\n                new JournalEntry(updatedTransactionAmount, JournalEntry.TransactionType.CREDIT));\n\n        expectedBalanceAfter = DEPOSIT_AMOUNT - updatedTransactionAmount;\n        recurringDepositSummaryAfter = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        balanceAfter = (Float) recurringDepositSummaryAfter.get(\"accountBalance\");\n\n        Assertions.assertEquals(expectedBalanceAfter, balanceAfter, \"Verifying account balance after updating Transaction\");\n\n        Integer undoTransactionId = this.recurringDepositAccountHelper.undoTransactionForRecurringDeposit(recurringDepositAccountId,\n                updateTransactionId, DEPOSIT_DATE, 0.0f);\n        Assertions.assertNotNull(undoTransactionId);\n\n        expectedBalanceAfter = expectedBalanceAfter - updatedTransactionAmount;\n        recurringDepositSummaryAfter = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        balanceAfter = (Float) recurringDepositSummaryAfter.get(\"accountBalance\");\n\n        Assertions.assertEquals(expectedBalanceAfter, balanceAfter, \"Verifying account balance after Undo Transaction\");\n\n    }"}
{"prompt": "Create a test that tests test Post Interest For Recurring Deposit", "completion": "    @Test\n    public void testPostInterestForRecurringDeposit() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(depositTransactionId);\n\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"totalDeposits\");\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        daysInMonth = daysInMonth - currentDate + 1;\n        Float interestToBePosted = (float) (interestPerDay * principal * daysInMonth);\n        principal += interestToBePosted;\n\n        Float expectedBalanceAfter = principal;\n        LOG.info(\"{}\", expectedBalanceAfter.toString());\n\n        Integer transactionIdForPostInterest = this.recurringDepositAccountHelper\n                .postInterestForRecurringDeposit(recurringDepositAccountId);\n        Assertions.assertNotNull(transactionIdForPostInterest);\n\n        HashMap recurringDepositAccountSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float interestAmountPosted = (Float) recurringDepositAccountSummary.get(\"totalInterestPosted\");\n        Float principalAfter = (Float) recurringDepositAccountSummary.get(\"accountBalance\");\n\n        Assertions.assertTrue(Math.abs(interestToBePosted - interestAmountPosted) < THRESHOLD,\n                \"Verifying Amount of Interest Posted to Recurring Deposit Account\");\n        Assertions.assertTrue(Math.abs(expectedBalanceAfter - principalAfter) < THRESHOLD,\n                \"Verifying Principal Amount after Interest Posting\");\n\n    }"}
{"prompt": "Create a test that tests test Premature Closure Amount With Penal Interest For Whole Term With 365 Days", "completion": "    @Test\n    public void testPrematureClosureAmountWithPenalInterestForWholeTerm_With_365_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.MONTH, 1);\n        final String CLOSED_ON_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Float preClosurePenalInterestRate = (Float) recurringDepositAccountData.get(\"preClosurePenalInterest\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(depositTransactionId);\n\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"totalDeposits\");\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        interestRate -= preClosurePenalInterestRate;\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(calendar.getTime()));\n        Integer daysInMonth = calendar.getActualMaximum(Calendar.DATE);\n        daysInMonth = daysInMonth - currentDate + 1;\n        Float interestPerMonth = (float) (interestPerDay * principal * daysInMonth);\n        principal += interestPerMonth + depositAmount;\n        calendar.add(Calendar.DATE, daysInMonth);\n        LOG.info(\"{}\", monthDayFormat.format(calendar.getTime()));\n\n        expectedFirstDepositOnDate = dateFormat.format(calendar.getTime());\n        Integer transactionIdForDeposit = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(transactionIdForDeposit);\n\n        currentDate = currentDate - 1;\n        interestPerMonth = (float) (interestPerDay * principal * currentDate);\n        LOG.info(\"IPM = {}\", interestPerMonth);\n        principal += interestPerMonth;\n        LOG.info(\"principal = {}\", principal);\n\n        HashMap recurringDepositPrematureData = this.recurringDepositAccountHelper\n                .calculatePrematureAmountForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.recurringDepositAccountHelper.prematureCloseForRecurringDeposit(\n                recurringDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsPrematureClosed(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    }"}
{"prompt": "Create a test that tests test Premature Closure Amount With Penal Interest For Whole Term With 360 Days", "completion": "    @Test\n    public void testPrematureClosureAmountWithPenalInterestForWholeTerm_With_360_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -1);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.MONTH, 1);\n        final String CLOSED_ON_DATE = dateFormat.format(todaysDate.getTime());\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, MONTHLY, MONTHLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.activateRecurringDeposit(recurringDepositAccountId,\n                ACTIVATION_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsActive(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        Float depositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Float preClosurePenalInterestRate = (Float) recurringDepositAccountData.get(\"preClosurePenalInterest\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Integer depositTransactionId = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(depositTransactionId);\n\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"totalDeposits\");\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        interestRate -= preClosurePenalInterestRate;\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.MONTH, -1);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(calendar.getTime()));\n        Integer daysInMonth = calendar.getActualMaximum(Calendar.DATE);\n        daysInMonth = daysInMonth - currentDate + 1;\n        Float interestPerMonth = (float) (interestPerDay * principal * daysInMonth);\n        principal += interestPerMonth + depositAmount;\n        calendar.add(Calendar.DATE, daysInMonth);\n        LOG.info(\"{}\", monthDayFormat.format(calendar.getTime()));\n\n        expectedFirstDepositOnDate = dateFormat.format(calendar.getTime());\n        Integer transactionIdForDeposit = this.recurringDepositAccountHelper.depositToRecurringDepositAccount(recurringDepositAccountId,\n                DEPOSIT_AMOUNT, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(transactionIdForDeposit);\n\n        currentDate = currentDate - 1;\n        interestPerMonth = (float) (interestPerDay * principal * currentDate);\n        LOG.info(\"IPM = {}\", interestPerMonth);\n        principal += interestPerMonth;\n        LOG.info(\"principal = {}\", principal);\n\n        HashMap recurringDepositPrematureData = this.recurringDepositAccountHelper\n                .calculatePrematureAmountForRecurringDeposit(recurringDepositAccountId, CLOSED_ON_DATE);\n\n        Integer prematureClosureTransactionId = (Integer) this.recurringDepositAccountHelper.prematureCloseForRecurringDeposit(\n                recurringDepositAccountId, CLOSED_ON_DATE, CLOSURE_TYPE_WITHDRAW_DEPOSIT, null, CommonConstants.RESPONSE_RESOURCE_ID);\n        Assertions.assertNotNull(prematureClosureTransactionId);\n\n        recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker.getStatusOfRecurringDepositAccount(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositAccountIsPrematureClosed(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(principal - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit With Bi Annual Compounding And Posting 365 Days", "completion": "    @Test\n    public void testRecurringDepositWithBi_AnnualCompoundingAndPosting_365_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        LOG.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_365, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, BI_ANNUALLY, BI_ANNUALLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        LOG.info(\"per day = {}\", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, BIANNULLY_INTERVAL, BIANNULLY_INTERVAL);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit With Bi Annual Compounding And Posting 360 Days", "completion": "    @Test\n    public void testRecurringDepositWithBi_AnnualCompoundingAndPosting_360_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        LOG.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, BI_ANNUALLY, BI_ANNUALLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        LOG.info(\"per day = {} \", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, BIANNULLY_INTERVAL, BIANNULLY_INTERVAL);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    }"}
{"prompt": "Create a test that tests test Maturity Amount For Daily Compounding And Annually Posting With 360 Days", "completion": "    @Test\n    public void testMaturityAmountForDailyCompoundingAndAnnuallyPosting_With_360_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        LOG.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, DAILY, ANNUALLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        LOG.info(\"per day = {} \", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, DAILY_COMPOUNDING_INTERVAL, ANNUL_INTERVAL);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Maturity amount\");\n\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Quarterly Compounding And Quarterly Posting 365 Days", "completion": "    @Test\n    public void testRecurringDepositQuarterlyCompoundingAndQuarterlyPosting_365_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        LOG.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_365, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, QUARTERLY, QUARTERLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        LOG.info(\"per day = {} \", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, QUARTERLY_INTERVAL, QUARTERLY_INTERVAL);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Quarterly Compounding And Quarterly Posting 360 Days", "completion": "    @Test\n    public void testRecurringDepositQuarterlyCompoundingAndQuarterlyPosting_360_Days() {\n        this.recurringDepositProductHelper = new RecurringDepositProductHelper(this.requestSpec, this.responseSpec);\n        this.accountHelper = new AccountHelper(this.requestSpec, this.responseSpec);\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n        this.recurringDepositAccountHelper = new RecurringDepositAccountHelper(this.requestSpec, this.responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        DateFormat monthDayFormat = new SimpleDateFormat(\"dd MMM\", Locale.US);\n        DateFormat currentMonthFormat = new SimpleDateFormat(\"MM\");\n        DateFormat currentDateFormat = new SimpleDateFormat(\"dd\");\n\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.YEAR, -1);\n        Integer currentMonth = Integer.valueOf(currentMonthFormat.format(todaysDate.getTime()));\n        Integer numberOfMonths = 12 - currentMonth;\n        todaysDate.add(Calendar.MONTH, numberOfMonths);\n        Integer currentDate = Integer.valueOf(currentDateFormat.format(todaysDate.getTime()));\n        Integer daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        Integer daysLeft = daysInMonth - currentDate;\n        todaysDate.add(Calendar.DATE, daysLeft + 1);\n        daysInMonth = todaysDate.getActualMaximum(Calendar.DATE);\n        LOG.info(\"{}\", dateFormat.format(todaysDate.getTime()));\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n\n        final String VALID_TO = null;\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        final String expectedFirstDepositOnDate = dateFormat.format(todaysDate.getTime());\n        final String MONTH_DAY = monthDayFormat.format(todaysDate.getTime());\n\n        Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final String accountingRule = NONE;\n        Integer recurringDepositProductId = createRecurringDepositProduct(VALID_FROM, VALID_TO, accountingRule);\n        Assertions.assertNotNull(recurringDepositProductId);\n\n        Integer recurringDepositAccountId = applyForRecurringDepositApplication(clientId.toString(), recurringDepositProductId.toString(),\n                VALID_FROM, VALID_TO, SUBMITTED_ON_DATE, WHOLE_TERM, expectedFirstDepositOnDate);\n        Assertions.assertNotNull(recurringDepositAccountId);\n\n        HashMap modificationsHashMap = this.recurringDepositAccountHelper.updateInterestCalculationConfigForRecurringDeposit(\n                clientId.toString(), recurringDepositProductId.toString(), recurringDepositAccountId.toString(), SUBMITTED_ON_DATE,\n                VALID_FROM, VALID_TO, DAYS_360, WHOLE_TERM, INTEREST_CALCULATION_USING_DAILY_BALANCE, QUARTERLY, QUARTERLY,\n                expectedFirstDepositOnDate);\n\n        HashMap recurringDepositAccountStatusHashMap = RecurringDepositAccountStatusChecker\n                .getStatusOfRecurringDepositAccount(this.requestSpec, this.responseSpec, recurringDepositAccountId.toString());\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsPending(recurringDepositAccountStatusHashMap);\n\n        recurringDepositAccountStatusHashMap = this.recurringDepositAccountHelper.approveRecurringDeposit(recurringDepositAccountId,\n                APPROVED_ON_DATE);\n        RecurringDepositAccountStatusChecker.verifyRecurringDepositIsApproved(recurringDepositAccountStatusHashMap);\n\n        HashMap recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec,\n                this.responseSpec, recurringDepositAccountId);\n        HashMap recurringDepositSummary = this.recurringDepositAccountHelper.getRecurringDepositSummary(recurringDepositAccountId);\n        Float principal = (Float) recurringDepositSummary.get(\"accountBalance\");\n        Float recurringDepositAmount = (Float) recurringDepositAccountData.get(\"mandatoryRecommendedDepositAmount\");\n        Integer depositPeriod = (Integer) recurringDepositAccountData.get(\"depositPeriod\");\n        HashMap daysInYearMap = (HashMap) recurringDepositAccountData.get(\"interestCalculationDaysInYearType\");\n        Integer daysInYear = (Integer) daysInYearMap.get(\"id\");\n        ArrayList<ArrayList<HashMap>> interestRateChartData = RecurringDepositProductHelper\n                .getInterestRateChartSlabsByProductId(this.requestSpec, this.responseSpec, recurringDepositProductId);\n\n        Float interestRate = RecurringDepositAccountHelper.getInterestRate(interestRateChartData, depositPeriod);\n        double interestRateInFraction = interestRate / 100;\n        double perDay = (double) 1 / daysInYear;\n        LOG.info(\"per day = {} \", perDay);\n        double interestPerDay = interestRateInFraction * perDay;\n\n        principal = RecurringDepositAccountHelper.getPrincipalAfterCompoundingInterest(todaysDate, principal, recurringDepositAmount,\n                depositPeriod, interestPerDay, QUARTERLY_INTERVAL, QUARTERLY_INTERVAL);\n\n        recurringDepositAccountData = RecurringDepositAccountHelper.getRecurringDepositAccountById(this.requestSpec, this.responseSpec,\n                recurringDepositAccountId);\n\n        Float expectedPrematureAmount = principal;\n        Float maturityAmount = (Float) recurringDepositAccountData.get(\"maturityAmount\");\n\n        Assertions.assertTrue(Math.abs(expectedPrematureAmount - maturityAmount) < THRESHOLD, \"Verifying Pre-Closure maturity amount\");\n\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Period Interest Rate Chart", "completion": "    @Test\n    public void testRecurringDepositAccountWithPeriodInterestRateChart() {\n        final String chartToUse = \"period\";\n        final String depositAmount = \"1000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 6.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Period Interest Rate Chart AMOUNT VARIATION", "completion": "    @Test\n    public void testRecurringDepositAccountWithPeriodInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"period\";\n        final String depositAmount = \"10000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 6.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Period Interest Rate Chart PERIOD VARIATION", "completion": "    @Test\n    public void testRecurringDepositAccountWithPeriodInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"period\";\n        final String depositAmount = \"1000\";\n        final String depositPeriod = \"18\";\n        final Float interestRate = Float.valueOf((float) 7.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Amount Interest Rate Chart", "completion": "    @Test\n    public void testRecurringDepositAccountWithAmountInterestRateChart() {\n        final String chartToUse = \"amount\";\n        final String depositAmount = \"1000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 8.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Amount Interest Rate Chart AMOUNT VARIATION", "completion": "    @Test\n    public void testRecurringDepositAccountWithAmountInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"amount\";\n        final String depositAmount = \"500\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 7.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Amount Interest Rate Chart PERIOD VARIATION", "completion": "    @Test\n    public void testRecurringDepositAccountWithAmountInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"amount\";\n        final String depositAmount = \"500\";\n        final String depositPeriod = \"10\";\n        final Float interestRate = Float.valueOf((float) 5.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Period And Amount Interest Rate Chart", "completion": "    @Test\n    public void testRecurringDepositAccountWithPeriodAndAmountInterestRateChart() {\n        final String chartToUse = \"period_amount\";\n        final String depositAmount = \"1000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 7.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Period And Amount Interest Rate Chart AMOUNT VARIATION", "completion": "    @Test\n    public void testRecurringDepositAccountWithPeriodAndAmountInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"period_amount\";\n        final String depositAmount = \"400\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 6.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Period And Amount Interest Rate Chart PERIOD VARIATION", "completion": "    @Test\n    public void testRecurringDepositAccountWithPeriodAndAmountInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"period_amount\";\n        final String depositAmount = \"1000\";\n        final String depositPeriod = \"14\";\n        final Float interestRate = Float.valueOf((float) 8.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Amount And Period Interest Rate Chart", "completion": "    @Test\n    public void testRecurringDepositAccountWithAmountAndPeriodInterestRateChart() {\n        final String chartToUse = \"amount_period\";\n        final String depositAmount = \"1000\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 8.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Amount And Period Interest Rate Chart AMOUNT VARIATION", "completion": "    @Test\n    public void testRecurringDepositAccountWithAmountAndPeriodInterestRateChart_AMOUNT_VARIATION() {\n        final String chartToUse = \"amount_period\";\n        final String depositAmount = \"100\";\n        final String depositPeriod = \"12\";\n        final Float interestRate = Float.valueOf((float) 6.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Recurring Deposit Account With Amount And Period Interest Rate Chart PERIOD VARIATION", "completion": "    @Test\n    public void testRecurringDepositAccountWithAmountAndPeriodInterestRateChart_PERIOD_VARIATION() {\n        final String chartToUse = \"amount_period\";\n        final String depositAmount = \"1000\";\n        final String depositPeriod = \"6\";\n        final Float interestRate = Float.valueOf((float) 7.0);\n        testFixedDepositAccountForInterestRate(chartToUse, depositAmount, depositPeriod, interestRate);\n    }"}
{"prompt": "Create a test that tests test Repayment With Post Dated Checks", "completion": "    @Test\n    public void testRepaymentWithPostDatedChecks() {\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        Calendar meetingCalendar = Calendar.getInstance();\n        meetingCalendar.set(2012, 3, 4);\n\n        final String disbursalDate = this.dateFormatterStandard.format(meetingCalendar.getTime());\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientID);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(new LoanProductTestBuilder().build(null));\n        Assertions.assertNotNull(loanProductID, \"Could not create Loan Product\");\n\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"8000\");\n        Assertions.assertNotNull(loanID, \"Could not create Loan Account\");\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        // Test for loan account is created, can be approved\n        this.loanTransactionHelper.approveLoan(disbursalDate, loanID);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        // Get repayments Template for Repayment\n        ArrayList<HashMap> installmentData = this.loanTransactionHelper.getRepayments(loanID);\n        Assertions.assertNotNull(installmentData, \"Empty Installment Data Template\");\n\n        // Get repayments for Disburse\n        installmentData = this.loanTransactionHelper.getRepayments(loanID);\n        Assertions.assertNotNull(installmentData, \"Empty Installment Data\");\n        List<HashMap> postDatedChecks = new ArrayList<>();\n        Gson gson = new Gson();\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n\n        // Get the first installment date\n        ArrayList installmentDate = (ArrayList) installmentData.get(0).get(\"date\");\n        Assertions.assertNotNull(installmentDate);\n        Assertions.assertEquals(3, installmentDate.size());\n        Calendar calendar = Calendar.getInstance();\n        calendar.set((Integer) installmentDate.get(0), (Integer) installmentDate.get(1) - 1, (Integer) installmentDate.get(2));\n        final String LOAN_REPAYMENT_DATE = dateFormat.format(calendar.getTime());\n        Float firstInstallmentAmount = (Float) installmentData.get(0).get(\"amount\");\n\n        for (int i = 0; i < installmentData.size(); i++) {\n            String result = gson.toJson(installmentData.get(i));\n            JsonObject reportObject = JsonParser.parseString(result).getAsJsonObject();\n            final Integer installmentId = reportObject.get(\"installmentId\").getAsInt();\n            final BigDecimal amount = reportObject.get(\"amount\").getAsBigDecimal();\n            postDatedChecks.add(postDatedCheck(installmentId, amount));\n        }\n\n        Assertions.assertNotNull(postDatedChecks);\n\n        // Test for loan account approved can be disbursed\n        this.loanTransactionHelper.disburseLoanWithPostDatedChecks(disbursalDate, loanID, BigDecimal.valueOf(8000), postDatedChecks);\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // Create payment type PDC - Post Dated Checks\n        String name = \"PDC\";\n        String description = PaymentTypeHelper.randomNameGenerator(\"PDC\", 15);\n        Boolean isCashPayment = false;\n        Integer position = 1;\n\n        Integer paymentTypeId = PaymentTypeHelper.createPaymentType(requestSpec, responseSpec, name, description, isCashPayment, position);\n        Assertions.assertNotNull(paymentTypeId);\n        PaymentTypeHelper.verifyPaymentTypeCreatedOnServer(requestSpec, responseSpec, paymentTypeId);\n        PaymentTypeDomain paymentTypeResponse = PaymentTypeHelper.retrieveById(requestSpec, responseSpec, paymentTypeId);\n        Assertions.assertEquals(name, paymentTypeResponse.getName());\n\n        // Repay for the installment 1 using post dated check\n        HashMap postDatedCheck = this.loanTransactionHelper.getPostDatedCheck(loanID, Integer.valueOf(1));\n        Assertions.assertNotNull(postDatedCheck);\n        Assertions.assertNotNull(Float.valueOf(String.valueOf(postDatedCheck.get(\"amount\"))));\n\n        this.loanTransactionHelper.makeRepaymentWithPDC(LOAN_REPAYMENT_DATE, firstInstallmentAmount, loanID, paymentTypeId);\n    }"}
{"prompt": "Create a test that tests test Create Roles Status", "completion": "    @SuppressWarnings(\"cast\")\n    @Test\n    public void testCreateRolesStatus() {\n\n        LOG.info(\"---------------------------------CREATING A ROLE---------------------------------------------\");\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        LOG.info(\"--------------------------------- Getting ROLE -------------------------------\");\n        HashMap<String, Object> role = RolesHelper.getRoleDetails(requestSpec, responseSpec, roleId);\n        assertEquals((Integer) role.get(\"id\"), roleId);\n\n    }"}
{"prompt": "Create a test that tests test Disable Roles Status", "completion": "    @SuppressWarnings(\"cast\")\n    @Test\n    public void testDisableRolesStatus() {\n\n        LOG.info(\"---------------------------------CREATING A ROLE---------------------------------------------\");\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        LOG.info(\"--------------------------------- Getting ROLE -------------------------------\");\n        HashMap<String, Object> role = RolesHelper.getRoleDetails(requestSpec, responseSpec, roleId);\n        assertEquals((Integer) role.get(\"id\"), roleId);\n\n        LOG.info(\"--------------------------------- DISABLING ROLE -------------------------------\");\n        final Integer disableRoleId = RolesHelper.disableRole(this.requestSpec, this.responseSpec, roleId);\n        assertEquals(disableRoleId, roleId);\n        role = RolesHelper.getRoleDetails(requestSpec, responseSpec, roleId);\n        assertEquals((Integer) role.get(\"id\"), roleId);\n        assertEquals(true, (Boolean) role.get(\"disabled\"));\n\n    }"}
{"prompt": "Create a test that tests test Enable Roles Status", "completion": "    @SuppressWarnings(\"cast\")\n    @Test\n    public void testEnableRolesStatus() {\n\n        LOG.info(\"---------------------------------CREATING A ROLE---------------------------------------------\");\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        LOG.info(\"--------------------------------- Getting ROLE -------------------------------\");\n        HashMap<String, Object> role = RolesHelper.getRoleDetails(requestSpec, responseSpec, roleId);\n        assertEquals((Integer) role.get(\"id\"), roleId);\n\n        LOG.info(\"--------------------------------- DISABLING ROLE -------------------------------\");\n        final Integer disableRoleId = RolesHelper.disableRole(this.requestSpec, this.responseSpec, roleId);\n        assertEquals(disableRoleId, roleId);\n        role = RolesHelper.getRoleDetails(requestSpec, responseSpec, roleId);\n        assertEquals((Integer) role.get(\"id\"), roleId);\n        assertEquals(true, (Boolean) role.get(\"disabled\"));\n\n        LOG.info(\"--------------------------------- ENABLING ROLE -------------------------------\");\n        final Integer enableRoleId = RolesHelper.enableRole(this.requestSpec, this.responseSpec, roleId);\n        assertEquals(enableRoleId, roleId);\n        role = RolesHelper.getRoleDetails(requestSpec, responseSpec, roleId);\n        assertEquals((Integer) role.get(\"id\"), roleId);\n        assertEquals(false, (Boolean) role.get(\"disabled\"));\n\n    }"}
{"prompt": "Create a test that tests test Delete Role Status", "completion": "    @SuppressWarnings(\"cast\")\n    @Test\n    public void testDeleteRoleStatus() {\n\n        LOG.info(\"-------------------------------- CREATING A ROLE---------------------------------------------\");\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        LOG.info(\"--------------------------------- Getting ROLE -------------------------------\");\n        HashMap<String, Object> role = RolesHelper.getRoleDetails(requestSpec, responseSpec, roleId);\n        assertEquals((Integer) role.get(\"id\"), roleId);\n\n        LOG.info(\"--------------------------------- DELETE ROLE -------------------------------\");\n        final Integer deleteRoleId = RolesHelper.deleteRole(this.requestSpec, this.responseSpec, roleId);\n        assertEquals(deleteRoleId, roleId);\n    }"}
{"prompt": "Create a test that tests test Role Should Get Deleted If No Active User Exists", "completion": "    @Test\n    public void testRoleShouldGetDeletedIfNoActiveUserExists() {\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(staffId);\n\n        final Integer userId = UserHelper.createUser(this.requestSpec, this.responseSpec, roleId, staffId);\n        Assertions.assertNotNull(userId);\n\n        final Integer deletedUserId = UserHelper.deleteUser(this.requestSpec, this.responseSpec, userId);\n        Assertions.assertEquals(deletedUserId, userId);\n\n        final Integer deletedRoleId = RolesHelper.deleteRole(this.requestSpec, this.responseSpec, roleId);\n        assertEquals(deletedRoleId, roleId);\n    }"}
{"prompt": "Create a test that tests test Role Should Not Get Deleted If Active User Exists", "completion": "    @Test\n    public void testRoleShouldNotGetDeletedIfActiveUserExists() {\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(staffId);\n\n        final Integer userId = UserHelper.createUser(this.requestSpec, this.responseSpec, roleId, staffId);\n        Assertions.assertNotNull(userId);\n\n        this.responseSpec = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final Integer deletedRoleId = RolesHelper.deleteRole(this.requestSpec, this.responseSpec, roleId);\n        assertNotEquals(deletedRoleId, roleId);\n    }"}
{"prompt": "Create a test that tests test Savings Balance After Withdrawal", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSavingsBalanceAfterWithdrawal() {\n        SavingsAccountHelper savingsAccountHelperValidationError = new SavingsAccountHelper(this.requestSpec,\n                new ResponseSpecBuilder().build());\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, START_DATE);\n        Assertions.assertNotNull(clientID);\n        final Integer savingsId = createSavingsAccountDailyPosting(clientID);\n        Integer depositTransactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"10000\", START_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        this.savingsAccountHelper.reverseSavingsAccountTransaction(savingsId, depositTransactionId);\n        HashMap reversedDepositTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, depositTransactionId);\n        Assertions.assertTrue((Boolean) reversedDepositTransaction.get(\"reversed\"));\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(\"0.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance is 0\");\n        List<HashMap> error = (List<HashMap>) savingsAccountHelperValidationError.withdrawalFromSavingsAccount(savingsId, \"100\", START_DATE,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.savingsaccount.transaction.insufficient.account.balance\",\n                error.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n    }"}
{"prompt": "Create a test that tests test Savings Balance With Over Draft After Withdrawal", "completion": "    @Test\n    public void testSavingsBalanceWithOverDraftAfterWithdrawal() {\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, START_DATE);\n        Assertions.assertNotNull(clientID);\n        final Integer savingsId = createSavingsAccountDailyPostingWithOverDraft(clientID);\n        Integer withdrawalTransactionId = (Integer) this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"1000\", START_DATE,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        this.savingsAccountHelper.reverseSavingsAccountTransaction(savingsId, withdrawalTransactionId);\n        HashMap reversedWithdrawalTransaction = this.savingsAccountHelper.getSavingsTransaction(savingsId, withdrawalTransactionId);\n        Assertions.assertTrue((Boolean) reversedWithdrawalTransaction.get(\"reversed\"));\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(\"0.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance is 0\");\n        Integer withdrawalAfterReversalTransactionId = (Integer) savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"500\",\n                START_DATE, CommonConstants.RESPONSE_RESOURCE_ID);\n        summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(\"-500.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance is -500\");\n    }"}
{"prompt": "Create a test that tests approve Savings Account", "completion": "    @Test\n    @Order(2)\n    void approveSavingsAccount() {\n        LOG.info(\"------------------------------ APPROVING SAVINGS ACCOUNT ---------------------------------------\");\n        PostSavingsAccountsAccountIdRequest request = new PostSavingsAccountsAccountIdRequest();\n        request.dateFormat(dateFormat);\n        request.setLocale(locale);\n        request.setApprovedOnDate(formattedDate);\n        Response<PostSavingsAccountsAccountIdResponse> response = okR(\n                fineract().savingsAccounts.handleCommands6((long) savingId, request, \"approve\"));\n\n        assertThat(response.isSuccessful()).isTrue();\n        assertThat(response.body()).isNotNull();\n    }"}
{"prompt": "Create a test that tests activate Savings Account", "completion": "    @Test\n    @Order(3)\n    void activateSavingsAccount() {\n        LOG.info(\"------------------------------ ACTIVATING SAVINGS ACCOUNT ---------------------------------------\");\n        PostSavingsAccountsAccountIdRequest request = new PostSavingsAccountsAccountIdRequest();\n        request.dateFormat(dateFormat);\n        request.setLocale(locale);\n        request.setActivatedOnDate(formattedDate);\n        Response<PostSavingsAccountsAccountIdResponse> response = okR(\n                fineract().savingsAccounts.handleCommands6((long) savingId, request, \"activate\"));\n\n        assertThat(response.isSuccessful()).isTrue();\n        assertThat(response.body()).isNotNull();\n    }"}
{"prompt": "Create a test that tests test Savings Daily Interest Posting", "completion": "    @Test\n    public void testSavingsDailyInterestPosting() {\n        // client activation, savings activation and 1st transaction date\n        final String startDate = \"01 November 2021\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPosting(clientID, startDate);\n\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"1000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        /***\n         * Perform Post interest transaction and verify the posted transaction date\n         */\n        this.savingsAccountHelper.postInterestForSavings(savingsId);\n        HashMap accountDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) accountDetails.get(\"transactions\");\n        HashMap<String, Object> interestPostingTransaction = transactions.get(transactions.size() - 2);\n        for (Map.Entry<String, Object> entry : interestPostingTransaction.entrySet()) {\n            LOG.info(\"{} - {}\", entry.getKey(), entry.getValue().toString());\n        }\n        assertEquals(\"0.274\", interestPostingTransaction.get(\"amount\").toString(), \"Equality check for interest posted amount\");\n        assertEquals(\"[2021, 11, 2]\", interestPostingTransaction.get(\"date\").toString(), \"Date check for Interest Posting transaction\");\n\n    }"}
{"prompt": "Create a test that tests test Savings Balance Check After Daily Interest Posting Job", "completion": "    @Test\n    public void testSavingsBalanceCheckAfterDailyInterestPostingJob() {\n        // client activation, savings activation and 1st transaction date\n        final String startDate = \"10 April 2022\";\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPosting(clientID, startDate);\n\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"10000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        /***\n         * Runs Post interest posting job and verify the new account created with accounting configuration set as none\n         * is picked up by job\n         */\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        Object transactionObj = this.savingsAccountHelper.getSavingsDetails(savingsId, \"transactions\");\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) transactionObj;\n        HashMap<String, Object> interestPostingTransaction = transactions.get(transactions.size() - 48);\n        for (Map.Entry<String, Object> entry : interestPostingTransaction.entrySet()) {\n            LOG.info(\"{} - {}\", entry.getKey(), entry.getValue().toString());\n        }\n        assertEquals(\"10129.582\", interestPostingTransaction.get(\"runningBalance\").toString(), \"Equality check for Balance\");\n    }"}
{"prompt": "Create a test that tests test Savings Daily Interest Posting Job With Accounting None", "completion": "    @Test\n    public void testSavingsDailyInterestPostingJobWithAccountingNone() {\n        final String startDate = \"10 April 2022\";\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n        this.accountHelper = new AccountHelper(requestSpec, responseSpec);\n        this.journalEntryHelper = new JournalEntryHelper(requestSpec, responseSpec);\n\n        final Integer savingsId = createSavingsAccountDailyPostingWithAccounting(clientID, startDate);\n\n        Integer transactionId = (Integer) this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"1000\", startDate,\n                CommonConstants.RESPONSE_RESOURCE_ID);\n        ArrayList<HashMap> journalEntries = this.journalEntryHelper.getJournalEntriesByTransactionId(String.valueOf(transactionId));\n        assertEquals(0, journalEntries.size());\n    }"}
{"prompt": "Create a test that tests test Duplicate Overdraft Interest Posting Job", "completion": "    @Test\n    public void testDuplicateOverdraftInterestPostingJob() {\n        // client activation, savings activation and 1st transaction date\n        final String startDate = \"01 July 2022\";\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"1000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"1000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        Object transactionObj = this.savingsAccountHelper.getSavingsDetails(savingsId, \"transactions\");\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) transactionObj;\n        Integer dateCount = 0;\n        for (HashMap<String, Object> transaction : transactions) {\n            if (transaction.get(\"date\").toString().equals(\"[2022, 7, 10]\") && transaction.get(\"reversed\").toString().equals(\"false\")) {\n                dateCount++;\n            }\n        }\n        assertEquals(1, dateCount, \"No Duplicate Overdraft Interest Posting\");\n    }"}
{"prompt": "Create a test that tests test Savings Daily Interest Posting Job", "completion": "    @Test\n    public void testSavingsDailyInterestPostingJob() {\n        // client activation, savings activation and 1st transaction date\n        final String startDate = \"10 April 2022\";\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPosting(clientID, startDate);\n\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"10000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        /***\n         * Runs Post interest posting job and verify the new account created with accounting configuration set as none\n         * is picked up by job\n         */\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        Object transactionObj = this.savingsAccountHelper.getSavingsDetails(savingsId, \"transactions\");\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) transactionObj;\n        HashMap<String, Object> interestPostingTransaction = transactions.get(transactions.size() - 3);\n        for (Map.Entry<String, Object> entry : interestPostingTransaction.entrySet()) {\n            LOG.info(\"{} - {}\", entry.getKey(), entry.getValue().toString());\n        }\n        assertEquals(\"2.7405\", interestPostingTransaction.get(\"amount\").toString(), \"Equality check for interest posted amount\");\n        assertEquals(\"[2022, 4, 12]\", interestPostingTransaction.get(\"date\").toString(), \"Date check for Interest Posting transaction\");\n    }"}
{"prompt": "Create a test that tests test Savings Daily Overdraft Interest Posting Job", "completion": "    @Test\n    public void testSavingsDailyOverdraftInterestPostingJob() {\n        // client activation, savings activation and 1st transaction date\n        final String startDate = \"10 April 2022\";\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingOverdraft(clientID, startDate);\n\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"10000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        /***\n         * Runs Post interest posting job and verify the new account created with Overdraft is posting negative interest\n         */\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        Object transactionObj = this.savingsAccountHelper.getSavingsDetails(savingsId, \"transactions\");\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) transactionObj;\n        HashMap<String, Object> interestPostingTransaction = transactions.get(transactions.size() - 2);\n        for (Map.Entry<String, Object> entry : interestPostingTransaction.entrySet()) {\n            LOG.info(\"{} - {}\", entry.getKey(), entry.getValue().toString());\n        }\n        assertEquals(\"2.7397\", interestPostingTransaction.get(\"amount\").toString(), \"Equality check for overdatft interest posted amount\");\n        assertEquals(\"[2022, 4, 11]\", interestPostingTransaction.get(\"date\").toString(),\n                \"Date check for overdraft Interest Posting transaction\");\n\n    }"}
{"prompt": "Create a test that tests test Account Balance With Withdrawal Fee After Interest Posting Job", "completion": "    @Test\n    public void testAccountBalanceWithWithdrawalFeeAfterInterestPostingJob() {\n        final String startDate = \"21 June 2022\";\n        final String jobName = \"Post Interest For Savings\";\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec, startDate);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsId = createSavingsAccountDailyPostingWithCharge(clientID, startDate);\n        this.savingsAccountHelper.depositToSavingsAccount(savingsId, \"1000\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n\n        this.savingsAccountHelper.withdrawalFromSavingsAccount(savingsId, \"100\", startDate, CommonConstants.RESPONSE_RESOURCE_ID);\n        HashMap summary = this.savingsAccountHelper.getSavingsSummary(savingsId);\n        Float balance = Float.parseFloat(\"800.0\");\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying account balance is 800\");\n\n        this.scheduleJobHelper.executeAndAwaitJob(jobName);\n        Object transactionObj = this.savingsAccountHelper.getSavingsDetails(savingsId, \"transactions\");\n        ArrayList<HashMap<String, Object>> transactions = (ArrayList<HashMap<String, Object>>) transactionObj;\n        HashMap<String, Object> interestPostingTransaction = transactions.get(transactions.size() - 5);\n        for (Map.Entry<String, Object> entry : interestPostingTransaction.entrySet()) {\n            LOG.info(\"{} - {}\", entry.getKey(), entry.getValue().toString());\n        }\n        assertEquals(\"800.4384\", interestPostingTransaction.get(\"runningBalance\").toString(), \"Equality check for Balance\");\n    }"}
{"prompt": "Create a test that tests test Date Format", "completion": "    @Test // FINERACT-926\n    public void testDateFormat() {\n        // must start scheduler and make job active to have nextRunTime (which\n        // is a\n        // java.util.Date)\n        schedulerJobHelper.updateSchedulerStatus(true);\n        int minJobId = schedulerJobHelper.getAllSchedulerJobIds().stream().mapToInt(number -> number).min().orElse(Integer.MAX_VALUE);\n        schedulerJobHelper.updateSchedulerJob(minJobId, true);\n        String nextRunTimeText = await().until(() -> (String) schedulerJobHelper.getSchedulerJobById(minJobId).get(\"nextRunTime\"),\n                Objects::nonNull);\n        DateTimeFormatter.ISO_INSTANT.parse(nextRunTimeText);\n    }"}
{"prompt": "Create a test that tests test Flipping Scheduler Status", "completion": "    @Test\n    @Disabled // TODO FINERACT-1167\n    public void testFlippingSchedulerStatus() throws InterruptedException {\n        // Retrieving Status of Scheduler\n        Boolean schedulerStatus = schedulerJobHelper.getSchedulerStatus();\n        if (schedulerStatus == true) {\n            schedulerJobHelper.updateSchedulerStatus(false);\n            schedulerStatus = schedulerJobHelper.getSchedulerStatus();\n            // Verifying Status of the Scheduler after stopping\n            assertEquals(false, schedulerStatus, \"Verifying Scheduler Job Status\");\n        } else {\n            schedulerJobHelper.updateSchedulerStatus(true);\n            schedulerStatus = schedulerJobHelper.getSchedulerStatus();\n            // Verifying Status of the Scheduler after starting\n            assertEquals(true, schedulerStatus, \"Verifying Scheduler Job Status\");\n        }\n    }"}
{"prompt": "Create a test that tests test Number Of Jobs", "completion": "    @Test\n    public void testNumberOfJobs() {\n        List<Integer> jobIds = schedulerJobHelper.getAllSchedulerJobIds();\n        assertEquals(JobName.values().length, jobIds.size(), \"Number of jobs in database and code do not match: \" + jobIds);\n    }"}
{"prompt": "Create a test that tests test Flipping Jobs Active Status", "completion": "    @Test\n    public void testFlippingJobsActiveStatus() throws InterruptedException {\n        // Stop the Scheduler while we test flapping jobs' active on/off, to\n        // avoid side\n        // effects\n        schedulerJobHelper.updateSchedulerStatus(false);\n\n        // For each retrieved scheduled job (by ID)...\n        for (Integer jobId : schedulerJobHelper.getAllSchedulerJobIds()) {\n            // Retrieving Scheduler Job by ID\n            Map<String, Object> schedulerJob = schedulerJobHelper.getSchedulerJobById(jobId);\n\n            Boolean active = (Boolean) schedulerJob.get(\"active\");\n            active = !active;\n\n            // Updating Scheduler Job\n            Map<String, Object> changes = schedulerJobHelper.updateSchedulerJob(jobId, active);\n\n            // Verifying Scheduler Job updates\n            assertEquals(active, changes.get(\"active\"), \"Verifying Scheduler Job Updates\");\n\n            schedulerJob = schedulerJobHelper.getSchedulerJobById(jobId);\n            assertEquals(active, schedulerJob.get(\"active\"), \"Verifying Get Scheduler Job\");\n        }\n    }"}
{"prompt": "Create a test that tests test Triggering Manual Execution Of All Scheduler Jobs", "completion": "    @Test\n    public void testTriggeringManualExecutionOfAllSchedulerJobs() {\n        ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            for (String jobName : schedulerJobHelper.getAllSchedulerJobNames()) {\n                schedulerJobHelper.executeAndAwaitJob(jobName);\n            }\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Apply Annual Fee For Savings Job Outcome", "completion": "    @Test\n    public void testApplyAnnualFeeForSavingsJobOutcome() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsProductID = createSavingsProduct(requestSpec, responseSpec,\n                ClientSavingsIntegrationTest.MINIMUM_OPENING_BALANCE);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID,\n                ClientSavingsIntegrationTest.ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        final Integer annualFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper.getSavingsAnnualFeeJSON());\n        Assertions.assertNotNull(annualFeeChargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, annualFeeChargeId, true);\n        ArrayList<HashMap> chargesPendingState = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertEquals(1, chargesPendingState.size());\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        String JobName = \"Apply Annual Fee For Savings\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        final HashMap savingsDetails = this.savingsAccountHelper.getSavingsDetails(savingsId);\n        final HashMap annualFeeDetails = (HashMap) savingsDetails.get(\"annualFee\");\n        ArrayList<Integer> annualFeeDueDateAsArrayList = (ArrayList<Integer>) annualFeeDetails.get(\"dueDate\");\n        LocalDate nextDueDateForAnnualFee = LocalDate.of(annualFeeDueDateAsArrayList.get(0), annualFeeDueDateAsArrayList.get(1),\n                annualFeeDueDateAsArrayList.get(2));\n        LocalDate todaysDate = LocalDate.now(ZoneId.of(\"Asia/Kolkata\"));\n\n        Truth.assertWithMessage(\"Verifying that all due Annual Fees have been paid\").that(nextDueDateForAnnualFee)\n                .isGreaterThan(todaysDate);\n    }"}
{"prompt": "Create a test that tests test Interest Posting For Savings Job Outcome", "completion": "    @Test\n    public void testInterestPostingForSavingsJobOutcome() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsProductID = createSavingsProduct(requestSpec, responseSpec,\n                ClientSavingsIntegrationTest.MINIMUM_OPENING_BALANCE);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID,\n                ClientSavingsIntegrationTest.ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        String JobName = \"Post Interest For Savings\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n        final HashMap summaryAfter = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        Assertions.assertNotSame(summaryBefore.get(\"accountBalance\"), summaryAfter.get(\"accountBalance\"),\n                \"Verifying the Balance after running Post Interest for Savings Job\");\n    }"}
{"prompt": "Create a test that tests test Transfer Fee For Loans From Savings Job Outcome", "completion": "    @Test\n    public void testTransferFeeForLoansFromSavingsJobOutcome() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsProductID = createSavingsProduct(requestSpec, responseSpec,\n                ClientSavingsIntegrationTest.MINIMUM_OPENING_BALANCE);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID,\n                ClientSavingsIntegrationTest.ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        final Integer loanProductID = createLoanProduct(null);\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), savingsId.toString(),\n                \"10 January 2013\");\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(AccountTransferTest.LOAN_APPROVAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        Integer specifiedDueDateChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateWithAccountTransferJSON());\n        Assertions.assertNotNull(specifiedDueDateChargeId);\n\n        this.loanTransactionHelper.addChargesForLoan(loanID,\n                LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(specifiedDueDateChargeId.toString(), \"12 March 2013\", \"100\"));\n        ArrayList<HashMap> chargesPendingState = this.loanTransactionHelper.getLoanCharges(loanID);\n        Assertions.assertEquals(1, chargesPendingState.size());\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(AccountTransferTest.LOAN_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n        final HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        String JobName = \"Transfer Fee For Loans From Savings\";\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n        final HashMap summaryAfter = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        final HashMap chargeData = ChargesHelper.getChargeById(requestSpec, responseSpec, specifiedDueDateChargeId);\n\n        Float chargeAmount = (Float) chargeData.get(\"amount\");\n\n        final Float balance = (Float) summaryBefore.get(\"accountBalance\") - chargeAmount;\n\n        Assertions.assertEquals(balance, (Float) summaryAfter.get(\"accountBalance\"),\n                \"Verifying the Balance after running Transfer Fee for Loans from Savings\");\n    }"}
{"prompt": "Create a test that tests test Apply Holidays To Loans Job Outcome", "completion": "    @Test\n    public void testApplyHolidaysToLoansJobOutcome() throws InterruptedException {\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer holidayId = HolidayHelper.createHolidays(requestSpec, responseSpec);\n        Assertions.assertNotNull(holidayId);\n\n        final Integer loanProductID = createLoanProduct(null);\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2013\");\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(AccountTransferTest.LOAN_APPROVAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(AccountTransferTest.LOAN_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // Retrieving All Global Configuration details\n        final ArrayList<HashMap> globalConfig = GlobalConfigurationHelper.getAllGlobalConfigurations(requestSpec, responseSpec);\n        Assertions.assertNotNull(globalConfig);\n\n        // Updating Value for reschedule-repayments-on-holidays Global\n        // Configuration\n        Integer configId = (Integer) globalConfig.get(3).get(\"id\");\n        Assertions.assertNotNull(configId);\n\n        HashMap configData = GlobalConfigurationHelper.getGlobalConfigurationById(requestSpec, responseSpec, configId.toString());\n        Assertions.assertNotNull(configData);\n\n        Boolean enabled = (Boolean) globalConfig.get(3).get(\"enabled\");\n\n        if (!enabled) {\n            enabled = true;\n            configId = GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(requestSpec, responseSpec, configId, enabled);\n        }\n\n        holidayId = HolidayHelper.activateHolidays(requestSpec, responseSpec, holidayId.toString());\n        Assertions.assertNotNull(holidayId);\n\n        String JobName = \"Apply Holidays To Loans\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        HashMap holidayData = HolidayHelper.getHolidayById(requestSpec, responseSpec, holidayId.toString());\n        ArrayList<Integer> repaymentsRescheduledDate = (ArrayList<Integer>) holidayData.get(\"repaymentsRescheduledTo\");\n\n        Assertions.assertEquals(repaymentsRescheduledDate, repaymentsRescheduledDate,\n                \"Verifying Repayment Rescheduled Date after Running Apply Holidays to Loans Scheduler Job\");\n    }"}
{"prompt": "Create a test that tests test Apply Due Fee Charges For Savings Job Outcome", "completion": "    @Test\n    public void testApplyDueFeeChargesForSavingsJobOutcome() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsProductID = createSavingsProduct(requestSpec, responseSpec,\n                ClientSavingsIntegrationTest.MINIMUM_OPENING_BALANCE);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID,\n                ClientSavingsIntegrationTest.ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        final Integer specifiedDueDateChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getSavingsSpecifiedDueDateJSON());\n        Assertions.assertNotNull(specifiedDueDateChargeId);\n\n        this.savingsAccountHelper.addChargesForSavings(savingsId, specifiedDueDateChargeId, true);\n        ArrayList<HashMap> chargesPendingState = this.savingsAccountHelper.getSavingsCharges(savingsId);\n        Assertions.assertEquals(1, chargesPendingState.size());\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        HashMap summaryBefore = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        String JobName = \"Pay Due Savings Charges\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n        HashMap summaryAfter = this.savingsAccountHelper.getSavingsSummary(savingsId);\n\n        final HashMap chargeData = ChargesHelper.getChargeById(requestSpec, responseSpec, specifiedDueDateChargeId);\n\n        Float chargeAmount = (Float) chargeData.get(\"amount\");\n\n        final Float balance = (Float) summaryBefore.get(\"accountBalance\") - chargeAmount;\n\n        Assertions.assertEquals(balance, (Float) summaryAfter.get(\"accountBalance\"),\n                \"Verifying the Balance after running Pay due Savings Charges\");\n    }"}
{"prompt": "Create a test that tests test Update Accounting Running Balances Job Outcome", "completion": "    @Test\n    public void testUpdateAccountingRunningBalancesJobOutcome() {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n\n        final Account assetAccount = this.accountHelper.createAssetAccount();\n        final Account incomeAccount = this.accountHelper.createIncomeAccount();\n        final Account expenseAccount = this.accountHelper.createExpenseAccount();\n        final Account liabilityAccount = this.accountHelper.createLiabilityAccount();\n\n        final Integer accountID = assetAccount.getAccountID();\n\n        final Integer savingsProductID = createSavingsProduct(MINIMUM_OPENING_BALANCE, assetAccount, incomeAccount, expenseAccount,\n                liabilityAccount);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec, DATE_OF_JOINING);\n        final Integer savingsID = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, savingsID);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsID);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsID);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n\n        // Checking initial Account entries.\n        final JournalEntry[] assetAccountInitialEntry = { new JournalEntry(SP_BALANCE, JournalEntry.TransactionType.DEBIT) };\n        final JournalEntry[] liabilityAccountInitialEntry = { new JournalEntry(SP_BALANCE, JournalEntry.TransactionType.CREDIT) };\n        this.journalEntryHelper.checkJournalEntryForAssetAccount(assetAccount, TRANSACTION_DATE, assetAccountInitialEntry);\n        this.journalEntryHelper.checkJournalEntryForLiabilityAccount(liabilityAccount, TRANSACTION_DATE, liabilityAccountInitialEntry);\n\n        String JobName = \"Update Accounting Running Balances\";\n\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n        final HashMap runningBalanceAfter = this.accountHelper.getAccountingWithRunningBalanceById(accountID.toString());\n\n        final Integer INT_BALANCE = Integer.valueOf(MINIMUM_OPENING_BALANCE);\n\n        Assertions.assertEquals(INT_BALANCE, runningBalanceAfter.get(\"organizationRunningBalance\"),\n                \"Verifying Account Running Balance after running Update Accounting Running Balances Scheduler Job\");\n    }"}
{"prompt": "Create a test that tests test Update Loan Arrears Aging Job Outcome", "completion": "    @Test\n    public void testUpdateLoanArrearsAgingJobOutcome() {\n        loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        final Integer loanProductID = createLoanProduct(null);\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2013\");\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = loanTransactionHelper.approveLoan(AccountTransferTest.LOAN_APPROVAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(AccountTransferTest.LOAN_DISBURSAL_DATE, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        String JobName = \"Update Loan Arrears Ageing\";\n\n        schedulerJobHelper.executeAndAwaitJob(JobName);\n        HashMap loanSummaryData = loanTransactionHelper.getLoanSummary(requestSpec, responseSpec, loanID);\n\n        Float totalLoanArrearsAging = (Float) loanSummaryData.get(\"principalOverdue\") + (Float) loanSummaryData.get(\"interestOverdue\");\n\n        Assertions.assertEquals(totalLoanArrearsAging, loanSummaryData.get(\"totalOverdue\"),\n                \"Verifying Arrears Aging after Running Update Loan Arrears Aging Scheduler Job\");\n    }"}
{"prompt": "Create a test that tests test Execute Standing Instructions Job Outcome", "completion": "    @Test\n    public void testExecuteStandingInstructionsJobOutcome() throws InterruptedException {\n        savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        StandingInstructionsHelper standingInstructionsHelper = new StandingInstructionsHelper(requestSpec, responseSpec);\n\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"dd MMMM yyyy\", Locale.US);\n        final DateTimeFormatter monthDayFormat = DateTimeFormatter.ofPattern(\"dd MMMM\", Locale.US);\n\n        // Create the LocalDate with the Zone used by default\n        final LocalDate localDate = LocalDate.now(this.systemTimeZone.toZoneId());\n        ZonedDateTime currentDate = ZonedDateTime.of(localDate, LocalTime.MIDNIGHT, this.systemTimeZone.toZoneId());\n        // When the Stanging Instruction will be applied\n        final String MONTH_DAY = monthDayFormat.format(currentDate.toLocalDate());\n        // Standing Instruction valid from (One week before today)\n        currentDate = currentDate.minus(Duration.ofDays(7));\n        final String VALID_FROM = dateFormat.format(currentDate);\n        // Standing Instruction valid to (One year after)\n        currentDate = currentDate.plus(1, ChronoUnit.YEARS);\n        final String VALID_TO = dateFormat.format(currentDate);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        final Integer savingsProductID = createSavingsProduct(requestSpec, responseSpec,\n                ClientSavingsIntegrationTest.MINIMUM_OPENING_BALANCE);\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer fromSavingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID,\n                ClientSavingsIntegrationTest.ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap fromSavingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, fromSavingsId);\n        SavingsStatusChecker.verifySavingsIsPending(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.approveSavings(fromSavingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(fromSavingsStatusHashMap);\n\n        fromSavingsStatusHashMap = this.savingsAccountHelper.activateSavings(fromSavingsId);\n        SavingsStatusChecker.verifySavingsIsActive(fromSavingsStatusHashMap);\n\n        final Integer toSavingsId = this.savingsAccountHelper.applyForSavingsApplication(clientID, savingsProductID,\n                ClientSavingsIntegrationTest.ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsProductID);\n\n        HashMap toSavingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, toSavingsId);\n        SavingsStatusChecker.verifySavingsIsPending(toSavingsStatusHashMap);\n\n        toSavingsStatusHashMap = this.savingsAccountHelper.approveSavings(toSavingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(toSavingsStatusHashMap);\n\n        toSavingsStatusHashMap = this.savingsAccountHelper.activateSavings(toSavingsId);\n        SavingsStatusChecker.verifySavingsIsActive(toSavingsStatusHashMap);\n\n        HashMap fromSavingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(fromSavingsId);\n        Float fromSavingsBalanceBefore = (Float) fromSavingsSummaryBefore.get(\"accountBalance\");\n\n        HashMap toSavingsSummaryBefore = this.savingsAccountHelper.getSavingsSummary(toSavingsId);\n        Float toSavingsBalanceBefore = (Float) toSavingsSummaryBefore.get(\"accountBalance\");\n\n        Integer standingInstructionId = standingInstructionsHelper.createStandingInstruction(clientID.toString(), fromSavingsId.toString(),\n                toSavingsId.toString(), FROM_ACCOUNT_TYPE_SAVINGS, TO_ACCOUNT_TYPE_SAVINGS, VALID_FROM, VALID_TO, MONTH_DAY);\n        Assertions.assertNotNull(standingInstructionId);\n\n        String JobName = \"Execute Standing Instruction\";\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n        HashMap fromSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(fromSavingsId);\n        Float fromSavingsBalanceAfter = (Float) fromSavingsSummaryAfter.get(\"accountBalance\");\n\n        HashMap toSavingsSummaryAfter = this.savingsAccountHelper.getSavingsSummary(toSavingsId);\n        Float toSavingsBalanceAfter = (Float) toSavingsSummaryAfter.get(\"accountBalance\");\n\n        final HashMap standingInstructionData = standingInstructionsHelper.getStandingInstructionById(standingInstructionId.toString());\n        Float expectedFromSavingsBalance = fromSavingsBalanceBefore - (Float) standingInstructionData.get(\"amount\");\n        Float expectedToSavingsBalance = toSavingsBalanceBefore + (Float) standingInstructionData.get(\"amount\");\n\n        Assertions.assertEquals(expectedFromSavingsBalance, fromSavingsBalanceAfter,\n                \"Verifying From Savings Balance after Successful completion of Scheduler Job\");\n        Assertions.assertEquals(expectedToSavingsBalance, toSavingsBalanceAfter,\n                \"Verifying To Savings Balance after Successful completion of Scheduler Job\");\n        Integer fromAccountType = PortfolioAccountType.SAVINGS.getValue();\n        Integer transferType = AccountTransferType.ACCOUNT_TRANSFER.getValue();\n        List<HashMap> standingInstructionHistoryData = standingInstructionsHelper.getStandingInstructionHistory(fromSavingsId,\n                fromAccountType, clientID, transferType);\n        Assertions.assertEquals(1, standingInstructionHistoryData.size(),\n                \"Verifying the no of standing instruction transactions logged for the client\");\n        HashMap loggedTransaction = standingInstructionHistoryData.get(0);\n\n        Assertions.assertEquals((Float) standingInstructionData.get(\"amount\"), (Float) loggedTransaction.get(\"amount\"),\n                \"Verifying transferred amount and logged transaction amounts\");\n    }"}
{"prompt": "Create a test that tests test Apply Penalty For Overdue Loans Job Outcome", "completion": "    @Test\n    public void testApplyPenaltyForOverdueLoansJobOutcome() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper.getLoanOverdueFeeJSON());\n        Assertions.assertNotNull(overdueFeeChargeId);\n\n        final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        String JobName = \"Apply penalty to overdue loans\";\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        final HashMap chargeData = ChargesHelper.getChargeById(requestSpec, responseSpec, overdueFeeChargeId);\n\n        Float chargeAmount = (Float) chargeData.get(\"amount\");\n\n        ArrayList<HashMap> repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec,\n                loanID);\n\n        Assertions.assertEquals(chargeAmount, (Float) repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                \"Verifying From Penalty Charges due fot first Repayment after Successful completion of Scheduler Job\");\n\n        loanStatusHashMap = this.loanTransactionHelper.undoDisbursal(loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n    }"}
{"prompt": "Create a test that tests test Apply Penalty For Overdue Loans Job Outcome If Loan Charged Off", "completion": "    @Test\n    public void testApplyPenaltyForOverdueLoansJobOutcomeIfLoanChargedOff() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, ChargesHelper.getLoanOverdueFeeJSON());\n        Assertions.assertNotNull(overdueFeeChargeId);\n\n        final Integer loanProductID = createLoanProductNoInterest(overdueFeeChargeId.toString());\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplicationNoInterest(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        this.loanTransactionHelper.chargeOffLoan((long) loanID,\n                new PostLoansLoanIdTransactionsRequest().transactionDate(\"03 March 2020\").locale(\"en\").dateFormat(\"dd MMMM yyyy\"));\n\n        String JobName = \"Apply penalty to overdue loans\";\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        ArrayList<HashMap> repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec,\n                loanID);\n\n        Assertions.assertEquals(0, (Integer) repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                \"Verifying From Penalty Charges due fot first Repayment after Successful completion of Scheduler Job\");\n\n    }"}
{"prompt": "Create a test that tests test Loan COBJob Outcome", "completion": "    @Test\n    public void testLoanCOBJobOutcome() {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n        Assertions.assertNotNull(overdueFeeChargeId);\n\n        Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n        Assertions.assertNotNull(fee);\n\n        final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n        Assertions.assertNotNull(loanProductID);\n        List<Integer> loanIDs = new ArrayList<>();\n        HashMap loanStatusHashMap;\n        for (int i = 0; i < 3; i++) {\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n            loanIDs.add(loanID);\n\n            this.loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), \"02 March 2020\", \"10\", null));\n        }\n\n        String jobName = \"Loan COB\";\n        this.schedulerJobHelper.executeAndAwaitJob(jobName);\n        for (Integer loanId : loanIDs) {\n            List<HashMap> repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec,\n                    loanId);\n\n            Assertions.assertEquals(10.00f, (Float) repaymentScheduleDataAfter.get(1).get(\"feeChargesDue\"),\n                    \"Verifying From Fee Charges due for first Repayment after Successful completion of Scheduler Job\");\n            Assertions.assertEquals(39.39f, (Float) repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due for first Repayment after Successful completion of Scheduler Job\");\n            Assertions.assertEquals(39.39f, (Float) repaymentScheduleDataAfter.get(2).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due for first Repayment after Successful completion of Scheduler Job\");\n            Assertions.assertEquals(39.39f, (Float) repaymentScheduleDataAfter.get(3).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due for first Repayment after Successful completion of Scheduler Job\");\n            Assertions.assertEquals(39.39f, (Float) repaymentScheduleDataAfter.get(4).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due for first Repayment after Successful completion of Scheduler Job\");\n\n        }\n    }"}
{"prompt": "Create a test that tests test Loan COBJob Outcome While Adding Fee On Disbursement Date", "completion": "    @Test\n    public void testLoanCOBJobOutcomeWhileAddingFeeOnDisbursementDate() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n            this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer fee = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", false));\n            Assertions.assertNotNull(fee);\n\n            final Integer loanProductID = createLoanProductWithPeriodicAccrual(null);\n            Assertions.assertNotNull(loanProductID);\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            this.loanTransactionHelper.addChargesForLoan(loanID,\n                    LoanTransactionHelper.getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(fee), \"02 March 2020\", \"10\", null));\n\n            String jobName = \"Loan COB\";\n            this.schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            List<HashMap> repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec,\n                    loanID);\n\n            Assertions.assertEquals(10.00f, (Float) repaymentScheduleDataAfter.get(1).get(\"feeChargesDue\"),\n                    \"Verifying From Fee Charges due for first Repayment after Successful completion of Scheduler Job\");\n\n            GetLoansLoanIdResponse getLoansLoanIdResponse = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            // First accrual transaction\n            assertTrue(getLoansLoanIdResponse.getTransactions().get(1).getType().getAccrual());\n            assertEquals(10.0f, getLoansLoanIdResponse.getTransactions().get(1).getFeeChargesPortion());\n            assertEquals(LocalDate.of(2020, 3, 2), getLoansLoanIdResponse.getTransactions().get(1).getDate());\n            Long transactionId = getLoansLoanIdResponse.getTransactions().get(1).getId();\n\n            final GetJournalEntriesTransactionIdResponse journalEntriesResponse = journalEntryHelper.getJournalEntries(\"L\" + transactionId);\n            assertNotNull(journalEntriesResponse);\n            final List<JournalEntryTransactionItem> journalEntries = journalEntriesResponse.getPageItems();\n            assertEquals(2, journalEntries.size());\n            assertEquals(10, journalEntries.get(0).getAmount());\n            assertEquals(10, journalEntries.get(1).getAmount());\n            assertEquals(LocalDate.of(2020, 3, 2), journalEntries.get(1).getTransactionDate());\n            assertEquals(LocalDate.of(2020, 3, 2), journalEntries.get(0).getTransactionDate());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Loan COBRuns Only On Loans One Day Behind", "completion": "    @Test\n    public void testLoanCOBRunsOnlyOnLoansOneDayBehind() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            String jobName = \"Loan COB\";\n\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 2), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 3));\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 3), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 5));\n            schedulerJobHelper.executeAndAwaitJob(jobName);\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 3), loan.getLastClosedBusinessDate());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Loan COBApply Penalty On Due", "completion": "    @Test\n    public void testLoanCOBApplyPenaltyOnDue() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            // set penalty wait period to 0\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"0\");\n            this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 4, 1));\n            String jobName = \"Loan COB\";\n\n            this.schedulerJobHelper.executeAndAwaitJob(jobName);\n            List<HashMap> repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec,\n                    loanID);\n            Assertions.assertEquals(0, (Integer) repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due fot first Repayment after Successful completion of Scheduler Job\");\n\n            LocalDate lastBusinessDateBeforeFastForward = LocalDate.of(2020, 4, 2);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, lastBusinessDateBeforeFastForward);\n            this.schedulerJobHelper.executeAndAwaitJob(jobName);\n            repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(39.39f, (Float) repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due fot first Repayment after Successful completion of Scheduler Job\");\n\n            List<Map> transactions = this.loanTransactionHelper.getLoanTransactions(this.requestSpec, this.responseSpec, loanID);\n            Assertions.assertEquals(39.39f, (Float) transactions.get(2).get(\"amount\"));\n            Assertions.assertEquals(2020, ((List) transactions.get(2).get(\"date\")).get(0));\n            Assertions.assertEquals(4, ((List) transactions.get(2).get(\"date\")).get(1));\n            Assertions.assertEquals(2, ((List) transactions.get(2).get(\"date\")).get(2));\n\n            // Test penalty where there is 1 day grace period\n            final Integer loanID2 = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID2);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID2);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"01 April 2020\", loanID2);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails2 = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID2);\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 April 2020\", loanID2,\n                    JsonPath.from(loanDetails2).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"1\");\n            LocalDate dateToFastForward = LocalDate.of(2020, 5, 2);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, dateToFastForward);\n            this.schedulerJobHelper.executeAndAwaitJob(jobName);\n            repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID2);\n            Assertions.assertEquals(0, (Integer) repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due fot first Repayment after Successful completion of Scheduler Job\");\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 5, 3));\n            this.schedulerJobHelper.executeAndAwaitJob(jobName);\n            repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec, loanID2);\n            Assertions.assertEquals(39.39f, (Float) repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                    \"Verifying From Penalty Charges due fot first Repayment after Successful completion of Scheduler Job\");\n\n            transactions = this.loanTransactionHelper.getLoanTransactions(this.requestSpec, this.responseSpec, loanID2);\n            Assertions.assertEquals(39.39f, (Float) transactions.get(2).get(\"amount\"));\n            Assertions.assertEquals(2020, ((List) transactions.get(2).get(\"date\")).get(0));\n            Assertions.assertEquals(5, ((List) transactions.get(2).get(\"date\")).get(1));\n            Assertions.assertEquals(2, ((List) transactions.get(2).get(\"date\")).get(2));\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"2\");\n        }\n    }"}
{"prompt": "Create a test that tests test Avoid Unncessary Penalty When Amount Zero For Overdue Loans Job Outcome", "completion": "    @Test\n    public void testAvoidUnncessaryPenaltyWhenAmountZeroForOverdueLoansJobOutcome() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"0.000001\"));\n        Assertions.assertNotNull(overdueFeeChargeId);\n\n        final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2013\");\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(AccountTransferTest.LOAN_APPROVAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(AccountTransferTest.LOAN_APPROVAL_DATE_PLUS_ONE,\n                loanID, JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        String JobName = \"Apply penalty to overdue loans\";\n        int jobId = 12;\n\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n\n        Map<String, Object> schedulerJob = this.schedulerJobHelper.getSchedulerJobById(jobId);\n\n        Assertions.assertNotNull(schedulerJob);\n        while ((Boolean) schedulerJob.get(\"currentlyRunning\")) {\n            Thread.sleep(15000);\n            schedulerJob = this.schedulerJobHelper.getSchedulerJobById(jobId);\n            Assertions.assertNotNull(schedulerJob);\n        }\n\n        ArrayList<HashMap> repaymentScheduleDataAfter = this.loanTransactionHelper.getLoanRepaymentSchedule(requestSpec, responseSpec,\n                loanID);\n\n        Assertions.assertEquals(0, repaymentScheduleDataAfter.get(1).get(\"penaltyChargesDue\"),\n                \"Verifying From Penalty Charges due fot first Repayment after Successful completion of Scheduler Job\");\n\n        final List<?> loanCharges = this.loanTransactionHelper.getLoanCharges(requestSpec, responseSpec, loanID);\n        Assertions.assertNull(loanCharges, \"Verifying that charge isn't created when the amount is 0\");\n\n        loanStatusHashMap = this.loanTransactionHelper.undoDisbursal(loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n    }"}
{"prompt": "Create a test that tests test Update Overdue Days For NPA", "completion": "    @Test\n    public void testUpdateOverdueDaysForNPA() throws InterruptedException {\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientID);\n\n        final Integer loanProductID = createLoanProduct(null);\n        Assertions.assertNotNull(loanProductID);\n\n        final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2013\");\n        Assertions.assertNotNull(loanID);\n\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(AccountTransferTest.LOAN_APPROVAL_DATE, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(AccountTransferTest.LOAN_APPROVAL_DATE_PLUS_ONE,\n                loanID, JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        final Boolean isNPABefore = (Boolean) this.loanTransactionHelper.getLoanDetail(requestSpec, responseSpec, loanID, \"isNPA\");\n        Assertions.assertFalse(isNPABefore);\n        String JobName = \"Update Non Performing Assets\";\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n        final Boolean isNPAAfter = (Boolean) this.loanTransactionHelper.getLoanDetail(requestSpec, responseSpec, loanID, \"isNPA\");\n        assertTrue(isNPAAfter);\n    }"}
{"prompt": "Create a test that tests test Interest Transfer For Savings", "completion": "    @Test\n    public void testInterestTransferForSavings() throws InterruptedException {\n        this.savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        FixedDepositAccountHelper fixedDepositAccountHelper = new FixedDepositAccountHelper(requestSpec, responseSpec);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -3);\n        final String VALID_FROM = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.YEAR, 10);\n        final String VALID_TO = dateFormat.format(todaysDate.getTime());\n\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.MONTH, -2);\n        final String SUBMITTED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String APPROVED_ON_DATE = dateFormat.format(todaysDate.getTime());\n        final String ACTIVATION_DATE = dateFormat.format(todaysDate.getTime());\n        todaysDate.add(Calendar.MONTH, 1);\n        final String WHOLE_TERM = \"1\";\n\n        Integer clientId = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(clientId);\n        Float balance = Float.parseFloat(MINIMUM_OPENING_BALANCE) + Float.parseFloat(FixedDepositAccountHelper.DEPOSIT_AMOUNT);\n        final Integer savingsProductID = createSavingsProduct(requestSpec, responseSpec, String.valueOf(balance));\n        Assertions.assertNotNull(savingsProductID);\n\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplication(clientId, savingsProductID,\n                ClientSavingsIntegrationTest.ACCOUNT_TYPE_INDIVIDUAL);\n        Assertions.assertNotNull(savingsId);\n\n        HashMap savingsStatusHashMap = SavingsStatusChecker.getStatusOfSavings(requestSpec, responseSpec, savingsId);\n        SavingsStatusChecker.verifySavingsIsPending(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.approveSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsApproved(savingsStatusHashMap);\n\n        savingsStatusHashMap = this.savingsAccountHelper.activateSavings(savingsId);\n        SavingsStatusChecker.verifySavingsIsActive(savingsStatusHashMap);\n        HashMap summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying opening Balance\");\n\n        Integer fixedDepositProductId = createFixedDepositProduct(VALID_FROM, VALID_TO);\n        Assertions.assertNotNull(fixedDepositProductId);\n\n        Integer fixedDepositAccountId = applyForFixedDepositApplication(clientId.toString(), fixedDepositProductId.toString(),\n                SUBMITTED_ON_DATE, WHOLE_TERM, savingsId.toString());\n        Assertions.assertNotNull(fixedDepositAccountId);\n\n        HashMap fixedDepositAccountStatusHashMap = FixedDepositAccountStatusChecker.getStatusOfFixedDepositAccount(requestSpec,\n                responseSpec, fixedDepositAccountId.toString());\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsPending(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = fixedDepositAccountHelper.approveFixedDeposit(fixedDepositAccountId, APPROVED_ON_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsApproved(fixedDepositAccountStatusHashMap);\n\n        fixedDepositAccountStatusHashMap = fixedDepositAccountHelper.activateFixedDeposit(fixedDepositAccountId, ACTIVATION_DATE);\n        FixedDepositAccountStatusChecker.verifyFixedDepositIsActive(fixedDepositAccountStatusHashMap);\n        summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(MINIMUM_OPENING_BALANCE);\n        assertEquals(balance, summary.get(\"accountBalance\"), \"Verifying Balance\");\n\n        fixedDepositAccountHelper.postInterestForFixedDeposit(fixedDepositAccountId);\n\n        HashMap fixedDepositSummary = savingsAccountHelper.getSavingsSummary(fixedDepositAccountId);\n        float interestPosted = (Float) fixedDepositSummary.get(\"accountBalance\")\n                - Float.parseFloat(FixedDepositAccountHelper.DEPOSIT_AMOUNT);\n\n        String JobName = \"Transfer Interest To Savings\";\n        this.schedulerJobHelper.executeAndAwaitJob(JobName);\n        fixedDepositSummary = savingsAccountHelper.getSavingsSummary(fixedDepositAccountId);\n        assertEquals(Float.parseFloat(FixedDepositAccountHelper.DEPOSIT_AMOUNT), fixedDepositSummary.get(\"accountBalance\"),\n                \"Verifying opening Balance\");\n\n        summary = savingsAccountHelper.getSavingsSummary(savingsId);\n        balance = Float.parseFloat(MINIMUM_OPENING_BALANCE) + interestPosted;\n        validateNumberForEqualExcludePrecision(String.valueOf(balance), String.valueOf(summary.get(\"accountBalance\")));\n    }"}
{"prompt": "Create a test that tests business Date Is Correct For Cron Job", "completion": "    @Test\n    public void businessDateIsCorrectForCronJob() throws InterruptedException {\n        this.loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2022.09.04\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            final Account assetAccount = this.accountHelper.createAssetAccount();\n            final Account assetFeeAndPenaltyAccount = this.accountHelper.createAssetAccount();\n            final Account incomeAccount = this.accountHelper.createIncomeAccount();\n            final Account expenseAccount = this.accountHelper.createExpenseAccount();\n            final Account overpaymentAccount = this.accountHelper.createLiabilityAccount();\n\n            Integer penalty = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanSpecifiedDueDateJSON(ChargesHelper.CHARGE_CALCULATION_TYPE_FLAT, \"10\", true));\n\n            final String loanProductJSON = new LoanProductTestBuilder().withPrincipal(\"1000\").withRepaymentTypeAsMonth()\n                    .withRepaymentAfterEvery(\"1\").withNumberOfRepayments(\"1\").withRepaymentTypeAsMonth().withinterestRatePerPeriod(\"0\")\n                    .withInterestRateFrequencyTypeAsMonths().withAmortizationTypeAsEqualPrincipalPayment().withInterestTypeAsFlat()\n                    .withAccountingRulePeriodicAccrual(new Account[] { assetAccount, incomeAccount, expenseAccount, overpaymentAccount })\n                    .withDaysInMonth(\"30\").withDaysInYear(\"365\").withMoratorium(\"0\", \"0\")\n                    .withFeeAndPenaltyAssetAccount(assetFeeAndPenaltyAccount).build(null);\n            final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJSON);\n\n            final PostClientsResponse client = clientHelper.createClient(ClientHelper.defaultClientCreationRequest());\n\n            Integer loanId = applyForLoanApplication(client.getClientId().toString(), loanProductID.toString(), null, \"02 September 2022\");\n\n            this.loanTransactionHelper.approveLoan(\"02 September 2022\", loanId);\n            this.loanTransactionHelper.disburseLoan(\"03 September 2022\", loanId, \"1000\", null);\n\n            businessDateHelper.updateBusinessDate(new BusinessDateRequest().type(BusinessDateType.BUSINESS_DATE.getName())\n                    .date(\"2022.09.05\").dateFormat(\"yyyy.MM.dd\").locale(\"en\"));\n\n            LocalDate targetDate = LocalDate.of(2022, 9, 5);\n            String penaltyCharge1AddedDate = dateFormatter.format(targetDate);\n\n            this.loanTransactionHelper.addChargesForLoan(loanId, LoanTransactionHelper\n                    .getSpecifiedDueDateChargesForLoanAsJSON(String.valueOf(penalty), penaltyCharge1AddedDate, \"10\", null));\n            this.schedulerJobHelper.updateSchedulerJob(16L, new PutJobsJobIDRequest().cronExpression(\"0/5 * * * * ?\"));\n\n            Thread.sleep(11000);\n            GetLoansLoanIdResponse loanDetails = this.loanTransactionHelper.getLoanDetails((long) loanId);\n            assertEquals(LocalDate.of(2022, 9, 5), loanDetails.getTransactions().get(1).getDate());\n        } finally {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n\n        try {\n            this.schedulerJobHelper.updateSchedulerJob(16L, new PutJobsJobIDRequest().cronExpression(\"0 2 0 1/1 * ? *\"));\n        } catch (CallFailedRuntimeException e) {\n            // Try again (maybe it was executed by scheduler at the same time when it was called... :/\n            Thread.sleep(2000);\n            this.schedulerJobHelper.updateSchedulerJob(16L, new PutJobsJobIDRequest().cronExpression(\"0 2 0 1/1 * ? *\"));\n        }\n    }"}
{"prompt": "Create a test that tests test Datatable Creation For Share Product", "completion": "    @Test\n    public void testDatatableCreationForShareProduct() {\n        // create dataTable\n        String datatableName = Utils.uniqueRandomStringGenerator(\"dt_\" + SHARES_APP_TABLE_NAME + \"_\", 5).toLowerCase().toLowerCase();\n        String column1Name = \"aNumber\";\n        String column2Name = \"aString\";\n\n        PostDataTablesRequest request = new PostDataTablesRequest();\n        request.setDatatableName(datatableName);\n        request.setApptableName(SHARES_APP_TABLE_NAME);\n        request.setMultiRow(false);\n\n        PostColumnHeaderData column1HeaderRequestData = new PostColumnHeaderData();\n        column1HeaderRequestData.setName(column1Name);\n        column1HeaderRequestData.setType(\"Number\");\n        column1HeaderRequestData.setMandatory(false);\n        column1HeaderRequestData.setLength(10L);\n        column1HeaderRequestData.setCode(\"\");\n        column1HeaderRequestData.setUnique(false);\n        column1HeaderRequestData.setIndexed(false);\n\n        request.addColumnsItem(column1HeaderRequestData);\n\n        PostColumnHeaderData column2HeaderRequestData = new PostColumnHeaderData();\n        column2HeaderRequestData.setName(column2Name);\n        column2HeaderRequestData.setType(\"String\");\n        column2HeaderRequestData.setMandatory(false);\n        column2HeaderRequestData.setLength(10L);\n        column2HeaderRequestData.setCode(\"\");\n        column2HeaderRequestData.setUnique(false);\n        column2HeaderRequestData.setIndexed(false);\n\n        request.addColumnsItem(column2HeaderRequestData);\n\n        PostDataTablesResponse response = datatableHelper.createDatatable(request);\n\n        assertNotNull(response.getResourceIdentifier());\n\n        // verify Datatable got created\n        GetDataTablesResponse dataTable = datatableHelper.getDataTableDetails(datatableName);\n\n        // verfify columns\n        List<ResultsetColumnHeaderData> columnHeaderData = dataTable.getColumnHeaderData();\n        assertNotNull(columnHeaderData);\n\n        // two columns with 1 primary key and 2 audit columns created\n        assertEquals(columnHeaderData.size(), 5);\n    }"}
{"prompt": "Create a test that tests test Datatable Entry For Share Product", "completion": "    @Test\n    public void testDatatableEntryForShareProduct() {\n        // create Shares Product\n        shareProductHelper = new ShareProductHelper();\n        final Integer shareProductId = createShareProduct();\n\n        assertNotNull(shareProductId);\n\n        // create dataTable\n        String datatableName = Utils.uniqueRandomStringGenerator(\"dt_\" + SHARES_APP_TABLE_NAME + \"_\", 5).toLowerCase().toLowerCase();\n        String column1Name = \"aNumber\";\n\n        PostDataTablesRequest request = new PostDataTablesRequest();\n        request.setDatatableName(datatableName);\n        request.setApptableName(SHARES_APP_TABLE_NAME);\n        request.setMultiRow(true);\n\n        PostColumnHeaderData column1HeaderRequestData = new PostColumnHeaderData();\n        column1HeaderRequestData.setName(column1Name);\n        column1HeaderRequestData.setType(\"Number\");\n        column1HeaderRequestData.setMandatory(false);\n        column1HeaderRequestData.setLength(10L);\n        column1HeaderRequestData.setCode(\"\");\n        column1HeaderRequestData.setUnique(false);\n        column1HeaderRequestData.setIndexed(false);\n\n        request.addColumnsItem(column1HeaderRequestData);\n\n        PostDataTablesResponse response = datatableHelper.createDatatable(request);\n\n        assertNotNull(response);\n\n        String datatableId = response.getResourceIdentifier();\n\n        // add entries\n        final HashMap<String, Object> datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(column1Name, Utils.randomNumberGenerator(5));\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(\"dateFormat\", \"yyyy-MM-dd\");\n\n        String datatabelEntryRequestJsonString = new Gson().toJson(datatableEntryMap);\n\n        final boolean genericResultSet = true;\n\n        HashMap<String, Object> datatableEntryResponseFirst = this.datatableHelper.createDatatableEntry(datatableId, shareProductId,\n                genericResultSet, datatabelEntryRequestJsonString);\n        HashMap<String, Object> datatableEntryResponseSecond = this.datatableHelper.createDatatableEntry(datatableId, shareProductId,\n                genericResultSet, datatabelEntryRequestJsonString);\n\n        assertNotNull(datatableEntryResponseFirst.get(\"resourceId\"));\n        assertNotNull(datatableEntryResponseSecond.get(\"resourceId\"));\n\n        // Read the Datatable entry generated with genericResultSet\n        HashMap<String, Object> items = this.datatableHelper.readDatatableEntry(datatableId, shareProductId, genericResultSet, null, \"\");\n        assertNotNull(items);\n        assertEquals(2, ((List) items.get(\"data\")).size());\n    }"}
{"prompt": "Create a test that tests test Skipping Repayment On First Day Of Month", "completion": "    @Test\n    public void testSkippingRepaymentOnFirstDayOfMonth() {\n        this.globalConfigurationHelper = new GlobalConfigurationHelper(this.requestSpec, this.responseSpec);\n\n        // Retrieving All Global Configuration details\n        final ArrayList<HashMap> globalConfig = GlobalConfigurationHelper.getAllGlobalConfigurations(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(globalConfig);\n\n        String configName = \"skip-repayment-on-first-day-of-month\";\n        boolean newBooleanValue = true;\n\n        for (Integer configIndex = 0; configIndex < globalConfig.size(); configIndex++) {\n            if (globalConfig.get(configIndex).get(\"name\").equals(configName)) {\n                String configId = globalConfig.get(configIndex).get(\"id\").toString();\n                Integer updateConfigId = GlobalConfigurationHelper.updateEnabledFlagForGlobalConfiguration(this.requestSpec,\n                        this.responseSpec, configId.toString(), newBooleanValue);\n                Assertions.assertNotNull(updateConfigId);\n                break;\n            }\n        }\n\n    }"}
{"prompt": "Create a test that tests check Repayment Skip On First Day Of Month", "completion": "    @Test\n    public void checkRepaymentSkipOnFirstDayOfMonth() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Integer groupID = GroupHelper.createGroup(this.requestSpec, this.responseSpec, true);\n        groupID = GroupHelper.associateClient(this.requestSpec, this.responseSpec, groupID.toString(), clientID.toString());\n        final String startDate = \"15 September 2011\";\n        final String frequency = \"3\"; // Monthly\n        final String interval = \"1\"; // Every One Moth\n        Integer calendarID = CalendarHelper.createMeetingForGroup(requestSpec, responseSpec, groupID, startDate, frequency, interval, null);\n        LOG.info(\"caladerId -------------------- {}\", calendarID);\n        final Integer loanProductID = createLoanProduct();\n        final Integer loanID = applyForLoanApplication(groupID, loanProductID, calendarID, clientID);\n        LOG.info(\"loanID---- {}\", loanID);\n        final ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec,\n                loanID);\n        verifyLoanRepaymentSchedule(loanSchedule);\n\n    }"}
{"prompt": "Create a test that tests test Staff Create", "completion": "    @Test\n    public void testStaffCreate() {\n        Map<String, Object> response = StaffHelper.createStaffMap(requestSpec, responseSpec);\n\n        Assertions.assertNotNull(response);\n        Assertions.assertEquals(1, response.get(\"officeId\"));\n        Assertions.assertNotNull(response.get(\"resourceId\"));\n    }"}
{"prompt": "Create a test that tests test Staff Create Validation Error", "completion": "    @Test\n    public void testStaffCreateValidationError() {\n        final String noOfficeJson = StaffHelper.createStaffWithJSONFields(\"firstname\", \"lastname\");\n        final String noFirstnameJson = StaffHelper.createStaffWithJSONFields(\"officeId\", \"lastname\");\n        final String noLastnameJson = StaffHelper.createStaffWithJSONFields(\"officeId\", \"firstname\");\n\n        StaffHelper.createStaffWithJson(requestSpec, responseSpecForValidationError, noOfficeJson);\n        StaffHelper.createStaffWithJson(requestSpec, responseSpecForValidationError, noFirstnameJson);\n        StaffHelper.createStaffWithJson(requestSpec, responseSpecForValidationError, noLastnameJson);\n\n        final Map<String, Object> map = StaffHelper.getMapWithJoiningDate();\n\n        map.put(\"officeId\", 1);\n        map.put(\"firstname\", Utils.uniqueRandomStringGenerator(\"michael_\", 5));\n        map.put(\"lastname\", Utils.uniqueRandomStringGenerator(\"Doe_\", 4));\n\n        /** Long firstname test */\n        map.put(\"firstname\", Utils.uniqueRandomStringGenerator(\"michael_\", 43));\n        StaffHelper.createStaffWithJson(requestSpec, responseSpecForValidationError, new Gson().toJson(map));\n        map.put(\"firstname\", Utils.uniqueRandomStringGenerator(\"michael_\", 5));\n\n        /** Long lastname test */\n        map.put(\"lastname\", Utils.uniqueRandomStringGenerator(\"Doe_\", 47));\n        StaffHelper.createStaffWithJson(requestSpec, responseSpecForValidationError, new Gson().toJson(map));\n        map.put(\"lastname\", Utils.uniqueRandomStringGenerator(\"Doe_\", 4));\n\n        /** Long mobileNo test */\n        map.put(\"mobileNo\", Utils.uniqueRandomStringGenerator(\"num_\", 47));\n        StaffHelper.createStaffWithJson(requestSpec, responseSpecForValidationError, new Gson().toJson(map));\n    }"}
{"prompt": "Create a test that tests test Staff Create Max Name Length", "completion": "    @Test\n    public void testStaffCreateMaxNameLength() {\n\n        final Map<String, Object> map = StaffHelper.getMapWithJoiningDate();\n\n        map.put(\"officeId\", 1);\n        map.put(\"firstname\", Utils.uniqueRandomStringGenerator(\"michael_\", 42));\n        map.put(\"lastname\", Utils.uniqueRandomStringGenerator(\"Doe_\", 46));\n\n        StaffHelper.createStaffWithJson(requestSpec, responseSpec, new Gson().toJson(map));\n    }"}
{"prompt": "Create a test that tests test Staff Create External Id Validation Error", "completion": "    @Test\n    public void testStaffCreateExternalIdValidationError() {\n        final Map<String, Object> map = StaffHelper.getMapWithJoiningDate();\n\n        map.put(\"officeId\", 1);\n        map.put(\"firstname\", Utils.uniqueRandomStringGenerator(\"michael_\", 5));\n        map.put(\"lastname\", Utils.uniqueRandomStringGenerator(\"Doe_\", 4));\n\n        map.put(\"externalId\", Utils.randomStringGenerator(\"EXT\", 98));\n        StaffHelper.createStaffWithJson(requestSpec, responseSpecForValidationError, new Gson().toJson(map));\n    }"}
{"prompt": "Create a test that tests test Staff Fetch", "completion": "    @Test\n    public void testStaffFetch() {\n        Map<String, Object> response = StaffHelper.getStaff(requestSpec, responseSpec, 1);\n        Assertions.assertNotNull(response);\n        Assertions.assertNotNull(response.get(\"id\"));\n        Assertions.assertEquals(1, response.get(\"id\"));\n    }"}
{"prompt": "Create a test that tests test Staff List Fetch", "completion": "    @Test\n    public void testStaffListFetch() {\n        StaffHelper.getStaffList(requestSpec, responseSpec);\n    }"}
{"prompt": "Create a test that tests test Staff List Status All", "completion": "    @Test\n    public void testStaffListStatusAll() {\n        StaffHelper.getStaffListWithState(requestSpec, responseSpec, \"all\");\n    }"}
{"prompt": "Create a test that tests test Staff List Status Active", "completion": "    @Test\n    public void testStaffListStatusActive() {\n        List<Map<String, Object>> responseActive = StaffHelper.getStaffListWithState(requestSpec, responseSpec, \"active\");\n        for (final Map<String, Object> staff : responseActive) {\n            Assertions.assertNotNull(staff.get(\"id\"));\n            Assertions.assertEquals(true, staff.get(\"isActive\"));\n        }\n    }"}
{"prompt": "Create a test that tests test Staff List Status Inactive", "completion": "    @Test\n    public void testStaffListStatusInactive() {\n        List<Map<String, Object>> responseInactive = StaffHelper.getStaffListWithState(requestSpec, responseSpec, \"inactive\");\n        for (final Map<String, Object> staff : responseInactive) {\n            Assertions.assertNotNull(staff.get(\"id\"));\n            Assertions.assertEquals(false, staff.get(\"isActive\"));\n        }\n    }"}
{"prompt": "Create a test that tests test Staff List Fetch Wrong State", "completion": "    @Test // because \"xyz\" will return an error, not a List\n    public void testStaffListFetchWrongState() throws ClassCastException {\n        Assertions.assertThrows(ClassCastException.class, () -> {\n            StaffHelper.getStaffListWithState(requestSpec, responseSpecForValidationError, \"xyz\");\n        });\n    }"}
{"prompt": "Create a test that tests test Staff Fetch Not Found", "completion": "    @Test\n    public void testStaffFetchNotFound() {\n        StaffHelper.getStaff(requestSpec, responseSpecForNotFoundError, Integer.MAX_VALUE);\n    }"}
{"prompt": "Create a test that tests test Staff Update", "completion": "    @Test\n    public void testStaffUpdate() {\n        final Map<String, Object> map = new HashMap<>();\n        final String firstname = Utils.uniqueRandomStringGenerator(\"michael_\", 10);\n        final String lastname = Utils.uniqueRandomStringGenerator(\"Doe_\", 10);\n        final String externalId = UUID.randomUUID().toString();\n        final String mobileNo = Utils.uniqueRandomStringGenerator(\"num_\", 10);\n\n        map.put(\"firstname\", firstname);\n        map.put(\"lastname\", lastname);\n        map.put(\"externalId\", externalId);\n        map.put(\"mobileNo\", mobileNo);\n\n        Map<String, Object> response = StaffHelper.updateStaff(requestSpec, responseSpec, 1, map);\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> changes = (Map<String, Object>) response.get(\"changes\");\n\n        Assertions.assertEquals(1, response.get(\"resourceId\"));\n        Assertions.assertEquals(firstname, changes.get(\"firstname\"));\n        Assertions.assertEquals(lastname, changes.get(\"lastname\"));\n        Assertions.assertEquals(externalId, changes.get(\"externalId\"));\n        Assertions.assertEquals(mobileNo, changes.get(\"mobileNo\"));\n    }"}
{"prompt": "Create a test that tests test Staff Update Long External Id Error", "completion": "    @Test\n    public void testStaffUpdateLongExternalIdError() {\n        final HashMap<String, Object> map = new HashMap<>();\n        map.put(\"externalId\", Utils.randomStringGenerator(\"EXT\", 98));\n\n        StaffHelper.updateStaff(requestSpec, responseSpecForValidationError, 1, map);\n    }"}
{"prompt": "Create a test that tests test Staff Update Wrong Active State", "completion": "    @Test\n    public void testStaffUpdateWrongActiveState() {\n        final HashMap<String, Object> map = new HashMap<>();\n        map.put(\"isActive\", \"xyz\");\n\n        StaffHelper.updateStaff(requestSpec, responseSpecForValidationError, 1, map);\n    }"}
{"prompt": "Create a test that tests test Staff Update Not Found Error", "completion": "    @Test\n    public void testStaffUpdateNotFoundError() {\n        final HashMap<String, Object> map = new HashMap<>();\n        map.put(\"firstname\", Utils.uniqueRandomStringGenerator(\"michael_\", 5));\n\n        StaffHelper.updateStaff(requestSpec, responseSpecForNotFoundError, Integer.MAX_VALUE, map);\n    }"}
{"prompt": "Create a test that tests test Staff Update Validation Error", "completion": "    @Test\n    public void testStaffUpdateValidationError() {\n        final HashMap<String, Object> map = new HashMap<>();\n        final String firstname = Utils.uniqueRandomStringGenerator(\"michael_\", 5);\n        final String lastname = Utils.uniqueRandomStringGenerator(\"Doe_\", 4);\n        final String firstnameLong = Utils.uniqueRandomStringGenerator(\"michael_\", 43);\n        final String lastnameLong = Utils.uniqueRandomStringGenerator(\"Doe_\", 47);\n\n        map.put(\"firstname\", firstname);\n        map.put(\"lastname\", lastname);\n\n        /** Test long firstname */\n        map.put(\"firstname\", firstnameLong);\n        StaffHelper.updateStaff(requestSpec, responseSpecForValidationError, 1, map);\n        map.put(\"firstname\", firstname);\n\n        /** Test long lastname */\n        map.put(\"lastname\", lastnameLong);\n        StaffHelper.updateStaff(requestSpec, responseSpecForValidationError, 1, map);\n        map.put(\"lastname\", lastname);\n\n        /** Long mobileNo test */\n        map.put(\"mobileNo\", Utils.uniqueRandomStringGenerator(\"num_\", 47));\n        StaffHelper.updateStaff(requestSpec, responseSpecForValidationError, 1, map);\n        map.remove(\"mobileNo\");\n\n        /** Test unsupported parameter */\n        map.put(\"xyz\", \"xyz\");\n        StaffHelper.updateStaff(requestSpec, responseSpecForValidationError, 1, map);\n    }"}
{"prompt": "Create a test that tests test Staff Loan Officer", "completion": "    @Test\n    public void testStaffLoanOfficer() {\n        final Map<String, Object> map = StaffHelper.getMapWithJoiningDate();\n\n        map.put(\"officeId\", 1);\n        map.put(\"firstname\", Utils.uniqueRandomStringGenerator(\"michael_\", 5));\n        map.put(\"lastname\", Utils.uniqueRandomStringGenerator(\"Doe_\", 5));\n        map.put(\"isLoanOfficer\", true);\n\n        StaffHelper.createStaffWithJson(requestSpec, responseSpec, new Gson().toJson(map));\n\n        List<Map<String, Object>> responseActive = StaffHelper.getStaffListWithLoanOfficerStatus(requestSpec, responseSpec, \"true\");\n        for (final Map<String, Object> staff : responseActive) {\n            Assertions.assertNotNull(staff.get(\"id\"));\n            Assertions.assertEquals(true, staff.get(\"isLoanOfficer\"));\n        }\n    }"}
{"prompt": "Create a test that tests test Swaggerui Access", "completion": "    @Test\n    public void testSwaggeruiAccess() {\n        Utils.performServerGet(requestSpec, responseSpec, \"/fineract-provider/swagger-ui/index.html\", null);\n        Utils.performServerGet(requestSpec, responseSpec, \"/fineract-provider/fineract.json\", null);\n    }"}
{"prompt": "Create a test that tests test Create Code", "completion": "    @Test\n    // scenario 57, 58, 59, 60\n    public void testCreateCode() {\n        final String codeName = \"Client Marital Status\";\n\n        final Integer createResponseId = (Integer) CodeHelper.createCode(this.requestSpec, this.responseSpec, codeName,\n                CodeHelper.RESPONSE_ID_ATTRIBUTE_NAME);\n\n        // verify code created\n\n        final HashMap newCodeAttributes = (HashMap) CodeHelper.getCodeById(this.requestSpec, this.responseSpec, createResponseId, \"\");\n\n        Assertions.assertNotNull(newCodeAttributes);\n        assertEquals(createResponseId, newCodeAttributes.get(CodeHelper.CODE_ID_ATTRIBUTE_NAME), \"Verify value of codeId\");\n\n        assertEquals(codeName, newCodeAttributes.get(CodeHelper.CODE_NAME_ATTRIBUTE_NAME), \"Verify code name\");\n        assertEquals(false, newCodeAttributes.get(CodeHelper.CODE_SYSTEM_DEFINED_ATTRIBUTE_NAME), \"Verify system defined is false\");\n\n        // update code\n        final HashMap updateChangeResponse = (HashMap) CodeHelper.updateCode(this.requestSpec, this.responseSpec, createResponseId,\n                codeName + \"(CHANGE)\", \"changes\");\n\n        assertEquals(codeName + \"(CHANGE)\", updateChangeResponse.get(CodeHelper.CODE_NAME_ATTRIBUTE_NAME), \"Verify code name updated\");\n\n        // delete code\n        final Integer deleteResponseId = (Integer) CodeHelper.deleteCodeById(this.requestSpec, this.responseSpec, createResponseId,\n                CodeHelper.RESPONSE_ID_ATTRIBUTE_NAME);\n        assertEquals(createResponseId, deleteResponseId, \"Verify code deleted\");\n\n        // verify code deleted\n        final HashMap deletedCodeValues = (HashMap) CodeHelper.getCodeById(this.requestSpec, this.generalResponseSpec, deleteResponseId,\n                \"\");\n\n        Assertions.assertNotNull(deletedCodeValues);\n        assertNull(deletedCodeValues.get(CodeHelper.CODE_ID_ATTRIBUTE_NAME), \"Verify value of codeId\");\n\n        assertNull(deletedCodeValues.get(CodeHelper.CODE_NAME_ATTRIBUTE_NAME), \"Verify code name\");\n        assertNull(deletedCodeValues.get(CodeHelper.CODE_SYSTEM_DEFINED_ATTRIBUTE_NAME), \"Verify system defined is false\");\n    }"}
{"prompt": "Create a test that tests test Prevent Create Duplicate Code", "completion": "    @Test\n    // scenario 57, 60\n    public void testPreventCreateDuplicateCode() {\n        final String codeName = \"Client Marital Status\";\n\n        // create code\n        final Integer createResponseId = (Integer) CodeHelper.createCode(this.requestSpec, this.responseSpec, codeName,\n                CodeHelper.RESPONSE_ID_ATTRIBUTE_NAME);\n\n        // verify code created\n        final HashMap newCodeAttributes = (HashMap) CodeHelper.getCodeById(this.requestSpec, this.responseSpec, createResponseId, \"\");\n\n        Assertions.assertNotNull(newCodeAttributes);\n        assertEquals(createResponseId, newCodeAttributes.get(CodeHelper.CODE_ID_ATTRIBUTE_NAME), \"Verify value of codeId\");\n\n        assertEquals(codeName, newCodeAttributes.get(CodeHelper.CODE_NAME_ATTRIBUTE_NAME), \"Verify code name\");\n        assertEquals(false, newCodeAttributes.get(CodeHelper.CODE_SYSTEM_DEFINED_ATTRIBUTE_NAME), \"Verify system defined is false\");\n\n        // try to create duplicate-- should fail\n        final List<HashMap> error = (List) CodeHelper.createCode(this.requestSpec, this.generalResponseSpec, codeName,\n                CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.code.duplicate.name\", error.get(0).get(\"userMessageGlobalisationCode\"), \"Verify duplication error\");\n\n        // delete code that was just created\n\n        final Integer deleteResponseId = (Integer) CodeHelper.deleteCodeById(this.requestSpec, this.responseSpec, createResponseId,\n                CodeHelper.RESPONSE_ID_ATTRIBUTE_NAME);\n        assertEquals(createResponseId, deleteResponseId, \"Verify code deleted\");\n\n        // verify code deleted\n        final HashMap deletedCodeAttributes = (HashMap) CodeHelper.getCodeById(this.requestSpec, this.generalResponseSpec, deleteResponseId,\n                \"\");\n\n        Assertions.assertNotNull(deletedCodeAttributes);\n        assertNull(deletedCodeAttributes.get(CodeHelper.CODE_ID_ATTRIBUTE_NAME), \"Verify value of codeId\");\n\n        assertNull(deletedCodeAttributes.get(CodeHelper.CODE_NAME_ATTRIBUTE_NAME), \"Verify code name\");\n        assertNull(deletedCodeAttributes.get(CodeHelper.CODE_SYSTEM_DEFINED_ATTRIBUTE_NAME), \"Verify system defined is false\");\n\n    }"}
{"prompt": "Create a test that tests test Update Delete System Defined Code", "completion": "    // @Ignore\n    @Test\n    public void testUpdateDeleteSystemDefinedCode() {\n\n        // get any systemDefined code\n        final HashMap systemDefinedCode = (HashMap) CodeHelper.getSystemDefinedCodes(this.requestSpec, this.responseSpec);\n\n        // delete system-defined code should fail\n        final List<HashMap> error = (List) CodeHelper.deleteCodeById(this.requestSpec, this.generalResponseSpec,\n                (Integer) systemDefinedCode.get(CodeHelper.CODE_ID_ATTRIBUTE_NAME), CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.code.systemdefined\", error.get(0).get(\"userMessageGlobalisationCode\"), \"Cannot delete system-defined code\");\n\n        // update system-defined code should fail\n\n        final List<HashMap> updateError = (List) CodeHelper.updateCode(this.requestSpec, this.generalResponseSpec,\n                (Integer) systemDefinedCode.get(CodeHelper.CODE_ID_ATTRIBUTE_NAME),\n                systemDefinedCode.get(CodeHelper.CODE_NAME_ATTRIBUTE_NAME) + \"CHANGE\", CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.code.systemdefined\", updateError.get(0).get(\"userMessageGlobalisationCode\"),\n                \"Cannot update system-defined code\");\n\n    }"}
{"prompt": "Create a test that tests test Code Values Not Assigned To Table", "completion": "    // @Ignore\n    @Test\n    public void testCodeValuesNotAssignedToTable() {\n\n        final String codeName = Utils.uniqueRandomStringGenerator(\"Marital Status1\", 10);\n\n        final String codeValue1 = \"Married1\";\n        final String codeValue2 = \"Unmarried1\";\n\n        final int codeValue1Position = 1;\n        final int codeValue2Position = 1;\n\n        final String codeDescription1 = \"Description11\";\n        final String codeDescription2 = \"Description22\";\n\n        // create code\n        final Integer createCodeResponseId = (Integer) CodeHelper.createCode(this.requestSpec, this.responseSpec, codeName,\n                CodeHelper.RESPONSE_ID_ATTRIBUTE_NAME);\n\n        // create first code value\n        final Integer createCodeValueResponseId1 = (Integer) CodeHelper.createCodeValue(this.requestSpec, this.responseSpec,\n                createCodeResponseId, codeValue1, codeDescription1, codeValue1Position, CodeHelper.SUBRESPONSE_ID_ATTRIBUTE_NAME);\n\n        // create second code value\n        final Integer createCodeValueResponseId2 = (Integer) CodeHelper.createCodeValue(this.requestSpec, this.responseSpec,\n                createCodeResponseId, codeValue2, codeDescription2, codeValue1Position, CodeHelper.SUBRESPONSE_ID_ATTRIBUTE_NAME);\n\n        // verify two code values created\n\n        final List<HashMap> codeValuesList = (List) CodeHelper.getCodeValuesForCode(this.requestSpec, this.responseSpec,\n                createCodeResponseId, \"\");\n\n        assertEquals(2, codeValuesList.size(), \"Number of code values returned matches number created\");\n\n        // verify values of first code value\n        final HashMap codeValuesAttributes1 = (HashMap) CodeHelper.getCodeValueById(this.requestSpec, this.responseSpec,\n                createCodeResponseId, createCodeValueResponseId1, \"\");\n\n        Assertions.assertNotNull(codeValuesAttributes1);\n        assertEquals(createCodeValueResponseId1, codeValuesAttributes1.get(CodeHelper.CODE_VALUE_ID_ATTRIBUTE_NAME),\n                \"Verify value of codeValueId\");\n\n        assertEquals(codeValue1, codeValuesAttributes1.get(CodeHelper.CODE_VALUE_NAME_ATTRIBUTE_NAME), \"Verify value of code name\");\n\n        assertEquals(codeDescription1, codeValuesAttributes1.get(CodeHelper.CODE_VALUE_DESCRIPTION_ATTRIBUTE_NAME),\n                \"Verify value of code description\");\n\n        assertEquals(codeValue1Position, codeValuesAttributes1.get(CodeHelper.CODE_VALUE_POSITION_ATTRIBUTE_NAME),\n                \"Verify position of code value\");\n\n        // verify values of second code value\n        final HashMap codeValuesAttributes2 = (HashMap) CodeHelper.getCodeValueById(this.requestSpec, this.responseSpec,\n                createCodeResponseId, createCodeValueResponseId2, \"\");\n\n        Assertions.assertNotNull(codeValuesAttributes2);\n        assertEquals(createCodeValueResponseId2, codeValuesAttributes2.get(CodeHelper.CODE_VALUE_ID_ATTRIBUTE_NAME),\n                \"Verify value of codeValueId\");\n\n        assertEquals(codeValue2, codeValuesAttributes2.get(CodeHelper.CODE_VALUE_NAME_ATTRIBUTE_NAME), \"Verify value of code name\");\n\n        assertEquals(codeDescription2, codeValuesAttributes2.get(CodeHelper.CODE_VALUE_DESCRIPTION_ATTRIBUTE_NAME),\n                \"Verify value of code description\");\n\n        assertEquals(codeValue2Position, codeValuesAttributes2.get(CodeHelper.CODE_VALUE_POSITION_ATTRIBUTE_NAME),\n                \"Verify position of code value\");\n\n        // update code value 1\n        final HashMap codeValueChanges = (HashMap) CodeHelper.updateCodeValue(this.requestSpec, this.responseSpec, createCodeResponseId,\n                createCodeValueResponseId1, codeValue1 + \"CHANGE\", codeDescription1 + \"CHANGE\", 4, \"changes\");\n\n        assertEquals(codeValue1 + \"CHANGE\", codeValueChanges.get(\"name\"), \"Verify changed code value name\");\n\n        assertEquals(codeDescription1 + \"CHANGE\", codeValueChanges.get(\"description\"), \"Verify changed code value description\");\n\n        // delete code value\n        Integer deletedCodeValueResponseId1 = (Integer) CodeHelper.deleteCodeValueById(this.requestSpec, this.generalResponseSpec,\n                createCodeResponseId, createCodeValueResponseId1, CodeHelper.SUBRESPONSE_ID_ATTRIBUTE_NAME);\n\n        // Verify code value deleted\n\n        final ArrayList<HashMap> deletedCodeValueAttributes1 = (ArrayList<HashMap>) CodeHelper.getCodeValueById(this.requestSpec,\n                this.generalResponseSpec, createCodeResponseId, deletedCodeValueResponseId1, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(\"error.msg.codevalue.id.invalid\", deletedCodeValueAttributes1.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        final List<HashMap> deletedCodeValuesList = (List) CodeHelper.getCodeValuesForCode(this.requestSpec, this.responseSpec,\n                createCodeResponseId, \"\");\n\n        assertEquals(1, deletedCodeValuesList.size(), \"Number of code values is 1\");\n\n        final Integer deletedCodeValueResponseId2 = (Integer) CodeHelper.deleteCodeValueById(this.requestSpec, this.generalResponseSpec,\n                createCodeResponseId, createCodeValueResponseId2, CodeHelper.SUBRESPONSE_ID_ATTRIBUTE_NAME);\n\n        final ArrayList<HashMap> deletedCodeValueAttributes2 = (ArrayList<HashMap>) CodeHelper.getCodeValueById(this.requestSpec,\n                this.generalResponseSpec, createCodeResponseId, deletedCodeValueResponseId2, CommonConstants.RESPONSE_ERROR);\n\n        assertEquals(deletedCodeValueAttributes2.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE), \"error.msg.codevalue.id.invalid\");\n\n        final List<HashMap> deletedCodeValuesList1 = (List) CodeHelper.getCodeValuesForCode(this.requestSpec, this.responseSpec,\n                createCodeResponseId, \"\");\n\n        assertEquals(0, deletedCodeValuesList1.size(), \"Number of code values is 0\");\n\n    }"}
{"prompt": "Create a test that tests test Code Values Assigned To Table", "completion": "    @Disabled\n    @Test\n    public void testCodeValuesAssignedToTable() {\n\n    }"}
{"prompt": "Create a test that tests test Create New User Blocks Duplicate Username", "completion": "    @Test\n    public void testCreateNewUserBlocksDuplicateUsername() {\n\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(staffId);\n\n        final Integer userId = (Integer) UserHelper.createUser(this.requestSpec, this.responseSpec, roleId, staffId, \"alphabet\",\n                \"resourceId\");\n        Assertions.assertNotNull(userId);\n        this.transientUsers.add(userId);\n\n        final List errors = (List) UserHelper.createUser(this.requestSpec, expectStatusCode(403), roleId, staffId, \"alphabet\", \"errors\");\n        Map reason = (Map) errors.get(0);\n        LOG.info(\"Reason: {}\", reason.get(\"defaultUserMessage\"));\n        LOG.info(\"Code: {}\", reason.get(\"userMessageGlobalisationCode\"));\n        Assertions.assertEquals(\"User with username alphabet already exists.\", reason.get(\"defaultUserMessage\"));\n        Assertions.assertEquals(\"error.msg.user.duplicate.username\", reason.get(\"userMessageGlobalisationCode\"));\n    }"}
{"prompt": "Create a test that tests test Update User Accepts New Or Same Username", "completion": "    @Test\n    public void testUpdateUserAcceptsNewOrSameUsername() {\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(staffId);\n\n        final Integer userId = (Integer) UserHelper.createUser(this.requestSpec, this.responseSpec, roleId, staffId, \"alphabet\",\n                \"resourceId\");\n        Assertions.assertNotNull(userId);\n        this.transientUsers.add(userId);\n\n        final Integer userId2 = (Integer) UserHelper.updateUser(this.requestSpec, this.responseSpec, userId, \"renegade\", \"resourceId\");\n        Assertions.assertNotNull(userId2);\n\n        final Integer userId3 = (Integer) UserHelper.updateUser(this.requestSpec, this.responseSpec, userId, \"renegade\", \"resourceId\");\n        Assertions.assertNotNull(userId3);\n    }"}
{"prompt": "Create a test that tests test Update User Block Duplicate Username", "completion": "    @Test\n    public void testUpdateUserBlockDuplicateUsername() {\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(staffId);\n\n        final Integer userId = (Integer) UserHelper.createUser(this.requestSpec, this.responseSpec, roleId, staffId, \"alphabet\",\n                \"resourceId\");\n        Assertions.assertNotNull(userId);\n        this.transientUsers.add(userId);\n\n        final Integer userId2 = (Integer) UserHelper.createUser(this.requestSpec, this.responseSpec, roleId, staffId, \"bilingual\",\n                \"resourceId\");\n        Assertions.assertNotNull(userId2);\n        this.transientUsers.add(userId2);\n\n        final List errors = (List) UserHelper.updateUser(this.requestSpec, expectStatusCode(403), userId2, \"alphabet\", \"errors\");\n        Map reason = (Map) errors.get(0);\n        Assertions.assertEquals(\"User with username alphabet already exists.\", reason.get(\"defaultUserMessage\"));\n        Assertions.assertEquals(\"error.msg.user.duplicate.username\", reason.get(\"userMessageGlobalisationCode\"));\n    }"}
{"prompt": "Create a test that tests test Create New User Blocks Duplicate Client Id", "completion": "    @Test\n    public void testCreateNewUserBlocksDuplicateClientId() {\n        final Integer roleId = RolesHelper.createRole(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(roleId);\n\n        final Integer staffId = StaffHelper.createStaff(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(staffId);\n\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n\n        final Integer userId = (Integer) UserHelper.createUserForSelfService(this.requestSpec, this.responseSpec, roleId, staffId, clientId,\n                \"resourceId\");\n        Assertions.assertNotNull(userId);\n        this.transientUsers.add(userId);\n\n        final List errors = (List) UserHelper.createUserForSelfService(this.requestSpec, expectStatusCode(403), roleId, staffId, clientId,\n                \"errors\");\n        Map reason = (Map) errors.get(0);\n        Assertions.assertEquals(\"Self Service User Id is already created. Go to Admin->Users to edit or delete the self-service user.\",\n                reason.get(\"defaultUserMessage\"));\n    }"}
{"prompt": "Create a test that tests test Delete System User", "completion": "    @Test\n    public void testDeleteSystemUser() {\n        final Integer userId = UserHelper.getUserId(requestSpec, responseSpec, AppUserConstants.SYSTEM_USER_NAME);\n        Assertions.assertNotNull(userId);\n\n        UserHelper.deleteUser(requestSpec, expectStatusCode(403), userId.intValue());\n    }"}
{"prompt": "Create a test that tests test Modify System User", "completion": "    @Test\n    public void testModifySystemUser() {\n        final Integer userId = UserHelper.getUserId(requestSpec, responseSpec, AppUserConstants.SYSTEM_USER_NAME);\n        Assertions.assertNotNull(userId);\n\n        final List errors = (List) UserHelper.updateUser(this.requestSpec, expectStatusCode(403), userId, \"systemtest\", \"errors\");\n    }"}
{"prompt": "Create a test that tests update Working Days", "completion": "    @Test\n    public void updateWorkingDays() {\n        HashMap response = (HashMap) WorkingDaysHelper.updateWorkingDays(requestSpec, responseSpec);\n        Assertions.assertNotNull(response.get(\"resourceId\"));\n    }"}
{"prompt": "Create a test that tests update Working Days With Wrong Recurrence Pattern", "completion": "    @Test\n    public void updateWorkingDaysWithWrongRecurrencePattern() {\n        final List<HashMap> error = (List) WorkingDaysHelper.updateWorkingDaysWithWrongRecurrence(requestSpec, generalResponseSpec,\n                CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.recurring.rule.parsing.error\", error.get(0).get(\"userMessageGlobalisationCode\"),\n                \"Verify wrong recurrence pattern error\");\n    }"}
{"prompt": "Create a test that tests should Retrieve Taxonomy List", "completion": "    @Test\n    public void shouldRetrieveTaxonomyList() {\n        this.xbrlHelper = new XBRLIntegrationTestHelper(this.requestSpec, this.responseSpec);\n\n        final ArrayList<HashMap> taxonomyList = this.xbrlHelper.getTaxonomyList();\n        verifyTaxonomyList(taxonomyList);\n    }"}
{"prompt": "Create a test that tests test Accounting Rule Creation", "completion": "    @Test\n    public void testAccountingRuleCreation() {\n        // given\n        final Account accountToCredit = accountHelper.createIncomeAccount();\n        final Account accountToDebit = accountHelper.createExpenseAccount();\n        final GetOfficesResponse headOffice = OfficeHelper.getHeadOffice(requestSpec, responseSpec);\n\n        // when\n        final PostAccountingRulesResponse accountingRule = accountRuleHelper.createAccountRule(headOffice.getId(), accountToCredit,\n                accountToDebit);\n        final ArrayList<GetAccountRulesResponse> accountingRules = accountRuleHelper.getAccountingRules();\n\n        // then\n        assertNotNull(accountingRule);\n        assertNotNull(accountingRule.getResourceId());\n        assertNotNull(accountingRules);\n        assertTrue(accountingRules.size() > 0);\n    }"}
{"prompt": "Create a test that tests test Client Import", "completion": "    @Test\n    public void testClientImport() throws InterruptedException, IOException, ParseException {\n\n        // in order to populate helper sheets\n        requestSpec.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON);\n        Integer outcome_staff_creation = StaffHelper.createStaff(requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_staff_creation, \"Could not create staff\");\n\n        // in order to populate helper sheets\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        Integer outcome_office_creation = officeHelper.createOffice(\"02 May 2000\");\n        Assertions.assertNotNull(outcome_office_creation, \"Could not create office\");\n\n        // in order to populate helper columns in client entity sheet\n        // create constitution\n        CodeHelper.retrieveOrCreateCodeValue(24, requestSpec, responseSpec);\n        // create client classification\n        CodeHelper.retrieveOrCreateCodeValue(17, requestSpec, responseSpec);\n        // create client types\n        CodeHelper.retrieveOrCreateCodeValue(16, requestSpec, responseSpec);\n        // create Address types\n        CodeHelper.retrieveOrCreateCodeValue(29, requestSpec, responseSpec);\n        // create State\n        CodeHelper.retrieveOrCreateCodeValue(27, requestSpec, responseSpec);\n        // create Country\n        CodeHelper.retrieveOrCreateCodeValue(28, requestSpec, responseSpec);\n        // create Main business line\n        CodeHelper.retrieveOrCreateCodeValue(25, requestSpec, responseSpec);\n\n        ClientHelper clientHelper = new ClientHelper(requestSpec, responseSpec);\n        Workbook workbook = clientHelper.getClientEntityWorkbook(GlobalEntityType.CLIENTS_ENTITY, \"dd MMMM yyyy\");\n\n        // insert dummy data into client entity sheet\n        Sheet clientEntitySheet = workbook.getSheet(TemplatePopulateImportConstants.CLIENT_ENTITY_SHEET_NAME);\n        Row firstClientRow = clientEntitySheet.getRow(1);\n        firstClientRow.createCell(ClientEntityConstants.NAME_COL).setCellValue(Utils.randomStringGenerator(\"C_E_\", 6));\n        Sheet staffSheet = workbook.getSheet(TemplatePopulateImportConstants.STAFF_SHEET_NAME);\n        firstClientRow.createCell(ClientEntityConstants.OFFICE_NAME_COL).setCellValue(staffSheet.getRow(1).getCell(0).getStringCellValue());\n        firstClientRow.createCell(ClientEntityConstants.STAFF_NAME_COL).setCellValue(staffSheet.getRow(1).getCell(1).getStringCellValue());\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Date incoporationDate = simpleDateFormat.parse(\"14 May 2001\");\n        firstClientRow.createCell(ClientEntityConstants.INCOPORATION_DATE_COL).setCellValue(incoporationDate);\n        Date validTill = simpleDateFormat.parse(\"14 May 2019\");\n        firstClientRow.createCell(ClientEntityConstants.INCOPORATION_VALID_TILL_COL).setCellValue(validTill);\n        firstClientRow.createCell(ClientEntityConstants.MOBILE_NO_COL).setCellValue(Utils.uniqueRandomNumberGenerator(7));\n        firstClientRow.createCell(ClientEntityConstants.CLIENT_TYPE_COL)\n                .setCellValue(clientEntitySheet.getRow(1).getCell(ClientEntityConstants.LOOKUP_CLIENT_TYPES).getStringCellValue());\n        firstClientRow.createCell(ClientEntityConstants.CLIENT_CLASSIFICATION_COL)\n                .setCellValue(clientEntitySheet.getRow(1).getCell(ClientEntityConstants.LOOKUP_CLIENT_CLASSIFICATION).getStringCellValue());\n        firstClientRow.createCell(ClientEntityConstants.INCOPORATION_NUMBER_COL).setCellValue(Utils.randomNumberGenerator(6));\n        firstClientRow.createCell(ClientEntityConstants.MAIN_BUSINESS_LINE)\n                .setCellValue(clientEntitySheet.getRow(1).getCell(ClientEntityConstants.LOOKUP_MAIN_BUSINESS_LINE).getStringCellValue());\n        firstClientRow.createCell(ClientEntityConstants.CONSTITUTION_COL)\n                .setCellValue(clientEntitySheet.getRow(1).getCell(ClientEntityConstants.LOOKUP_CONSTITUTION_COL).getStringCellValue());\n        firstClientRow.createCell(ClientEntityConstants.ACTIVE_COL).setCellValue(\"False\");\n        Date submittedDate = simpleDateFormat.parse(\"28 September 2017\");\n        firstClientRow.createCell(ClientEntityConstants.SUBMITTED_ON_COL).setCellValue(submittedDate);\n        firstClientRow.createCell(ClientEntityConstants.ADDRESS_ENABLED).setCellValue(\"False\");\n\n        File directory = new File(System.getProperty(\"user.home\") + File.separator + \"Fineract\" + File.separator + \"bulkimport\"\n                + File.separator + \"integration_tests\" + File.separator + \"importhandler\" + File.separator + \"client\");\n        if (!directory.exists()) {\n            directory.mkdirs();\n        }\n        File file = new File(directory + File.separator + \"ClientEntity.xls\");\n        OutputStream outputStream = new FileOutputStream(file);\n        workbook.write(outputStream);\n        outputStream.close();\n\n        String importDocumentId = clientHelper.importClientEntityTemplate(file);\n        file.delete();\n        Assertions.assertNotNull(importDocumentId);\n\n        // Wait for the creation of output excel\n        Thread.sleep(10000);\n\n        // check status column of output excel\n        String location = clientHelper.getOutputTemplateLocation(importDocumentId);\n        FileInputStream fileInputStream = new FileInputStream(location);\n        Workbook outputWorkbook = new HSSFWorkbook(fileInputStream);\n        Sheet outputClientEntitySheet = outputWorkbook.getSheet(TemplatePopulateImportConstants.CLIENT_ENTITY_SHEET_NAME);\n        Row row = outputClientEntitySheet.getRow(1);\n\n        LOG.info(\"Output location: {}\", location);\n        LOG.info(\"Failure reason column: {}\", row.getCell(ClientEntityConstants.STATUS_COL).getStringCellValue());\n\n        Assertions.assertEquals(\"Imported\", row.getCell(ClientEntityConstants.STATUS_COL).getStringCellValue());\n        outputWorkbook.close();\n    }"}
{"prompt": "Create a test that tests test Loan Import", "completion": "    @Test\n    public void testLoanImport() throws InterruptedException, IOException, ParseException {\n        requestSpec.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON);\n\n        // in order to populate helper sheets\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        Integer outcome_office_creation = officeHelper.createOffice(\"02 May 2000\");\n        Assertions.assertNotNull(outcome_office_creation, \"Could not create office\");\n\n        OfficeDomain office = officeHelper.retrieveOfficeByID(outcome_office_creation);\n        Assertions.assertNotNull(office, \"Could not retrieve created office\");\n\n        String firstName = Utils.randomStringGenerator(\"Client_FirstName_\", 5);\n        String lastName = Utils.randomStringGenerator(\"Client_LastName_\", 4);\n        String externalId = UUID.randomUUID().toString();\n\n        final HashMap<String, Object> clientMap = new HashMap<>();\n        clientMap.put(\"officeId\", outcome_office_creation.toString());\n        clientMap.put(\"firstname\", firstName);\n        clientMap.put(\"lastname\", lastName);\n        clientMap.put(\"externalId\", externalId);\n        clientMap.put(\"dateFormat\", DATE_FORMAT);\n        clientMap.put(\"legalFormId\", 1);\n        clientMap.put(\"locale\", \"en\");\n        clientMap.put(\"active\", \"true\");\n        clientMap.put(\"activationDate\", \"04 March 2011\");\n\n        Integer outcome_client_creation = Utils.performServerPost(requestSpec, responseSpec, CREATE_CLIENT_URL,\n                new Gson().toJson(clientMap), \"clientId\");\n        Assertions.assertNotNull(outcome_client_creation, \"Could not create client\");\n\n        List<HashMap> collaterals = new ArrayList<>();\n        HashMap<String, String> collateralHashMap = new HashMap<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(outcome_client_creation), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        collateralHashMap.put(\"clientCollateralId\", collateralId.toString());\n        collateralHashMap.put(\"quantity\", \"1\");\n        collaterals.add(collateralHashMap);\n\n        final String disbursementChargeJsonString = ChargesHelper.getLoanDisbursementJSON();\n\n        final Integer disbursementChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec, disbursementChargeJsonString);\n\n        final JsonPath disbursementChargeJSON = JsonPath.from(disbursementChargeJsonString);\n\n        Assertions.assertNotNull(disbursementChargeId, \"Could not create charge\");\n\n        // in order to populate helper sheets\n        Integer outcome_group_creation = GroupHelper.createGroup(requestSpec, responseSpec, true);\n        Assertions.assertNotNull(outcome_group_creation, \"Could not create group\");\n\n        // in order to populate helper sheets\n        Integer outcome_staff_creation = StaffHelper.createStaff(requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_staff_creation, \"Could not create staff\");\n\n        Map<String, Object> staffMap = StaffHelper.getStaff(requestSpec, responseSpec, outcome_staff_creation);\n        Assertions.assertNotNull(staffMap, \"Could not retrieve created staff\");\n\n        LoanTransactionHelper ltHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n        LoanProductTestBuilder loanProductTestBuilder = new LoanProductTestBuilder();\n        String jsonLoanProduct = loanProductTestBuilder.build(null);\n        Integer outcome_lp_creation = ltHelper.getLoanProductId(jsonLoanProduct);\n        Assertions.assertNotNull(outcome_lp_creation, \"Could not create Loan Product\");\n\n        String loanProductStr = ltHelper.getLoanProductDetails(requestSpec, responseSpec, outcome_lp_creation);\n        Assertions.assertNotNull(\"Could not get created Loan Product\", loanProductStr);\n        JsonPath loanProductJson = JsonPath.from(loanProductStr);\n\n        String fundName = Utils.uniqueRandomStringGenerator(\"\", 9);\n        FundsHelper fh = FundsHelper.create(fundName).externalId(UUID.randomUUID().toString()).build();\n        Integer outcome_fund_creation = FundsResourceHandler.createFund(new Gson().toJson(fh), requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_fund_creation, \"Could not create Fund\");\n\n        String paymentTypeName = PaymentTypeHelper.randomNameGenerator(\"P_T\", 5);\n        String paymentTypeDescription = PaymentTypeHelper.randomNameGenerator(\"PT_Desc\", 15);\n        Integer outcome_payment_creation = PaymentTypeHelper.createPaymentType(requestSpec, responseSpec, paymentTypeName,\n                paymentTypeDescription, true, 1);\n        Assertions.assertNotNull(outcome_payment_creation, \"Could not create payment type\");\n\n        LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n        Workbook workbook = loanTransactionHelper.getLoanWorkbook(DATE_FORMAT);\n\n        // insert dummy data into loan Sheet\n        Sheet loanSheet = workbook.getSheet(TemplatePopulateImportConstants.LOANS_SHEET_NAME);\n        Row firstLoanRow = loanSheet.getRow(1);\n        firstLoanRow.createCell(LoanConstants.OFFICE_NAME_COL).setCellValue(office.getName());\n        firstLoanRow.createCell(LoanConstants.LOAN_TYPE_COL).setCellValue(\"Individual\");\n        firstLoanRow.createCell(LoanConstants.CLIENT_NAME_COL)\n                .setCellValue(firstName + \" \" + lastName + \"(\" + outcome_client_creation + \")\");\n        firstLoanRow.createCell(LoanConstants.CLIENT_EXTERNAL_ID).setCellValue(externalId);\n        firstLoanRow.createCell(LoanConstants.PRODUCT_COL).setCellValue(loanProductJson.getString(\"name\"));\n        firstLoanRow.createCell(LoanConstants.LOAN_OFFICER_NAME_COL).setCellValue((String) staffMap.get(\"displayName\"));\n\n        final DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(DATE_FORMAT, Locale.US);\n        final LocalDate localDate = LocalDate.parse(\"17 May 2017\", dateFormat);\n\n        firstLoanRow.createCell(LoanConstants.SUBMITTED_ON_DATE_COL).setCellValue(localDate);\n        firstLoanRow.createCell(LoanConstants.APPROVED_DATE_COL).setCellValue(localDate);\n        firstLoanRow.createCell(LoanConstants.DISBURSED_DATE_COL).setCellValue(localDate);\n        firstLoanRow.createCell(LoanConstants.DISBURSED_PAYMENT_TYPE_COL).setCellValue(paymentTypeName);\n        firstLoanRow.createCell(LoanConstants.FUND_NAME_COL).setCellValue(fundName);\n        firstLoanRow.createCell(LoanConstants.PRINCIPAL_COL).setCellValue(loanProductJson.getFloat(\"principal\"));\n        firstLoanRow.createCell(LoanConstants.NO_OF_REPAYMENTS_COL).setCellValue(loanProductJson.getInt(\"numberOfRepayments\"));\n        firstLoanRow.createCell(LoanConstants.REPAID_EVERY_COL).setCellValue(loanProductJson.getInt(\"repaymentEvery\"));\n        firstLoanRow.createCell(LoanConstants.REPAID_EVERY_FREQUENCY_COL)\n                .setCellValue(loanProductJson.getString(\"repaymentFrequencyType.value\"));\n        firstLoanRow.createCell(LoanConstants.LOAN_TERM_COL)\n                .setCellValue(loanProductJson.getInt(\"repaymentEvery\") * loanProductJson.getInt(\"numberOfRepayments\"));\n        firstLoanRow.createCell(LoanConstants.LOAN_TERM_FREQUENCY_COL)\n                .setCellValue(loanProductJson.getString(\"repaymentFrequencyType.value\"));\n        firstLoanRow.createCell(LoanConstants.NOMINAL_INTEREST_RATE_COL).setCellValue(loanProductJson.getDouble(\"interestRatePerPeriod\"));\n        firstLoanRow.createCell(LoanConstants.NOMINAL_INTEREST_RATE_FREQUENCY_COL)\n                .setCellValue(loanProductJson.getString(\"interestRateFrequencyType.value\"));\n        firstLoanRow.createCell(LoanConstants.AMORTIZATION_COL).setCellValue(loanProductJson.getString(\"amortizationType.value\"));\n        firstLoanRow.createCell(LoanConstants.INTEREST_METHOD_COL).setCellValue(loanProductJson.getString(\"interestType.value\"));\n        firstLoanRow.createCell(LoanConstants.INTEREST_CALCULATION_PERIOD_COL)\n                .setCellValue(loanProductJson.getString(\"interestCalculationPeriodType.value\"));\n        firstLoanRow.createCell(LoanConstants.ARREARS_TOLERANCE_COL).setCellValue(0);\n        firstLoanRow.createCell(LoanConstants.REPAYMENT_STRATEGY_COL)\n                .setCellValue(loanProductJson.getString(\"transactionProcessingStrategyName\"));\n        firstLoanRow.createCell(LoanConstants.GRACE_ON_PRINCIPAL_PAYMENT_COL).setCellValue(0);\n        firstLoanRow.createCell(LoanConstants.GRACE_ON_INTEREST_PAYMENT_COL).setCellValue(0);\n        firstLoanRow.createCell(LoanConstants.GRACE_ON_INTEREST_CHARGED_COL).setCellValue(0);\n        firstLoanRow.createCell(LoanConstants.FIRST_REPAYMENT_COL).setCellValue(localDate);\n        firstLoanRow.createCell(LoanConstants.TOTAL_AMOUNT_REPAID_COL).setCellValue(6000);\n        firstLoanRow.createCell(LoanConstants.LAST_REPAYMENT_DATE_COL).setCellValue(localDate);\n        firstLoanRow.createCell(LoanConstants.REPAYMENT_TYPE_COL).setCellValue(paymentTypeName);\n        firstLoanRow.createCell(LoanConstants.LOAN_COLLATERAL_ID).setCellValue(collaterals.get(0).get(\"clientCollateralId\").toString());\n        firstLoanRow.createCell(LoanConstants.LOAN_COLLATERAL_QUANTITY).setCellValue(collaterals.get(0).get(\"quantity\").toString());\n        firstLoanRow.createCell(LoanConstants.CHARGE_NAME_1).setCellValue(disbursementChargeJSON.getString(\"name\"));\n        firstLoanRow.createCell(LoanConstants.CHARGE_AMOUNT_1).setCellValue(disbursementChargeJSON.getFloat(\"amount\"));\n        firstLoanRow.createCell(LoanConstants.CHARGE_AMOUNT_TYPE_1)\n                .setCellValue(disbursementChargeJSON.getString(\"chargeCalculationType.value\"));\n\n        String currentdirectory = new File(\"\").getAbsolutePath();\n        File directory = new File(currentdirectory + File.separator + \"src\" + File.separator + \"integrationTest\" + File.separator\n                + \"resources\" + File.separator + \"bulkimport\" + File.separator + \"importhandler\" + File.separator + \"loan\");\n        if (!directory.exists()) {\n            directory.mkdirs();\n        }\n        File file = new File(directory + File.separator + \"Loan.xls\");\n        OutputStream outputStream = new FileOutputStream(file);\n        workbook.write(outputStream);\n        outputStream.close();\n\n        String importDocumentId = loanTransactionHelper.importLoanTemplate(file);\n        file.delete();\n        Assertions.assertNotNull(importDocumentId);\n\n        // Wait for the creation of output excel\n        Thread.sleep(10000);\n\n        // check status column of output excel\n        String location = loanTransactionHelper.getOutputTemplateLocation(importDocumentId);\n        FileInputStream fileInputStream = new FileInputStream(location);\n        Workbook outputworkbook = new HSSFWorkbook(fileInputStream);\n        Sheet outputLoanSheet = outputworkbook.getSheet(TemplatePopulateImportConstants.LOANS_SHEET_NAME);\n        Row row = outputLoanSheet.getRow(1);\n\n        LOG.info(\"Output location: {}\", location);\n        LOG.info(\"Failure reason column: {}\", row.getCell(LoanConstants.FAILURE_REPORT_COL).getStringCellValue());\n\n        Assertions.assertEquals(\"Imported\", row.getCell(LoanConstants.STATUS_COL).getStringCellValue());\n        outputworkbook.close();\n    }"}
{"prompt": "Create a test that tests test Office Import", "completion": "    @Test\n    public void testOfficeImport() throws IOException, InterruptedException, NoSuchFieldException, ParseException {\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        Workbook workbook = officeHelper.getOfficeWorkBook(\"dd MMMM yyyy\");\n\n        // insert dummy data into excel\n        Sheet sheet = workbook.getSheet(TemplatePopulateImportConstants.OFFICE_SHEET_NAME);\n        Row firstOfficeRow = sheet.getRow(1);\n        firstOfficeRow.createCell(OfficeConstants.OFFICE_NAME_COL).setCellValue(Utils.uniqueRandomStringGenerator(\"Test_Off_\", 6));\n        firstOfficeRow.createCell(OfficeConstants.PARENT_OFFICE_NAME_COL)\n                .setCellValue(firstOfficeRow.getCell(OfficeConstants.LOOKUP_OFFICE_COL).getStringCellValue());\n        firstOfficeRow.createCell(OfficeConstants.PARENT_OFFICE_ID_COL)\n                .setCellValue(firstOfficeRow.getCell(OfficeConstants.LOOKUP_OFFICE_ID_COL).getNumericCellValue());\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Date date = simpleDateFormat.parse(\"14 May 2001\");\n        firstOfficeRow.createCell(OfficeConstants.OPENED_ON_COL).setCellValue(date);\n\n        String currentdirectory = new File(\"\").getAbsolutePath();\n        File directory = new File(currentdirectory + File.separator + \"src\" + File.separator + \"integrationTest\" + File.separator\n                + \"resources\" + File.separator + \"bulkimport\" + File.separator + \"importhandler\" + File.separator + \"office\");\n        if (!directory.exists()) {\n            directory.mkdirs();\n        }\n        File file = new File(directory + File.separator + \"Office.xls\");\n        OutputStream outputStream = new FileOutputStream(file);\n        workbook.write(outputStream);\n        outputStream.close();\n\n        String importDocumentId = officeHelper.importOfficeTemplate(file);\n        file.delete();\n        Assertions.assertNotNull(importDocumentId);\n\n        // Wait for the creation of output excel\n        Thread.sleep(10000);\n\n        // check status column of output excel\n        String location = officeHelper.getOutputTemplateLocation(importDocumentId);\n        FileInputStream fileInputStream = new FileInputStream(location);\n        Workbook outputWorkbook = new HSSFWorkbook(fileInputStream);\n        Sheet officeSheet = outputWorkbook.getSheet(TemplatePopulateImportConstants.OFFICE_SHEET_NAME);\n        Row row = officeSheet.getRow(1);\n\n        LOG.info(\"Output location: {}\", location);\n        LOG.info(\"Failure reason column: {}\", row.getCell(OfficeConstants.STATUS_COL).getStringCellValue());\n\n        Assertions.assertEquals(\"Imported\", row.getCell(OfficeConstants.STATUS_COL).getStringCellValue());\n        outputWorkbook.close();\n    }"}
{"prompt": "Create a test that tests test Savings Import", "completion": "    @Test\n    public void testSavingsImport() throws InterruptedException, IOException, ParseException {\n\n        requestSpec.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON);\n        // in order to populate helper sheets\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        Integer outcome_office_creation = officeHelper.createOffice(\"02 May 2000\");\n        Assertions.assertNotNull(outcome_office_creation, \"Could not create office\");\n\n        OfficeDomain office = officeHelper.retrieveOfficeByID(outcome_office_creation);\n        Assertions.assertNotNull(office, \"Could not retrieve created office\");\n\n        String firstName = Utils.randomStringGenerator(\"Client_FirstName_\", 5);\n        String lastName = Utils.randomStringGenerator(\"Client_LastName_\", 4);\n        String externalId = UUID.randomUUID().toString();\n\n        final HashMap<String, Object> clientMap = new HashMap<>();\n        clientMap.put(\"officeId\", outcome_office_creation.toString());\n        clientMap.put(\"legalFormId\", 1);\n        clientMap.put(\"firstname\", firstName);\n        clientMap.put(\"lastname\", lastName);\n        clientMap.put(\"externalId\", externalId);\n        clientMap.put(\"dateFormat\", DATE_FORMAT);\n        clientMap.put(\"locale\", \"en\");\n        clientMap.put(\"active\", \"true\");\n        clientMap.put(\"activationDate\", \"04 March 2011\");\n\n        Integer outcome_client_creation = Utils.performServerPost(requestSpec, responseSpec, CREATE_CLIENT_URL,\n                new Gson().toJson(clientMap), \"clientId\");\n        Assertions.assertNotNull(outcome_client_creation, \"Could not create client\");\n\n        // in order to populate helper sheets\n        Integer outcome_group_creation = GroupHelper.createGroup(requestSpec, responseSpec, true);\n        Assertions.assertNotNull(outcome_group_creation, \"Could not create group\");\n\n        // in order to populate helper sheets\n        Integer outcome_staff_creation = StaffHelper.createStaff(requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_staff_creation, \"Could not create staff\");\n\n        Map<String, Object> staffMap = StaffHelper.getStaff(requestSpec, responseSpec, outcome_staff_creation);\n        Assertions.assertNotNull(staffMap, \"Could not retrieve created staff\");\n\n        SavingsProductHelper savingsProductHelper = new SavingsProductHelper();\n        String jsonSavingsProduct = savingsProductHelper.build();\n        Integer outcome_sp_creaction = SavingsProductHelper.createSavingsProduct(jsonSavingsProduct, requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_sp_creaction, \"Could not create Savings product\");\n\n        SavingsAccountHelper savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        Workbook workbook = savingsAccountHelper.getSavingsWorkbook(\"dd MMMM yyyy\");\n\n        // insert dummy data into Savings sheet\n        Sheet savingsSheet = workbook.getSheet(TemplatePopulateImportConstants.SAVINGS_ACCOUNTS_SHEET_NAME);\n        Row firstSavingsRow = savingsSheet.getRow(1);\n        firstSavingsRow.createCell(SavingsConstants.OFFICE_NAME_COL).setCellValue(office.getName());\n        firstSavingsRow.createCell(SavingsConstants.SAVINGS_TYPE_COL).setCellValue(\"Individual\");\n        firstSavingsRow.createCell(SavingsConstants.CLIENT_NAME_COL)\n                .setCellValue(firstName + \" \" + lastName + \"(\" + outcome_client_creation + \")\");\n        Sheet savingsProductSheet = workbook.getSheet(TemplatePopulateImportConstants.PRODUCT_SHEET_NAME);\n        firstSavingsRow.createCell(SavingsConstants.PRODUCT_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(1).getStringCellValue());\n        firstSavingsRow.createCell(SavingsConstants.FIELD_OFFICER_NAME_COL).setCellValue((String) staffMap.get(\"displayName\"));\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Date date = simpleDateFormat.parse(\"13 May 2017\");\n        firstSavingsRow.createCell(SavingsConstants.SUBMITTED_ON_DATE_COL).setCellValue(date);\n        firstSavingsRow.createCell(SavingsConstants.APPROVED_DATE_COL).setCellValue(date);\n        firstSavingsRow.createCell(SavingsConstants.ACTIVATION_DATE_COL).setCellValue(date);\n        firstSavingsRow.createCell(SavingsConstants.CURRENCY_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(10).getStringCellValue());\n        firstSavingsRow.createCell(SavingsConstants.DECIMAL_PLACES_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(11).getNumericCellValue());\n        firstSavingsRow.createCell(SavingsConstants.IN_MULTIPLES_OF_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(12).getNumericCellValue());\n        firstSavingsRow.createCell(SavingsConstants.NOMINAL_ANNUAL_INTEREST_RATE_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(2).getNumericCellValue());\n        firstSavingsRow.createCell(SavingsConstants.INTEREST_COMPOUNDING_PERIOD_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(3).getStringCellValue());\n        firstSavingsRow.createCell(SavingsConstants.INTEREST_POSTING_PERIOD_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(4).getStringCellValue());\n        firstSavingsRow.createCell(SavingsConstants.INTEREST_CALCULATION_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(5).getStringCellValue());\n        firstSavingsRow.createCell(SavingsConstants.INTEREST_CALCULATION_DAYS_IN_YEAR_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(6).getStringCellValue());\n        firstSavingsRow.createCell(SavingsConstants.MIN_OPENING_BALANCE_COL).setCellValue(1000.0);\n        firstSavingsRow.createCell(SavingsConstants.LOCKIN_PERIOD_COL).setCellValue(1);\n        firstSavingsRow.createCell(SavingsConstants.LOCKIN_PERIOD_FREQUENCY_COL).setCellValue(\"Weeks\");\n        firstSavingsRow.createCell(SavingsConstants.APPLY_WITHDRAWAL_FEE_FOR_TRANSFERS).setCellValue(\"False\");\n        firstSavingsRow.createCell(SavingsConstants.ALLOW_OVER_DRAFT_COL).setCellValue(\"False\");\n        firstSavingsRow.createCell(SavingsConstants.OVER_DRAFT_LIMIT_COL)\n                .setCellValue(savingsProductSheet.getRow(1).getCell(15).getNumericCellValue());\n\n        String currentdirectory = new File(\"\").getAbsolutePath();\n        File directory = new File(currentdirectory + File.separator + \"src\" + File.separator + \"integrationTest\" + File.separator\n                + \"resources\" + File.separator + \"bulkimport\" + File.separator + \"importhandler\" + File.separator + \"savings\");\n        if (!directory.exists()) {\n            directory.mkdirs();\n        }\n        File file = new File(directory + File.separator + \"Savings.xls\");\n        OutputStream outputStream = new FileOutputStream(file);\n        workbook.write(outputStream);\n        outputStream.close();\n\n        String importDocumentId = savingsAccountHelper.importSavingsTemplate(file);\n        file.delete();\n        Assertions.assertNotNull(importDocumentId);\n\n        // Wait for the creation of output excel\n        Thread.sleep(10000);\n\n        // check status column of output excel\n        String location = savingsAccountHelper.getOutputTemplateLocation(importDocumentId);\n        FileInputStream fileInputStream = new FileInputStream(location);\n        Workbook Outputworkbook = new HSSFWorkbook(fileInputStream);\n        Sheet OutputSavingsSheet = Outputworkbook.getSheet(TemplatePopulateImportConstants.SAVINGS_ACCOUNTS_SHEET_NAME);\n        Row row = OutputSavingsSheet.getRow(1);\n\n        LOG.info(\"Output location: {}\", location);\n        LOG.info(\"Failure reason column: {}\", row.getCell(SavingsConstants.STATUS_COL).getStringCellValue());\n\n        Assertions.assertEquals(\"Imported\", row.getCell(SavingsConstants.STATUS_COL).getStringCellValue());\n        Outputworkbook.close();\n    }"}
{"prompt": "Create a test that tests test Client Entity Workbook Populate", "completion": "    @Test\n    public void testClientEntityWorkbookPopulate() throws IOException {\n        // in order to populate helper sheets\n        requestSpec.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON);\n        Integer outcome_staff_creation = StaffHelper.createStaff(requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_staff_creation, \"Could not create staff\");\n\n        // in order to populate helper sheets\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        Integer outcome_office_creation = officeHelper.createOffice(\"02 May 2000\");\n        Assertions.assertNotNull(outcome_office_creation, \"Could not create office\");\n\n        ClientHelper clientHelper = new ClientHelper(requestSpec, responseSpec);\n        Workbook workbook = clientHelper.getClientEntityWorkbook(GlobalEntityType.CLIENTS_ENTITY, \"dd MMMM yyyy\");\n        Sheet officeSheet = workbook.getSheet(TemplatePopulateImportConstants.OFFICE_SHEET_NAME);\n        Row firstOfficeRow = officeSheet.getRow(1);\n        Assertions.assertNotNull(firstOfficeRow.getCell(1), \"No offices found for given OfficeId \");\n        Sheet staffSheet = workbook.getSheet(TemplatePopulateImportConstants.STAFF_SHEET_NAME);\n        Row firstStaffRow = staffSheet.getRow(1);\n        Assertions.assertNotNull(firstStaffRow.getCell(1), \"No staff found for given staffId\");\n    }"}
{"prompt": "Create a test that tests test Loan Workbook Populate", "completion": "    @Test\n    public void testLoanWorkbookPopulate() throws IOException {\n        requestSpec.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON);\n        // in order to populate helper sheets\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        Integer outcome_office_creation = officeHelper.createOffice(\"02 May 2000\");\n        Assertions.assertNotNull(outcome_office_creation, \"Could not create office\");\n\n        // in order to populate helper sheets\n        Integer outcome_client_creation = ClientHelper.createClient(requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_client_creation, \"Could not create client\");\n\n        // in order to populate helper sheets\n        Integer outcome_group_creation = GroupHelper.createGroup(requestSpec, responseSpec, true);\n        Assertions.assertNotNull(outcome_group_creation, \"Could not create group\");\n\n        // in order to populate helper sheets\n        Integer outcome_staff_creation = StaffHelper.createStaff(requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_staff_creation, \"Could not create staff\");\n\n        LoanTransactionHelper loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n        LoanProductTestBuilder loanProductTestBuilder = new LoanProductTestBuilder();\n        String jsonLoanProduct = loanProductTestBuilder.build(null);\n        Integer outcome_lp_creaion = loanTransactionHelper.getLoanProductId(jsonLoanProduct);\n        Assertions.assertNotNull(outcome_lp_creaion, \"Could not create Loan Product\");\n\n        String jsonFund = \"{\\n\" + \"\\t\\\"name\\\": \\\"\" + Utils.uniqueRandomStringGenerator(\"Fund_Name\", 9) + \"\\\"\\n\" + \"}\";\n        Integer outcome_fund_creation = FundsResourceHandler.createFund(jsonFund, requestSpec, responseSpec);\n        Assertions.assertNotNull(outcome_fund_creation, \"Could not create Fund\");\n\n        String name = PaymentTypeHelper.randomNameGenerator(\"P_T\", 5);\n        String description = PaymentTypeHelper.randomNameGenerator(\"PT_Desc\", 15);\n        Boolean isCashPayment = true;\n        Integer position = 1;\n        Integer outcome_payment_creation = PaymentTypeHelper.createPaymentType(requestSpec, responseSpec, name, description, isCashPayment,\n                position);\n        Assertions.assertNotNull(outcome_payment_creation, \"Could not create payment type\");\n\n        Workbook workbook = loanTransactionHelper.getLoanWorkbook(\"dd MMMM yyyy\");\n\n        Sheet officeSheet = workbook.getSheet(TemplatePopulateImportConstants.OFFICE_SHEET_NAME);\n        Row firstOfficeRow = officeSheet.getRow(1);\n        Assertions.assertNotNull(firstOfficeRow.getCell(1), \"No offices found \");\n\n        Sheet clientSheet = workbook.getSheet(TemplatePopulateImportConstants.CLIENT_SHEET_NAME);\n        Row firstClientRow = clientSheet.getRow(1);\n        Assertions.assertNotNull(firstClientRow.getCell(1), \"No clients found \");\n\n        Sheet groupSheet = workbook.getSheet(TemplatePopulateImportConstants.GROUP_SHEET_NAME);\n        Row firstGroupRow = groupSheet.getRow(1);\n        Assertions.assertNotNull(firstGroupRow.getCell(1), \"No groups found \");\n\n        Sheet staffSheet = workbook.getSheet(TemplatePopulateImportConstants.STAFF_SHEET_NAME);\n        Row firstStaffRow = staffSheet.getRow(1);\n        Assertions.assertNotNull(firstStaffRow.getCell(1), \"No staff found \");\n\n        Sheet productSheet = workbook.getSheet(TemplatePopulateImportConstants.PRODUCT_SHEET_NAME);\n        Row firstProductRow = productSheet.getRow(1);\n        Assertions.assertNotNull(firstProductRow.getCell(1), \"No products found \");\n\n        Sheet extrasSheet = workbook.getSheet(TemplatePopulateImportConstants.EXTRAS_SHEET_NAME);\n        Row firstExtrasRow = extrasSheet.getRow(1);\n        Assertions.assertNotNull(firstExtrasRow.getCell(1), \"No Extras found \");\n    }"}
{"prompt": "Create a test that tests test Office Workbook Populate", "completion": "    @Test\n    public void testOfficeWorkbookPopulate() throws IOException {\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        Workbook workbook = officeHelper.getOfficeWorkBook(\"dd MMMM yyyy\");\n        Sheet sheet = workbook.getSheet(TemplatePopulateImportConstants.OFFICE_SHEET_NAME);\n        Row firstRow = sheet.getRow(1);\n        Assertions.assertNotNull(\"No parent offices found\", firstRow.getCell(OfficeConstants.LOOKUP_OFFICE_COL).getStringCellValue());\n        Assertions.assertEquals(1, firstRow.getCell(OfficeConstants.LOOKUP_OFFICE_ID_COL).getNumericCellValue(), 0.0);\n\n    }"}
{"prompt": "Create a test that tests test Savings Workbook Populate", "completion": "    @Test\n    public void testSavingsWorkbookPopulate() throws IOException {\n        requestSpec.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON);\n        // in order to populate helper sheets\n        OfficeHelper officeHelper = new OfficeHelper(requestSpec, responseSpec);\n        Integer outcome_office_creation = officeHelper.createOffice(\"02 May 2000\");\n        assertNotNull(outcome_office_creation, \"Could not create office\");\n\n        // in order to populate helper sheets\n        Integer outcome_client_creation = ClientHelper.createClient(requestSpec, responseSpec);\n        assertNotNull(outcome_client_creation, \"Could not create client\");\n\n        // in order to populate helper sheets\n        Integer outcome_group_creation = GroupHelper.createGroup(requestSpec, responseSpec, true);\n        assertNotNull(outcome_group_creation, \"Could not create group\");\n\n        // in order to populate helper sheets\n        Integer outcome_staff_creation = StaffHelper.createStaff(requestSpec, responseSpec);\n        assertNotNull(outcome_staff_creation, \"Could not create staff\");\n\n        SavingsProductHelper savingsProductHelper = new SavingsProductHelper();\n        String jsonSavingsProduct = savingsProductHelper.build();\n        Integer outcome_sp_creaction = SavingsProductHelper.createSavingsProduct(jsonSavingsProduct, requestSpec, responseSpec);\n        assertNotNull(outcome_sp_creaction, \"Could not create Savings product\");\n\n        SavingsAccountHelper savingsAccountHelper = new SavingsAccountHelper(requestSpec, responseSpec);\n        Workbook workbook = savingsAccountHelper.getSavingsWorkbook(\"dd MMMM yyyy\");\n\n        Sheet officeSheet = workbook.getSheet(TemplatePopulateImportConstants.OFFICE_SHEET_NAME);\n        Row firstOfficeRow = officeSheet.getRow(1);\n        assertNotNull(firstOfficeRow.getCell(1), \"No offices found \");\n\n        Sheet clientSheet = workbook.getSheet(TemplatePopulateImportConstants.CLIENT_SHEET_NAME);\n        Row firstClientRow = clientSheet.getRow(1);\n        assertNotNull(firstClientRow.getCell(1), \"No clients found \");\n\n        Sheet groupSheet = workbook.getSheet(TemplatePopulateImportConstants.GROUP_SHEET_NAME);\n        Row firstGroupRow = groupSheet.getRow(1);\n        assertNotNull(firstGroupRow.getCell(1), \"No groups found \");\n\n        Sheet staffSheet = workbook.getSheet(TemplatePopulateImportConstants.STAFF_SHEET_NAME);\n        Row firstStaffRow = staffSheet.getRow(1);\n        assertNotNull(firstStaffRow.getCell(1), \"No staff found \");\n\n        Sheet productSheet = workbook.getSheet(TemplatePopulateImportConstants.PRODUCT_SHEET_NAME);\n        Row firstProductRow = productSheet.getRow(1);\n        assertNotNull(firstProductRow.getCell(1), \"No products found \");\n    }"}
{"prompt": "Create a test that tests test Client Search Works With Lastname Text With Paging", "completion": "    @Test\n    public void testClientSearchWorks_WithLastnameText_WithPaging() {\n        // given\n        String lastname = Utils.randomStringGenerator(\"Client_LastName_\", 5);\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        request1.setLastname(lastname);\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        request2.setLastname(lastname);\n        clientHelper.createClient(request2);\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        request3.setLastname(lastname);\n        clientHelper.createClient(request3);\n        // when\n        PageClientSearchData result = clientHelper.searchClients(lastname, 0, 1);\n        // then\n        assertThat(result.getTotalElements()).isEqualTo(3);\n        assertThat(result.getNumberOfElements()).isEqualTo(1);\n        assertThat(result.getTotalPages()).isEqualTo(3);\n    }"}
{"prompt": "Create a test that tests test Client Search Works With Lastname Text On Default Ordering", "completion": "    @Test\n    public void testClientSearchWorks_WithLastnameTextOnDefaultOrdering() {\n        // given\n        String lastname = Utils.randomStringGenerator(\"Client_LastName_\", 5);\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        request1.setLastname(lastname);\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        request2.setLastname(lastname);\n        clientHelper.createClient(request2);\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        request3.setLastname(lastname);\n        clientHelper.createClient(request3);\n        // when\n        PageClientSearchData result = clientHelper.searchClients(lastname);\n        // then\n        assertThat(result.getTotalElements()).isEqualTo(3);\n        assertThat(result.getContent().get(0).getExternalId().getValue()).isEqualTo(request3.getExternalId());\n        assertThat(result.getContent().get(1).getExternalId().getValue()).isEqualTo(request2.getExternalId());\n        assertThat(result.getContent().get(2).getExternalId().getValue()).isEqualTo(request1.getExternalId());\n    }"}
{"prompt": "Create a test that tests test Client Search Works With Lastname Text Ordered By Id Asc", "completion": "    @Test\n    public void testClientSearchWorks_WithLastnameText_OrderedByIdAsc() {\n        // given\n        String lastname = Utils.randomStringGenerator(\"Client_LastName_\", 5);\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        request1.setLastname(lastname);\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        request2.setLastname(lastname);\n        clientHelper.createClient(request2);\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        request3.setLastname(lastname);\n        clientHelper.createClient(request3);\n\n        SortOrder sortOrder = new SortOrder().property(\"id\").direction(SortOrder.DirectionEnum.ASC);\n        // when\n        PageClientSearchData result = clientHelper.searchClients(lastname, sortOrder);\n        // then\n        assertThat(result.getTotalElements()).isEqualTo(3);\n        assertThat(result.getContent().get(0).getExternalId().getValue()).isEqualTo(request1.getExternalId());\n        assertThat(result.getContent().get(1).getExternalId().getValue()).isEqualTo(request2.getExternalId());\n        assertThat(result.getContent().get(2).getExternalId().getValue()).isEqualTo(request3.getExternalId());\n    }"}
{"prompt": "Create a test that tests test Client Search Works By External Id", "completion": "    @Test\n    public void testClientSearchWorks_ByExternalId() {\n        // given\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request2);\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request3);\n        // when\n        PageClientSearchData result = clientHelper.searchClients(request2.getExternalId());\n        // then\n        assertThat(result.getTotalElements()).isEqualTo(1);\n        assertThat(result.getContent().get(0).getExternalId().getValue()).isEqualTo(request2.getExternalId());\n    }"}
{"prompt": "Create a test that tests test Client Search Works By Account Number", "completion": "    @Test\n    public void testClientSearchWorks_ByAccountNumber() {\n        // given\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        PostClientsResponse response2 = clientHelper.createClient(request2);\n        GetClientsClientIdResponse client2Data = ClientHelper.getClient(requestSpec, responseSpec,\n                Math.toIntExact(response2.getClientId()));\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request3);\n        // when\n        PageClientSearchData result = clientHelper.searchClients(client2Data.getAccountNo());\n        // then\n        assertThat(result.getTotalElements()).isEqualTo(1);\n        assertThat(result.getContent().get(0).getAccountNumber()).isEqualTo(client2Data.getAccountNo());\n    }"}
{"prompt": "Create a test that tests test Client Search Works By Display Name", "completion": "    @Test\n    public void testClientSearchWorks_ByDisplayName() {\n        // given\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request2);\n        String client2DisplayName = \"%s %s\".formatted(request2.getFirstname(), request2.getLastname());\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request3);\n        // when\n        PageClientSearchData result = clientHelper.searchClients(client2DisplayName);\n        // then\n        assertThat(result.getTotalElements()).isEqualTo(1);\n        assertThat(result.getContent().get(0).getDisplayName()).isEqualTo(client2DisplayName);\n    }"}
{"prompt": "Create a test that tests test Client Search Works By Mobile No", "completion": "    @Test\n    public void testClientSearchWorks_ByMobileNo() {\n        // given\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        request2.setMobileNo(Utils.randomNumberGenerator(8).toString());\n        clientHelper.createClient(request2);\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request3);\n        // when\n        PageClientSearchData result = clientHelper.searchClients(request2.getMobileNo());\n        // then\n        assertThat(result.getTotalElements()).isEqualTo(1);\n        assertThat(result.getContent().get(0).getMobileNo()).isEqualTo(request2.getMobileNo());\n    }"}
{"prompt": "Create a test that tests test Client Search Doesnt Return Anything By Mobile No", "completion": "    @Test\n    public void testClientSearchDoesntReturnAnything_ByMobileNo() {\n        // given\n        PostClientsRequest request1 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request1);\n\n        PostClientsRequest request2 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request2);\n\n        PostClientsRequest request3 = ClientHelper.defaultClientCreationRequest();\n        clientHelper.createClient(request3);\n        // when\n        PageClientSearchData result = clientHelper.searchClients(Utils.randomNumberGenerator(8).toString());\n        // then\n        assertThat(result.getTotalElements()).isEqualTo(0);\n        assertThat(result.getContent()).isEmpty();\n    }"}
{"prompt": "Create a test that tests retrieve Any Existing", "completion": "    @Test\n    @Order(2)\n    void retrieveAnyExisting() {\n        assertThat(retrieveFirst()).isPresent();\n    }"}
{"prompt": "Create a test that tests create Document", "completion": "    @Test\n    @Order(2)\n    void createDocument() {\n        String name = \"Test\";\n        Part part = Parts.fromFile(testFile);\n        String description = \"The Description\";\n        var response = ok(fineract().documents.createDocument(\"clients\", clientId, part, name, description));\n        assertThat(response.getResourceId()).isNotNull();\n        assertThat(response.getResourceIdentifier()).isNotEmpty();\n        documentId = response.getResourceId();\n    }"}
{"prompt": "Create a test that tests get Document", "completion": "    @Test\n    @Order(3)\n    void getDocument() {\n        GetEntityTypeEntityIdDocumentsResponse doc = ok(fineract().documents.getDocument(\"clients\", clientId, documentId));\n        assertThat(doc.getName()).isEqualTo(\"Test\");\n        assertThat(doc.getFileName()).isEqualTo(testFile.getName());\n        assertThat(doc.getDescription()).isEqualTo(\"The Description\");\n        assertThat(doc.getId()).isEqualTo(documentId);\n        assertThat(doc.getParentEntityType()).isEqualTo(\"clients\");\n        assertThat(doc.getParentEntityId()).isEqualTo(clientId);\n        // TODO FINERACT-1251 It's more than uploaded file; seems like a bug - it's including create body, not just file\n        // size\n        assertThat(doc.getSize()).isEqualTo(testFile.length() + 618);\n        assertThat(doc.getType()).isEqualTo(\"image/jpeg\");\n        // TODO doc.getStorageType() shouldn't be exposed by the API?!\n    }"}
{"prompt": "Create a test that tests download File", "completion": "    @Test\n    @Order(4)\n    void downloadFile() throws IOException {\n        Response<ResponseBody> r = okR(fineract().documents.downloadFile(\"clients\", clientId, documentId));\n        try (ResponseBody body = r.body()) {\n            assertThat(body.contentType()).isEqualTo(MediaType.get(\"image/jpeg\"));\n            assertThat(body.bytes().length).isEqualTo(testFile.length());\n            assertThat(body.contentLength()).isEqualTo(testFile.length());\n        }\n        assertThat(Parts.fileName(r)).hasValue(testFile.getName());\n    }"}
{"prompt": "Create a test that tests update Document Without New Upload", "completion": "    @Test\n    @Order(10)\n    void updateDocumentWithoutNewUpload() {\n        String newName = \"Test changed name\";\n        String newDescription = getClass().getName();\n        ok(fineract().documents.updateDocument(\"clients\", clientId, documentId, null, newName, newDescription));\n\n        GetEntityTypeEntityIdDocumentsResponse doc = ok(fineract().documents.getDocument(\"clients\", clientId, documentId));\n        assertThat(doc.getName()).isEqualTo(newName);\n        assertThat(doc.getDescription()).isEqualTo(newDescription);\n        // TODO FINERACT-1251 It's more than uploaded file; seems like a bug - it's including create body, not just file\n        // size\n        assertThat(doc.getSize()).isEqualTo(testFile.length() + 618);\n    }"}
{"prompt": "Create a test that tests delete Document", "completion": "    @Test\n    @Order(99)\n    void deleteDocument() {\n        ok(fineract().documents.deleteDocument(\"clients\", clientId, documentId));\n        assertThat(fineract().documents.getDocument(\"clients\", clientId, documentId)).hasHttpStatus(404);\n    }"}
{"prompt": "Create a test that tests create Document Bad Args", "completion": "    @Order(9999)\n    @Test // FINERACT-1036\n    void createDocumentBadArgs() {\n        assertThat(fineract().documents.createDocument(\"clients\", 123L, null, \"test.pdf\", null)).hasHttpStatus(400);\n    }"}
{"prompt": "Create a test that tests get Original Size", "completion": "    @Test\n    @Order(2)\n    void getOriginalSize() throws IOException {\n        ResponseBody r = ok(fineract().images.get(\"staff\", staffId, 3505, 1972, null));\n        assertThat(r.contentType()).isEqualTo(MediaType.get(\"text/plain\"));\n        String encodedImage = r.string();\n        assertThat(encodedImage).startsWith(\"data:image/jpeg;base64,\");\n        assertThat(encodedImage).hasLength(2846549);\n        assertThat(r.contentLength()).isEqualTo(-1);\n    }"}
{"prompt": "Create a test that tests get Smaller Size", "completion": "    @Test\n    @Order(3)\n    void getSmallerSize() throws IOException {\n        ResponseBody r = ok(fineract().images.get(\"staff\", staffId, 128, 128, null));\n        assertThat(r.string()).hasLength(6591);\n    }"}
{"prompt": "Create a test that tests get Bigger Size", "completion": "    @Test\n    @Order(4)\n    void getBiggerSize() throws IOException {\n        ResponseBody r = ok(fineract().images.get(\"staff\", staffId, 9000, 6000, null));\n        assertThat(r.string()).hasLength(2846549);\n    }"}
{"prompt": "Create a test that tests get Inline Octet Output", "completion": "    @Test\n    @Order(5)\n    void getInlineOctetOutput() throws IOException {\n        // 3505x1972 is the exact original size of testFile\n        Response<ResponseBody> r = okR(fineract().images.get(\"staff\", staffId, 3505, 1972, \"inline_octet\"));\n        try (ResponseBody body = r.body()) {\n            assertThat(body.contentType()).isEqualTo(MediaType.get(\"image/jpeg\"));\n            assertThat(body.bytes().length).isEqualTo(testPart.body().contentLength());\n            assertThat(body.contentLength()).isEqualTo(testPart.body().contentLength());\n        }\n\n        var staff = ok(fineract().staff.retrieveOne8(staffId));\n        String expectedFileName = staff.getDisplayName() + \"JPEG\"; // without dot!\n        assertThat(Parts.fileName(r)).hasValue(expectedFileName);\n    }"}
{"prompt": "Create a test that tests get Octet Output", "completion": "    @Test\n    @Order(6)\n    void getOctetOutput() throws IOException {\n        ResponseBody r = ok(fineract().images.get(\"staff\", staffId, 3505, 1972, \"octet\"));\n        assertThat(r.contentType()).isEqualTo(MediaType.get(\"image/jpeg\"));\n        assertThat(r.bytes().length).isEqualTo(testPart.body().contentLength());\n        assertThat(r.contentLength()).isEqualTo(testPart.body().contentLength());\n    }"}
{"prompt": "Create a test that tests get Another Output", "completion": "    @Test\n    @Order(7)\n    void getAnotherOutput() throws IOException {\n        ResponseBody r = ok(fineract().images.get(\"staff\", staffId, 3505, 1972, \"abcd\"));\n        assertThat(r.contentType()).isEqualTo(MediaType.get(\"text/plain\"));\n        assertThat(r.string()).startsWith(\"data:image/jpeg;base64,\");\n    }"}
{"prompt": "Create a test that tests get Text", "completion": "    @Test\n    @Order(8)\n    void getText() throws IOException {\n        ResponseBody r = ok(fineract().createService(ImagesApiWithHeadersForTest.class).getText(\"staff\", staffId, 3505, 1972, null));\n        assertThat(r.contentType()).isEqualTo(MediaType.get(\"text/plain\"));\n        assertThat(r.string()).startsWith(\"data:image/jpeg;base64,\");\n    }"}
{"prompt": "Create a test that tests get Bytes", "completion": "    @Test\n    @Order(9)\n    void getBytes() throws IOException {\n        ResponseBody r = ok(fineract().createService(ImagesApiWithHeadersForTest.class).getBytes(\"staff\", staffId, 3505, 1972, null));\n        assertThat(r.contentType()).isEqualTo(MediaType.get(\"image/jpeg\"));\n        assertThat(r.bytes().length).isEqualTo(testPart.body().contentLength());\n    }"}
{"prompt": "Create a test that tests update", "completion": "    @Test\n    @Order(50)\n    void update() {\n        ok(fineract().images.update(\"staff\", staffId, testPart));\n    }"}
{"prompt": "Create a test that tests delete", "completion": "    @Test\n    @Order(99)\n    void delete() {\n        ok(fineract().images.delete(\"staff\", staffId));\n        ok(fineract().images.delete(\"clients\", clientId));\n    }"}
{"prompt": "Create a test that tests path Traversal Jsp", "completion": "    @Test\n    @Order(100)\n    void pathTraversalJsp() {\n        final MultipartBody.Part part = createPart(\"image-text-wrong-content.jsp\",\n                \"../../../../../../../../../../tmp/image-text-wrong-content.jsp\", \"image/gif\");\n\n        assertThat(part).isNotNull();\n\n        Exception exception = assertThrows(Exception.class, () -> {\n            ok(fineract().images.create(\"clients\", clientId, part));\n        });\n\n        assertThat(exception).isNotNull();\n\n        log.warn(\"Should not be able to upload a file that doesn't match the indicated content type: {}\", exception.getMessage());\n    }"}
{"prompt": "Create a test that tests gif With Png Extension", "completion": "    @Test\n    @Order(101)\n    void gifWithPngExtension() {\n        final MultipartBody.Part part = createPart(\"image-gif-wrong-extension.png\", \"image-gif-wrong-extension.png\", \"image/png\");\n\n        assertThat(part).isNotNull();\n\n        Exception exception = assertThrows(Exception.class, () -> {\n            ok(fineract().images.create(\"clients\", clientId, part));\n        });\n\n        assertThat(exception).isNotNull();\n\n        log.warn(\"Should not be able to upload a gif by just renaming the file extension: {}\", exception.getMessage());\n    }"}
{"prompt": "Create a test that tests gif Image", "completion": "    @Test\n    @Order(102)\n    void gifImage() {\n        final MultipartBody.Part part = createPart(\"image-gif-correct-extension.gif\", \"image-gif-correct-extension.gif\", \"image/png\");\n\n        assertThat(part).isNotNull();\n\n        Exception exception = assertThrows(Exception.class, () -> {\n            ok(fineract().images.create(\"clients\", clientId, part));\n        });\n\n        assertThat(exception).isNotNull();\n\n        log.warn(\"Should not be able to upload a gif it is not whitelisted: {}\", exception.getMessage());\n    }"}
{"prompt": "Create a test that tests path Traversal Jpg", "completion": "    @Test\n    @Order(103)\n    void pathTraversalJpg() {\n        final MultipartBody.Part part = createPart(\"michael.vorburger-crepes.jpg\",\n                \"../../../../../../../../../../tmp/michael.vorburger-crepes.jpg\", \"image/jpeg\");\n\n        assertThat(part).isNotNull();\n\n        Exception exception = assertThrows(Exception.class, () -> {\n            ok(fineract().images.create(\"clients\", clientId, part));\n        });\n\n        assertThat(exception).isNotNull();\n\n        log.warn(\"Should not be able to upload a file with a forbidden name pattern: {}\", exception.getMessage());\n    }"}
{"prompt": "Create a test that tests path Traversal With Absolute Path Jpg", "completion": "    @Test\n    @Order(104)\n    void pathTraversalWithAbsolutePathJpg() {\n        final MultipartBody.Part part = createPart(\"michael.vorburger-crepes.jpg\", \"../17/michael.vorburger-crepes.jpg\", \"image/jpeg\");\n\n        assertThat(part).isNotNull();\n\n        Exception exception = assertThrows(Exception.class, () -> {\n            ok(fineract().images.create(\"clients\", clientId, part));\n        });\n\n        assertThat(exception).isNotNull();\n\n        log.warn(\"Should not be able to upload a file with a forbidden name pattern: {}\", exception.getMessage());\n    }"}
{"prompt": "Create a test that tests path Traversal With Absolute Path Jpg2", "completion": "    @Test\n    @Order(105)\n    void pathTraversalWithAbsolutePathJpg2() {\n        final MultipartBody.Part part = createPart(\"michael.vorburger-crepes.jpg\", \"..//17//michael.vorburger-crepes.jpg\", \"image/jpeg\");\n\n        assertThat(part).isNotNull();\n\n        Exception exception = assertThrows(Exception.class, () -> {\n            ok(fineract().images.create(\"clients\", clientId, part));\n        });\n\n        assertThat(exception).isNotNull();\n\n        log.warn(\"Should not be able to upload a file with a forbidden name pattern: {}\", exception.getMessage());\n    }"}
{"prompt": "Create a test that tests retrieve One Existing Incl Date Format", "completion": "    @Test\n    @Order(2)\n    void retrieveOneExistingInclDateFormat() { // see FINERACT-1220 re. what this tests re. Date Format\n        List<GetOfficesResponse> response = ok(fineract().offices.retrieveOffices(true, null, null));\n        assertThat(response.size()).isAtLeast(1);\n        assertThat(response.get(0).getOpeningDate()).isNotNull();\n    }"}
{"prompt": "Create a test that tests run Client Listing Table Report CSV", "completion": "    @Test\n    void runClientListingTableReportCSV() throws IOException {\n        Response<ResponseBody> result = okR(\n                fineract().reportsRun.runReportGetFile(\"Client Listing\", Map.of(\"R_officeId\", \"1\", \"exportCSV\", \"true\"), false));\n        assertThat(result.body().contentType()).isEqualTo(MediaType.parse(\"text/csv\"));\n        assertThat(result.body().string()).contains(\"Office/Branch\");\n    }"}
{"prompt": "Create a test that tests run Client Listing Table Report S3", "completion": "    @Test\n    @CIOnly\n    void runClientListingTableReportS3() throws IOException {\n        Response<ResponseBody> result = okR(\n                fineract().reportsRun.runReportGetFile(\"Client Listing\", Map.of(\"R_officeId\", \"1\", \"exportS3\", \"true\"), false));\n        assertThat(result.code()).isEqualTo(204);\n    }"}
{"prompt": "Create a test that tests list Reports", "completion": "    @Test\n    void listReports() {\n        assertThat(ok(fineract().reports.retrieveReportList())).hasSize(126);\n    }"}
{"prompt": "Create a test that tests run Client Listing Table Report", "completion": "    @Test\n    void runClientListingTableReport() {\n        assertThat(ok(fineract().reportsRun.runReportGetData(\"Client Listing\", Map.of(\"R_officeId\", \"1\"), false)).getColumnHeaders().get(0)\n                .getColumnName()).isEqualTo(\"Office/Branch\");\n    }"}
{"prompt": "Create a test that tests run Report Category", "completion": "    @Test // see FINERACT-1306\n    void runReportCategory() throws IOException {\n        // Using raw OkHttp instead of Retrofit API here, because /runreports/reportCategoryList returns JSON Array -\n        // but runReportGetData() expects columnHeaders/data JSON.\n        var req = new Request.Builder().url(fineract().baseURL().resolve(\n                \"/fineract-provider/api/v1/runreports/reportCategoryList?R_reportCategory=Fund&genericResultSet=false&parameterType=true&tenantIdentifier=default\"))\n                .build();\n        try (var response = fineract().okHttpClient().newCall(req).execute()) {\n            assertThat(response.code()).isEqualTo(200);\n        }\n    }"}
{"prompt": "Create a test that tests run Expected Payments Pentaho Report Without Plugin", "completion": "    @Test\n    void runExpectedPaymentsPentahoReportWithoutPlugin() {\n        assertThat(fineract().reportsRun.runReportGetFile(\"Expected Payments By Date - Formatted\", Map.of(\"R_endDate\", \"2013-04-30\",\n                \"R_loanOfficerId\", \"-1\", \"R_officeId\", \"1\", \"R_startDate\", \"2013-04-16\", \"output-type\", \"PDF\"), false)).hasHttpStatus(503);\n    }"}
{"prompt": "Create a test that tests run Expected Payments Pentaho Report", "completion": "    @Test\n    @Disabled\n    void runExpectedPaymentsPentahoReport() {\n        ResponseBody r = ok(fineract().reportsRun.runReportGetFile(\"Expected Payments By Date - Formatted\", Map.of(\"R_endDate\",\n                \"2013-04-30\", \"R_loanOfficerId\", \"-1\", \"R_officeId\", \"1\", \"R_startDate\", \"2013-04-16\", \"output-type\", \"PDF\"), false));\n        assertThat(r.contentType()).isEqualTo(MediaType.get(\"application/pdf\"));\n    }"}
{"prompt": "Create a test that tests test Trial Balance Table Report Runs Successfully", "completion": "    @Test\n    void testTrialBalanceTableReportRunsSuccessfully() {\n        assertThat(fineract().reportsRun.runReportGetData(\"Trial Balance Table\",\n                Map.of(\"R_endDate\", \"2013-04-30\", \"R_officeId\", \"1\", \"R_startDate\", \"2013-04-16\"), false)).hasHttpStatus(200);\n    }"}
{"prompt": "Create a test that tests test Income Statement Table Report Runs Successfully", "completion": "    @Test\n    void testIncomeStatementTableReportRunsSuccessfully() {\n        assertThat(fineract().reportsRun.runReportGetData(\"Income Statement Table\",\n                Map.of(\"R_endDate\", \"2013-04-30\", \"R_officeId\", \"1\", \"R_startDate\", \"2013-04-16\"), false)).hasHttpStatus(200);\n    }"}
{"prompt": "Create a test that tests test General Ledger Report Table Report Runs Successfully", "completion": "    @Test\n    void testGeneralLedgerReportTableReportRunsSuccessfully() {\n        assertThat(fineract().reportsRun.runReportGetData(\"GeneralLedgerReport Table\",\n                Map.of(\"R_endDate\", \"2013-04-30\", \"R_officeId\", \"1\", \"R_startDate\", \"2013-04-16\", \"R_GLAccountNO\", \"1\"), false))\n                        .hasHttpStatus(200);\n    }"}
{"prompt": "Create a test that tests test Balance Sheet Table Report Runs Successfully", "completion": "    @Test\n    void testBalanceSheetTableReportRunsSuccessfully() {\n        assertThat(\n                fineract().reportsRun.runReportGetData(\"Balance Sheet Table\", Map.of(\"R_endDate\", \"2013-04-30\", \"R_officeId\", \"1\"), false))\n                        .hasHttpStatus(200);\n    }"}
{"prompt": "Create a test that tests client Charge Test", "completion": "    @Test\n    public void clientChargeTest() {\n\n        // Creates clientCharge\n        final Integer chargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getChargeSpecifiedDueDateJSON());\n        Assertions.assertNotNull(chargeId);\n\n        // creates client with activation date\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec, \"01 October 2011\");\n        Assertions.assertNotNull(clientId);\n\n        /**\n         * create a charge for loan and try to associate to client created in the above lines.it will be an invalid\n         * scenario the reason is client is not allowed to have only client charge.\n         *\n         */\n        final Integer loanChargeId = ChargesHelper.createCharges(this.requestSpec, this.responseSpec,\n                ChargesHelper.getLoanSpecifiedDueDateJSON());\n        Assertions.assertNotNull(loanChargeId);\n        ResponseSpecification responseLoanChargeFailure = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final Integer clientLoanChargeId = ClientHelper.addChargesForClient(this.requestSpec, responseLoanChargeFailure, clientId,\n                ClientHelper.getSpecifiedDueDateChargesClientAsJSON(loanChargeId.toString(), \"29 October 2011\"));\n        Assertions.assertNull(clientLoanChargeId);\n\n        /**\n         * associates a clientCharge to a client and pay client charge for 10 USD--success scenario\n         **/\n        final Integer clientChargeId = ClientHelper.addChargesForClient(this.requestSpec, this.responseSpec, clientId,\n                ClientHelper.getSpecifiedDueDateChargesClientAsJSON(chargeId.toString(), \"29 October 2011\"));\n        Assertions.assertNotNull(clientChargeId);\n        final String clientChargePaidTransactionId = ClientHelper.payChargesForClients(this.requestSpec, this.responseSpec, clientId,\n                clientChargeId, ClientHelper.getPayChargeJSON(\"25 AUGUST 2015\", \"10\"));\n        Assertions.assertNotNull(clientChargePaidTransactionId);\n        isValidOutstandingAmount(ClientHelper.getClientCharge(requestSpec, responseSpec, clientId.toString(), clientChargeId.toString()),\n                (float) 190.0);\n\n        /**\n         * Revert the paid client charge transaction by passing the clientChargePaidTransactionId and ensure the same is\n         * reverted.\n         */\n        final Integer undoTrxnId = ClientHelper.revertClientChargeTransaction(this.requestSpec, this.responseSpec, clientId.toString(),\n                clientChargePaidTransactionId);\n        Assertions.assertNotNull(undoTrxnId);\n        isReversedTransaction(clientId.toString(), undoTrxnId.toString());\n        /**\n         * Now pay client charge for 20 USD and ensure the outstanding amount is updated properly\n         */\n        ResponseSpecification responseSpecFailure = new ResponseSpecBuilder().expectStatusCode(400).build();\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        dateFormat.setTimeZone(Utils.getTimeZoneOfTenant());\n        Calendar today = Calendar.getInstance(Utils.getTimeZoneOfTenant());\n        today.add(Calendar.DAY_OF_MONTH, 2);\n        final String responseId_futureDate_failure = ClientHelper.payChargesForClients(this.requestSpec, responseSpecFailure, clientId,\n                clientChargeId, ClientHelper.getPayChargeJSON(dateFormat.format(today.getTime()), \"20\"));\n        Assertions.assertNull(responseId_futureDate_failure);\n\n        // waived off the outstanding client charge\n        final String waiveOffClientChargeTransactionId = ClientHelper.waiveChargesForClients(this.requestSpec, this.responseSpec, clientId,\n                clientChargeId, ClientHelper.getWaiveChargeJSON(\"100\", clientChargeId.toString()));\n        Assertions.assertNotNull(waiveOffClientChargeTransactionId);\n\n        /**\n         * Revert the waived off client charge transaction by passing the waiveOffClientChargeTransactionId and ensured\n         * the transaction is reversed.\n         */\n        final Integer undoWaiveTrxnId = ClientHelper.revertClientChargeTransaction(this.requestSpec, this.responseSpec, clientId.toString(),\n                waiveOffClientChargeTransactionId);\n        Assertions.assertNotNull(undoWaiveTrxnId);\n        isReversedTransaction(clientId.toString(), undoWaiveTrxnId.toString());\n        /**\n         * pay client charge before client activation date and ensured its a failure test case\n         */\n\n        final String responseId_activationDate_failure = ClientHelper.payChargesForClients(this.requestSpec, responseSpecFailure, clientId,\n                clientChargeId, ClientHelper.getPayChargeJSON(\"30 September 2011\", \"20\"));\n        Assertions.assertNull(responseId_activationDate_failure);\n        /**\n         * pay client charge more than outstanding amount amount and ensured its a failure test case\n         */\n        final String responseId_moreAmount_failure = ClientHelper.payChargesForClients(this.requestSpec, responseSpecFailure, clientId,\n                clientChargeId, ClientHelper.getPayChargeJSON(\"25 AUGUST 2015\", \"300\"));\n        Assertions.assertNull(responseId_moreAmount_failure);\n        /**\n         * pay client charge for 10 USD and ensure outstanding amount is updated properly\n         */\n        final String chargePaid_responseId = ClientHelper.payChargesForClients(this.requestSpec, this.responseSpec, clientId,\n                clientChargeId, ClientHelper.getPayChargeJSON(\"25 AUGUST 2015\", \"100\"));\n        Assertions.assertNotNull(chargePaid_responseId);\n\n        isValidOutstandingAmount(ClientHelper.getClientCharge(requestSpec, responseSpec, clientId.toString(), clientChargeId.toString()),\n                (float) 100.0);\n\n    }"}
{"prompt": "Create a test that tests test Create Provisioning Criteria", "completion": "    @Test\n    public void testCreateProvisioningCriteria() {\n        ProvisioningTransactionHelper transactionHelper = new ProvisioningTransactionHelper(requestSpec, responseSpec);\n        ArrayList<Integer> loanProducts = new ArrayList<>(LOANPRODUCTS_SIZE);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        for (int i = 0; i < LOANPRODUCTS_SIZE; i++) {\n            final Integer loanProductID = createLoanProduct(false, NONE);\n            loanProducts.add(loanProductID);\n            Assertions.assertNotNull(loanProductID);\n            List<HashMap> collaterals = new ArrayList<>();\n            final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n            Assertions.assertNotNull(collateralId);\n            final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                    String.valueOf(clientID), collateralId);\n            Assertions.assertNotNull(clientCollateralId);\n            addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n            final Integer loanID = applyForLoanApplication(clientID, loanProductID, null, null, \"1,00,000.00\", collaterals);\n            HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n            loanStatusHashMap = this.loanTransactionHelper.approveLoan(\"20 September 2011\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n            LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n            LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n            String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n            loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"20 September 2011\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n            Assertions.assertNotNull(loanID);\n        }\n\n        ArrayList categories = transactionHelper.retrieveAllProvisioningCategories();\n        Assertions.assertTrue(categories.size() > 0);\n        Account liability = accountHelper.createLiabilityAccount();\n        Account expense = accountHelper.createExpenseAccount();\n        Map requestCriteria = ProvisioningHelper.createProvisioingCriteriaJson(loanProducts, categories, liability, expense);\n        String provisioningCriteriaCreateJson = new Gson().toJson(requestCriteria);\n        Integer criteriaId = transactionHelper.createProvisioningCriteria(provisioningCriteriaCreateJson);\n        Assertions.assertNotNull(criteriaId);\n\n        Map newCriteria = transactionHelper.retrieveProvisioningCriteria(criteriaId);\n        validateProvisioningCriteria(requestCriteria, newCriteria);\n\n        ArrayList definitions = (ArrayList) newCriteria.get(\"definitions\");\n        for (int i = 0; i < definitions.size(); i++) {\n            Map criteriadefinition = (Map) definitions.get(i);\n            criteriadefinition.put(\"provisioningPercentage\", Float.valueOf((float) 20.0));\n        }\n        newCriteria.put(\"locale\", \"en\");\n        String updateCriteriaString = new Gson().toJson(newCriteria);\n        Integer criteriaId1 = transactionHelper.updateProvisioningCriteria(criteriaId, updateCriteriaString);\n        Map updatedCriteria = transactionHelper.retrieveProvisioningCriteria(criteriaId1);\n        validateProvisioningCriteria(newCriteria, updatedCriteria);\n\n        transactionHelper.deleteProvisioningCriteria(criteriaId1);\n\n        categories = transactionHelper.retrieveAllProvisioningCategories();\n        liability = accountHelper.createLiabilityAccount();\n        expense = accountHelper.createExpenseAccount();\n        requestCriteria = ProvisioningHelper.createProvisioingCriteriaJson(loanProducts, categories, liability, expense);\n        provisioningCriteriaCreateJson = new Gson().toJson(requestCriteria);\n        criteriaId = transactionHelper.createProvisioningCriteria(provisioningCriteriaCreateJson);\n        Assertions.assertNotNull(criteriaId);\n\n        String provisioningEntryJson = ProvisioningHelper.createProvisioningEntryJson();\n        Integer provisioningEntryId = transactionHelper.createProvisioningEntries(provisioningEntryJson);\n        Assertions.assertNotNull(provisioningEntryId);\n\n        transactionHelper.updateProvisioningEntry(\"recreateprovisioningentry\", provisioningEntryId, \"\");\n        transactionHelper.updateProvisioningEntry(\"createjournalentry\", provisioningEntryId, \"\");\n        Map entry = transactionHelper.retrieveProvisioningEntry(provisioningEntryId);\n        Assertions.assertTrue((Boolean) entry.get(\"journalEntry\"));\n        Map provisioningEntry = transactionHelper.retrieveProvisioningEntries(provisioningEntryId);\n        Assertions.assertTrue(((ArrayList) provisioningEntry.get(\"pageItems\")).size() > 0);\n    }"}
{"prompt": "Create a test that tests test Supported Actions For Campaign With Trigger Type As Direct", "completion": "    @Test\n    public void testSupportedActionsForCampaignWithTriggerTypeAsDirect() {\n        // creating new campaign\n        Integer campaignId = this.campaignsHelper.createCampaign(NON_TRIGGERED_REPORT_NAME, DIRECT_TRIGGER_TYPE);\n        this.campaignsHelper.verifyCampaignCreatedOnServer(this.requestSpec, this.responseSpec, campaignId);\n\n        // updating campaign\n        Integer updatedCampaignId = this.campaignsHelper.updateCampaign(this.requestSpec, this.responseSpec, campaignId,\n                NON_TRIGGERED_REPORT_NAME, DIRECT_TRIGGER_TYPE);\n        assertEquals(campaignId, updatedCampaignId);\n\n        // activating campaign\n        Integer activatedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                ACTIVATE_COMMAND);\n        assertEquals(activatedCampaignId, campaignId);\n\n        // closing campaign\n        Integer closedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                CLOSE_COMMAND);\n        assertEquals(closedCampaignId, campaignId);\n\n        // reactivating campaign\n        Integer reactivateCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                REACTIVATE_COMMAND);\n        assertEquals(reactivateCampaignId, campaignId);\n\n        // closing campaign again for deletion\n        closedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId, CLOSE_COMMAND);\n        assertEquals(closedCampaignId, campaignId);\n\n        // deleting campaign\n        Integer deletedCampaignId = this.campaignsHelper.deleteCampaign(this.requestSpec, this.responseSpec, campaignId);\n        assertEquals(deletedCampaignId, campaignId);\n    }"}
{"prompt": "Create a test that tests test Supported Actions For Campaign With Trigger Type As Scheduled", "completion": "    @Test\n    public void testSupportedActionsForCampaignWithTriggerTypeAsScheduled() {\n        // creating new campaign\n        Integer campaignId = this.campaignsHelper.createCampaign(NON_TRIGGERED_REPORT_NAME, SCHEDULED_TRIGGER_TYPE);\n        this.campaignsHelper.verifyCampaignCreatedOnServer(this.requestSpec, this.responseSpec, campaignId);\n\n        // updating campaign\n        Integer updatedCampaignId = this.campaignsHelper.updateCampaign(this.requestSpec, this.responseSpec, campaignId,\n                NON_TRIGGERED_REPORT_NAME, SCHEDULED_TRIGGER_TYPE);\n        assertEquals(campaignId, updatedCampaignId);\n\n        // activating campaign\n        Integer activatedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                ACTIVATE_COMMAND);\n        assertEquals(activatedCampaignId, campaignId);\n\n        // closing campaign\n        Integer closedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                CLOSE_COMMAND);\n        assertEquals(closedCampaignId, campaignId);\n\n        // reactivating campaign\n        Integer reactivateCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                REACTIVATE_COMMAND);\n        assertEquals(reactivateCampaignId, campaignId);\n\n        // closing campaign again for deletion\n        closedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId, CLOSE_COMMAND);\n        assertEquals(closedCampaignId, campaignId);\n\n        // deleting campaign\n        Integer deletedCampaignId = this.campaignsHelper.deleteCampaign(this.requestSpec, this.responseSpec, campaignId);\n        assertEquals(deletedCampaignId, campaignId);\n    }"}
{"prompt": "Create a test that tests test Supported Actions For Campaign With Trigger Type As Triggered", "completion": "    @Test\n    public void testSupportedActionsForCampaignWithTriggerTypeAsTriggered() {\n        // creating new campaign\n        Integer campaignId = this.campaignsHelper.createCampaign(TRIGGERED_REPORT_NAME, TRIGGERED_TRIGGER_TYPE);\n        this.campaignsHelper.verifyCampaignCreatedOnServer(this.requestSpec, this.responseSpec, campaignId);\n\n        // updating campaign\n        Integer updatedCampaignId = this.campaignsHelper.updateCampaign(this.requestSpec, this.responseSpec, campaignId,\n                TRIGGERED_REPORT_NAME, TRIGGERED_TRIGGER_TYPE);\n        assertEquals(campaignId, updatedCampaignId);\n\n        // activating campaign\n        Integer activatedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                ACTIVATE_COMMAND);\n        assertEquals(activatedCampaignId, campaignId);\n\n        // closing campaign\n        Integer closedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                CLOSE_COMMAND);\n        assertEquals(closedCampaignId, campaignId);\n\n        // reactivating campaign\n        Integer reactivateCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                REACTIVATE_COMMAND);\n        assertEquals(reactivateCampaignId, campaignId);\n\n        // closing campaign again for deletion\n        closedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId, CLOSE_COMMAND);\n        assertEquals(closedCampaignId, campaignId);\n\n        // deleting campaign\n        Integer deletedCampaignId = this.campaignsHelper.deleteCampaign(this.requestSpec, this.responseSpec, campaignId);\n        assertEquals(deletedCampaignId, campaignId);\n    }"}
{"prompt": "Create a test that tests test Supported Actions For Campaign With Error", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSupportedActionsForCampaignWithError() {\n        final ResponseSpecification responseSpecWithError = new ResponseSpecBuilder().expectStatusCode(400).build();\n        CampaignsHelper campaignsHelperWithError = new CampaignsHelper(this.requestSpec, responseSpecWithError);\n        // creating new campaign\n        Integer campaignId = this.campaignsHelper.createCampaign(NON_TRIGGERED_REPORT_NAME, DIRECT_TRIGGER_TYPE);\n        this.campaignsHelper.verifyCampaignCreatedOnServer(this.requestSpec, this.responseSpec, campaignId);\n\n        // activating campaign with failure\n        ArrayList<HashMap<String, Object>> campaignDateValidationData = (ArrayList<HashMap<String, Object>>) campaignsHelperWithError\n                .performActionsOnCampaignWithFailure(campaignId, ACTIVATE_COMMAND,\n                        Utils.getLocalDateOfTenant().plusDays(1).format(DateTimeFormatter.ofPattern(DATE_FORMAT)),\n                        CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.campaign.activationDate.in.the.future\",\n                campaignDateValidationData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        // activating campaign\n        Integer activatedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                ACTIVATE_COMMAND);\n        assertEquals(activatedCampaignId, campaignId);\n\n        // activating campaign with failure\n        ArrayList<HashMap<String, Object>> campaignErrorData = (ArrayList<HashMap<String, Object>>) campaignsHelperWithError\n                .performActionsOnCampaignWithFailure(activatedCampaignId, ACTIVATE_COMMAND,\n                        Utils.getLocalDateOfTenant().format(DateTimeFormatter.ofPattern(DATE_FORMAT)), CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.campaign.already.active\", campaignErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        // closing campaign again for deletion\n        Integer closedCampaignId = this.campaignsHelper.performActionsOnCampaign(this.requestSpec, this.responseSpec, campaignId,\n                CLOSE_COMMAND);\n        assertEquals(closedCampaignId, campaignId);\n\n        // deleting campaign\n        Integer deletedCampaignId = this.campaignsHelper.deleteCampaign(this.requestSpec, this.responseSpec, campaignId);\n        assertEquals(deletedCampaignId, campaignId);\n\n    }"}
{"prompt": "Create a test that tests validate Create Delete Datatable Check", "completion": "    @Test\n    public void validateCreateDeleteDatatableCheck() {\n        // creating datatable\n        String datatableName = this.datatableHelper.createDatatable(CLIENT_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, datatableName);\n\n        // creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(CLIENT_APP_TABLE_NAME, datatableName,\n                100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        // deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        // deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(datatableName);\n        assertEquals(datatableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    }"}
{"prompt": "Create a test that tests validate Create Delete Entity Datatable Check", "completion": "    @Test\n    public void validateCreateDeleteEntityDatatableCheck() {\n        // creating datatable\n        String datatableName = this.datatableHelper.createDatatable(CLIENT_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, datatableName);\n\n        // creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(CLIENT_APP_TABLE_NAME, datatableName,\n                100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        // deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        // deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(datatableName);\n        assertEquals(datatableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    }"}
{"prompt": "Create a test that tests validate Retrive Entity Datatable Checks List", "completion": "    @Test\n    public void validateRetriveEntityDatatableChecksList() {\n        // retrieving entity datatable check\n        String entityDatatableChecksList = this.entityDatatableChecksHelper.retrieveEntityDatatableCheck();\n        assertNotNull(\"ERROR IN RETRIEVING THE ENTITY DATATABLE CHECKS\", entityDatatableChecksList);\n    }"}
{"prompt": "Create a test that tests validate Create Client With Entity Datatable Check", "completion": "    @Test\n    public void validateCreateClientWithEntityDatatableCheck() {\n\n        // creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(CLIENT_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        // creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(CLIENT_APP_TABLE_NAME,\n                registeredTableName, 100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        // creating client with datatables\n        final Integer clientID = ClientHelper.createClientPendingWithDatatable(requestSpec, responseSpec, registeredTableName);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        // deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        // deleting datatable entries\n        Integer appTableId = this.datatableHelper.deleteDatatableEntries(registeredTableName, clientID, \"clientId\");\n        assertEquals(clientID, appTableId, \"ERROR IN DELETING THE DATATABLE ENTRIES\");\n\n        // deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    }"}
{"prompt": "Create a test that tests validate Create Client With Entity Datatable Check With Failure", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void validateCreateClientWithEntityDatatableCheckWithFailure() {\n        // building error response with status code 403\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final ClientHelper validationErrorHelper = new ClientHelper(this.requestSpec, errorResponse);\n\n        // creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(CLIENT_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        // creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(CLIENT_APP_TABLE_NAME,\n                registeredTableName, 100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        // creating client with datatables with error\n        ArrayList<HashMap<Object, Object>> clientErrorData = (ArrayList<HashMap<Object, Object>>) validationErrorHelper\n                .createClientPendingWithError(CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.entry.required.in.datatable.[\" + registeredTableName + \"]\",\n                clientErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        // deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        // deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    }"}
{"prompt": "Create a test that tests validate Create Group With Entity Datatable Check", "completion": "    @Test\n    public void validateCreateGroupWithEntityDatatableCheck() {\n\n        // creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(GROUP_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        // creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(GROUP_APP_TABLE_NAME,\n                registeredTableName, 100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        // creating group with datatables\n        final Integer groupId = GroupHelper.createGroupPendingWithDatatable(this.requestSpec, this.responseSpec, registeredTableName);\n        GroupHelper.verifyGroupCreatedOnServer(this.requestSpec, this.responseSpec, groupId);\n\n        // deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        // deleting datatable entries\n        Integer appTableId = this.datatableHelper.deleteDatatableEntries(registeredTableName, groupId, \"groupId\");\n        assertEquals(groupId, appTableId, \"ERROR IN DELETING THE DATATABLE ENTRIES\");\n\n        // deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    }"}
{"prompt": "Create a test that tests validate Create Group With Entity Datatable Check With Failure", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void validateCreateGroupWithEntityDatatableCheckWithFailure() {\n        // building error response with status code 403\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final GroupHelper validationErrorHelper = new GroupHelper(this.requestSpec, errorResponse);\n\n        // creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(GROUP_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        // creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(GROUP_APP_TABLE_NAME,\n                registeredTableName, 100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        // creating group with datatables with error\n        ArrayList<HashMap<Object, Object>> groupErrorData = (ArrayList<HashMap<Object, Object>>) validationErrorHelper\n                .createGroupWithError(CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.entry.required.in.datatable.[\" + registeredTableName + \"]\",\n                groupErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        // deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        // deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    }"}
{"prompt": "Create a test that tests validate Create Savings With Entity Datatable Check", "completion": "    @Test\n    public void validateCreateSavingsWithEntityDatatableCheck() {\n\n        this.savingsAccountHelper = new SavingsAccountHelper(this.requestSpec, this.responseSpec);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n\n        // creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(SAVINGS_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        // creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(SAVINGS_APP_TABLE_NAME,\n                registeredTableName, 100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        // creating savings with datatables\n        final Integer savingsId = this.savingsAccountHelper.applyForSavingsApplicationWithDatatables(clientID, savingsProductID,\n                ACCOUNT_TYPE_INDIVIDUAL, \"01 December 2016\", registeredTableName);\n        Assertions.assertNotNull(savingsId);\n\n        // deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        // deleting datatable entries\n        Integer appTableId = this.datatableHelper.deleteDatatableEntries(registeredTableName, savingsId, \"savingsId\");\n        assertEquals(savingsId, appTableId, \"ERROR IN DELETING THE DATATABLE ENTRIES\");\n\n        // deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    }"}
{"prompt": "Create a test that tests validate Create Savings With Entity Datatable Check With Failure", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void validateCreateSavingsWithEntityDatatableCheckWithFailure() {\n        // building error response with status code 403\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        final SavingsAccountHelper validationErrorHelper = new SavingsAccountHelper(this.requestSpec, errorResponse);\n\n        final String minBalanceForInterestCalculation = null;\n        final String minRequiredBalance = null;\n        final String enforceMinRequiredBalance = \"false\";\n        final boolean allowOverdraft = false;\n\n        // creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(SAVINGS_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        // creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(SAVINGS_APP_TABLE_NAME,\n                registeredTableName, 100, null);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        final Integer savingsProductID = createSavingsProduct(this.requestSpec, this.responseSpec, MINIMUM_OPENING_BALANCE,\n                minBalanceForInterestCalculation, minRequiredBalance, enforceMinRequiredBalance, allowOverdraft);\n        Assertions.assertNotNull(savingsProductID);\n\n        // creating savings with datatables with error\n        ArrayList<HashMap<Object, Object>> groupErrorData = (ArrayList<HashMap<Object, Object>>) validationErrorHelper\n                .applyForSavingsApplicationWithFailure(clientID, savingsProductID, ACCOUNT_TYPE_INDIVIDUAL, \"01 December 2016\",\n                        CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.entry.required.in.datatable.[\" + registeredTableName + \"]\",\n                groupErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        // deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        // deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    }"}
{"prompt": "Create a test that tests validate Create Loan With Entity Datatable Check", "completion": "    @Test\n    public void validateCreateLoanWithEntityDatatableCheck() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        // creating client\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        // creating loan product\n        final Integer loanProductID = createLoanProduct(\"100\", \"0\", LoanProductTestBuilder.DEFAULT_STRATEGY);\n        Assertions.assertNotNull(loanProductID);\n\n        // creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(LOAN_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        // creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(LOAN_APP_TABLE_NAME,\n                registeredTableName, 100, loanProductID);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        // creating new loan application\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, \"5\", registeredTableName);\n        Assertions.assertNotNull(loanID);\n\n        // deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        // deleting datatable entries\n        Integer appTableId = this.datatableHelper.deleteDatatableEntries(registeredTableName, loanID, \"loanId\");\n        assertEquals(loanID, appTableId, \"ERROR IN DELETING THE DATATABLE ENTRIES\");\n\n        // deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    }"}
{"prompt": "Create a test that tests validate Create Loan With Entity Datatable Check With Failure", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void validateCreateLoanWithEntityDatatableCheckWithFailure() {\n        this.loanTransactionHelper = new LoanTransactionHelper(this.requestSpec, this.responseSpec);\n\n        // building error response with status code 403\n        final ResponseSpecification errorResponse = new ResponseSpecBuilder().expectStatusCode(403).build();\n        this.validationErrorHelper = new LoanTransactionHelper(this.requestSpec, errorResponse);\n\n        // creating client\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        // creating loan product\n        final Integer loanProductID = createLoanProduct(\"100\", \"0\", LoanProductTestBuilder.DEFAULT_STRATEGY);\n        Assertions.assertNotNull(loanProductID);\n\n        // creating datatable\n        String registeredTableName = this.datatableHelper.createDatatable(LOAN_APP_TABLE_NAME, false);\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, registeredTableName);\n\n        // creating new entity datatable check\n        Integer entityDatatableCheckId = this.entityDatatableChecksHelper.createEntityDatatableCheck(LOAN_APP_TABLE_NAME,\n                registeredTableName, 100, loanProductID);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN CREATING THE ENTITY DATATABLE CHECK\");\n\n        // creating new loan application with error\n        ArrayList<HashMap<Object, Object>> loanErrorData = (ArrayList<HashMap<Object, Object>>) applyForLoanApplicationWithError(clientID,\n                loanProductID, \"5\", CommonConstants.RESPONSE_ERROR);\n        assertEquals(\"error.msg.entry.required.in.datatable.[\" + registeredTableName + \"]\",\n                loanErrorData.get(0).get(CommonConstants.RESPONSE_ERROR_MESSAGE_CODE));\n\n        // deleting entity datatable check\n        entityDatatableCheckId = this.entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheckId);\n        assertNotNull(entityDatatableCheckId, \"ERROR IN DELETING THE ENTITY DATATABLE CHECK\");\n\n        // deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(registeredTableName);\n        assertEquals(registeredTableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    }"}
{"prompt": "Create a test that tests create Client With Datatable Using Entity Subtype", "completion": "    @Test\n    public void createClientWithDatatableUsingEntitySubtype() {\n        // creating datatable for client entity person subentity\n        HashMap<String, Object> columnMap = new HashMap<>();\n        final List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n        final String datatableNamePerson = Utils.uniqueRandomStringGenerator(CLIENT_APP_TABLE_NAME + \"_person_\", 5).toLowerCase()\n                .toLowerCase();\n        final String datatableNameEntity = Utils.uniqueRandomStringGenerator(CLIENT_APP_TABLE_NAME + \"_entity_\", 5).toLowerCase()\n                .toLowerCase();\n\n        String itsAString = \"itsastring\";\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsAString, \"String\", true, 10, null);\n\n        // Person Subtype\n        columnMap.put(\"datatableName\", datatableNamePerson);\n        columnMap.put(\"apptableName\", CLIENT_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"PERSON\");\n        columnMap.put(\"multiRow\", false);\n        String dateFormat = \"dateFormat\";\n\n        columnMap.put(\"columns\", datatableColumnsList);\n        String datatabelRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"map : {}\", datatabelRequestJsonString);\n\n        datatableHelper.createDatatable(datatabelRequestJsonString, \"\");\n\n        PostEntityDatatableChecksTemplateResponse entityDatatableChecksResponse = entityDatatableChecksHelper\n                .addEntityDatatableCheck(CLIENT_APP_TABLE_NAME, datatableNamePerson, 100, null);\n        assertNotNull(entityDatatableChecksResponse);\n        final Long personDatatableCheck = entityDatatableChecksResponse.getResourceId();\n        LOG.info(\"entityDatatableChecksResponse Person: {}\", entityDatatableChecksResponse.getResourceId());\n\n        // Entity Subtype\n        columnMap = new HashMap<>();\n        columnMap.put(\"datatableName\", datatableNameEntity);\n        columnMap.put(\"apptableName\", CLIENT_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"ENTITY\");\n        columnMap.put(\"multiRow\", false);\n\n        columnMap.put(\"columns\", datatableColumnsList);\n        datatabelRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"map : {}\", datatabelRequestJsonString);\n\n        datatableHelper.createDatatable(datatabelRequestJsonString, \"\");\n\n        entityDatatableChecksResponse = entityDatatableChecksHelper.addEntityDatatableCheck(CLIENT_APP_TABLE_NAME, datatableNameEntity, 100,\n                null);\n        assertNotNull(entityDatatableChecksResponse);\n        final Long entityDatatableCheck = entityDatatableChecksResponse.getResourceId();\n        LOG.info(\"entityDatatableChecksResponse Entity: {}\", entityDatatableChecksResponse.getResourceId());\n\n        final HashMap<String, Object> datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(itsAString, Utils.randomStringGenerator(\"\", 8));\n        datatableEntryMap.put(\"locale\", \"en\");\n\n        final HashMap<String, Object> datatablesMap = new HashMap<>();\n        datatablesMap.put(\"registeredTableName\", datatableNamePerson);\n        datatablesMap.put(\"data\", datatableEntryMap);\n\n        String datatablesJsonString = new Gson().toJson(datatablesMap);\n        LOG.info(\"map : {}\", datatablesJsonString);\n\n        PostClientsResponse postClientsResponse = ClientHelper.createClientAsPersonWithDatatable(requestSpec, responseSpec, \"04 March 2011\",\n                \"1\", datatablesMap);\n        assertNotNull(postClientsResponse);\n        assertNotNull(postClientsResponse.getResourceId());\n\n        // Remove the Entity Datatable checks for others tests\n        entityDatatableChecksHelper.deleteEntityDatatableCheck(personDatatableCheck.intValue());\n        entityDatatableChecksHelper.deleteEntityDatatableCheck(entityDatatableCheck.intValue());\n    }"}
{"prompt": "Create a test that tests test Create Dividends", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testCreateDividends() {\n        DateFormat simple = new SimpleDateFormat(\"dd MMM yyyy\");\n        final Integer productId = createShareProduct();\n        ArrayList<Integer> shareAccounts = new ArrayList<>();\n        for (int i = 0; i < 5; i++) {\n            final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n            Assertions.assertNotNull(clientId);\n            Integer savingsAccountId = SavingsAccountHelper.openSavingsAccount(requestSpec, responseSpec, clientId, \"1000\");\n            Assertions.assertNotNull(savingsAccountId);\n            final Integer shareAccountId = createShareAccount(clientId, productId, savingsAccountId, dates[i], shares[i]);\n            shareAccounts.add(shareAccountId);\n            Assertions.assertNotNull(shareAccountId);\n            Map<String, Object> shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec,\n                    responseSpec);\n            Assertions.assertNotNull(shareAccountData);\n            // Approve share Account\n            Map<String, Object> approveMap = new HashMap<>();\n            approveMap.put(\"note\", \"Share Account Approval Note\");\n            approveMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n            approveMap.put(\"approvedDate\", \"01 Jan 2016\");\n            approveMap.put(\"locale\", \"en\");\n            String approve = new Gson().toJson(approveMap);\n            ShareAccountTransactionHelper.postCommand(\"approve\", shareAccountId, approve, requestSpec, responseSpec);\n            // Activate Share Account\n            Map<String, Object> activateMap = new HashMap<>();\n            activateMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n            activateMap.put(\"activatedDate\", \"01 Jan 2016\");\n            activateMap.put(\"locale\", \"en\");\n            String activateJson = new Gson().toJson(activateMap);\n            ShareAccountTransactionHelper.postCommand(\"activate\", shareAccountId, activateJson, requestSpec, responseSpec);\n        }\n\n        Map<String, Object> dividendsMap = new HashMap<>();\n        dividendsMap.put(\"dividendPeriodStartDate\", \"01 Jan 2015\");\n        dividendsMap.put(\"dividendPeriodEndDate\", \"01 Apr 2016\");\n        dividendsMap.put(\"dividendAmount\", \"50000\");\n        dividendsMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n        dividendsMap.put(\"locale\", \"en\");\n        String createDividendsJson = new Gson().toJson(dividendsMap);\n        final Integer dividendId = ShareDividendsTransactionHelper.createShareProductDividends(productId, createDividendsJson, requestSpec,\n                responseSpec);\n\n        Map<String, Object> productdividends = ShareDividendsTransactionHelper.retrieveAllDividends(productId, requestSpec, responseSpec);\n        Assertions.assertEquals(\"1\", String.valueOf(productdividends.get(\"totalFilteredRecords\")));\n        Map<String, Object> dividend = ((List<Map<String, Object>>) productdividends.get(\"pageItems\")).get(0);\n        Assertions.assertEquals(\"50000.0\", String.valueOf(dividend.get(\"amount\")));\n        Map<String, Object> status = (Map<String, Object>) dividend.get(\"status\");\n        Assertions.assertEquals(\"shareAccountDividendStatusType.initiated\", String.valueOf(status.get(\"code\")));\n        List<Integer> startdateList = (List<Integer>) dividend.get(\"dividendPeriodStartDate\");\n        Calendar cal = Calendar.getInstance();\n        cal.set(startdateList.get(0), startdateList.get(1) - 1, startdateList.get(2));\n        Date startDate = cal.getTime();\n        Assertions.assertEquals(\"01 Jan 2015\", simple.format(startDate));\n        List<Integer> enddateList = (List<Integer>) dividend.get(\"dividendPeriodEndDate\");\n        cal = Calendar.getInstance();\n        cal.set(enddateList.get(0), enddateList.get(1) - 1, enddateList.get(2));\n        Date endDate = cal.getTime();\n        Assertions.assertEquals(\"01 Apr 2016\", simple.format(endDate));\n\n        Map<String, Object> dividenddetails = ShareDividendsTransactionHelper.retrieveDividendDetails(productId, dividendId, requestSpec,\n                responseSpec);\n        Assertions.assertEquals(\"5\", String.valueOf(dividenddetails.get(\"totalFilteredRecords\")));\n        List<Map<String, Object>> pageItems = (List<Map<String, Object>>) dividenddetails.get(\"pageItems\");\n        for (Map<String, Object> dividendData : pageItems) {\n            Map<String, Object> accountData = (Map<String, Object>) dividendData.get(\"accountData\");\n            String accountId = String.valueOf(accountData.get(\"id\"));\n            if (String.valueOf(shareAccounts.get(0)).equals(accountId)) {\n                Assertions.assertEquals(\"11320.755\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(1)).equals(accountId)) {\n                Assertions.assertEquals(\"18172.791\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(2)).equals(accountId)) {\n                Assertions.assertEquals(\"13629.593\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(3)).equals(accountId)) {\n                Assertions.assertEquals(\"3028.7983\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(4)).equals(accountId)) {\n                Assertions.assertEquals(\"3848.0637\", String.valueOf(dividendData.get(\"amount\")));\n            }\n            Map<String, Object> statusMap = (Map<String, Object>) dividendData.get(\"status\");\n            Assertions.assertEquals(\"shareAccountDividendStatusType.initiated\", String.valueOf(statusMap.get(\"code\")));\n        }\n\n        String jsonString = \"\";\n        ShareDividendsTransactionHelper.postCommand(\"approve\", productId, dividendId, jsonString, requestSpec, responseSpec);\n\n        productdividends = ShareDividendsTransactionHelper.retrieveAllDividends(productId, requestSpec, responseSpec);\n        Assertions.assertEquals(\"1\", String.valueOf(productdividends.get(\"totalFilteredRecords\")));\n        dividend = ((List<Map<String, Object>>) productdividends.get(\"pageItems\")).get(0);\n        Assertions.assertEquals(\"50000.0\", String.valueOf(dividend.get(\"amount\")));\n        status = (Map<String, Object>) dividend.get(\"status\");\n        Assertions.assertEquals(\"shareAccountDividendStatusType.approved\", String.valueOf(status.get(\"code\")));\n        startdateList = (List<Integer>) dividend.get(\"dividendPeriodStartDate\");\n        cal = Calendar.getInstance();\n        cal.set(startdateList.get(0), startdateList.get(1) - 1, startdateList.get(2));\n        startDate = cal.getTime();\n        Assertions.assertEquals(\"01 Jan 2015\", simple.format(startDate));\n        enddateList = (List<Integer>) dividend.get(\"dividendPeriodEndDate\");\n        cal = Calendar.getInstance();\n        cal.set(enddateList.get(0), enddateList.get(1) - 1, enddateList.get(2));\n        endDate = cal.getTime();\n        Assertions.assertEquals(\"01 Apr 2016\", simple.format(endDate));\n\n        dividenddetails = ShareDividendsTransactionHelper.retrieveDividendDetails(productId, dividendId, requestSpec, responseSpec);\n        Assertions.assertEquals(\"5\", String.valueOf(dividenddetails.get(\"totalFilteredRecords\")));\n        pageItems = (List<Map<String, Object>>) dividenddetails.get(\"pageItems\");\n        for (Map<String, Object> dividendData : pageItems) {\n            Map<String, Object> accountData = (Map<String, Object>) dividendData.get(\"accountData\");\n            String accountId = String.valueOf(accountData.get(\"id\"));\n            if (String.valueOf(shareAccounts.get(0)).equals(accountId)) {\n                Assertions.assertEquals(\"11320.755\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(1)).equals(accountId)) {\n                Assertions.assertEquals(\"18172.791\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(2)).equals(accountId)) {\n                Assertions.assertEquals(\"13629.593\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(3)).equals(accountId)) {\n                Assertions.assertEquals(\"3028.7983\", String.valueOf(dividendData.get(\"amount\")));\n            } else if (String.valueOf(shareAccounts.get(4)).equals(accountId)) {\n                Assertions.assertEquals(\"3848.0637\", String.valueOf(dividendData.get(\"amount\")));\n            }\n            Map<String, Object> statusMap = (Map<String, Object>) dividendData.get(\"status\");\n            Assertions.assertEquals(\"shareAccountDividendStatusType.initiated\", String.valueOf(statusMap.get(\"code\")));\n        }\n\n    }"}
{"prompt": "Create a test that tests test Create Share Product", "completion": "    @Test\n    public void testCreateShareProduct() {\n        // This method will check create share product, get share product,\n        // update share product.\n        LOG.info(\"------------------------------CREATING NEW SHARE PRODUCT ---------------------------------------\");\n        shareProductHelper = new ShareProductHelper();\n        final Integer shareProductId = createShareProduct();\n        Assertions.assertNotNull(shareProductId);\n        LOG.info(\"------------------------------CREATING SHARE PRODUCT COMPLETE---------------------------------------\");\n\n        LOG.info(\"------------------------------RETRIEVING SHARE PRODUCT---------------------------------------\");\n        Map<String, Object> shareProductData = ShareProductTransactionHelper.retrieveShareProduct(shareProductId, requestSpec,\n                responseSpec);\n        Assertions.assertNotNull(shareProductData);\n        shareProductHelper.verifyShareProduct(shareProductData);\n\n        LOG.info(\"------------------------------RETRIEVING SHARE PRODUCT COMPLETE---------------------------------------\");\n\n        LOG.info(\"------------------------------UPDATING SHARE PRODUCT---------------------------------------\");\n\n        Map<String, Object> shareProductDataForUpdate = new HashMap<>();\n\n        shareProductDataForUpdate.put(\"totalShares\", \"2000\");\n        shareProductDataForUpdate.put(\"sharesIssued\", \"2000\");\n\n        String updateShareProductJsonString = new Gson().toJson(shareProductDataForUpdate);\n        Integer updatedProductId = ShareProductTransactionHelper.updateShareProduct(shareProductId, updateShareProductJsonString,\n                requestSpec, responseSpec);\n        Assertions.assertNotNull(updatedProductId);\n        Map<String, Object> updatedShareProductData = ShareProductTransactionHelper.retrieveShareProduct(updatedProductId, requestSpec,\n                responseSpec);\n        String updatedTotalShares = String.valueOf(updatedShareProductData.get(\"totalShares\"));\n        String updatedSharesIssued = String.valueOf(updatedShareProductData.get(\"totalSharesIssued\"));\n        Assertions.assertEquals(\"2000\", updatedTotalShares);\n        Assertions.assertEquals(\"2000\", updatedSharesIssued);\n        LOG.info(\"------------------------------UPDATING SHARE PRODUCT COMPLETE---------------------------------------\");\n\n    }"}
{"prompt": "Create a test that tests test Create Share Account", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testCreateShareAccount() {\n        shareProductHelper = new ShareProductHelper();\n        final Integer productId = createShareProduct();\n        Assertions.assertNotNull(productId);\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n        Integer savingsAccountId = SavingsAccountHelper.openSavingsAccount(requestSpec, responseSpec, clientId, \"1000\");\n        Assertions.assertNotNull(savingsAccountId);\n        final Integer shareAccountId = createShareAccount(clientId, productId, savingsAccountId);\n        Assertions.assertNotNull(shareAccountId);\n        Map<String, Object> shareProductData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec,\n                responseSpec);\n        Assertions.assertNotNull(shareProductData);\n\n        Map<String, Object> shareAccountDataForUpdate = new HashMap<>();\n        shareAccountDataForUpdate.put(\"requestedShares\", 30);\n        shareAccountDataForUpdate.put(\"applicationDate\", \"02 March 2016\");\n        shareAccountDataForUpdate.put(\"dateFormat\", \"dd MMMM yyyy\");\n        shareAccountDataForUpdate.put(\"locale\", \"en_GB\");\n        String updateShareAccountJsonString = new Gson().toJson(shareAccountDataForUpdate);\n        ShareAccountTransactionHelper.updateShareAccount(shareAccountId, updateShareAccountJsonString, requestSpec, responseSpec);\n        shareProductData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        List<Map<String, Object>> transactions = (List<Map<String, Object>>) shareProductData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(1, transactions.size());\n        Map<String, Object> transaction = transactions.get(0);\n        Assertions.assertEquals(\"30\", String.valueOf(transaction.get(\"numberOfShares\")));\n        Assertions.assertEquals(\"60.0\", String.valueOf(transaction.get(\"amount\")));\n        Assertions.assertEquals(\"60.0\", String.valueOf(transaction.get(\"amountPaid\")));\n        List<Integer> dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n        Calendar cal = Calendar.getInstance();\n        cal.set(dateList.get(0), dateList.get(1) - 1, dateList.get(2));\n        Date date = cal.getTime();\n        DateFormat simple = new SimpleDateFormat(\"dd MMMM yyyy\");\n        Assertions.assertEquals(\"02 March 2016\", simple.format(date));\n    }"}
{"prompt": "Create a test that tests test Share Account Approval", "completion": "    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testShareAccountApproval() {\n        shareProductHelper = new ShareProductHelper();\n        final Integer productId = createShareProduct();\n        Assertions.assertNotNull(productId);\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n        Integer savingsAccountId = SavingsAccountHelper.openSavingsAccount(requestSpec, responseSpec, clientId, \"1000\");\n        Assertions.assertNotNull(savingsAccountId);\n        String activationCharge = ChargesHelper.getShareAccountActivationChargeJson();\n        Integer activationChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, activationCharge);\n        String purchaseCharge = ChargesHelper.getShareAccountPurchaseChargeJson();\n        Integer purchaseChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, purchaseCharge);\n        String redeemCharge = ChargesHelper.getShareAccountRedeemChargeJson();\n        Integer redeemChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, redeemCharge);\n        List<Map<String, Object>> charges = new ArrayList<>();\n        charges.add(createCharge(activationChargeId, \"2\"));\n        charges.add(createCharge(purchaseChargeId, \"2\"));\n        charges.add(createCharge(redeemChargeId, \"1\"));\n        final Integer shareAccountId = createShareAccount(clientId, productId, savingsAccountId, charges);\n        Assertions.assertNotNull(shareAccountId);\n        Map<String, Object> shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec,\n                responseSpec);\n        Assertions.assertNotNull(shareAccountData);\n\n        // Approve share Account\n        Map<String, Object> approveMap = new HashMap<>();\n        approveMap.put(\"note\", \"Share Account Approval Note\");\n        approveMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n        approveMap.put(\"approvedDate\", \"01 January 2016\");\n        approveMap.put(\"locale\", \"en\");\n        String approve = new Gson().toJson(approveMap);\n        ShareAccountTransactionHelper.postCommand(\"approve\", shareAccountId, approve, requestSpec, responseSpec);\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        Map<String, Object> statusMap = (Map<String, Object>) shareAccountData.get(\"status\");\n        Assertions.assertEquals(\"shareAccountStatusType.approved\", String.valueOf(statusMap.get(\"code\")));\n        Map<String, Object> timelineMap = (Map<String, Object>) shareAccountData.get(\"timeline\");\n        List<Integer> dateList = (List<Integer>) timelineMap.get(\"approvedDate\");\n        LocalDate approvedDate = LocalDate.of(dateList.get(0), dateList.get(1), dateList.get(2));\n        Assertions.assertEquals(\"01 January 2016\", approvedDate.format(Utils.dateFormatter));\n        List<Map<String, Object>> transactions = (List<Map<String, Object>>) shareAccountData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(2, transactions.size());\n        for (int i = 0; i < transactions.size(); i++) {\n            Map<String, Object> transaction = transactions.get(i);\n            Map<String, Object> transactionTypeMap = (Map<String, Object>) transaction.get(\"type\");\n            dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n            LocalDate transactionDate = LocalDate.of(dateList.get(0), dateList.get(1), dateList.get(2));\n            String transactionType = (String) transactionTypeMap.get(\"code\");\n            if (transactionType.equals(\"purchasedSharesType.purchased\")) {\n                Assertions.assertEquals(\"25\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"52.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"52.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n                Assertions.assertEquals(\"01 January 2016\", transactionDate.format(Utils.dateFormatter));\n            } else if (transactionType.equals(\"charge.payment\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(Utils.getLocalDateOfTenant(), transactionDate);\n            }\n        }\n\n        Map<String, Object> summaryMap = (Map<String, Object>) shareAccountData.get(\"summary\");\n        Assertions.assertEquals(\"25\", String.valueOf(summaryMap.get(\"totalApprovedShares\")));\n        Assertions.assertEquals(\"0\", String.valueOf(summaryMap.get(\"totalPendingForApprovalShares\")));\n    }"}
{"prompt": "Create a test that tests reject Share Account", "completion": "    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void rejectShareAccount() {\n        shareProductHelper = new ShareProductHelper();\n        final Integer productId = createShareProduct();\n        Assertions.assertNotNull(productId);\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n        Integer savingsAccountId = SavingsAccountHelper.openSavingsAccount(requestSpec, responseSpec, clientId, \"1000\");\n        Assertions.assertNotNull(savingsAccountId);\n        String activationCharge = ChargesHelper.getShareAccountActivationChargeJson();\n        Integer activationChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, activationCharge);\n        String purchaseCharge = ChargesHelper.getShareAccountPurchaseChargeJson();\n        Integer purchaseChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, purchaseCharge);\n        String redeemCharge = ChargesHelper.getShareAccountRedeemChargeJson();\n        Integer redeemChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, redeemCharge);\n        List<Map<String, Object>> charges = new ArrayList<>();\n        charges.add(createCharge(activationChargeId, \"2\"));\n        charges.add(createCharge(purchaseChargeId, \"2\"));\n        charges.add(createCharge(redeemChargeId, \"1\"));\n        final Integer shareAccountId = createShareAccount(clientId, productId, savingsAccountId, charges);\n        Assertions.assertNotNull(shareAccountId);\n        Map<String, Object> shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec,\n                responseSpec);\n        Assertions.assertNotNull(shareAccountData);\n\n        // Reject share Account\n        Map<String, Object> rejectMap = new HashMap<>();\n        rejectMap.put(\"note\", \"Share Account Rejection Note\");\n        String rejectJson = new Gson().toJson(rejectMap);\n        ShareAccountTransactionHelper.postCommand(\"reject\", shareAccountId, rejectJson, requestSpec, responseSpec);\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        Map<String, Object> statusMap = (Map<String, Object>) shareAccountData.get(\"status\");\n        Assertions.assertEquals(\"shareAccountStatusType.rejected\", String.valueOf(statusMap.get(\"code\")));\n        Map<String, Object> timelineMap = (Map<String, Object>) shareAccountData.get(\"timeline\");\n        List<Integer> dateList = (List<Integer>) timelineMap.get(\"rejectedDate\");\n        LocalDate rejectedDate = LocalDate.of(dateList.get(0), dateList.get(1), dateList.get(2));\n        Assertions.assertEquals(Utils.getLocalDateOfTenant(), rejectedDate);\n\n        List<Map<String, Object>> transactions = (List<Map<String, Object>>) shareAccountData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(2, transactions.size());\n        for (int i = 0; i < transactions.size(); i++) {\n            Map<String, Object> transaction = transactions.get(i);\n            Map<String, Object> transactionTypeMap = (Map<String, Object>) transaction.get(\"type\");\n            dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n            LocalDate date = LocalDate.of(dateList.get(0), dateList.get(1), dateList.get(2));\n            String transactionType = (String) transactionTypeMap.get(\"code\");\n            if (transactionType.equals(\"purchasedSharesType.purchased\")) {\n                Assertions.assertEquals(\"25\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"50.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"50.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n                Assertions.assertEquals(\"01 January 2016\", date.format(Utils.dateFormatter));\n            } else if (transactionType.equals(\"charge.payment\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"0\", String.valueOf(transaction.get(\"amountPaid\")));\n                LocalDate transactionDate = Utils.getLocalDateOfTenant();\n                Assertions.assertEquals(transactionDate, date);\n            }\n        }\n\n        Map<String, Object> summaryMap = (Map<String, Object>) shareAccountData.get(\"summary\");\n        Assertions.assertEquals(\"0\", String.valueOf(summaryMap.get(\"totalApprovedShares\")));\n        Assertions.assertEquals(\"0\", String.valueOf(summaryMap.get(\"totalPendingForApprovalShares\")));\n    }"}
{"prompt": "Create a test that tests test Share Account Undo Approval", "completion": "    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testShareAccountUndoApproval() {\n        shareProductHelper = new ShareProductHelper();\n        final Integer productId = createShareProduct();\n        Assertions.assertNotNull(productId);\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n        Integer savingsAccountId = SavingsAccountHelper.openSavingsAccount(requestSpec, responseSpec, clientId, \"1000\");\n        Assertions.assertNotNull(savingsAccountId);\n        String activationCharge = ChargesHelper.getShareAccountActivationChargeJson();\n        Integer activationChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, activationCharge);\n        String purchaseCharge = ChargesHelper.getShareAccountPurchaseChargeJson();\n        Integer purchaseChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, purchaseCharge);\n        String redeemCharge = ChargesHelper.getShareAccountRedeemChargeJson();\n        Integer redeemChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, redeemCharge);\n        List<Map<String, Object>> charges = new ArrayList<>();\n        charges.add(createCharge(activationChargeId, \"2\"));\n        charges.add(createCharge(purchaseChargeId, \"2\"));\n        charges.add(createCharge(redeemChargeId, \"1\"));\n        final Integer shareAccountId = createShareAccount(clientId, productId, savingsAccountId, charges);\n        Assertions.assertNotNull(shareAccountId);\n        Map<String, Object> shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec,\n                responseSpec);\n        Assertions.assertNotNull(shareAccountData);\n\n        // Approve share Account\n        Map<String, Object> approveMap = new HashMap<>();\n        approveMap.put(\"note\", \"Share Account Approval Note\");\n        approveMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n        approveMap.put(\"approvedDate\", \"01 January 2016\");\n        approveMap.put(\"locale\", \"en\");\n        String approve = new Gson().toJson(approveMap);\n        ShareAccountTransactionHelper.postCommand(\"approve\", shareAccountId, approve, requestSpec, responseSpec);\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        Map<String, Object> statusMap = (Map<String, Object>) shareAccountData.get(\"status\");\n        Assertions.assertEquals(\"shareAccountStatusType.approved\", String.valueOf(statusMap.get(\"code\")));\n        Map<String, Object> timelineMap = (Map<String, Object>) shareAccountData.get(\"timeline\");\n        List<Integer> dateList = (List<Integer>) timelineMap.get(\"approvedDate\");\n\n        LocalDate approvedDate = LocalDate.of(dateList.get(0), dateList.get(1), dateList.get(2));\n        Assertions.assertEquals(\"01 January 2016\", approvedDate.format(Utils.dateFormatter));\n\n        // Undo Approval share Account\n        Map<String, Object> undoApprovalMap = new HashMap<>();\n        String undoApprovalJson = new Gson().toJson(undoApprovalMap);\n        ShareAccountTransactionHelper.postCommand(\"undoapproval\", shareAccountId, undoApprovalJson, requestSpec, responseSpec);\n\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n\n        statusMap = (Map<String, Object>) shareAccountData.get(\"status\");\n        Assertions.assertEquals(\"shareAccountStatusType.submitted.and.pending.approval\", String.valueOf(statusMap.get(\"code\")));\n\n        List<Map<String, Object>> transactions = (List<Map<String, Object>>) shareAccountData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(2, transactions.size());\n        for (int i = 0; i < transactions.size(); i++) {\n            Map<String, Object> transaction = transactions.get(i);\n            Map<String, Object> transactionTypeMap = (Map<String, Object>) transaction.get(\"type\");\n            dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n            LocalDate transactionDate = LocalDate.of(dateList.get(0), dateList.get(1), dateList.get(2));\n            String transactionType = (String) transactionTypeMap.get(\"code\");\n            if (transactionType.equals(\"purchasedSharesType.purchased\")) {\n                Assertions.assertEquals(\"25\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"52.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n                Assertions.assertEquals(\"01 January 2016\", transactionDate.format(Utils.dateFormatter));\n            } else if (transactionType.equals(\"charge.payment\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(Utils.getLocalDateOfTenant(), transactionDate);\n            }\n        }\n\n        Map<String, Object> summaryMap = (Map<String, Object>) shareAccountData.get(\"summary\");\n        Assertions.assertEquals(\"0\", String.valueOf(summaryMap.get(\"totalApprovedShares\")));\n        Assertions.assertEquals(\"25\", String.valueOf(summaryMap.get(\"totalPendingForApprovalShares\")));\n    }"}
{"prompt": "Create a test that tests test Create Share Account With Charges", "completion": "    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testCreateShareAccountWithCharges() {\n        shareProductHelper = new ShareProductHelper();\n        final Integer productId = createShareProduct();\n        Assertions.assertNotNull(productId);\n        final Integer clientId = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(clientId);\n        Integer savingsAccountId = SavingsAccountHelper.openSavingsAccount(requestSpec, responseSpec, clientId, \"1000\");\n        Assertions.assertNotNull(savingsAccountId);\n        String activationCharge = ChargesHelper.getShareAccountActivationChargeJson();\n        Integer activationChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, activationCharge);\n        String purchaseCharge = ChargesHelper.getShareAccountPurchaseChargeJson();\n        Integer purchaseChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, purchaseCharge);\n        String redeemCharge = ChargesHelper.getShareAccountRedeemChargeJson();\n        Integer redeemChargeId = ChargesHelper.createCharges(requestSpec, responseSpec, redeemCharge);\n        List<Map<String, Object>> charges = new ArrayList<>();\n        charges.add(createCharge(activationChargeId, \"2\"));\n        charges.add(createCharge(purchaseChargeId, \"2\"));\n        charges.add(createCharge(redeemChargeId, \"1\"));\n        final Integer shareAccountId = createShareAccount(clientId, productId, savingsAccountId, charges);\n        Assertions.assertNotNull(shareAccountId);\n        Map<String, Object> shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec,\n                responseSpec);\n        Assertions.assertNotNull(shareAccountData);\n\n        Map<String, Object> shareAccountDataForUpdate = new HashMap<>();\n        shareAccountDataForUpdate.put(\"requestedShares\", 30);\n        shareAccountDataForUpdate.put(\"applicationDate\", \"02 Mar 2016\");\n        shareAccountDataForUpdate.put(\"dateFormat\", \"dd MMMM yyyy\");\n        shareAccountDataForUpdate.put(\"locale\", \"en_GB\");\n        shareAccountDataForUpdate.put(\"charges\", charges);\n\n        String updateShareAccountJsonString = new Gson().toJson(shareAccountDataForUpdate);\n        ShareAccountTransactionHelper.updateShareAccount(shareAccountId, updateShareAccountJsonString, requestSpec, responseSpec);\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        List<Map<String, Object>> transactions = (List<Map<String, Object>>) shareAccountData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(2, transactions.size());\n        DateFormat simple = new SimpleDateFormat(\"dd MMM yyyy\");\n        for (int i = 0; i < transactions.size(); i++) {\n            Map<String, Object> transaction = transactions.get(i);\n            Map<String, Object> transactionTypeMap = (Map<String, Object>) transaction.get(\"type\");\n            List<Integer> dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n            Calendar cal = Calendar.getInstance();\n            cal.set(dateList.get(0), dateList.get(1) - 1, dateList.get(2));\n            Date date = cal.getTime();\n            String transactionType = (String) transactionTypeMap.get(\"code\");\n            if (transactionType.equals(\"purchasedSharesType.purchased\")) {\n                Assertions.assertEquals(\"30\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"62.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"60.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n                Assertions.assertEquals(\"02 Mar 2016\", simple.format(date));\n            } else if (transactionType.equals(\"charge.payment\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"0\", String.valueOf(transaction.get(\"chargeAmount\")));\n            }\n        }\n\n        // charges verification\n        List<Map<String, Object>> chargesList = (List<Map<String, Object>>) shareAccountData.get(\"charges\");\n        for (Map<String, Object> chargeDef : chargesList) {\n            Map<String, Object> chargeTimeTypeMap = (Map<String, Object>) chargeDef.get(\"chargeTimeType\");\n            String chargeTimeType = String.valueOf(chargeTimeTypeMap.get(\"code\"));\n            if (chargeTimeType.equals(\"chargeTimeType.activation\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharespurchase\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharesredeem\")) {\n                Assertions.assertEquals(\"1.0\", String.valueOf(chargeDef.get(\"amountOrPercentage\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else {\n                Assertions.fail(\"Other Charge defintion found\");\n            }\n        }\n\n        // Approve share Account\n        Map<String, Object> approveMap = new HashMap<>();\n        approveMap.put(\"note\", \"Share Account Approval Note\");\n        approveMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n        approveMap.put(\"approvedDate\", \"01 Jan 2016\");\n        approveMap.put(\"locale\", \"en\");\n        String approve = new Gson().toJson(approveMap);\n        ShareAccountTransactionHelper.postCommand(\"approve\", shareAccountId, approve, requestSpec, responseSpec);\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        Map<String, Object> statusMap = (Map<String, Object>) shareAccountData.get(\"status\");\n        Assertions.assertEquals(\"shareAccountStatusType.approved\", String.valueOf(statusMap.get(\"code\")));\n        Map<String, Object> timelineMap = (Map<String, Object>) shareAccountData.get(\"timeline\");\n        List<Integer> dateList = (List<Integer>) timelineMap.get(\"approvedDate\");\n        Calendar cal = Calendar.getInstance();\n        cal.set(dateList.get(0), dateList.get(1) - 1, dateList.get(2));\n        Date approvedDate = cal.getTime();\n        Assertions.assertEquals(\"01 Jan 2016\", simple.format(approvedDate));\n\n        // charges verification\n        chargesList = (List<Map<String, Object>>) shareAccountData.get(\"charges\");\n        for (Map<String, Object> chargeDef : chargesList) {\n            Map<String, Object> chargeTimeTypeMap = (Map<String, Object>) chargeDef.get(\"chargeTimeType\");\n            String chargeTimeType = String.valueOf(chargeTimeTypeMap.get(\"code\"));\n            if (chargeTimeType.equals(\"chargeTimeType.activation\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharespurchase\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharesredeem\")) {\n                Assertions.assertEquals(\"1.0\", String.valueOf(chargeDef.get(\"amountOrPercentage\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else {\n                Assertions.fail(\"Other Charge defintion found\");\n            }\n        }\n\n        Map<String, Object> activateMap = new HashMap<>();\n        activateMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n        activateMap.put(\"activatedDate\", \"01 Jan 2016\");\n        activateMap.put(\"locale\", \"en\");\n        String activateJson = new Gson().toJson(activateMap);\n        ShareAccountTransactionHelper.postCommand(\"activate\", shareAccountId, activateJson, requestSpec, responseSpec);\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        statusMap = (Map<String, Object>) shareAccountData.get(\"status\");\n        Assertions.assertEquals(\"shareAccountStatusType.active\", String.valueOf(statusMap.get(\"code\")));\n        timelineMap = (Map<String, Object>) shareAccountData.get(\"timeline\");\n        dateList = (List<Integer>) timelineMap.get(\"activatedDate\");\n        cal = Calendar.getInstance();\n        cal.set(dateList.get(0), dateList.get(1) - 1, dateList.get(2));\n        Date activatedDate = cal.getTime();\n        Assertions.assertEquals(\"01 Jan 2016\", simple.format(activatedDate));\n\n        transactions = (List<Map<String, Object>>) shareAccountData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(2, transactions.size());\n        for (int i = 0; i < transactions.size(); i++) {\n            Map<String, Object> transaction = transactions.get(i);\n            Map<String, Object> transactionTypeMap = (Map<String, Object>) transaction.get(\"type\");\n            dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n            cal = Calendar.getInstance();\n            cal.set(dateList.get(0), dateList.get(1) - 1, dateList.get(2));\n            Date date = cal.getTime();\n            String transactionType = (String) transactionTypeMap.get(\"code\");\n            if (transactionType.equals(\"purchasedSharesType.purchased\")) {\n                Assertions.assertEquals(\"30\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"62.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"62.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n                Assertions.assertEquals(\"02 Mar 2016\", simple.format(date));\n            } else if (transactionType.equals(\"charge.payment\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"01 Jan 2016\", simple.format(date));\n            }\n        }\n\n        // charges verification\n        chargesList = (List<Map<String, Object>>) shareAccountData.get(\"charges\");\n        for (Map<String, Object> chargeDef : chargesList) {\n            Map<String, Object> chargeTimeTypeMap = (Map<String, Object>) chargeDef.get(\"chargeTimeType\");\n            String chargeTimeType = String.valueOf(chargeTimeTypeMap.get(\"code\"));\n            if (chargeTimeType.equals(\"chargeTimeType.activation\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharespurchase\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharesredeem\")) {\n                Assertions.assertEquals(\"1.0\", String.valueOf(chargeDef.get(\"amountOrPercentage\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else {\n                Assertions.fail(\"Other Charge defintion found\");\n            }\n        }\n\n        Map<String, Object> summaryMap = (Map<String, Object>) shareAccountData.get(\"summary\");\n        Assertions.assertEquals(\"30\", String.valueOf(summaryMap.get(\"totalApprovedShares\")));\n        Assertions.assertEquals(\"0\", String.valueOf(summaryMap.get(\"totalPendingForApprovalShares\")));\n\n        // apply additional shares\n        Map<String, Object> additionalSharesRequestMap = new HashMap<>();\n        additionalSharesRequestMap.put(\"requestedDate\", \"01 Apr 2016\");\n        additionalSharesRequestMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n        additionalSharesRequestMap.put(\"locale\", \"en\");\n        additionalSharesRequestMap.put(\"requestedShares\", \"15\");\n        String additionalSharesRequestJson = new Gson().toJson(additionalSharesRequestMap);\n        ShareAccountTransactionHelper.postCommand(\"applyadditionalshares\", shareAccountId, additionalSharesRequestJson, requestSpec,\n                responseSpec);\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        transactions = (List<Map<String, Object>>) shareAccountData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(3, transactions.size());\n        String addtionalSharesRequestId = null;\n        for (int i = 0; i < transactions.size(); i++) {\n            Map<String, Object> transaction = transactions.get(i);\n            Map<String, Object> transactionTypeMap = (Map<String, Object>) transaction.get(\"type\");\n            dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n            cal = Calendar.getInstance();\n            cal.set(dateList.get(0), dateList.get(1) - 1, dateList.get(2));\n            Date date = cal.getTime();\n            String transactionType = (String) transactionTypeMap.get(\"code\");\n            String transactionDate = simple.format(date);\n            if (transactionType.equals(\"purchasedSharesType.purchased\") && transactionDate.equals(\"02 Mar 2016\")) {\n                Assertions.assertEquals(\"30\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"62.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"62.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n            } else if (transactionType.equals(\"purchasedSharesType.purchased\") && transactionDate.equals(\"01 Apr 2016\")) {\n                addtionalSharesRequestId = String.valueOf(transaction.get(\"id\"));\n                Assertions.assertEquals(\"15\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"32.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"30.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n                Map<String, Object> transactionstatusMap = (Map<String, Object>) transaction.get(\"status\");\n                Assertions.assertEquals(\"purchasedSharesStatusType.applied\", String.valueOf(transactionstatusMap.get(\"code\")));\n\n            } else if (transactionType.equals(\"charge.payment\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"01 Jan 2016\", transactionDate);\n            }\n        }\n\n        // charges verification\n        chargesList = (List<Map<String, Object>>) shareAccountData.get(\"charges\");\n        for (Map<String, Object> chargeDef : chargesList) {\n            Map<String, Object> chargeTimeTypeMap = (Map<String, Object>) chargeDef.get(\"chargeTimeType\");\n            String chargeTimeType = String.valueOf(chargeTimeTypeMap.get(\"code\"));\n            if (chargeTimeType.equals(\"chargeTimeType.activation\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharespurchase\")) {\n                Assertions.assertEquals(\"4.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharesredeem\")) {\n                Assertions.assertEquals(\"1.0\", String.valueOf(chargeDef.get(\"amountOrPercentage\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else {\n                Assertions.fail(\"Other Charge defintion found\");\n            }\n        }\n\n        summaryMap = (Map<String, Object>) shareAccountData.get(\"summary\");\n        Assertions.assertEquals(\"30\", String.valueOf(summaryMap.get(\"totalApprovedShares\")));\n        Assertions.assertEquals(\"15\", String.valueOf(summaryMap.get(\"totalPendingForApprovalShares\")));\n\n        // Approve additional Shares request\n        Map<String, List<Map<String, Object>>> approveadditionalsharesMap = new HashMap<>();\n        List<Map<String, Object>> list = new ArrayList<>();\n        Map<String, Object> idsMap = new HashMap<>();\n        idsMap.put(\"id\", addtionalSharesRequestId);\n        list.add(idsMap);\n        approveadditionalsharesMap.put(\"requestedShares\", list);\n        String approveadditionalsharesJson = new Gson().toJson(approveadditionalsharesMap);\n        ShareAccountTransactionHelper.postCommand(\"approveadditionalshares\", shareAccountId, approveadditionalsharesJson, requestSpec,\n                responseSpec);\n\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        transactions = (List<Map<String, Object>>) shareAccountData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(3, transactions.size());\n        for (int i = 0; i < transactions.size(); i++) {\n            Map<String, Object> transaction = transactions.get(i);\n            Map<String, Object> transactionTypeMap = (Map<String, Object>) transaction.get(\"type\");\n            dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n            cal = Calendar.getInstance();\n            cal.set(dateList.get(0), dateList.get(1) - 1, dateList.get(2));\n            Date date = cal.getTime();\n            String transactionType = (String) transactionTypeMap.get(\"code\");\n            String transactionDate = simple.format(date);\n            if (transactionType.equals(\"purchasedSharesType.purchased\") && transactionDate.equals(\"02 Mar 2016\")) {\n                Assertions.assertEquals(\"30\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"62.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"62.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n            } else if (transactionType.equals(\"purchasedSharesType.purchased\") && transactionDate.equals(\"01 Apr 2016\")) {\n                Assertions.assertEquals(\"15\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"32.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"32.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n                Map<String, Object> transactionstatusMap = (Map<String, Object>) transaction.get(\"status\");\n                Assertions.assertEquals(\"purchasedSharesStatusType.approved\", String.valueOf(transactionstatusMap.get(\"code\")));\n\n            } else if (transactionType.equals(\"charge.payment\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"01 Jan 2016\", transactionDate);\n            }\n        }\n\n        // charges verification\n        chargesList = (List<Map<String, Object>>) shareAccountData.get(\"charges\");\n        for (Map<String, Object> chargeDef : chargesList) {\n            Map<String, Object> chargeTimeTypeMap = (Map<String, Object>) chargeDef.get(\"chargeTimeType\");\n            String chargeTimeType = String.valueOf(chargeTimeTypeMap.get(\"code\"));\n            if (chargeTimeType.equals(\"chargeTimeType.activation\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharespurchase\")) {\n                Assertions.assertEquals(\"4.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"4.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharesredeem\")) {\n                Assertions.assertEquals(\"1.0\", String.valueOf(chargeDef.get(\"amountOrPercentage\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else {\n                Assertions.fail(\"Other Charge defintion found\");\n            }\n        }\n\n        summaryMap = (Map<String, Object>) shareAccountData.get(\"summary\");\n        Assertions.assertEquals(\"45\", String.valueOf(summaryMap.get(\"totalApprovedShares\")));\n        Assertions.assertEquals(\"0\", String.valueOf(summaryMap.get(\"totalPendingForApprovalShares\")));\n\n        // apply aditional shres and reject it\n        additionalSharesRequestMap = new HashMap<>();\n        additionalSharesRequestMap.put(\"requestedDate\", \"01 May 2016\");\n        additionalSharesRequestMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n        additionalSharesRequestMap.put(\"locale\", \"en\");\n        additionalSharesRequestMap.put(\"requestedShares\", \"20\");\n        additionalSharesRequestJson = new Gson().toJson(additionalSharesRequestMap);\n        ShareAccountTransactionHelper.postCommand(\"applyadditionalshares\", shareAccountId, additionalSharesRequestJson, requestSpec,\n                responseSpec);\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        transactions = (List<Map<String, Object>>) shareAccountData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(4, transactions.size());\n        addtionalSharesRequestId = null;\n        for (int i = 0; i < transactions.size(); i++) {\n            Map<String, Object> transaction = transactions.get(i);\n            Map<String, Object> transactionTypeMap = (Map<String, Object>) transaction.get(\"type\");\n            dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n            cal = Calendar.getInstance();\n            cal.set(dateList.get(0), dateList.get(1) - 1, dateList.get(2));\n            Date date = cal.getTime();\n            String transactionType = (String) transactionTypeMap.get(\"code\");\n            String transactionDate = simple.format(date);\n            if (transactionType.equals(\"purchasedSharesType.purchased\") && transactionDate.equals(\"01 May 2016\")) {\n                addtionalSharesRequestId = String.valueOf(transaction.get(\"id\"));\n                Assertions.assertEquals(\"20\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"42.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"40.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n                Map<String, Object> transactionstatusMap = (Map<String, Object>) transaction.get(\"status\");\n                Assertions.assertEquals(\"purchasedSharesStatusType.applied\", String.valueOf(transactionstatusMap.get(\"code\")));\n            }\n        }\n\n        // charges verification\n        chargesList = (List<Map<String, Object>>) shareAccountData.get(\"charges\");\n        for (Map<String, Object> chargeDef : chargesList) {\n            Map<String, Object> chargeTimeTypeMap = (Map<String, Object>) chargeDef.get(\"chargeTimeType\");\n            String chargeTimeType = String.valueOf(chargeTimeTypeMap.get(\"code\"));\n            if (chargeTimeType.equals(\"chargeTimeType.activation\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharespurchase\")) {\n                Assertions.assertEquals(\"6.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"4.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharesredeem\")) {\n                Assertions.assertEquals(\"1.0\", String.valueOf(chargeDef.get(\"amountOrPercentage\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else {\n                Assertions.fail(\"Other Charge defintion found\");\n            }\n        }\n\n        summaryMap = (Map<String, Object>) shareAccountData.get(\"summary\");\n        Assertions.assertEquals(\"45\", String.valueOf(summaryMap.get(\"totalApprovedShares\")));\n        Assertions.assertEquals(\"20\", String.valueOf(summaryMap.get(\"totalPendingForApprovalShares\")));\n\n        // rejectadditionalshares\n        Map<String, List<Map<String, Object>>> rejectadditionalsharesMap = new HashMap<>();\n        list = new ArrayList<>();\n        idsMap = new HashMap<>();\n        idsMap.put(\"id\", addtionalSharesRequestId);\n        list.add(idsMap);\n        rejectadditionalsharesMap.put(\"requestedShares\", list);\n        String rejectadditionalsharesJson = new Gson().toJson(rejectadditionalsharesMap);\n        ShareAccountTransactionHelper.postCommand(\"rejectadditionalshares\", shareAccountId, rejectadditionalsharesJson, requestSpec,\n                responseSpec);\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        transactions = (List<Map<String, Object>>) shareAccountData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(4, transactions.size());\n        for (int i = 0; i < transactions.size(); i++) {\n            Map<String, Object> transaction = transactions.get(i);\n            Map<String, Object> transactionTypeMap = (Map<String, Object>) transaction.get(\"type\");\n            dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n            cal = Calendar.getInstance();\n            cal.set(dateList.get(0), dateList.get(1) - 1, dateList.get(2));\n            Date date = cal.getTime();\n            String transactionType = (String) transactionTypeMap.get(\"code\");\n            String transactionDate = simple.format(date);\n            if (transactionType.equals(\"purchasedSharesType.purchased\") && transactionDate.equals(\"01 May 2016\")) {\n                addtionalSharesRequestId = String.valueOf(transaction.get(\"id\"));\n                Assertions.assertEquals(\"20\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"40.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"40.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n                Map<String, Object> transactionstatusMap = (Map<String, Object>) transaction.get(\"status\");\n                Assertions.assertEquals(\"purchasedSharesStatusType.rejected\", String.valueOf(transactionstatusMap.get(\"code\")));\n            }\n        }\n\n        // charges verification\n        chargesList = (List<Map<String, Object>>) shareAccountData.get(\"charges\");\n        for (Map<String, Object> chargeDef : chargesList) {\n            Map<String, Object> chargeTimeTypeMap = (Map<String, Object>) chargeDef.get(\"chargeTimeType\");\n            String chargeTimeType = String.valueOf(chargeTimeTypeMap.get(\"code\"));\n            if (chargeTimeType.equals(\"chargeTimeType.activation\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharespurchase\")) {\n                Assertions.assertEquals(\"6.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"6.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharesredeem\")) {\n                Assertions.assertEquals(\"1.0\", String.valueOf(chargeDef.get(\"amountOrPercentage\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else {\n                Assertions.fail(\"Other Charge defintion found\");\n            }\n        }\n\n        summaryMap = (Map<String, Object>) shareAccountData.get(\"summary\");\n        Assertions.assertEquals(\"45\", String.valueOf(summaryMap.get(\"totalApprovedShares\")));\n        Assertions.assertEquals(\"0\", String.valueOf(summaryMap.get(\"totalPendingForApprovalShares\")));\n\n        // redeem shares\n        Map<String, Object> redeemRequestMap = new HashMap<>();\n        redeemRequestMap.put(\"requestedDate\", \"05 May 2016\");\n        redeemRequestMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n        redeemRequestMap.put(\"locale\", \"en\");\n        redeemRequestMap.put(\"requestedShares\", \"15\");\n        String redeemRequestJson = new Gson().toJson(redeemRequestMap);\n        ShareAccountTransactionHelper.postCommand(\"redeemshares\", shareAccountId, redeemRequestJson, requestSpec, responseSpec);\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        transactions = (List<Map<String, Object>>) shareAccountData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(5, transactions.size());\n        for (int i = 0; i < transactions.size(); i++) {\n            Map<String, Object> transaction = transactions.get(i);\n            Map<String, Object> transactionTypeMap = (Map<String, Object>) transaction.get(\"type\");\n            dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n            cal = Calendar.getInstance();\n            cal.set(dateList.get(0), dateList.get(1) - 1, dateList.get(2));\n            Date date = cal.getTime();\n            String transactionType = (String) transactionTypeMap.get(\"code\");\n            String transactionDate = simple.format(date);\n            if (transactionType.equals(\"purchasedSharesType.purchased\") && transactionDate.equals(\"02 Mar 2016\")) {\n                Assertions.assertEquals(\"30\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"62.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"62.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n            } else if (transactionType.equals(\"purchasedSharesType.purchased\") && transactionDate.equals(\"01 Apr 2016\")) {\n                Assertions.assertEquals(\"15\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"32.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"32.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n                Map<String, Object> transactionstatusMap = (Map<String, Object>) transaction.get(\"status\");\n                Assertions.assertEquals(\"purchasedSharesStatusType.approved\", String.valueOf(transactionstatusMap.get(\"code\")));\n            } else if (transactionType.equals(\"purchasedSharesType.redeemed\") && transactionDate.equals(\"05 May 2016\")) {\n                Assertions.assertEquals(\"15\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"29.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"29.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"1.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Map<String, Object> transactionstatusMap = (Map<String, Object>) transaction.get(\"status\");\n                Assertions.assertEquals(\"purchasedSharesStatusType.approved\", String.valueOf(transactionstatusMap.get(\"code\")));\n            } else if (transactionType.equals(\"charge.payment\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"01 Jan 2016\", transactionDate);\n            }\n        }\n\n        // charges verification\n        chargesList = (List<Map<String, Object>>) shareAccountData.get(\"charges\");\n        for (Map<String, Object> chargeDef : chargesList) {\n            Map<String, Object> chargeTimeTypeMap = (Map<String, Object>) chargeDef.get(\"chargeTimeType\");\n            String chargeTimeType = String.valueOf(chargeTimeTypeMap.get(\"code\"));\n            if (chargeTimeType.equals(\"chargeTimeType.activation\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharespurchase\")) {\n                Assertions.assertEquals(\"6.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"6.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharesredeem\")) {\n                Assertions.assertEquals(\"1.0\", String.valueOf(chargeDef.get(\"amountOrPercentage\")));\n                Assertions.assertEquals(\"1.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"1.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else {\n                Assertions.fail(\"Other Charge defintion found\");\n            }\n        }\n        summaryMap = (Map<String, Object>) shareAccountData.get(\"summary\");\n        Assertions.assertEquals(\"30\", String.valueOf(summaryMap.get(\"totalApprovedShares\")));\n        Assertions.assertEquals(\"0\", String.valueOf(summaryMap.get(\"totalPendingForApprovalShares\")));\n\n        // Close Share Account\n        Map<String, Object> closeAccountMap = new HashMap<>();\n        closeAccountMap.put(\"note\", \"Share Account Close Note\");\n        closeAccountMap.put(\"dateFormat\", \"dd MMMM yyyy\");\n        closeAccountMap.put(\"closedDate\", \"10 May 2016\");\n        closeAccountMap.put(\"locale\", \"en\");\n        String closeJson = new Gson().toJson(closeAccountMap);\n        ShareAccountTransactionHelper.postCommand(\"close\", shareAccountId, closeJson, requestSpec, responseSpec);\n        shareAccountData = ShareAccountTransactionHelper.retrieveShareAccount(shareAccountId, requestSpec, responseSpec);\n        statusMap = (Map<String, Object>) shareAccountData.get(\"status\");\n        Assertions.assertEquals(\"shareAccountStatusType.closed\", String.valueOf(statusMap.get(\"code\")));\n        transactions = (List<Map<String, Object>>) shareAccountData.get(\"purchasedShares\");\n        Assertions.assertNotNull(transactions);\n        Assertions.assertEquals(6, transactions.size());\n        for (int i = 0; i < transactions.size(); i++) {\n            Map<String, Object> transaction = transactions.get(i);\n            Map<String, Object> transactionTypeMap = (Map<String, Object>) transaction.get(\"type\");\n            dateList = (List<Integer>) transaction.get(\"purchasedDate\");\n            cal = Calendar.getInstance();\n            cal.set(dateList.get(0), dateList.get(1) - 1, dateList.get(2));\n            Date date = cal.getTime();\n            String transactionType = (String) transactionTypeMap.get(\"code\");\n            String transactionDate = simple.format(date);\n            if (transactionType.equals(\"purchasedSharesType.purchased\") && transactionDate.equals(\"02 Mar 2016\")) {\n                Assertions.assertEquals(\"30\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"62.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"62.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n            } else if (transactionType.equals(\"purchasedSharesType.purchased\") && transactionDate.equals(\"01 Apr 2016\")) {\n                Assertions.assertEquals(\"15\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"32.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"32.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"purchasedPrice\")));\n                Map<String, Object> transactionstatusMap = (Map<String, Object>) transaction.get(\"status\");\n                Assertions.assertEquals(\"purchasedSharesStatusType.approved\", String.valueOf(transactionstatusMap.get(\"code\")));\n            } else if (transactionType.equals(\"purchasedSharesType.redeemed\") && transactionDate.equals(\"05 May 2016\")) {\n                Assertions.assertEquals(\"15\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"29.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"29.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"1.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Map<String, Object> transactionstatusMap = (Map<String, Object>) transaction.get(\"status\");\n                Assertions.assertEquals(\"purchasedSharesStatusType.approved\", String.valueOf(transactionstatusMap.get(\"code\")));\n            } else if (transactionType.equals(\"purchasedSharesType.redeemed\") && transactionDate.equals(\"10 May 2016\")) {\n                Assertions.assertEquals(\"30\", String.valueOf(transaction.get(\"numberOfShares\")));\n                Assertions.assertEquals(\"59.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"59.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"1.0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Map<String, Object> transactionstatusMap = (Map<String, Object>) transaction.get(\"status\");\n                Assertions.assertEquals(\"purchasedSharesStatusType.approved\", String.valueOf(transactionstatusMap.get(\"code\")));\n            } else if (transactionType.equals(\"charge.payment\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amount\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(transaction.get(\"amountPaid\")));\n                Assertions.assertEquals(\"0\", String.valueOf(transaction.get(\"chargeAmount\")));\n                Assertions.assertEquals(\"01 Jan 2016\", transactionDate);\n            }\n        }\n        // charges verification\n        chargesList = (List<Map<String, Object>>) shareAccountData.get(\"charges\");\n        for (Map<String, Object> chargeDef : chargesList) {\n            Map<String, Object> chargeTimeTypeMap = (Map<String, Object>) chargeDef.get(\"chargeTimeType\");\n            String chargeTimeType = String.valueOf(chargeTimeTypeMap.get(\"code\"));\n            if (chargeTimeType.equals(\"chargeTimeType.activation\")) {\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharespurchase\")) {\n                Assertions.assertEquals(\"6.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"6.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else if (chargeTimeType.equals(\"chargeTimeType.sharesredeem\")) {\n                Assertions.assertEquals(\"1.0\", String.valueOf(chargeDef.get(\"amountOrPercentage\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amount\")));\n                Assertions.assertEquals(\"0.0\", String.valueOf(chargeDef.get(\"amountOutstanding\")));\n                Assertions.assertEquals(\"2.0\", String.valueOf(chargeDef.get(\"amountPaid\")));\n            } else {\n                Assertions.fail(\"Other Charge defintion found\");\n            }\n        }\n        summaryMap = (Map<String, Object>) shareAccountData.get(\"summary\");\n        Assertions.assertEquals(\"0\", String.valueOf(summaryMap.get(\"totalApprovedShares\")));\n        Assertions.assertEquals(\"0\", String.valueOf(summaryMap.get(\"totalPendingForApprovalShares\")));\n    }"}
{"prompt": "Create a test that tests validate Create Read Delete Datatable", "completion": "    @Test\n    public void validateCreateReadDeleteDatatable() throws ParseException {\n        // Fetch / Create tst code\n        String tst_tst_tst = \"TST_TST_TST\".toLowerCase();\n        HashMap<String, Object> codeResponse = CodeHelper.getCodeByName(this.requestSpec, this.responseSpec, tst_tst_tst);\n\n        Integer createdCodeId = (Integer) codeResponse.get(\"id\");\n        Integer createdCodeValueId;\n        Integer createdCodeValueIdSecond;\n        if (createdCodeId == null) {\n            createdCodeId = (Integer) CodeHelper.createCode(this.requestSpec, this.responseSpec, tst_tst_tst, \"resourceId\");\n\n            createdCodeValueId = CodeHelper.createCodeValue(this.requestSpec, this.responseSpec, createdCodeId,\n                    Utils.randomStringGenerator(\"cv_\", 8), 1);\n            createdCodeValueIdSecond = CodeHelper.createCodeValue(this.requestSpec, this.responseSpec, createdCodeId,\n                    Utils.randomStringGenerator(\"cv_\", 8), 2);\n        } else {\n            List<HashMap<String, Object>> codeValuesForCode = CodeHelper.getCodeValuesForCode(this.requestSpec, this.responseSpec,\n                    createdCodeId, \"\");\n            createdCodeValueId = (Integer) codeValuesForCode.get(0).get(\"id\");\n            createdCodeValueIdSecond = (Integer) codeValuesForCode.get(1).get(\"id\");\n        }\n\n        // creating datatable for client entity\n        final HashMap<String, Object> columnMap = new HashMap<>();\n        final List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n        columnMap.put(\"datatableName\", Utils.uniqueRandomStringGenerator(CLIENT_APP_TABLE_NAME + \"_\", 5).toLowerCase().toLowerCase());\n        columnMap.put(\"apptableName\", CLIENT_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"PERSON\");\n        columnMap.put(\"multiRow\", false);\n        String itsABoolean = \"itsaboolean\";\n        String itsADate = \"itsadate\";\n        String itsADatetime = \"itsadatetime\";\n        String itsADecimal = \"itsadecimal\";\n        String itsADropdown = \"itsadropdown\";\n        String itsANumber = \"itsanumber\";\n        String itsAString = \"itsastring\";\n        String itsAText = \"itsatext\";\n        String tst_tst_tst_cd_itsADropdown = tst_tst_tst + \"_cd_itsadropdown\";\n        String dateFormat = \"dateFormat\";\n\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsABoolean, \"Boolean\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsADate, \"Date\", true, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsADatetime, \"Datetime\", true, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsADecimal, \"Decimal\", true, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsADropdown, \"Dropdown\", false, null, tst_tst_tst);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsANumber, \"Number\", true, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsAString, \"String\", true, 10, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsAText, \"Text\", true, null, null);\n        columnMap.put(\"columns\", datatableColumnsList);\n        String datatabelRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"map : {}\", datatabelRequestJsonString);\n\n        HashMap<String, Object> datatableResponse = this.datatableHelper.createDatatable(datatabelRequestJsonString, \"\");\n        String datatableName = (String) datatableResponse.get(\"resourceIdentifier\");\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, datatableName);\n\n        // try to create with the same name\n        ResponseSpecification responseSpecError400 = new ResponseSpecBuilder().expectStatusCode(400).build();\n        this.datatableHelper = new DatatableHelper(this.requestSpec, responseSpecError400);\n        HashMap<String, Object> response = this.datatableHelper.createDatatable(datatabelRequestJsonString, \"\");\n        assertEquals(\"validation.msg.validation.errors.exist\", ((Map) response).get(\"userMessageGlobalisationCode\"));\n        this.datatableHelper = new DatatableHelper(this.requestSpec, this.responseSpec);\n\n        // creating client with datatables\n        final Integer clientID = ClientHelper.createClientAsPerson(requestSpec, responseSpec);\n\n        // creating new client datatable entry\n        final boolean genericResultSet = true;\n\n        final HashMap<String, Object> datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(itsABoolean, Utils.randomNumberGenerator(1) % 2 == 0);\n        datatableEntryMap.put(itsADate, Utils.randomDateGenerator(\"yyyy-MM-dd\"));\n        datatableEntryMap.put(itsADatetime, Utils.randomDateTimeGenerator(\"yyyy-MM-dd\"));\n        datatableEntryMap.put(itsADecimal, Utils.randomDecimalGenerator(4, 3));\n        datatableEntryMap.put(tst_tst_tst_cd_itsADropdown, createdCodeValueId);\n        datatableEntryMap.put(itsANumber, Utils.randomNumberGenerator(5));\n        datatableEntryMap.put(itsAString, Utils.randomStringGenerator(\"\", 8));\n        datatableEntryMap.put(itsAText, Utils.randomStringGenerator(\"\", 1000));\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(dateFormat, \"yyyy-MM-dd\");\n\n        String datatabelEntryRequestJsonString = new Gson().toJson(datatableEntryMap);\n        LOG.info(\"map : {}\", datatabelEntryRequestJsonString);\n\n        HashMap<String, Object> datatableEntryResponse = this.datatableHelper.createDatatableEntry(datatableName, clientID,\n                genericResultSet, datatabelEntryRequestJsonString);\n        assertNotNull(datatableEntryResponse.get(\"resourceId\"), \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n\n        // Read the Datatable entry generated with genericResultSet in true (default)\n        final HashMap<String, Object> items = this.datatableHelper.readDatatableEntry(datatableName, clientID, genericResultSet,\n                (Integer) datatableEntryResponse.get(\"resourceId\"), \"\");\n        assertNotNull(items);\n        assertEquals(1, ((List) items.get(\"data\")).size());\n\n        assertEquals(\"client_id\", ((Map) ((List) items.get(\"columnHeaders\")).get(0)).get(\"columnName\"));\n        assertEquals(clientID, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(0));\n\n        assertEquals(itsABoolean, ((Map) ((List) items.get(\"columnHeaders\")).get(1)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(itsABoolean), ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(1));\n\n        assertEquals(itsADate, ((Map) ((List) items.get(\"columnHeaders\")).get(2)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(itsADate),\n                Utils.arrayDateToString((List) ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(2)));\n\n        assertEquals(itsADatetime, ((Map) ((List) items.get(\"columnHeaders\")).get(3)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(itsADatetime),\n                Utils.arrayDateTimeToString((List) ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(3)));\n\n        assertEquals(itsADecimal, ((Map) ((List) items.get(\"columnHeaders\")).get(4)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(itsADecimal), ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(4));\n\n        assertEquals(tst_tst_tst_cd_itsADropdown, ((Map) ((List) items.get(\"columnHeaders\")).get(5)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(tst_tst_tst_cd_itsADropdown),\n                ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(5));\n\n        assertEquals(itsANumber, ((Map) ((List) items.get(\"columnHeaders\")).get(6)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(itsANumber), ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(6));\n\n        assertEquals(itsAString, ((Map) ((List) items.get(\"columnHeaders\")).get(7)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(itsAString), ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(7));\n\n        assertEquals(itsAText, ((Map) ((List) items.get(\"columnHeaders\")).get(8)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(itsAText), ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(8));\n\n        // Read the Datatable entry generated with genericResultSet in false\n        List<HashMap<String, Object>> datatableEntryResponseNoGenericResult = this.datatableHelper.readDatatableEntry(datatableName,\n                clientID, !genericResultSet, (Integer) datatableEntryResponse.get(\"resourceId\"), \"\");\n        assertNotNull(datatableEntryResponseNoGenericResult, \"ERROR IN GETTING THE DATE VALUE FROM DATATABLE RECORD\");\n        assertEquals(1, datatableEntryResponseNoGenericResult.size());\n\n        assertEquals(clientID, datatableEntryResponseNoGenericResult.get(0).get(\"client_id\"));\n        assertEquals(datatableEntryMap.get(itsABoolean),\n                Boolean.valueOf((String) datatableEntryResponseNoGenericResult.get(0).get(itsABoolean)));\n        assertEquals(datatableEntryMap.get(itsADate),\n                Utils.arrayDateToString((List) datatableEntryResponseNoGenericResult.get(0).get(itsADate)));\n        assertEquals(datatableEntryMap.get(itsADecimal), datatableEntryResponseNoGenericResult.get(0).get(itsADecimal));\n        assertEquals(datatableEntryMap.get(itsADatetime),\n                Utils.arrayDateTimeToString((List<Integer>) datatableEntryResponseNoGenericResult.get(0).get(itsADatetime)));\n        assertEquals(datatableEntryMap.get(tst_tst_tst_cd_itsADropdown),\n                datatableEntryResponseNoGenericResult.get(0).get(tst_tst_tst_cd_itsADropdown));\n        assertEquals(datatableEntryMap.get(itsANumber), datatableEntryResponseNoGenericResult.get(0).get(itsANumber));\n        assertEquals(datatableEntryMap.get(itsAString), datatableEntryResponseNoGenericResult.get(0).get(itsAString));\n        assertEquals(datatableEntryMap.get(itsAText), datatableEntryResponseNoGenericResult.get(0).get(itsAText));\n\n        // Update datatable entry\n        Boolean previousBoolean = (Boolean) datatableEntryMap.get(itsABoolean);\n        datatableEntryMap.put(itsABoolean, !previousBoolean);\n        datatableEntryMap.put(itsADate, Utils.randomDateGenerator(\"yyyy-MM-dd\"));\n        datatableEntryMap.put(itsADatetime, Utils.randomDateTimeGenerator(\"yyyy-MM-dd\"));\n        datatableEntryMap.put(itsADecimal, Utils.randomDecimalGenerator(4, 3));\n        datatableEntryMap.put(tst_tst_tst_cd_itsADropdown, null);\n        datatableEntryMap.put(itsANumber, Utils.randomNumberGenerator(5));\n        datatableEntryMap.put(itsAString, Utils.randomStringGenerator(\"\", 8));\n        datatableEntryMap.put(itsAText, Utils.randomStringGenerator(\"\", 1000));\n\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(dateFormat, \"yyyy-MM-dd\");\n\n        datatabelEntryRequestJsonString = new Gson().toJson(datatableEntryMap);\n        LOG.info(\"map : {}\", datatabelEntryRequestJsonString);\n\n        HashMap<String, Object> updatedDatatableEntryResponse = this.datatableHelper.updateDatatableEntry(datatableName, clientID, false,\n                datatabelEntryRequestJsonString);\n\n        assertEquals(clientID, updatedDatatableEntryResponse.get(\"clientId\"));\n\n        assertEquals(datatableEntryMap.get(itsABoolean), ((Map) updatedDatatableEntryResponse.get(\"changes\")).get(itsABoolean));\n        assertEquals(datatableEntryMap.get(itsADate),\n                Utils.arrayDateToString((List) ((Map) updatedDatatableEntryResponse.get(\"changes\")).get(itsADate)));\n        assertEquals(datatableEntryMap.get(itsADecimal), ((Map) updatedDatatableEntryResponse.get(\"changes\")).get(itsADecimal));\n        assertEquals(datatableEntryMap.get(itsADatetime),\n                Utils.arrayDateTimeToString((List<Integer>) ((Map) updatedDatatableEntryResponse.get(\"changes\")).get(itsADatetime)));\n        assertEquals(datatableEntryMap.get(tst_tst_tst_cd_itsADropdown),\n                ((Map) updatedDatatableEntryResponse.get(\"changes\")).get(tst_tst_tst_cd_itsADropdown));\n        assertEquals(datatableEntryMap.get(itsANumber), ((Map) updatedDatatableEntryResponse.get(\"changes\")).get(itsANumber));\n        assertEquals(datatableEntryMap.get(itsAString), ((Map) updatedDatatableEntryResponse.get(\"changes\")).get(itsAString));\n        assertEquals(datatableEntryMap.get(itsAText), ((Map) updatedDatatableEntryResponse.get(\"changes\")).get(itsAText));\n\n        List<String> columnsToValidate = List.of(itsABoolean, itsADate, itsADatetime, itsAString, itsAText, itsADecimal,\n                tst_tst_tst_cd_itsADropdown);\n        for (String column : columnsToValidate) {\n            String valueFilter = column.equals(tst_tst_tst_cd_itsADropdown) ? createdCodeValueId.toString()\n                    : datatableEntryMap.get(column).toString();\n            String rows = Calls.ok(fineract().dataTables.queryValues(datatableName, column, valueFilter, column));\n            JsonArray jsonArray = JsonParser.parseString(rows).getAsJsonArray();\n            if (itsADatetime.equals(column)) {\n                DateFormat df1 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                DateFormat df2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                Date parsedRequest = df1.parse(datatableEntryMap.get(column).toString());\n                Date parsedResponse = df2.parse(jsonArray.get(0).getAsJsonObject().get(column).getAsString());\n                assertFalse(parsedRequest.after(parsedResponse));\n                assertFalse(parsedRequest.before(parsedResponse));\n            } else if (itsADecimal.equals(column)) {\n                assertEquals(0, new BigDecimal(datatableEntryMap.get(column).toString())\n                        .compareTo(new BigDecimal(jsonArray.get(0).getAsJsonObject().get(column).getAsString())));\n            } else if (tst_tst_tst_cd_itsADropdown.equals(column)) {\n                assertEquals(createdCodeValueId.toString(), jsonArray.get(0).getAsJsonObject().get(column).getAsString());\n            } else {\n                assertEquals(datatableEntryMap.get(column).toString(), jsonArray.get(0).getAsJsonObject().get(column).getAsString());\n            }\n        }\n\n        // deleting datatable entries\n        Integer appTableId = this.datatableHelper.deleteDatatableEntries(datatableName, clientID, \"clientId\");\n        assertEquals(clientID, appTableId, \"ERROR IN DELETING THE DATATABLE ENTRIES\");\n\n        // deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(datatableName);\n        assertEquals(datatableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    }"}
{"prompt": "Create a test that tests validate Create Read Delete Datatable With Case Sensitive", "completion": "    @Test\n    public void validateCreateReadDeleteDatatableWithCaseSensitive() throws ParseException {\n\n        // creating datatable for client entity\n        final HashMap<String, Object> columnMap = new HashMap<>();\n        final List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n        columnMap.put(\"datatableName\", Utils.uniqueRandomStringGenerator(CLIENT_APP_TABLE_NAME + \"_\", 5));\n        columnMap.put(\"apptableName\", CLIENT_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"PERSON\");\n        columnMap.put(\"multiRow\", false);\n        String itsADate = \"itsADate\";\n        String itsADecimal = \"itsADecimal\";\n        String itsAString = \"itsAString\";\n        String dateFormat = \"dateFormat\";\n\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsADate, \"Date\", true, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsADecimal, \"Decimal\", true, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, itsAString, \"String\", true, 10, null);\n        columnMap.put(\"columns\", datatableColumnsList);\n        String datatabelRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"map : {}\", datatabelRequestJsonString);\n\n        HashMap<String, Object> datatableResponse = this.datatableHelper.createDatatable(datatabelRequestJsonString, \"\");\n        String datatableName = (String) datatableResponse.get(\"resourceIdentifier\");\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, datatableName);\n\n        // creating client with datatables\n        final Integer clientID = ClientHelper.createClientAsPerson(requestSpec, responseSpec);\n\n        // creating new client datatable entry\n        final boolean genericResultSet = true;\n\n        final HashMap<String, Object> datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(itsADate, Utils.randomDateGenerator(\"yyyy-MM-dd\"));\n        datatableEntryMap.put(itsADecimal, Utils.randomDecimalGenerator(4, 3));\n        datatableEntryMap.put(itsAString, Utils.randomStringGenerator(\"\", 8));\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(dateFormat, \"yyyy-MM-dd\");\n\n        String datatabelEntryRequestJsonString = new Gson().toJson(datatableEntryMap);\n        LOG.info(\"map : {}\", datatabelEntryRequestJsonString);\n\n        HashMap<String, Object> datatableEntryResponse = this.datatableHelper.createDatatableEntry(datatableName, clientID,\n                genericResultSet, datatabelEntryRequestJsonString);\n        assertNotNull(datatableEntryResponse.get(\"resourceId\"), \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n\n        // Read the Datatable entry generated with genericResultSet in true (default)\n        final HashMap<String, Object> items = this.datatableHelper.readDatatableEntry(datatableName, clientID, genericResultSet,\n                (Integer) datatableEntryResponse.get(\"resourceId\"), \"\");\n        assertNotNull(items);\n        assertEquals(1, ((List) items.get(\"data\")).size());\n\n        assertEquals(\"client_id\", ((Map) ((List) items.get(\"columnHeaders\")).get(0)).get(\"columnName\"));\n        assertEquals(clientID, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(0));\n\n        assertEquals(itsADate, ((Map) ((List) items.get(\"columnHeaders\")).get(1)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(itsADate),\n                Utils.arrayDateToString((List) ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(1)));\n\n        assertEquals(itsADecimal, ((Map) ((List) items.get(\"columnHeaders\")).get(2)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(itsADecimal), ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(2));\n\n        assertEquals(itsAString, ((Map) ((List) items.get(\"columnHeaders\")).get(3)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(itsAString), ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(3));\n\n        // Update datatable entry\n        final String randomValue = Utils.randomStringGenerator(\"\", 8);\n        datatableEntryMap.put(itsADate, Utils.randomDateGenerator(\"yyyy-MM-dd\"));\n        datatableEntryMap.put(itsADecimal, Utils.randomDecimalGenerator(4, 3));\n        datatableEntryMap.put(itsAString, randomValue);\n\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(dateFormat, \"yyyy-MM-dd\");\n\n        datatabelEntryRequestJsonString = new Gson().toJson(datatableEntryMap);\n        LOG.info(\"map : {}\", datatabelEntryRequestJsonString);\n\n        HashMap<String, Object> updatedDatatableEntryResponse = this.datatableHelper.updateDatatableEntry(datatableName, clientID, false,\n                datatabelEntryRequestJsonString);\n\n        assertEquals(clientID, updatedDatatableEntryResponse.get(\"clientId\"));\n\n        assertEquals(datatableEntryMap.get(itsADate),\n                Utils.arrayDateToString((List) ((Map) updatedDatatableEntryResponse.get(\"changes\")).get(itsADate)));\n        assertEquals(datatableEntryMap.get(itsADecimal), ((Map) updatedDatatableEntryResponse.get(\"changes\")).get(itsADecimal));\n        assertEquals(datatableEntryMap.get(itsAString), ((Map) updatedDatatableEntryResponse.get(\"changes\")).get(itsAString));\n\n        // Read the datatable with a query\n        LOG.info(\"query in {} for value : {}\", itsAString, randomValue);\n        final String queryResult = this.datatableHelper.runDatatableQuery(datatableName, itsAString, randomValue, \"client_id,itsADecimal\");\n        assertNotNull(queryResult);\n        LOG.info(\"query result : {}\", queryResult);\n\n        // deleting datatable entries\n        Integer appTableId = this.datatableHelper.deleteDatatableEntries(datatableName, clientID, \"clientId\");\n        assertEquals(clientID, appTableId, \"ERROR IN DELETING THE DATATABLE ENTRIES\");\n\n        // deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(datatableName);\n        assertEquals(datatableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    }"}
{"prompt": "Create a test that tests validate Insert Null Values", "completion": "    @Test\n    public void validateInsertNullValues() {\n        // Fetch / Create TST code\n        HashMap<String, Object> codeResponse = CodeHelper.getCodeByName(this.requestSpec, this.responseSpec, \"TST_TST_TST\");\n\n        // creating datatable for client entity\n        final HashMap<String, Object> columnMap = new HashMap<>();\n        final List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n        columnMap.put(\"datatableName\", Utils.uniqueRandomStringGenerator(LOAN_APP_TABLE_NAME + \"_\", 5));\n        columnMap.put(\"apptableName\", LOAN_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"\");\n        columnMap.put(\"multiRow\", true);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsABoolean\", \"Boolean\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsADate\", \"Date\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsADatetime\", \"Datetime\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsADecimal\", \"Decimal\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsADropdown\", \"Dropdown\", false, null, \"TST_TST_TST\");\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsANumber\", \"Number\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsAString\", \"String\", false, 10, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsAText\", \"Text\", false, null, null);\n        columnMap.put(\"columns\", datatableColumnsList);\n        String datatabelRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"map : {}\", datatabelRequestJsonString);\n\n        HashMap<String, Object> datatableResponse = this.datatableHelper.createDatatable(datatabelRequestJsonString, \"\");\n        String datatableName = (String) datatableResponse.get(\"resourceIdentifier\");\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, datatableName);\n\n        // try to create with the same name\n        ResponseSpecification responseSpecError400 = new ResponseSpecBuilder().expectStatusCode(400).build();\n        this.datatableHelper = new DatatableHelper(this.requestSpec, responseSpecError400);\n        HashMap<String, Object> response = this.datatableHelper.createDatatable(datatabelRequestJsonString, \"\");\n        assertEquals(\"validation.msg.validation.errors.exist\", ((Map) response).get(\"userMessageGlobalisationCode\"));\n        this.datatableHelper = new DatatableHelper(this.requestSpec, this.responseSpec);\n\n        // creating client with datatables\n        final Integer clientID = ClientHelper.createClientAsPerson(requestSpec, responseSpec);\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingEnabled();\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        // creating new client datatable entry\n        final boolean genericResultSet = true;\n\n        HashMap<String, Object> datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(\"itsABoolean\", null);\n        datatableEntryMap.put(\"itsADate\", null);\n        datatableEntryMap.put(\"itsADatetime\", null);\n        datatableEntryMap.put(\"itsADecimal\", null);\n        datatableEntryMap.put(\"TST_TST_TST_cd_itsADropdown\", null);\n        datatableEntryMap.put(\"itsANumber\", null);\n        datatableEntryMap.put(\"itsAString\", null);\n        datatableEntryMap.put(\"itsAText\", null);\n\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(\"dateFormat\", \"yyyy-MM-dd\");\n\n        String datatableEntryRequestJsonString = new GsonBuilder().serializeNulls().create().toJson(datatableEntryMap);\n        LOG.info(\"map : {}\", datatableEntryRequestJsonString);\n\n        HashMap<String, Object> datatableEntryResponseFirst = this.datatableHelper.createDatatableEntry(datatableName, loanID,\n                genericResultSet, datatableEntryRequestJsonString);\n\n        datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(\"itsABoolean\", \"\");\n        datatableEntryMap.put(\"itsADate\", \"\");\n        datatableEntryMap.put(\"itsADatetime\", \"\");\n        datatableEntryMap.put(\"itsADecimal\", \"\");\n        datatableEntryMap.put(\"TST_TST_TST_cd_itsADropdown\", \"\");\n        datatableEntryMap.put(\"itsANumber\", \"\");\n        datatableEntryMap.put(\"itsAString\", \"\");\n        datatableEntryMap.put(\"itsAText\", \"\");\n\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(\"dateFormat\", \"yyyy-MM-dd\");\n\n        datatableEntryRequestJsonString = new GsonBuilder().serializeNulls().create().toJson(datatableEntryMap);\n        HashMap<String, Object> datatableEntryResponseSecond = this.datatableHelper.createDatatableEntry(datatableName, loanID,\n                genericResultSet, datatableEntryRequestJsonString);\n        assertNotNull(datatableEntryResponseFirst.get(\"resourceId\"), \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n        assertNotNull(datatableEntryResponseSecond.get(\"resourceId\"), \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n\n        // Read the Datatable entry generated with genericResultSet in true (default)\n        HashMap<String, Object> items = this.datatableHelper.readDatatableEntry(datatableName, loanID, genericResultSet, null, \"\");\n        assertNotNull(items);\n        assertEquals(2, ((List) items.get(\"data\")).size());\n\n        assertEquals(\"id\", ((Map) ((List) items.get(\"columnHeaders\")).get(0)).get(\"columnName\"));\n        assertEquals(1, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(0));\n        assertEquals(\"loan_id\", ((Map) ((List) items.get(\"columnHeaders\")).get(1)).get(\"columnName\"));\n        assertEquals(loanID, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(1));\n        assertEquals(\"itsABoolean\", ((Map) ((List) items.get(\"columnHeaders\")).get(2)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(2));\n        assertEquals(\"itsADate\", ((Map) ((List) items.get(\"columnHeaders\")).get(3)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(3));\n        assertEquals(\"itsADatetime\", ((Map) ((List) items.get(\"columnHeaders\")).get(4)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(4));\n        assertEquals(\"itsADecimal\", ((Map) ((List) items.get(\"columnHeaders\")).get(5)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(5));\n        assertEquals(\"TST_TST_TST_cd_itsADropdown\", ((Map) ((List) items.get(\"columnHeaders\")).get(6)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(6));\n        assertEquals(\"itsANumber\", ((Map) ((List) items.get(\"columnHeaders\")).get(7)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(7));\n        assertEquals(\"itsAString\", ((Map) ((List) items.get(\"columnHeaders\")).get(8)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(8));\n        assertEquals(\"itsAText\", ((Map) ((List) items.get(\"columnHeaders\")).get(9)).get(\"columnName\"));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(9));\n\n        assertEquals(2, ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(0));\n        assertEquals(loanID, ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(1));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(2));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(3));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(4));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(5));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(6));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(7));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(8));\n        assertNull(((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(9));\n\n        PutDataTablesAppTableIdDatatableIdResponse updatedDatatableEntryResponse = this.datatableHelper.updateDatatableEntry(datatableName,\n                loanID, 1, datatableEntryRequestJsonString);\n        assertNotNull(updatedDatatableEntryResponse);\n        assertEquals(0, updatedDatatableEntryResponse.getChanges().size());\n    }"}
{"prompt": "Create a test that tests validate Create And Edit Datatable", "completion": "    @Test\n    public void validateCreateAndEditDatatable() {\n        // Creating client\n        final Integer clientId = ClientHelper.createClientAsPerson(requestSpec, responseSpec);\n        final Integer randomNumber = Utils.randomNumberGenerator(3);\n\n        // Creating datatable for Client Person\n        final String datatableName = Utils.uniqueRandomStringGenerator(CLIENT_APP_TABLE_NAME + \"_\", 5);\n        final boolean genericResultSet = true;\n\n        HashMap<String, Object> columnMap = new HashMap<>();\n        List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n        columnMap.put(\"datatableName\", datatableName);\n        columnMap.put(\"apptableName\", CLIENT_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", CLIENT_PERSON_SUBTYPE_NAME);\n        columnMap.put(\"multiRow\", false);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsANumber\", \"Number\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsAString\", \"String\", false, 10, null);\n        columnMap.put(\"columns\", datatableColumnsList);\n        String datatabelRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"map : {}\", datatabelRequestJsonString);\n\n        PostDataTablesResponse datatableCreateResponse = this.datatableHelper.createDatatable(datatabelRequestJsonString);\n        assertEquals(datatableName, datatableCreateResponse.getResourceIdentifier());\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, datatableName);\n\n        // Insert first values\n        final String value = Utils.randomStringGenerator(\"Q\", 8);\n        HashMap<String, Object> datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(\"itsANumber\", randomNumber);\n        datatableEntryMap.put(\"itsAString\", value);\n\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(\"dateFormat\", \"yyyy-MM-dd\");\n\n        String datatableEntryRequestJsonString = new GsonBuilder().serializeNulls().create().toJson(datatableEntryMap);\n        PostDataTablesAppTableIdResponse datatableEntryResponse = this.datatableHelper.addDatatableEntry(datatableName, clientId,\n                genericResultSet, datatableEntryRequestJsonString);\n        assertNotNull(datatableEntryResponse.getResourceId(), \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n\n        // Read the Datatable entry generated with genericResultSet in true (default)\n        HashMap<String, Object> items = this.datatableHelper.readDatatableEntry(datatableName, clientId, genericResultSet, null, \"\");\n        assertNotNull(items);\n        assertEquals(1, ((List) items.get(\"data\")).size());\n        LOG.info(\"Record created at {}\", ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(3));\n        LOG.info(\"Record updated at {}\", ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(4));\n\n        assertEquals(clientId, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(0));\n        assertEquals(value, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(2));\n\n        // Update DataTable\n        columnMap = new HashMap<>();\n        columnMap.put(\"apptableName\", CLIENT_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", CLIENT_PERSON_SUBTYPE_NAME);\n        datatableColumnsList = new ArrayList<>();\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsAText\", \"Text\", false, null, null);\n        columnMap.put(\"addColumns\", datatableColumnsList);\n        datatabelRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"map to update : {}\", datatabelRequestJsonString);\n        PutDataTablesResponse datatableUpdateResponse = this.datatableHelper.updateDatatable(datatableName, datatabelRequestJsonString);\n        assertNotNull(datatableUpdateResponse);\n        assertEquals(datatableName, datatableUpdateResponse.getResourceIdentifier());\n\n        // Update DataTable Entry after Update DataTable schema\n        datatableEntryMap = new HashMap<>();\n        final String textValue = Utils.randomStringGenerator(value, 120);\n        datatableEntryMap.put(\"itsAText\", textValue);\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(\"dateFormat\", \"yyyy-MM-dd\");\n\n        datatableEntryRequestJsonString = new GsonBuilder().serializeNulls().create().toJson(datatableEntryMap);\n        LOG.info(\"map to update : {}\", datatableEntryRequestJsonString);\n        PutDataTablesAppTableIdDatatableIdResponse updatedDatatableEntryResponse = this.datatableHelper.updateDatatableEntry(datatableName,\n                clientId, datatableEntryRequestJsonString);\n        assertNotNull(updatedDatatableEntryResponse);\n        assertEquals(1, updatedDatatableEntryResponse.getChanges().size());\n\n        // Read the Datatable entry generated with genericResultSet in true (default)\n        items = this.datatableHelper.readDatatableEntry(datatableName, clientId, genericResultSet, null, \"\");\n        assertNotNull(items);\n        assertEquals(1, ((List) items.get(\"data\")).size());\n        LOG.info(\"Record created at {}\", ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(3));\n        LOG.info(\"Record updated at {}\", ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(4));\n\n        assertEquals(clientId, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(0));\n        assertEquals(value, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(2));\n        assertEquals(textValue, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(5));\n    }"}
{"prompt": "Create a test that tests validate Read Datatable Multirow", "completion": "    @Test\n    public void validateReadDatatableMultirow() {\n        // Fetch / Create TST code\n        String tst_tst_tst = \"tst_tst_tst\";\n        HashMap<String, Object> codeResponse = CodeHelper.getCodeByName(this.requestSpec, this.responseSpec, tst_tst_tst);\n\n        Integer createdCodeId = (Integer) codeResponse.get(\"id\");\n        Integer createdCodeValueId;\n        Integer createdCodeValueIdSecond;\n        if (createdCodeId == null) {\n            createdCodeId = (Integer) CodeHelper.createCode(this.requestSpec, this.responseSpec, tst_tst_tst, \"resourceId\");\n\n            createdCodeValueId = CodeHelper.createCodeValue(this.requestSpec, this.responseSpec, createdCodeId,\n                    Utils.randomStringGenerator(\"cv_\", 8), 1);\n            createdCodeValueIdSecond = CodeHelper.createCodeValue(this.requestSpec, this.responseSpec, createdCodeId,\n                    Utils.randomStringGenerator(\"cv_\", 8), 2);\n        } else {\n            List<HashMap<String, Object>> codeValuesForCode = CodeHelper.getCodeValuesForCode(this.requestSpec, this.responseSpec,\n                    createdCodeId, \"\");\n            createdCodeValueId = (Integer) codeValuesForCode.get(0).get(\"id\");\n            createdCodeValueIdSecond = (Integer) codeValuesForCode.get(1).get(\"id\");\n        }\n\n        // creating datatable for client entity\n        final HashMap<String, Object> columnMap = new HashMap<>();\n        final List<HashMap<String, Object>> datatableColumnsList = new ArrayList<>();\n        columnMap.put(\"datatableName\", Utils.uniqueRandomStringGenerator(LOAN_APP_TABLE_NAME + \"_\", 5));\n        columnMap.put(\"apptableName\", LOAN_APP_TABLE_NAME);\n        columnMap.put(\"entitySubType\", \"\");\n        columnMap.put(\"multiRow\", true);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsABoolean\", \"Boolean\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsADate\", \"Date\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsADatetime\", \"Datetime\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsADecimal\", \"Decimal\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsADropdown\", \"Dropdown\", false, null, tst_tst_tst);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsANumber\", \"Number\", false, null, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsAString\", \"String\", false, 10, null);\n        DatatableHelper.addDatatableColumns(datatableColumnsList, \"itsAText\", \"Text\", false, null, null);\n        columnMap.put(\"columns\", datatableColumnsList);\n        String datatabelRequestJsonString = new Gson().toJson(columnMap);\n        LOG.info(\"map : {}\", datatabelRequestJsonString);\n\n        HashMap<String, Object> datatableResponse = this.datatableHelper.createDatatable(datatabelRequestJsonString, \"\");\n        String datatableName = (String) datatableResponse.get(\"resourceIdentifier\");\n        DatatableHelper.verifyDatatableCreatedOnServer(this.requestSpec, this.responseSpec, datatableName);\n\n        // try to create with the same name\n        ResponseSpecification responseSpecError400 = new ResponseSpecBuilder().expectStatusCode(400).build();\n        this.datatableHelper = new DatatableHelper(this.requestSpec, responseSpecError400);\n        HashMap<String, Object> response = this.datatableHelper.createDatatable(datatabelRequestJsonString, \"\");\n        assertEquals(\"validation.msg.validation.errors.exist\", ((Map) response).get(\"userMessageGlobalisationCode\"));\n        this.datatableHelper = new DatatableHelper(this.requestSpec, this.responseSpec);\n\n        // creating client with datatables\n        final Integer clientID = ClientHelper.createClientAsPerson(requestSpec, responseSpec);\n        final Integer loanProductID = createLoanProductWithPeriodicAccrualAccountingEnabled();\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID);\n\n        // creating new client datatable entry\n        final boolean genericResultSet = true;\n\n        final HashMap<String, Object> datatableEntryMap = new HashMap<>();\n        datatableEntryMap.put(\"itsABoolean\", Utils.randomNumberGenerator(1) % 2 == 0);\n        datatableEntryMap.put(\"itsADate\", Utils.randomDateGenerator(\"yyyy-MM-dd\"));\n        datatableEntryMap.put(\"itsADatetime\", Utils.randomDateTimeGenerator(\"yyyy-MM-dd\"));\n        datatableEntryMap.put(\"itsADecimal\", Utils.randomDecimalGenerator(4, 3));\n        datatableEntryMap.put(tst_tst_tst + \"_cd_itsADropdown\", createdCodeValueId);\n        datatableEntryMap.put(\"itsANumber\", Utils.randomNumberGenerator(5));\n        datatableEntryMap.put(\"itsAString\", Utils.randomStringGenerator(\"\", 8));\n        datatableEntryMap.put(\"itsAText\", Utils.randomStringGenerator(\"\", 1000));\n\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(\"dateFormat\", \"yyyy-MM-dd\");\n\n        String datatabelEntryRequestJsonString = new Gson().toJson(datatableEntryMap);\n        LOG.info(\"map : {}\", datatabelEntryRequestJsonString);\n\n        HashMap<String, Object> datatableEntryResponseFirst = this.datatableHelper.createDatatableEntry(datatableName, loanID,\n                genericResultSet, datatabelEntryRequestJsonString);\n        HashMap<String, Object> datatableEntryResponseSecond = this.datatableHelper.createDatatableEntry(datatableName, loanID,\n                genericResultSet, datatabelEntryRequestJsonString);\n        assertNotNull(datatableEntryResponseFirst.get(\"resourceId\"), \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n        assertNotNull(datatableEntryResponseSecond.get(\"resourceId\"), \"ERROR IN CREATING THE ENTITY DATATABLE RECORD\");\n\n        // Read the Datatable entry generated with genericResultSet in true (default)\n        HashMap<String, Object> items = this.datatableHelper.readDatatableEntry(datatableName, loanID, genericResultSet, null, \"\");\n        assertNotNull(items);\n        assertEquals(2, ((List) items.get(\"data\")).size());\n\n        assertEquals(\"id\", ((Map) ((List) items.get(\"columnHeaders\")).get(0)).get(\"columnName\"));\n        assertEquals(1, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(0));\n        assertEquals(\"loan_id\", ((Map) ((List) items.get(\"columnHeaders\")).get(1)).get(\"columnName\"));\n        assertEquals(loanID, ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(1));\n        assertEquals(\"itsABoolean\", ((Map) ((List) items.get(\"columnHeaders\")).get(2)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(\"itsABoolean\"), ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(2));\n        assertEquals(\"itsADate\", ((Map) ((List) items.get(\"columnHeaders\")).get(3)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(\"itsADate\"),\n                Utils.arrayDateToString((List) ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(3)));\n        assertEquals(\"itsADatetime\", ((Map) ((List) items.get(\"columnHeaders\")).get(4)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(\"itsADatetime\"),\n                Utils.arrayDateTimeToString((List) ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(4)));\n        assertEquals(\"itsADecimal\", ((Map) ((List) items.get(\"columnHeaders\")).get(5)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(\"itsADecimal\"), ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(5));\n        assertEquals(tst_tst_tst + \"_cd_itsADropdown\", ((Map) ((List) items.get(\"columnHeaders\")).get(6)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(tst_tst_tst + \"_cd_itsADropdown\"),\n                ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(6));\n        assertEquals(\"itsANumber\", ((Map) ((List) items.get(\"columnHeaders\")).get(7)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(\"itsANumber\"), ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(7));\n        assertEquals(\"itsAString\", ((Map) ((List) items.get(\"columnHeaders\")).get(8)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(\"itsAString\"), ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(8));\n        assertEquals(\"itsAText\", ((Map) ((List) items.get(\"columnHeaders\")).get(9)).get(\"columnName\"));\n        assertEquals(datatableEntryMap.get(\"itsAText\"), ((List) ((Map) ((List) items.get(\"data\")).get(0)).get(\"row\")).get(9));\n\n        assertEquals(2, ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(0));\n        assertEquals(loanID, ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(1));\n        assertEquals(datatableEntryMap.get(\"itsABoolean\"), ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(2));\n        assertEquals(datatableEntryMap.get(\"itsADate\"),\n                Utils.arrayDateToString((List) ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(3)));\n        assertEquals(datatableEntryMap.get(\"itsADatetime\"),\n                Utils.arrayDateTimeToString((List) ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(4)));\n        assertEquals(datatableEntryMap.get(\"itsADecimal\"), ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(5));\n        assertEquals(datatableEntryMap.get(tst_tst_tst + \"_cd_itsADropdown\"),\n                ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(6));\n        assertEquals(datatableEntryMap.get(\"itsANumber\"), ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(7));\n        assertEquals(datatableEntryMap.get(\"itsAString\"), ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(8));\n        assertEquals(datatableEntryMap.get(\"itsAText\"), ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(9));\n\n        // Read the Datatable entry generated with genericResultSet in false\n        List<HashMap<String, Object>> datatableEntryResponseNoGenericResult = this.datatableHelper.readDatatableEntry(datatableName, loanID,\n                !genericResultSet, (Integer) datatableEntryResponseFirst.get(\"resourceId\"), \"\");\n        assertNotNull(datatableEntryResponseNoGenericResult, \"ERROR IN GETTING THE DATE VALUE FROM DATATABLE RECORD\");\n        assertEquals(1, datatableEntryResponseNoGenericResult.size());\n\n        assertEquals(loanID, datatableEntryResponseNoGenericResult.get(0).get(\"loan_id\"));\n        assertEquals(datatableEntryMap.get(\"itsABoolean\"),\n                Boolean.valueOf((String) datatableEntryResponseNoGenericResult.get(0).get(\"itsABoolean\")));\n        assertEquals(datatableEntryMap.get(\"itsADate\"),\n                Utils.arrayDateToString((List) datatableEntryResponseNoGenericResult.get(0).get(\"itsADate\")));\n        assertEquals(datatableEntryMap.get(\"itsADecimal\"), datatableEntryResponseNoGenericResult.get(0).get(\"itsADecimal\"));\n        assertEquals(datatableEntryMap.get(\"itsADatetime\"),\n                Utils.arrayDateTimeToString((List<Integer>) datatableEntryResponseNoGenericResult.get(0).get(\"itsADatetime\")));\n        assertEquals(datatableEntryMap.get(tst_tst_tst + \"_cd_itsADropdown\"),\n                datatableEntryResponseNoGenericResult.get(0).get(tst_tst_tst + \"_cd_itsADropdown\"));\n        assertEquals(datatableEntryMap.get(\"itsANumber\"), datatableEntryResponseNoGenericResult.get(0).get(\"itsANumber\"));\n        assertEquals(datatableEntryMap.get(\"itsAString\"), datatableEntryResponseNoGenericResult.get(0).get(\"itsAString\"));\n        assertEquals(datatableEntryMap.get(\"itsAText\"), datatableEntryResponseNoGenericResult.get(0).get(\"itsAText\"));\n\n        // Update datatable entry\n\n        Boolean previousBoolean = (Boolean) datatableEntryMap.get(\"itsABoolean\");\n\n        datatableEntryMap.put(\"itsABoolean\", null);\n        datatableEntryMap.put(\"itsADate\", null);\n        datatableEntryMap.put(\"itsADatetime\", null);\n        datatableEntryMap.put(\"itsADecimal\", null);\n        datatableEntryMap.put(tst_tst_tst + \"_cd_itsADropdown\", null);\n        datatableEntryMap.put(\"itsANumber\", null);\n        datatableEntryMap.put(\"itsAString\", null);\n        datatableEntryMap.put(\"itsAText\", null);\n\n        datatableEntryMap.put(\"locale\", \"en\");\n        datatableEntryMap.put(\"dateFormat\", \"yyyy-MM-dd\");\n\n        datatabelEntryRequestJsonString = new GsonBuilder().serializeNulls().create().toJson(datatableEntryMap);\n        LOG.info(\"map : {}\", datatabelEntryRequestJsonString);\n\n        PutDataTablesAppTableIdDatatableIdResponse updatedDatatableEntryResponse = this.datatableHelper.updateDatatableEntry(datatableName,\n                loanID, 1, datatabelEntryRequestJsonString);\n        assertNotNull(updatedDatatableEntryResponse);\n        assertEquals(1L, updatedDatatableEntryResponse.getResourceId());\n        updatedDatatableEntryResponse = this.datatableHelper.updateDatatableEntry(datatableName, loanID, 2,\n                datatabelEntryRequestJsonString);\n        assertNotNull(updatedDatatableEntryResponse);\n        assertEquals(2L, updatedDatatableEntryResponse.getResourceId());\n\n        assertEquals(Long.valueOf(loanID), updatedDatatableEntryResponse.getLoanId());\n\n        assertEquals(null, updatedDatatableEntryResponse.getChanges().get(\"itsABoolean\"));\n        assertEquals(null, updatedDatatableEntryResponse.getChanges().get(\"itsADate\"));\n        assertEquals(null, updatedDatatableEntryResponse.getChanges().get(\"itsADecimal\"));\n        assertEquals(null, updatedDatatableEntryResponse.getChanges().get(\"itsADatetime\"));\n        assertEquals(null, updatedDatatableEntryResponse.getChanges().get(tst_tst_tst + \"_cd_itsADropdown\"));\n        assertEquals(null, updatedDatatableEntryResponse.getChanges().get(\"itsANumber\"));\n        assertEquals(null, updatedDatatableEntryResponse.getChanges().get(\"itsAString\"));\n        assertEquals(null, updatedDatatableEntryResponse.getChanges().get(\"itsAText\"));\n\n        items = this.datatableHelper.readDatatableEntry(datatableName, loanID, genericResultSet, null, \"\");\n        assertNotNull(items);\n        assertEquals(2, ((List) items.get(\"data\")).size());\n\n        assertEquals(\"loan_id\", ((Map) ((List) items.get(\"columnHeaders\")).get(1)).get(\"columnName\"));\n        assertEquals(loanID, ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(1));\n        assertEquals(\"itsABoolean\", ((Map) ((List) items.get(\"columnHeaders\")).get(2)).get(\"columnName\"));\n        assertEquals(null, ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(2));\n        assertEquals(\"itsADate\", ((Map) ((List) items.get(\"columnHeaders\")).get(3)).get(\"columnName\"));\n        assertEquals(null, ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(3));\n        assertEquals(\"itsADatetime\", ((Map) ((List) items.get(\"columnHeaders\")).get(4)).get(\"columnName\"));\n        assertEquals(null, ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(4));\n        assertEquals(\"itsADecimal\", ((Map) ((List) items.get(\"columnHeaders\")).get(5)).get(\"columnName\"));\n        assertEquals(null, ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(5));\n        assertEquals(tst_tst_tst + \"_cd_itsADropdown\", ((Map) ((List) items.get(\"columnHeaders\")).get(6)).get(\"columnName\"));\n        assertEquals(null, ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(6));\n        assertEquals(\"itsANumber\", ((Map) ((List) items.get(\"columnHeaders\")).get(7)).get(\"columnName\"));\n        assertEquals(null, ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(7));\n        assertEquals(\"itsAString\", ((Map) ((List) items.get(\"columnHeaders\")).get(8)).get(\"columnName\"));\n        assertEquals(null, ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(8));\n        assertEquals(\"itsAText\", ((Map) ((List) items.get(\"columnHeaders\")).get(9)).get(\"columnName\"));\n        assertEquals(null, ((List) ((Map) ((List) items.get(\"data\")).get(1)).get(\"row\")).get(9));\n\n        // Read the Datatable entry generated with genericResultSet in false\n        datatableEntryResponseNoGenericResult = this.datatableHelper.readDatatableEntry(datatableName, loanID, !genericResultSet,\n                (Integer) datatableEntryResponseFirst.get(\"resourceId\"), \"\");\n        assertNotNull(datatableEntryResponseNoGenericResult, \"ERROR IN GETTING THE DATE VALUE FROM DATATABLE RECORD\");\n        assertEquals(1, datatableEntryResponseNoGenericResult.size());\n\n        assertEquals(loanID, datatableEntryResponseNoGenericResult.get(0).get(\"loan_id\"));\n        assertEquals(datatableEntryMap.get(\"itsABoolean\"), datatableEntryResponseNoGenericResult.get(0).get(\"itsABoolean\"));\n        assertEquals(datatableEntryMap.get(\"itsADate\"), datatableEntryResponseNoGenericResult.get(0).get(\"itsADate\"));\n        assertEquals(datatableEntryMap.get(\"itsADecimal\"), datatableEntryResponseNoGenericResult.get(0).get(\"itsADecimal\"));\n        assertEquals(datatableEntryMap.get(\"itsADatetime\"), datatableEntryResponseNoGenericResult.get(0).get(\"itsADatetime\"));\n        assertEquals(datatableEntryMap.get(tst_tst_tst + \"_cd_itsADropdown\"),\n                datatableEntryResponseNoGenericResult.get(0).get(tst_tst_tst + \"_cd_itsADropdown\"));\n        assertEquals(datatableEntryMap.get(\"itsANumber\"), datatableEntryResponseNoGenericResult.get(0).get(\"itsANumber\"));\n        assertEquals(datatableEntryMap.get(\"itsAString\"), datatableEntryResponseNoGenericResult.get(0).get(\"itsAString\"));\n        assertEquals(datatableEntryMap.get(\"itsAText\"), datatableEntryResponseNoGenericResult.get(0).get(\"itsAText\"));\n\n        // deleting datatable entries\n        Integer appTableId = this.datatableHelper.deleteDatatableEntries(datatableName, loanID, \"loanId\");\n        assertEquals(loanID, appTableId, \"ERROR IN DELETING THE DATATABLE ENTRIES\");\n\n        // deleting the datatable\n        String deletedDataTableName = this.datatableHelper.deleteDatatable(datatableName);\n        assertEquals(datatableName, deletedDataTableName, \"ERROR IN DELETING THE DATATABLE\");\n    }"}
{"prompt": "Create a test that tests test Datable Creation With Unique And Indexed Columns", "completion": "    @Test\n    public void testDatableCreationWithUniqueAndIndexedColumns() {\n        // given\n        String datatableName = DatatableTestNameGenerator.generateDatatableName(LOAN);\n        String column1Name = \"itsanumber\";\n        String column2Name = \"itsastring\";\n\n        PostDataTablesRequest request = new PostDataTablesRequest();\n        request.setDatatableName(datatableName);\n        request.setApptableName(LOAN.getReferencedTableName());\n        request.setMultiRow(false);\n\n        PostColumnHeaderData column1HeaderRequestData = new PostColumnHeaderData();\n        column1HeaderRequestData.setName(column1Name);\n        column1HeaderRequestData.setType(\"Number\");\n        column1HeaderRequestData.setMandatory(false);\n        column1HeaderRequestData.setLength(10L);\n        column1HeaderRequestData.setCode(\"\");\n        column1HeaderRequestData.setUnique(true);\n        column1HeaderRequestData.setIndexed(true);\n\n        request.addColumnsItem(column1HeaderRequestData);\n\n        PostColumnHeaderData column2HeaderRequestData = new PostColumnHeaderData();\n        column2HeaderRequestData.setName(column2Name);\n        column2HeaderRequestData.setType(\"String\");\n        column2HeaderRequestData.setMandatory(false);\n        column2HeaderRequestData.setLength(10L);\n        column2HeaderRequestData.setCode(\"\");\n        column2HeaderRequestData.setUnique(false);\n        column2HeaderRequestData.setIndexed(true);\n\n        request.addColumnsItem(column2HeaderRequestData);\n\n        // when\n        PostDataTablesResponse response = datatableHelper.createDatatable(request);\n\n        // then\n        assertThat(response.getResourceIdentifier()).isNotBlank();\n\n        GetDataTablesResponse dataTable = datatableHelper.getDataTableDetails(datatableName);\n\n        List<ResultsetColumnHeaderData> columnHeaderData = dataTable.getColumnHeaderData();\n        assertThat(columnHeaderData).isNotNull().hasSize(5);\n\n        List<NameUniqueIndexedHeaderData> expected = List.of(new NameUniqueIndexedHeaderData(column1Name, true, true),\n                new NameUniqueIndexedHeaderData(column2Name, false, true));\n\n        NameUniqueIndexedHeaderData.Mapper mapper = Mappers.getMapper(NameUniqueIndexedHeaderData.Mapper.class);\n        List<NameUniqueIndexedHeaderData> data = mapper.map(columnHeaderData);\n\n        assertThat(data).containsAll(expected);\n    }"}
{"prompt": "Create a test that tests test Datable Modification With Unique And Indexed Columns", "completion": "    @Test\n    public void testDatableModificationWithUniqueAndIndexedColumns() {\n        // given\n        // region Datatable creation\n        String datatableName = DatatableTestNameGenerator.generateDatatableName(LOAN);\n        String column1Name = \"itsanumber\";\n        String column2Name = \"itsastring\";\n\n        PostDataTablesRequest request = new PostDataTablesRequest();\n        request.setDatatableName(datatableName);\n        request.setApptableName(LOAN.getReferencedTableName());\n        request.setMultiRow(false);\n\n        PostColumnHeaderData column1HeaderRequestData = new PostColumnHeaderData();\n        column1HeaderRequestData.setName(column1Name);\n        column1HeaderRequestData.setType(\"Number\");\n        column1HeaderRequestData.setMandatory(false);\n        column1HeaderRequestData.setLength(10L);\n        column1HeaderRequestData.setCode(\"\");\n        column1HeaderRequestData.setUnique(true);\n        column1HeaderRequestData.setIndexed(true);\n\n        request.addColumnsItem(column1HeaderRequestData);\n\n        PostColumnHeaderData column2HeaderRequestData = new PostColumnHeaderData();\n        column2HeaderRequestData.setName(column2Name);\n        column2HeaderRequestData.setType(\"String\");\n        column2HeaderRequestData.setMandatory(false);\n        column2HeaderRequestData.setLength(10L);\n        column2HeaderRequestData.setCode(\"\");\n        column2HeaderRequestData.setUnique(false);\n        column2HeaderRequestData.setIndexed(true);\n\n        request.addColumnsItem(column2HeaderRequestData);\n\n        PostDataTablesResponse response = datatableHelper.createDatatable(request);\n\n        assertThat(response.getResourceIdentifier()).isNotBlank();\n        // endregion\n\n        // region Datatable update\n        PutDataTablesRequest updateRequest = new PutDataTablesRequest();\n        updateRequest.setApptableName(LOAN.getReferencedTableName());\n\n        String column3Name = \"number1\";\n        String column4Name = \"number2\";\n\n        PutDataTablesRequestAddColumns addColumn1 = new PutDataTablesRequestAddColumns();\n        addColumn1.setName(column3Name);\n        addColumn1.setType(\"Number\");\n        addColumn1.setMandatory(false);\n        addColumn1.setCode(\"\");\n        addColumn1.setUnique(true);\n        addColumn1.setIndexed(false);\n\n        updateRequest.addAddColumnsItem(addColumn1);\n\n        PutDataTablesRequestAddColumns addColumn2 = new PutDataTablesRequestAddColumns();\n        addColumn2.setName(column4Name);\n        addColumn2.setType(\"Number\");\n        addColumn2.setMandatory(false);\n        addColumn2.setCode(\"\");\n        addColumn2.setUnique(false);\n        addColumn2.setIndexed(true);\n\n        updateRequest.addAddColumnsItem(addColumn2);\n\n        PutDataTablesRequestChangeColumns changeColumns = new PutDataTablesRequestChangeColumns();\n        changeColumns.setName(column1Name);\n        String newColumnName = column1Name + \"new\";\n        changeColumns.setNewName(newColumnName);\n        changeColumns.setIndexed(true);\n\n        updateRequest.addChangeColumnsItem(changeColumns);\n\n        // endregion\n        // when\n        PutDataTablesResponse updateResponse = datatableHelper.updateDatatable(datatableName, updateRequest);\n\n        // then\n        GetDataTablesResponse dataTable = datatableHelper.getDataTableDetails(datatableName);\n\n        List<ResultsetColumnHeaderData> columnHeaderData = dataTable.getColumnHeaderData();\n        assertThat(columnHeaderData).isNotNull().hasSize(7);\n\n        List<NameUniqueIndexedHeaderData> expected = List.of(new NameUniqueIndexedHeaderData(column3Name, true, true),\n                new NameUniqueIndexedHeaderData(column4Name, false, true), new NameUniqueIndexedHeaderData(newColumnName, false, true));\n\n        NameUniqueIndexedHeaderData.Mapper mapper = Mappers.getMapper(NameUniqueIndexedHeaderData.Mapper.class);\n        List<NameUniqueIndexedHeaderData> data = mapper.map(columnHeaderData);\n\n        assertThat(data).containsAll(expected);\n    }"}
{"prompt": "Create a test that tests test Datable Creation Makes Fk Column Indexed If Multirow", "completion": "    @Test\n    public void testDatableCreationMakesFkColumnIndexedIfMultirow() {\n        // given\n        String datatableName = DatatableTestNameGenerator.generateDatatableName(LOAN);\n        String column1Name = \"itsanumber\";\n\n        PostDataTablesRequest request = new PostDataTablesRequest();\n        request.setDatatableName(datatableName);\n        request.setApptableName(LOAN.getReferencedTableName());\n        request.setMultiRow(true);\n\n        PostColumnHeaderData column1HeaderRequestData = new PostColumnHeaderData();\n        column1HeaderRequestData.setName(column1Name);\n        column1HeaderRequestData.setType(\"Number\");\n        column1HeaderRequestData.setMandatory(false);\n        column1HeaderRequestData.setLength(10L);\n        column1HeaderRequestData.setCode(\"\");\n        column1HeaderRequestData.setUnique(false);\n        column1HeaderRequestData.setIndexed(false);\n\n        request.addColumnsItem(column1HeaderRequestData);\n\n        // when\n        PostDataTablesResponse response = datatableHelper.createDatatable(request);\n\n        // then\n        assertThat(response.getResourceIdentifier()).isNotBlank();\n\n        GetDataTablesResponse dataTable = datatableHelper.getDataTableDetails(datatableName);\n\n        List<ResultsetColumnHeaderData> columnHeaderData = dataTable.getColumnHeaderData();\n        assertThat(columnHeaderData).isNotNull().hasSize(5);\n\n        List<NameUniqueIndexedHeaderData> expected = List.of(new NameUniqueIndexedHeaderData(\"id\", true, true),\n                new NameUniqueIndexedHeaderData(\"loan_id\", false, true), new NameUniqueIndexedHeaderData(column1Name, false, false),\n                new NameUniqueIndexedHeaderData(\"created_at\", false, false), new NameUniqueIndexedHeaderData(\"updated_at\", false, false));\n\n        NameUniqueIndexedHeaderData.Mapper mapper = Mappers.getMapper(NameUniqueIndexedHeaderData.Mapper.class);\n        List<NameUniqueIndexedHeaderData> data = mapper.map(columnHeaderData);\n\n        assertThat(data).containsExactlyInAnyOrderElementsOf(expected);\n    }"}
{"prompt": "Create a test that tests test Datable Creation Makes Fk Column Indexed If Not Multirow", "completion": "    @Test\n    public void testDatableCreationMakesFkColumnIndexedIfNotMultirow() {\n        // given\n        String datatableName = DatatableTestNameGenerator.generateDatatableName(LOAN);\n        String column1Name = \"itsanumber\";\n\n        PostDataTablesRequest request = new PostDataTablesRequest();\n        request.setDatatableName(datatableName);\n        request.setApptableName(LOAN.getReferencedTableName());\n        request.setMultiRow(false);\n\n        PostColumnHeaderData column1HeaderRequestData = new PostColumnHeaderData();\n        column1HeaderRequestData.setName(column1Name);\n        column1HeaderRequestData.setType(\"Number\");\n        column1HeaderRequestData.setMandatory(false);\n        column1HeaderRequestData.setLength(10L);\n        column1HeaderRequestData.setCode(\"\");\n        column1HeaderRequestData.setUnique(false);\n        column1HeaderRequestData.setIndexed(false);\n\n        request.addColumnsItem(column1HeaderRequestData);\n\n        // when\n        PostDataTablesResponse response = datatableHelper.createDatatable(request);\n\n        // then\n        assertThat(response.getResourceIdentifier()).isNotBlank();\n\n        GetDataTablesResponse dataTable = datatableHelper.getDataTableDetails(datatableName);\n\n        List<ResultsetColumnHeaderData> columnHeaderData = dataTable.getColumnHeaderData();\n        assertThat(columnHeaderData).isNotNull().hasSize(4);\n\n        List<NameUniqueIndexedHeaderData> expected = List.of(new NameUniqueIndexedHeaderData(\"loan_id\", true, true),\n                new NameUniqueIndexedHeaderData(column1Name, false, false), new NameUniqueIndexedHeaderData(\"created_at\", false, false),\n                new NameUniqueIndexedHeaderData(\"updated_at\", false, false));\n\n        NameUniqueIndexedHeaderData.Mapper mapper = Mappers.getMapper(NameUniqueIndexedHeaderData.Mapper.class);\n        List<NameUniqueIndexedHeaderData> data = mapper.map(columnHeaderData);\n\n        assertThat(data).containsExactlyInAnyOrderElementsOf(expected);\n    }"}
{"prompt": "Create a test that tests test Guarantor", "completion": "    @Test\n    public void testGuarantor() {\n\n        Float self1_hold_funds = Float.valueOf((float) 0);\n        Float external1_hold_funds = Float.valueOf((float) 0);\n        Float external2_hold_funds = Float.valueOf((float) 0);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer clientID_external = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        final Integer clientID_external2 = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID_external);\n\n        final Integer selfSavigsId = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID,\n                String.valueOf(SELF1_BALANCE));\n        final Integer externalSavigsId_1 = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID_external,\n                String.valueOf(EXTERNAL1_BALANCE));\n        final Integer externalSavigsId_2 = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID_external2,\n                String.valueOf(EXTERNAL2_BALANCE));\n\n        final Integer loanProductID = createLoanProductWithHoldFunds(\"50\", \"20\", \"20\");\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7 * 4);\n        final String loanDisbursementDate = dateFormat.format(todaysDate.getTime());\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, loanDisbursementDate);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        String guarantorJSON = new GuarantorTestBuilder().externalCustomer().build();\n        Integer externalGuarantor = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        Assertions.assertNotNull(externalGuarantor);\n\n        guarantorJSON = new GuarantorTestBuilder().existingCustomerWithoutGuaranteeAmount(String.valueOf(clientID_external)).build();\n        Integer withoutGuaranteeAmount = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        Assertions.assertNotNull(withoutGuaranteeAmount);\n\n        ArrayList<HashMap> errorData = (ArrayList<HashMap>) this.loanTransactionHelper.approveLoan(loanDisbursementDate, null, loanID,\n                CommonConstants.RESPONSE_ERROR);\n        assertTrue(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.min.self.guarantee.required\"));\n        assertTrue(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.min.external.guarantee.required\"));\n        assertTrue(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.mandated.guarantee.required\"));\n\n        guarantorJSON = new GuarantorTestBuilder()\n                .existingCustomerWithGuaranteeAmount(String.valueOf(clientID), String.valueOf(selfSavigsId), String.valueOf(SELF1_GURANTEE))\n                .build();\n        Integer selfGuarantee = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(selfSavigsId, null);\n        Assertions.assertNotNull(selfGuarantee);\n\n        errorData = (ArrayList<HashMap>) this.loanTransactionHelper.approveLoan(loanDisbursementDate, null, loanID,\n                CommonConstants.RESPONSE_ERROR);\n        assertFalse(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.min.self.guarantee.required\"));\n        assertTrue(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.min.external.guarantee.required\"));\n        assertTrue(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.mandated.guarantee.required\"));\n\n        guarantorJSON = new GuarantorTestBuilder().existingCustomerWithGuaranteeAmount(String.valueOf(clientID_external),\n                String.valueOf(externalSavigsId_1), String.valueOf(EXTERNAL1_GURANTEE)).build();\n        Integer externalGuarantee_1 = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(externalSavigsId_1, null);\n        Assertions.assertNotNull(externalGuarantee_1);\n\n        errorData = (ArrayList<HashMap>) this.loanTransactionHelper.approveLoan(loanDisbursementDate, null, loanID,\n                CommonConstants.RESPONSE_ERROR);\n        assertFalse(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.min.self.guarantee.required\"));\n        assertFalse(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.min.external.guarantee.required\"));\n        assertTrue(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.mandated.guarantee.required\"));\n\n        guarantorJSON = new GuarantorTestBuilder().existingCustomerWithGuaranteeAmount(String.valueOf(clientID_external2),\n                String.valueOf(externalSavigsId_2), String.valueOf(EXTERNAL2_GURANTEE)).build();\n        Integer externalGuarantee_2 = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(externalSavigsId_2, null);\n        Assertions.assertNotNull(externalGuarantee_2);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        self1_hold_funds += SELF1_GURANTEE;\n        external1_hold_funds += EXTERNAL1_GURANTEE;\n        external2_hold_funds += EXTERNAL2_GURANTEE;\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_2, external2_hold_funds);\n\n        LOG.info(\"-----------------------------------UNDO APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.undoApproval(loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        verifySavingsOnHoldBalance(selfSavigsId, Float.valueOf((float) 0));\n        verifySavingsOnHoldBalance(externalSavigsId_1, Float.valueOf((float) 0));\n        verifySavingsOnHoldBalance(externalSavigsId_2, Float.valueOf((float) 0));\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_2, external2_hold_funds);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // First repayment\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7 * 3);\n        String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        external1_hold_funds -= Float.valueOf((float) 827.5867);\n        external2_hold_funds -= Float.valueOf((float) 413.7933);\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, totalDueForCurrentPeriod, loanID);\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_2, external2_hold_funds);\n\n        // Second repayment\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7 * 2);\n        loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        totalDueForCurrentPeriod = (Float) loanSchedule.get(2).get(\"totalDueForPeriod\");\n        external1_hold_funds -= Float.valueOf((float) 831.4067);\n        external2_hold_funds -= Float.valueOf((float) 415.7033333);\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, totalDueForCurrentPeriod, loanID);\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_2, external2_hold_funds);\n\n        // third repayment\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        totalDueForCurrentPeriod = (Float) loanSchedule.get(3).get(\"totalDueForPeriod\");\n        self1_hold_funds -= Float.valueOf((float) 741.355);\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, totalDueForCurrentPeriod, loanID);\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, Float.valueOf((float) 0));\n        verifySavingsOnHoldBalance(externalSavigsId_2, Float.valueOf((float) 0));\n\n        // forth repayment\n        todaysDate = Calendar.getInstance();\n        loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        totalDueForCurrentPeriod = (Float) loanSchedule.get(3).get(\"totalDueForPeriod\");\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, totalDueForCurrentPeriod, loanID);\n        verifySavingsOnHoldBalance(selfSavigsId, Float.valueOf((float) 0));\n        verifySavingsOnHoldBalance(externalSavigsId_1, Float.valueOf((float) 0));\n        verifySavingsOnHoldBalance(externalSavigsId_2, Float.valueOf((float) 0));\n\n        loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanAccountIsClosed(loanStatusHashMap);\n\n    }\n\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" }"}
{"prompt": "Create a test that tests test Guarantor UNDO DISBURSAL", "completion": "    @Test\n    public void testGuarantor_UNDO_DISBURSAL() {\n\n        Float self1_hold_funds = Float.valueOf((float) 0);\n        Float external1_hold_funds = Float.valueOf((float) 0);\n        Float external2_hold_funds = Float.valueOf((float) 0);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer clientID_external = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        final Integer clientID_external2 = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID_external);\n\n        final Integer selfSavigsId = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID,\n                String.valueOf(SELF1_BALANCE));\n        final Integer externalSavigsId_1 = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID_external,\n                String.valueOf(EXTERNAL1_BALANCE));\n        final Integer externalSavigsId_3 = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID_external,\n                String.valueOf(EXTERNAL1_BALANCE));\n        final Integer externalSavigsId_2 = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID_external2,\n                String.valueOf(EXTERNAL2_BALANCE));\n\n        final Integer loanProductID = createLoanProductWithHoldFunds(\"50\", \"20\", \"20\");\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7 * 4);\n        final String loanDisbursementDate = dateFormat.format(todaysDate.getTime());\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, loanDisbursementDate);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        String guarantorJSON = new GuarantorTestBuilder().externalCustomer().build();\n        Integer externalGuarantor = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        Assertions.assertNotNull(externalGuarantor);\n\n        guarantorJSON = new GuarantorTestBuilder().existingCustomerWithoutGuaranteeAmount(String.valueOf(clientID_external)).build();\n        Integer withoutGuaranteeAmount = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        Assertions.assertNotNull(withoutGuaranteeAmount);\n\n        ArrayList<HashMap> errorData = (ArrayList<HashMap>) this.loanTransactionHelper.approveLoan(loanDisbursementDate, null, loanID,\n                CommonConstants.RESPONSE_ERROR);\n        assertTrue(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.min.self.guarantee.required\"));\n        assertTrue(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.min.external.guarantee.required\"));\n        assertTrue(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.mandated.guarantee.required\"));\n\n        guarantorJSON = new GuarantorTestBuilder()\n                .existingCustomerWithGuaranteeAmount(String.valueOf(clientID), String.valueOf(selfSavigsId), String.valueOf(SELF1_GURANTEE))\n                .build();\n        Integer selfGuarantee = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(selfSavigsId, null);\n        Assertions.assertNotNull(selfGuarantee);\n\n        errorData = (ArrayList<HashMap>) this.loanTransactionHelper.approveLoan(loanDisbursementDate, null, loanID,\n                CommonConstants.RESPONSE_ERROR);\n        assertFalse(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.min.self.guarantee.required\"));\n        assertTrue(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.min.external.guarantee.required\"));\n        assertTrue(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.mandated.guarantee.required\"));\n\n        guarantorJSON = new GuarantorTestBuilder().existingCustomerWithGuaranteeAmount(String.valueOf(clientID_external),\n                String.valueOf(externalSavigsId_1), String.valueOf(EXTERNAL1_GURANTEE)).build();\n        Integer externalGuarantee_1 = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(externalSavigsId_1, null);\n        Assertions.assertNotNull(externalGuarantee_1);\n\n        errorData = (ArrayList<HashMap>) this.loanTransactionHelper.approveLoan(loanDisbursementDate, null, loanID,\n                CommonConstants.RESPONSE_ERROR);\n        assertFalse(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.min.self.guarantee.required\"));\n        assertFalse(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.min.external.guarantee.required\"));\n        assertTrue(checkForErrorCode(errorData, \"validation.msg.loan.guarantor.mandated.guarantee.required\"));\n\n        guarantorJSON = new GuarantorTestBuilder().existingCustomerWithGuaranteeAmount(String.valueOf(clientID_external2),\n                String.valueOf(externalSavigsId_2), String.valueOf(EXTERNAL2_GURANTEE)).build();\n        Integer externalGuarantee_2 = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        Assertions.assertNotNull(externalGuarantee_2);\n        verifySavingsOnHoldBalance(externalSavigsId_2, null);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        self1_hold_funds += SELF1_GURANTEE;\n        external1_hold_funds += EXTERNAL1_GURANTEE;\n        external2_hold_funds += EXTERNAL2_GURANTEE;\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_2, external2_hold_funds);\n\n        LOG.info(\"-----------------------------------UNDO APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.undoApproval(loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        verifySavingsOnHoldBalance(selfSavigsId, Float.valueOf((float) 0));\n        verifySavingsOnHoldBalance(externalSavigsId_1, Float.valueOf((float) 0));\n        verifySavingsOnHoldBalance(externalSavigsId_2, Float.valueOf((float) 0));\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_2, external2_hold_funds);\n        List<HashMap> guarantors = this.guarantorHelper.getAllGuarantor(loanID);\n        HashMap response = this.guarantorHelper.deleteGuarantor(externalGuarantor, loanID);\n        assertEquals(externalGuarantor, response.get(\"resourceId\"));\n        assertFalse((Boolean) this.guarantorHelper.getGuarantor(externalGuarantor, loanID, \"status\"));\n        HashMap errorlog = this.guarantorHelper.deleteGuarantor(withoutGuaranteeAmount, loanID);\n        ArrayList<HashMap> error = (ArrayList<HashMap>) errorlog.get(CommonConstants.RESPONSE_ERROR);\n        assertTrue(checkForErrorCode(error, \"error.msg.loan.guarantor.not.found\"));\n        guarantors = this.guarantorHelper.getAllGuarantor(loanID);\n        assertEquals(4, guarantors.size());\n        List<HashMap> externalGuarantee_1_details = (List<HashMap>) this.guarantorHelper.getGuarantor(externalGuarantee_1, loanID,\n                \"guarantorFundingDetails\");\n        Integer fundDetailId = (Integer) externalGuarantee_1_details.get(0).get(\"id\");\n        errorlog = this.guarantorHelper.deleteGuarantor(externalGuarantee_1, fundDetailId, loanID);\n        error = (ArrayList<HashMap>) errorlog.get(CommonConstants.RESPONSE_ERROR);\n        assertTrue(checkForErrorCode(error, \"validation.msg.loan.guarantor.min.external.guarantee.required\"));\n\n        guarantorJSON = new GuarantorTestBuilder().existingCustomerWithGuaranteeAmount(String.valueOf(clientID_external),\n                String.valueOf(externalSavigsId_3), String.valueOf(EXTERNAL1_GURANTEE)).build();\n        Integer externalGuarantee_3 = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(externalSavigsId_3, EXTERNAL1_GURANTEE);\n        Assertions.assertNotNull(externalGuarantee_3);\n\n        response = this.guarantorHelper.deleteGuarantor(externalGuarantee_3, fundDetailId, loanID);\n        assertEquals(externalGuarantee_3, response.get(\"resourceId\"));\n        guarantors = this.guarantorHelper.getAllGuarantor(loanID);\n        assertEquals(4, guarantors.size());\n        externalGuarantee_1_details = (List<HashMap>) this.guarantorHelper.getGuarantor(externalGuarantee_1, loanID,\n                \"guarantorFundingDetails\");\n        assertEquals(2, externalGuarantee_1_details.size());\n\n        for (HashMap map : externalGuarantee_1_details) {\n            if (map.get(\"id\").equals(fundDetailId)) {\n                HashMap status = (HashMap) map.get(\"status\");\n                assertEquals(\"guarantorFundStatusType.withdrawn\", status.get(\"code\"));\n            }\n        }\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // First repayment\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7 * 3);\n        String loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        external1_hold_funds -= Float.valueOf((float) 827.5867);\n        external2_hold_funds -= Float.valueOf((float) 413.7933);\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, totalDueForCurrentPeriod, loanID);\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_3, external1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_2, external2_hold_funds);\n\n        // Second repayment\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7 * 2);\n        loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        totalDueForCurrentPeriod = (Float) loanSchedule.get(2).get(\"totalDueForPeriod\");\n        external1_hold_funds -= Float.valueOf((float) 831.4067);\n        external2_hold_funds -= Float.valueOf((float) 415.7033333);\n        this.loanTransactionHelper.makeRepayment(loanRepaymentDate, totalDueForCurrentPeriod, loanID);\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_3, external1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_2, external2_hold_funds);\n\n        // third repayment\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -7);\n        loanRepaymentDate = dateFormat.format(todaysDate.getTime());\n        totalDueForCurrentPeriod = (Float) loanSchedule.get(3).get(\"totalDueForPeriod\");\n        Float self1_hold_funds_temp = self1_hold_funds - Float.valueOf((float) 741.355);\n        HashMap transactionDetail = this.loanTransactionHelper.makeRepayment(loanRepaymentDate, totalDueForCurrentPeriod, loanID);\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds_temp);\n        verifySavingsOnHoldBalance(externalSavigsId_3, Float.valueOf((float) 0));\n        verifySavingsOnHoldBalance(externalSavigsId_2, Float.valueOf((float) 0));\n\n        // undo repayment\n        this.loanTransactionHelper.adjustLoanTransaction(loanID, (Integer) transactionDetail.get(CommonConstants.RESPONSE_RESOURCE_ID),\n                loanRepaymentDate, \"0\", \"\");\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_3, external1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_2, external2_hold_funds);\n\n        // undo disbursal\n        loanStatusHashMap = this.loanTransactionHelper.undoDisbursal(loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        verifySavingsOnHoldBalance(selfSavigsId, Float.valueOf((float) SELF1_GURANTEE));\n        verifySavingsOnHoldBalance(externalSavigsId_3, Float.valueOf((float) EXTERNAL1_GURANTEE));\n        verifySavingsOnHoldBalance(externalSavigsId_2, Float.valueOf((float) EXTERNAL2_GURANTEE));\n    }\n\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" }"}
{"prompt": "Create a test that tests test Guarantor RECOVER GUARANTEES", "completion": "    @Test\n    public void testGuarantor_RECOVER_GUARANTEES() {\n\n        Float self1_hold_funds = Float.valueOf((float) 0);\n        Float external1_hold_funds = Float.valueOf((float) 0);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer clientID_external = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID_external);\n\n        final Integer selfSavigsId = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID,\n                String.valueOf(SELF1_BALANCE));\n        final Integer externalSavigsId_1 = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID_external,\n                String.valueOf(EXTERNAL1_BALANCE));\n\n        final Integer loanProductID = createLoanProductWithHoldFunds(\"40\", \"20\", \"20\");\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -21);\n        final String loanDisbursementDate = dateFormat.format(todaysDate.getTime());\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, loanDisbursementDate);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        String guarantorJSON = new GuarantorTestBuilder()\n                .existingCustomerWithGuaranteeAmount(String.valueOf(clientID), String.valueOf(selfSavigsId), String.valueOf(SELF1_GURANTEE))\n                .build();\n        Integer selfGuarantee = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(selfSavigsId, null);\n        Assertions.assertNotNull(selfGuarantee);\n\n        guarantorJSON = new GuarantorTestBuilder().existingCustomerWithGuaranteeAmount(String.valueOf(clientID_external),\n                String.valueOf(externalSavigsId_1), String.valueOf(EXTERNAL1_GURANTEE)).build();\n        Integer externalGuarantee_1 = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(externalSavigsId_1, null);\n        Assertions.assertNotNull(externalGuarantee_1);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        self1_hold_funds += SELF1_GURANTEE;\n        external1_hold_funds += EXTERNAL1_GURANTEE;\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // First repayment\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        external1_hold_funds -= Float.valueOf((float) 993.104);\n        this.loanTransactionHelper.makeRepayment(LOAN_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n\n        this.loanTransactionHelper.recoverFromGuarantor(loanID);\n        verifySavingsBalanceAndOnHoldBalance(selfSavigsId, Float.valueOf((float) 0), SELF1_BALANCE - self1_hold_funds);\n        verifySavingsBalanceAndOnHoldBalance(externalSavigsId_1, Float.valueOf((float) 0), EXTERNAL1_BALANCE - external1_hold_funds);\n\n    }\n\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" }"}
{"prompt": "Create a test that tests test Guarantor RECOVER GUARANTEES WITH MORE GUARANTEE", "completion": "    @Test\n    public void testGuarantor_RECOVER_GUARANTEES_WITH_MORE_GUARANTEE() {\n\n        Float self1_hold_funds = Float.valueOf((float) 0);\n        Float external1_hold_funds = Float.valueOf((float) 0);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer clientID_external = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID_external);\n\n        Float selfBalance = Float.valueOf((float) 10000);\n        Float externalBalance = Float.valueOf((float) 10000);\n        Float selfguarantee = Float.valueOf((float) 6000);\n        Float externalguarantee = Float.valueOf((float) 7000);\n\n        final Integer selfSavigsId = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID,\n                String.valueOf(selfBalance));\n        final Integer externalSavigsId_1 = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID_external,\n                String.valueOf(externalBalance));\n\n        final Integer loanProductID = createLoanProductWithHoldFunds(\"40\", \"20\", \"20\");\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -21);\n        final String loanDisbursementDate = dateFormat.format(todaysDate.getTime());\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, loanDisbursementDate);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        String guarantorJSON = new GuarantorTestBuilder()\n                .existingCustomerWithGuaranteeAmount(String.valueOf(clientID), String.valueOf(selfSavigsId), String.valueOf(selfguarantee))\n                .build();\n        Integer selfGuarantee = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(selfSavigsId, null);\n        Assertions.assertNotNull(selfGuarantee);\n\n        guarantorJSON = new GuarantorTestBuilder().existingCustomerWithGuaranteeAmount(String.valueOf(clientID_external),\n                String.valueOf(externalSavigsId_1), String.valueOf(externalguarantee)).build();\n        Integer externalGuarantee_1 = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(externalSavigsId_1, null);\n        Assertions.assertNotNull(externalGuarantee_1);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        self1_hold_funds += selfguarantee;\n        external1_hold_funds += externalguarantee;\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // First repayment\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        external1_hold_funds -= Float.valueOf((float) 3227.588);\n        this.loanTransactionHelper.makeRepayment(LOAN_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n\n        this.loanTransactionHelper.recoverFromGuarantor(loanID);\n        verifySavingsBalanceAndOnHoldBalance(selfSavigsId, Float.valueOf((float) 0), selfBalance - Float.valueOf((float) 4615.385));\n        verifySavingsBalanceAndOnHoldBalance(externalSavigsId_1, Float.valueOf((float) 0),\n                externalBalance - Float.valueOf((float) 2901.8553));\n\n    }\n\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" }"}
{"prompt": "Create a test that tests test Guarantor WRITE OFF LOAN", "completion": "    @Test\n    public void testGuarantor_WRITE_OFF_LOAN() {\n\n        Float self1_hold_funds = Float.valueOf((float) 0);\n        Float external1_hold_funds = Float.valueOf((float) 0);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        final Integer clientID_external = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID_external);\n\n        final Integer selfSavigsId = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID,\n                String.valueOf(SELF1_BALANCE));\n        final Integer externalSavigsId_1 = SavingsAccountHelper.openSavingsAccount(this.requestSpec, this.responseSpec, clientID_external,\n                String.valueOf(EXTERNAL1_BALANCE));\n\n        final Integer loanProductID = createLoanProductWithHoldFunds(\"40\", \"20\", \"20\");\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM yyyy\", Locale.US);\n        Calendar todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -21);\n        final String loanDisbursementDate = dateFormat.format(todaysDate.getTime());\n        final Integer loanID = applyForLoanApplication(clientID, loanProductID, loanDisbursementDate);\n        Assertions.assertNotNull(loanID);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n        String guarantorJSON = new GuarantorTestBuilder()\n                .existingCustomerWithGuaranteeAmount(String.valueOf(clientID), String.valueOf(selfSavigsId), String.valueOf(SELF1_GURANTEE))\n                .build();\n        Integer selfGuarantee = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        verifySavingsOnHoldBalance(selfSavigsId, null);\n        Assertions.assertNotNull(selfGuarantee);\n\n        guarantorJSON = new GuarantorTestBuilder().existingCustomerWithGuaranteeAmount(String.valueOf(clientID_external),\n                String.valueOf(externalSavigsId_1), String.valueOf(EXTERNAL1_GURANTEE)).build();\n        Integer externalGuarantee_1 = this.guarantorHelper.createGuarantor(loanID, guarantorJSON);\n        Assertions.assertNotNull(externalGuarantee_1);\n        verifySavingsOnHoldBalance(externalSavigsId_1, null);\n\n        LOG.info(\"-----------------------------------APPROVE LOAN-----------------------------------------\");\n        loanStatusHashMap = this.loanTransactionHelper.approveLoan(loanDisbursementDate, loanID);\n        LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n        LoanStatusChecker.verifyLoanIsWaitingForDisbursal(loanStatusHashMap);\n        self1_hold_funds += SELF1_GURANTEE;\n        external1_hold_funds += EXTERNAL1_GURANTEE;\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n\n        LOG.info(\"-------------------------------DISBURSE LOAN-------------------------------------------\");\n        String loanDetails = this.loanTransactionHelper.getLoanDetails(this.requestSpec, this.responseSpec, loanID);\n        loanStatusHashMap = this.loanTransactionHelper.disburseLoanWithNetDisbursalAmount(loanDisbursementDate, loanID,\n                JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n        LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n        // First repayment\n        ArrayList<HashMap> loanSchedule = this.loanTransactionHelper.getLoanRepaymentSchedule(this.requestSpec, this.responseSpec, loanID);\n        todaysDate = Calendar.getInstance();\n        todaysDate.add(Calendar.DAY_OF_MONTH, -14);\n        final String LOAN_REPAYMENT_DATE = dateFormat.format(todaysDate.getTime());\n        Float totalDueForCurrentPeriod = (Float) loanSchedule.get(1).get(\"totalDueForPeriod\");\n        external1_hold_funds -= Float.valueOf((float) 993.104);\n        this.loanTransactionHelper.makeRepayment(LOAN_REPAYMENT_DATE, totalDueForCurrentPeriod, loanID);\n        verifySavingsOnHoldBalance(selfSavigsId, self1_hold_funds);\n        verifySavingsOnHoldBalance(externalSavigsId_1, external1_hold_funds);\n\n        todaysDate = Calendar.getInstance();\n        final String LOAN_WRITEOFF_DATE = dateFormat.format(todaysDate.getTime());\n        this.loanTransactionHelper.writeOffLoan(LOAN_WRITEOFF_DATE, loanID);\n        verifySavingsBalanceAndOnHoldBalance(selfSavigsId, Float.valueOf((float) 0), SELF1_BALANCE);\n        verifySavingsBalanceAndOnHoldBalance(externalSavigsId_1, Float.valueOf((float) 0), EXTERNAL1_BALANCE);\n\n    }"}
{"prompt": "Create a test that tests test Inline COB", "completion": "    @Test\n    public void testInlineCOB() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"0\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 2), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 3));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 3), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 10));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 10), loan.getLastClosedBusinessDate());\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Inline COBCatch Up Loans", "completion": "    @Test\n    public void testInlineCOBCatchUpLoans() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            ArrayList<Integer> rangeIds = new ArrayList<>();\n            // First Range\n            String jsonRange = DelinquencyRangesHelper.getAsJSON(1, 3);\n            PostDelinquencyRangeResponse delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec,\n                    responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n            jsonRange = DelinquencyRangesHelper.getAsJSON(4, 60);\n\n            GetDelinquencyRangesResponse range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec,\n                    delinquencyRangeResponse.getResourceId());\n\n            // Second Range\n            delinquencyRangeResponse = DelinquencyRangesHelper.createDelinquencyRange(requestSpec, responseSpec, jsonRange);\n            rangeIds.add(delinquencyRangeResponse.getResourceId());\n\n            range = DelinquencyRangesHelper.getDelinquencyRange(requestSpec, responseSpec, delinquencyRangeResponse.getResourceId());\n            final String classificationExpected = range.getClassification();\n            log.info(\"Expected Delinquency Range classification after Disbursement {}\", classificationExpected);\n\n            String jsonBucket = DelinquencyBucketsHelper.getAsJSON(rangeIds);\n            PostDelinquencyBucketResponse delinquencyBucketResponse = DelinquencyBucketsHelper.createDelinquencyBucket(requestSpec,\n                    responseSpec, jsonBucket);\n            assertNotNull(delinquencyBucketResponse);\n            final GetDelinquencyBucketsResponse delinquencyBucket = DelinquencyBucketsHelper.getDelinquencyBucket(requestSpec, responseSpec,\n                    delinquencyBucketResponse.getResourceId());\n\n            final Integer loanProductID = createLoanProduct(loanTransactionHelper, delinquencyBucket.getId());\n\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            ArrayList<GetDelinquencyTagHistoryResponse> loanDelinquencyTags = loanTransactionHelper.getLoanDelinquencyTags(requestSpec,\n                    responseSpec, loanID);\n            Assertions.assertTrue(loanDelinquencyTags.isEmpty());\n            Assertions.assertEquals(LocalDate.of(2020, 3, 2), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 4, 4));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            loanDelinquencyTags = loanTransactionHelper.getLoanDelinquencyTags(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 4, 4), loan.getLastClosedBusinessDate());\n            Assertions.assertEquals(1, loanDelinquencyTags.size());\n            Assertions.assertEquals(LocalDate.of(2020, 4, 3), loanDelinquencyTags.get(0).getAddedOnDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 4, 10));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            loanDelinquencyTags = loanTransactionHelper.getLoanDelinquencyTags(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 4, 10), loan.getLastClosedBusinessDate());\n            Assertions.assertEquals(2, loanDelinquencyTags.size());\n            Assertions.assertEquals(LocalDate.of(2020, 4, 3), loanDelinquencyTags.get(1).getAddedOnDate());\n            Assertions.assertEquals(LocalDate.of(2020, 4, 6), loanDelinquencyTags.get(0).getAddedOnDate());\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Inline COBOn Repayment With Soft Locked Loan", "completion": "    @Test\n    public void testInlineCOBOnRepaymentWithSoftLockedLoan() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"0\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n            loanAccountLockHelper = new LoanAccountLockHelper(requestSpec, new ResponseSpecBuilder().expectStatusCode(202).build());\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 2), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 10));\n\n            requestSpec = UserHelper.getSimpleUserWithoutBypassPermission(requestSpec, responseSpec);\n\n            loanAccountLockHelper.placeSoftLockOnLoanAccount(loanID, \"LOAN_COB_PARTITIONING\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            loanTransactionHelper.makeRepayment(\"10 March 2020\", 10.0f, loanID);\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 9), loan.getLastClosedBusinessDate());\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Inline COBCatch Up On Repayment With Not Locked Loan", "completion": "    @Test\n    public void testInlineCOBCatchUpOnRepaymentWithNotLockedLoan() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"0\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n            loanAccountLockHelper = new LoanAccountLockHelper(requestSpec, new ResponseSpecBuilder().expectStatusCode(202).build());\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 2), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 10));\n\n            requestSpec = UserHelper.getSimpleUserWithoutBypassPermission(requestSpec, responseSpec);\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            loanTransactionHelper.makeRepayment(\"10 March 2020\", 10.0f, loanID);\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 9), loan.getLastClosedBusinessDate());\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Inline COBOn Batch APIWith Old Relative Urls", "completion": "    @Test\n    public void testInlineCOBOnBatchAPIWithOldRelativeUrls() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"0\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n            loanAccountLockHelper = new LoanAccountLockHelper(requestSpec, new ResponseSpecBuilder().expectStatusCode(202).build());\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 2), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 10));\n\n            requestSpec = UserHelper.getSimpleUserWithoutBypassPermission(requestSpec, responseSpec);\n\n            loanAccountLockHelper.placeSoftLockOnLoanAccount(loanID, \"LOAN_COB_PARTITIONING\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            final BatchRequest br1 = BatchHelper.oldRepayLoanRequestWithGivenLoanId(4730L, loanID, \"10\", LocalDate.of(2020, 3, 10));\n\n            final List<BatchRequest> batchRequests = new ArrayList<>();\n\n            batchRequests.add(br1);\n\n            final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n            final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec,\n                    this.responseSpec, jsonifiedRequest);\n            Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(0).getStatusCode(), \"Verify Status Code 200 for Repayment\");\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 9), loan.getLastClosedBusinessDate());\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Inline COBOn Batch API", "completion": "    @Test\n    public void testInlineCOBOnBatchAPI() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(this.requestSpec, this.responseSpec, \"10\", \"0\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n            loanAccountLockHelper = new LoanAccountLockHelper(requestSpec, new ResponseSpecBuilder().expectStatusCode(202).build());\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.COB_DATE, LocalDate.of(2020, 3, 2));\n            inlineLoanCOBHelper.executeInlineCOB(List.of(loanID.longValue()));\n            GetLoansLoanIdResponse loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 2), loan.getLastClosedBusinessDate());\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 10));\n\n            requestSpec = UserHelper.getSimpleUserWithoutBypassPermission(requestSpec, responseSpec);\n\n            loanAccountLockHelper.placeSoftLockOnLoanAccount(loanID, \"LOAN_COB_PARTITIONING\");\n            loanTransactionHelper = new LoanTransactionHelper(requestSpec, responseSpec);\n\n            final BatchRequest br1 = BatchHelper.repayLoanRequestWithGivenLoanId(4730L, loanID, \"10\", LocalDate.of(2020, 3, 10));\n\n            final List<BatchRequest> batchRequests = new ArrayList<>();\n\n            batchRequests.add(br1);\n\n            final String jsonifiedRequest = BatchHelper.toJsonString(batchRequests);\n\n            final List<BatchResponse> response = BatchHelper.postBatchRequestsWithoutEnclosingTransaction(this.requestSpec,\n                    this.responseSpec, jsonifiedRequest);\n            Assertions.assertEquals(HttpStatus.SC_OK, (long) response.get(0).getStatusCode(), \"Verify Status Code 200 for Repayment\");\n\n            loan = loanTransactionHelper.getLoan(requestSpec, responseSpec, loanID);\n            Assertions.assertEquals(LocalDate.of(2020, 3, 9), loan.getLastClosedBusinessDate());\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Inline COBRequest Body Item Limit Validation", "completion": "    @Test\n    public void testInlineCOBRequestBodyItemLimitValidation() {\n        responseSpec = new ResponseSpecBuilder().expectStatusCode(400).build();\n        inlineLoanCOBHelper = new InlineLoanCOBHelper(requestSpec, responseSpec);\n        List<Long> loanIds = LongStream.rangeClosed(1, 1001).boxed().toList();\n        String responseUserMessage = inlineLoanCOBHelper.executeInlineCOB(loanIds, \"defaultUserMessage\");\n        assertEquals(\"Size of the loan IDs list cannot be over 1000\", responseUserMessage);\n    }"}
{"prompt": "Create a test that tests test Validate Action", "completion": "    @Test\n    public void testValidateAction() {\n        interopHelper.setResponseSpec(responseClientErrorSpec);\n        interopHelper.postTransferMissingAction(UUID.randomUUID().toString(), InteropTransactionRole.PAYER);\n        interopHelper.postTransfer(UUID.randomUUID().toString(), null, InteropTransactionRole.PAYER);\n        interopHelper.setResponseSpec(responseSpec);\n    }"}
{"prompt": "Create a test that tests test Interoperation", "completion": "    @Test\n    public void testInteroperation() {\n        createClient();\n        createSavingsProduct();\n        createCharge();\n        openSavingsAccount();\n\n        testParties();\n        testRequests();\n        testQuotes();\n        testTransfers();\n    }"}
{"prompt": "Create a test that tests sale Active Loan To External Asset Owner", "completion": "    @Test\n    public void saleActiveLoanToExternalAssetOwner() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(requestSpec, responseSpec, \"10\", \"0\");\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            String transferExternalId = \"36efeb06-d835-48a1-99eb-09bd1d348c1e\";\n            String saleResponse = externalAssetOwnerHelper.initiateTransferByLoanId(loanID.longValue(), \"sale\",\n                    getSaleRequestJson(\"04 March 2020\", transferExternalId));\n            Type type = new TypeToken<Map<String, Object>>() {}.getType();\n            Map<String, Object> responseMap = new Gson().fromJson(saleResponse, type);\n            assertEquals(responseMap.get(\"resourceExternalId\"), transferExternalId);\n\n            String retrieveResponse = externalAssetOwnerHelper.retrieveTransferByLoanId(loanID.longValue());\n            Type retrieveType = new TypeToken<List<Map<String, Object>>>() {}.getType();\n            List<Map<String, Object>> retrieveResponseMap = new Gson().fromJson(retrieveResponse, retrieveType);\n            assertEquals(1, retrieveResponseMap.size());\n            assertEquals(retrieveResponseMap.get(0).get(\"transferExternalId\"), transferExternalId);\n            assertEquals(retrieveResponseMap.get(0).get(\"status\"), \"PENDING\");\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests sale Is Not Allowed When Transfer Is Already Pending", "completion": "    @Test\n    public void saleIsNotAllowedWhenTransferIsAlreadyPending() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(requestSpec, responseSpec, \"10\", \"0\");\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            String transferExternalId = \"36efeb06-d835-48a1-99eb-09bd1d348c1e\";\n            String saleResponse = externalAssetOwnerHelper.initiateTransferByLoanId(loanID.longValue(), \"sale\",\n                    getSaleRequestJson(\"04 March 2020\", transferExternalId));\n            Type type = new TypeToken<Map<String, Object>>() {}.getType();\n            Map<String, Object> responseMap = new Gson().fromJson(saleResponse, type);\n            assertEquals(responseMap.get(\"resourceExternalId\"), transferExternalId);\n\n            externalAssetOwnerHelper = new ExternalAssetOwnerHelper(requestSpec, responseSpecError);\n            String errorResponse = externalAssetOwnerHelper.initiateTransferByLoanId(loanID.longValue(), \"sale\",\n                    getSaleRequestJson(\"04 March 2020\", transferExternalId));\n            Map<String, Object> errorResponseMap = new Gson().fromJson(errorResponse, type);\n            assertEquals(\"External asset owner transfer is already in PENDING state for this loan.\",\n                    errorResponseMap.get(\"developerMessage\"));\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests sale And Buyback On The Same Day", "completion": "    @Test\n    public void saleAndBuybackOnTheSameDay() {\n        try {\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.TRUE);\n\n            BusinessDateHelper.updateBusinessDate(requestSpec, responseSpec, BusinessDateType.BUSINESS_DATE, LocalDate.of(2020, 3, 2));\n            GlobalConfigurationHelper.updateValueForGlobalConfiguration(requestSpec, responseSpec, \"10\", \"0\");\n\n            final Integer clientID = ClientHelper.createClient(requestSpec, responseSpec);\n            Assertions.assertNotNull(clientID);\n\n            Integer overdueFeeChargeId = ChargesHelper.createCharges(requestSpec, responseSpec,\n                    ChargesHelper.getLoanOverdueFeeJSONWithCalculationTypePercentage(\"1\"));\n            Assertions.assertNotNull(overdueFeeChargeId);\n\n            final Integer loanProductID = createLoanProduct(overdueFeeChargeId.toString());\n            Assertions.assertNotNull(loanProductID);\n            HashMap loanStatusHashMap;\n\n            final Integer loanID = applyForLoanApplication(clientID.toString(), loanProductID.toString(), null, \"10 January 2020\");\n\n            Assertions.assertNotNull(loanID);\n\n            loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(requestSpec, responseSpec, loanID);\n            LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n\n            loanStatusHashMap = loanTransactionHelper.approveLoan(\"01 March 2020\", loanID);\n            LoanStatusChecker.verifyLoanIsApproved(loanStatusHashMap);\n\n            String loanDetails = loanTransactionHelper.getLoanDetails(requestSpec, responseSpec, loanID);\n            loanStatusHashMap = loanTransactionHelper.disburseLoanWithNetDisbursalAmount(\"02 March 2020\", loanID,\n                    JsonPath.from(loanDetails).get(\"netDisbursalAmount\").toString());\n            LoanStatusChecker.verifyLoanIsActive(loanStatusHashMap);\n\n            String transferExternalId = \"36efeb06-d835-48a1-99eb-09bd1d348c1e\";\n            String saleResponse = externalAssetOwnerHelper.initiateTransferByLoanId(loanID.longValue(), \"sale\",\n                    getSaleRequestJson(\"04 March 2020\", transferExternalId));\n            Type type = new TypeToken<Map<String, Object>>() {}.getType();\n            Map<String, Object> responseMap = new Gson().fromJson(saleResponse, type);\n            assertEquals(responseMap.get(\"resourceExternalId\"), transferExternalId);\n\n            String buybackTransferExternalId = \"36efeb06-d835-48a1-99eb-09bd1d348c1e\";\n            String buybackResponse = externalAssetOwnerHelper.initiateTransferByLoanId(loanID.longValue(), \"buyback\",\n                    getSaleRequestJson(\"04 March 2020\", buybackTransferExternalId));\n            Map<String, Object> buybackResponseMap = new Gson().fromJson(buybackResponse, type);\n            assertEquals(buybackResponseMap.get(\"resourceExternalId\"), buybackTransferExternalId);\n\n            String retrieveResponse = externalAssetOwnerHelper.retrieveTransferByLoanId(loanID.longValue());\n            Type retrieveType = new TypeToken<List<Map<String, Object>>>() {}.getType();\n            List<Map<String, Object>> retrieveResponseMap = new Gson().fromJson(retrieveResponse, retrieveType);\n            assertEquals(2, retrieveResponseMap.size());\n            assertEquals(retrieveResponseMap.get(0).get(\"transferExternalId\"), transferExternalId);\n            assertEquals(retrieveResponseMap.get(0).get(\"status\"), \"PENDING\");\n            assertEquals(retrieveResponseMap.get(1).get(\"transferExternalId\"), buybackTransferExternalId);\n            assertEquals(retrieveResponseMap.get(1).get(\"status\"), \"BUYBACK\");\n        } finally {\n            requestSpec = new RequestSpecBuilder().setContentType(ContentType.JSON).build();\n            requestSpec.header(\"Authorization\", \"Basic \" + Utils.loginIntoServerAndGetBase64EncodedAuthenticationKey());\n            requestSpec.header(\"Fineract-Platform-TenantId\", \"default\");\n            responseSpec = new ResponseSpecBuilder().expectStatusCode(200).build();\n            GlobalConfigurationHelper.updateIsBusinessDateEnabled(requestSpec, responseSpec, Boolean.FALSE);\n        }\n    }"}
{"prompt": "Create a test that tests test Variable Loan Product Creation", "completion": "    @Test\n    public void testVariableLoanProductCreation() {\n        final String json = VariableInstallmentsDecliningBalanceHelper.createLoanProductWithVaribleConfig(false, NONE);\n        final Integer loanProductID = this.loanTransactionHelper.getLoanProductId(json);\n        LOG.info(\"------------------------------RETRIEVING CREATED LOAN PRODUCT DETAILS ---------------------------------------\");\n        Map loanProduct = (Map) loanTransactionHelper.getLoanProductDetail(requestSpec, responseSpec, loanProductID, \"\");\n        Assertions.assertTrue((Boolean) loanProduct.get(\"allowVariableInstallments\"));\n        Assertions.assertEquals(Integer.valueOf(5), loanProduct.get(\"minimumGap\"));\n        Assertions.assertEquals(Integer.valueOf(90), loanProduct.get(\"maximumGap\"));\n    }"}
{"prompt": "Create a test that tests test Loan Product Creation", "completion": "    @Test\n    public void testLoanProductCreation() {\n        final String josn = VariableInstallmentsDecliningBalanceHelper.createLoanProductWithoutVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(josn);\n        LOG.info(\"------------------------------RETRIEVING CREATED LOAN PRODUCT DETAILS ---------------------------------------\");\n        Map loanProduct = (Map) loanTransactionHelper.getLoanProductDetail(requestSpec, responseSpec, loanProductID, \"\");\n        Assertions.assertTrue(!(Boolean) loanProduct.get(\"allowVariableInstallments\"));\n    }"}
{"prompt": "Create a test that tests test Delete Installments With Declining Balance Equal Installments", "completion": "    @Test\n    public void testDeleteInstallmentsWithDecliningBalanceEqualInstallments() {\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsDecliningBalanceHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n\n        List<HashMap> collaterals = new ArrayList<>();\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final String json = VariableInstallmentsDecliningBalanceHelper.applyForLoanApplication(clientID, loanProductID, null, null,\n                \"1,00,000.00\", collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        // Integer loanID = 49 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        ArrayList toDelete = new ArrayList<>();\n        toDelete.add(periods.get(1));\n        String toDeletedata = VariableInstallmentsDecliningBalanceHelper.createDeleteVariations(toDelete);\n        HashMap modifiedReschdule = transactionHelper.validateVariations(toDeletedata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsDecliningBalanceHelper.constructVerifyData(\n                new String[] { \"20 November 2011\", \"20 December 2011\", \"20 January 2012\" },\n                new String[] { \"34675.47\", \"34675.47\", \"36756.26\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(toDeletedata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); // Repayments Schedule includes disbursement also. So\n                           // remove this.\n        assertAfterSubmit(periods, toVerifyData);\n\n    }"}
{"prompt": "Create a test that tests test Add Installments With Declining Balance Equal Installments", "completion": "    @Test\n    public void testAddInstallmentsWithDecliningBalanceEqualInstallments() {\n        // 31 October 2011 - 5000\n        // Result: 20 October 2011 - 21,215.84, 31 October 2011 - 5000, 20\n        // November 2011 26,477.31, 20 December 2011 26,477.31, 20 January 2012\n        // 25,947.7\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsDecliningBalanceHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final String json = VariableInstallmentsDecliningBalanceHelper.applyForLoanApplication(clientID, loanProductID, null, null,\n                \"1,00,000.00\", collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        // Integer loanID = 57 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        String addVariationsjsondata = VariableInstallmentsDecliningBalanceHelper.createAddVariations();\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsDecliningBalanceHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"31 October 2011\", \"20 November 2011\", \"20 December 2011\", \"20 January 2012\" },\n                new String[] { \"21215.84\", \"5000.0\", \"26477.31\", \"26477.31\", \"25947.7\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); // Repayments Schedule includes disbursement also. So\n                           // remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    }"}
{"prompt": "Create a test that tests test Modify Installment With Declining Balance Equal Installments", "completion": "    @Test\n    public void testModifyInstallmentWithDecliningBalanceEqualInstallments() {\n        // 20 October 2011 - 30000 modify\n        // Result 20 October 2011 - 30000.0, 20 November 2011 - 24,966.34, 20\n        // December 2011 - 24,966.34, 20 January 2012 - 24,966.33\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsDecliningBalanceHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n\n        final String json = VariableInstallmentsDecliningBalanceHelper.applyForLoanApplication(clientID, loanProductID, null, null,\n                \"1,00,000.00\", collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        // Integer loanID = 57 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        String addVariationsjsondata = VariableInstallmentsDecliningBalanceHelper.createModifiyVariations((Map) periods.get(1)); // 0th\n                                                                                                                                 // position\n                                                                                                                                 // will\n                                                                                                                                 // have\n                                                                                                                                 // disbursement\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsDecliningBalanceHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"20 November 2011\", \"20 December 2011\", \"20 January 2012\" },\n                new String[] { \"30000.0\", \"24966.34\", \"24966.34\", \"24966.33\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); // Repayments Schedule includes disbursement also. So\n                           // remove this.\n        assertAfterSubmit(periods, toVerifyData);\n\n    }"}
{"prompt": "Create a test that tests test All Variations Declining Balancewith Equal Installments", "completion": "    @Test\n    public void testAllVariationsDecliningBalancewithEqualInstallments() {\n        // Request: Delete 20 December 2011 26,262.38, Modify 20 November 2011\n        // from 26,262.38 to 30000, Add 25 December 2011 5000\n        // Result: 20 October 2011 - 26262.38, 20 November 2011 - 30000, 25\n        // December 2011 - 5000, 20 January 2012 - 44077\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsDecliningBalanceHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsDecliningBalanceHelper.applyForLoanApplication(clientID, loanProductID, null, null,\n                \"1,00,000.00\", collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        // Integer loanID = 57 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n\n        String addVariationsjsondata = VariableInstallmentsDecliningBalanceHelper.createAllVariations(); // 0th\n                                                                                                         // position\n                                                                                                         // will\n                                                                                                         // have\n                                                                                                         // disbursement\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsDecliningBalanceHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"20 November 2011\", \"25 December 2011\", \"20 January 2012\" },\n                new String[] { \"26262.38\", \"30000.0\", \"5000.0\", \"44077.0\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); // Repayments Schedule includes disbursement also. So\n                           // remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    }"}
{"prompt": "Create a test that tests test All Variations Declining Balancewith Equal Principal", "completion": "    @Test\n    public void testAllVariationsDecliningBalancewithEqualPrincipal() {\n        // Request: Delete 20 December 2011 26,262.38, Modify 20 November 2011\n        // from 26,262.38 to 30000, Add 25 December 2011 5000\n        // Result: 20 October 2011 - 27000.0, 20 November 2011 - 31500.0, 25\n        // December 2011 - 6045.16, 20 January 2012 - 40670.97\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsDecliningBalanceHelper\n                .createLoanProductWithVaribleConfigwithEqualPrincipal(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                clientID.toString(), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsDecliningBalanceHelper.applyForLoanApplicationWithEqualPrincipal(clientID, loanProductID,\n                null, null, \"1,00,000.00\", collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        // Integer loanID = 109 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n\n        String addVariationsjsondata = VariableInstallmentsDecliningBalanceHelper.createAllVariationsWithEqualPrincipal(); // 0th\n                                                                                                                           // position\n                                                                                                                           // will\n                                                                                                                           // have\n                                                                                                                           // disbursement\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsDecliningBalanceHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"20 November 2011\", \"25 December 2011\", \"20 January 2012\" },\n                new String[] { \"27000.0\", \"31500.0\", \"6045.16\", \"40670.97\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); // Repayments Schedule includes disbursement also. So\n                           // remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    }"}
{"prompt": "Create a test that tests test Modify Dates With Declining Balance Equal Installments", "completion": "    @Test\n    public void testModifyDatesWithDecliningBalanceEqualInstallments() {\n        // Modify 20 December 2011:25000 -> 04 January 2012:20000\n        // Modify 20 January 2012 -> 08 February 2012\n        // Result 20 October 2011 -26262.38, 20 November 2011 - 26262.38, 04\n        // January 2012 -20000, 08 February 2012 - 33242.97\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsDecliningBalanceHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsDecliningBalanceHelper.applyForLoanApplication(clientID, loanProductID, null, null,\n                \"1,00,000.00\", collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        // Integer loanID = 57 ;\n\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        //\n        //\n        String addVariationsjsondata = VariableInstallmentsDecliningBalanceHelper.createModifiyDateVariations(\n                new String[] { \"20 December 2011\", \"20 January 2012\" }, new String[] { \"04 January 2012\", \"08 February 2012\" },\n                new String[] { \"20000\" }); // 0th position will have\n                                           // disbursement\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsDecliningBalanceHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"20 November 2011\", \"04 January 2012\", \"08 February 2012\" },\n                new String[] { \"26262.38\", \"26262.38\", \"20000.0\", \"33242.97\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); // Repayments Schedule includes disbursement also. So\n                           // remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    }"}
{"prompt": "Create a test that tests test Delete Installments With Interest Type Flat", "completion": "    @Test\n    public void testDeleteInstallmentsWithInterestTypeFlat() {\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsFlatHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsFlatHelper.applyForLoanApplication(clientID, loanProductID, null, null, \"1,00,000.00\",\n                collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        ArrayList toDelete = new ArrayList<>();\n        toDelete.add(periods.get(1));\n        String toDeletedata = VariableInstallmentsFlatHelper.createDeleteVariations(toDelete);\n        HashMap modifiedReschdule = transactionHelper.validateVariations(toDeletedata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsFlatHelper.constructVerifyData(\n                new String[] { \"20 November 2011\", \"20 December 2011\", \"20 January 2012\" },\n                new String[] { \"36000.0\", \"36000.0\", \"36000.0\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(toDeletedata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); // Repayments Schedule includes disbursement also. So\n                           // remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    }"}
{"prompt": "Create a test that tests test Add Installments With Interest Type Flat", "completion": "    @Test\n    public void testAddInstallmentsWithInterestTypeFlat() {\n        // 31 October 2011 - 5000\n        // Result: 20 October 2011 - 21600.0, 31 October 2011 - 6600.0, 20\n        // November 2011 26600.0, 20 December 2011 26600.0, 20 January 2012\n        // 26600.0\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsFlatHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsFlatHelper.applyForLoanApplication(clientID, loanProductID, null, null, \"1,00,000.00\",\n                collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        // Integer loanID = 67 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        String addVariationsjsondata = VariableInstallmentsFlatHelper.createAddVariations();\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsFlatHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"31 October 2011\", \"20 November 2011\", \"20 December 2011\", \"20 January 2012\" },\n                new String[] { \"21600.0\", \"6600.0\", \"26600.0\", \"26600.0\", \"26600.0\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); // Repayments Schedule includes disbursement also. So\n                           // remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    }"}
{"prompt": "Create a test that tests test Modify Installments With Interest Typeis Flat", "completion": "    @Test\n    public void testModifyInstallmentsWithInterestTypeisFlat() {\n        // 20 October 2011 - 30000 modify\n        // Result 20 October 2011 - 32000.0, 20 November 2011 - 25333.33, 20\n        // December 2011 - 25333.33, 20 January 2012 - 25333.34\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsFlatHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsFlatHelper.applyForLoanApplication(clientID, loanProductID, null, null, \"1,00,000.00\",\n                collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        // Integer loanID = 67 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        String addVariationsjsondata = VariableInstallmentsFlatHelper.createModifiyVariations((Map) periods.get(1)); // 0th\n                                                                                                                     // position\n                                                                                                                     // will\n                                                                                                                     // have\n                                                                                                                     // disbursement\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsFlatHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"20 November 2011\", \"20 December 2011\", \"20 January 2012\" },\n                new String[] { \"32000.0\", \"25333.33\", \"25333.33\", \"25333.34\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); // Repayments Schedule includes disbursement also. So\n                           // remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    }"}
{"prompt": "Create a test that tests test All Variations With Interest Type Flat", "completion": "    @Test\n    public void testAllVariationsWithInterestTypeFlat() {\n        // Request: Delete 20 December 2011 25000.0, Modify 20 November 2011\n        // from 25,000 to 30000, Add 25 December 2011 5000\n        // Result: 20 October 2011 - 27000.0, 20 November 2011 - 32000.0, 25\n        // December 2011 - 7000.0, 20 January 2012 - 42000.0\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsFlatHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsFlatHelper.applyForLoanApplication(clientID, loanProductID, null, null, \"1,00,000.00\",\n                collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        // Integer loanID = 67 ;\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n\n        String addVariationsjsondata = VariableInstallmentsFlatHelper.createAllVariations(); // 0th\n                                                                                             // position\n                                                                                             // will\n                                                                                             // have\n                                                                                             // disbursement\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsFlatHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"20 November 2011\", \"25 December 2011\", \"20 January 2012\" },\n                new String[] { \"27000.0\", \"32000.0\", \"7000.0\", \"42000.0\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); // Repayments Schedule includes disbursement also. So\n                           // remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    }"}
{"prompt": "Create a test that tests test Modify Dates With Interest Type Flat", "completion": "    @Test\n    public void testModifyDatesWithInterestTypeFlat() {\n        // Modify 20 December 2011:25000 -> 04 January 2012:20000\n        // Modify 20 January 2012 -> 08 February 2012\n        // Result 20 October 2011 -27306.45, 20 November 2011 - 27306.45, 04\n        // January 2012 -22306.45, 08 February 2012 - 32306.46\n        VariableIntallmentsTransactionHelper transactionHelper = new VariableIntallmentsTransactionHelper(requestSpec, responseSpec);\n        final String loanProductJson = VariableInstallmentsFlatHelper.createLoanProductWithVaribleConfig(false, NONE);\n        Integer loanProductID = this.loanTransactionHelper.getLoanProductId(loanProductJson);\n        final Integer clientID = ClientHelper.createClient(this.requestSpec, this.responseSpec);\n        ClientHelper.verifyClientCreatedOnServer(this.requestSpec, this.responseSpec, clientID);\n        List<HashMap> collaterals = new ArrayList<>();\n\n        final Integer collateralId = CollateralManagementHelper.createCollateralProduct(this.requestSpec, this.responseSpec);\n        Assertions.assertNotNull(collateralId);\n        final Integer clientCollateralId = CollateralManagementHelper.createClientCollateral(this.requestSpec, this.responseSpec,\n                String.valueOf(clientID), collateralId);\n        Assertions.assertNotNull(clientCollateralId);\n        addCollaterals(collaterals, clientCollateralId, BigDecimal.valueOf(1));\n        final String json = VariableInstallmentsFlatHelper.applyForLoanApplication(clientID, loanProductID, null, null, \"1,00,000.00\",\n                collaterals);\n        final Integer loanID = this.loanTransactionHelper.getLoanId(json);\n        HashMap loanStatusHashMap = LoanStatusChecker.getStatusOfLoan(this.requestSpec, this.responseSpec, loanID);\n        LoanStatusChecker.verifyLoanIsPending(loanStatusHashMap);\n        // Integer loanID = 67 ;\n\n        Map list = transactionHelper.retrieveSchedule(loanID);\n        Map repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        ArrayList periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        //\n        //\n        String addVariationsjsondata = VariableInstallmentsFlatHelper.createModifiyDateVariations(\n                new String[] { \"20 December 2011\", \"20 January 2012\" }, new String[] { \"04 January 2012\", \"08 February 2012\" },\n                new String[] { \"20000\" }); // 0th position will have\n                                           // disbursement\n        HashMap modifiedReschdule = transactionHelper.validateVariations(addVariationsjsondata, loanID);\n        ArrayList newperiods = (ArrayList) modifiedReschdule.get(\"periods\");\n        ArrayList toVerifyData = VariableInstallmentsFlatHelper.constructVerifyData(\n                new String[] { \"20 October 2011\", \"20 November 2011\", \"04 January 2012\", \"08 February 2012\" },\n                new String[] { \"27306.45\", \"27306.45\", \"22306.45\", \"32306.46\" });\n        assertAfterSubmit(newperiods, toVerifyData);\n        transactionHelper.submitVariations(addVariationsjsondata, loanID);\n        list = transactionHelper.retrieveSchedule(loanID);\n        repaymentSchedule = (Map) list.get(\"repaymentSchedule\");\n        periods = (ArrayList) repaymentSchedule.get(\"periods\");\n        periods.remove(0); // Repayments Schedule includes disbursement also. So\n                           // remove this.\n        assertAfterSubmit(periods, toVerifyData);\n    }"}
